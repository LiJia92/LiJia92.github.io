[{"title":"Android 串口通信小记","date":"2020-07-15T07:40:19.000Z","path":"2020/07/15/serial-port/","text":"最近项目有需要用到串口通信，硬件同事通过串口给应用层发送数据，稍微记录一下。 串口串口通信（Serial Communications）是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。串口通信是计算机中非常常见的通信方式，比如一些有线鼠标、键盘、打印机等都是通过串口进行通信的。串口的通信一般使用3根线完成，分别是地线、发送线（tx）、接收线（rx）。串口中有五个重要的参数：串口设备名、波特率、奇偶校验位、数据位、停止位。 设备名称：串口的名称。 波特率：传输速率的参数，波特率和传输距离成反比。 校验位：在串口通信中一种简单的检错方式，有四种检错方式：偶、奇、高和低，允许无校验位。 数据位：通信中实际数据位的参数 停止位：用于表示单个包的最后一位。 接入Google 官方有基于串口通信的 demo，部分代码可以用以借鉴。在 github 上有几个三方库，封装了串口通信，项目决定采用的是Android-SerialPort-API。打开串口：12345678910111213141516171819private synchronized void doOpenSerial() throws OpenSerialPortException &#123; if (mSerialPort != null) &#123; close(); &#125; try &#123; mSerialPort = SerialPort.newBuilder(\"/dev/ttyMT1\", 115200).build(); mInputStream = new BufferedInputStream(mSerialPort.getInputStream()); mOutputStream = new BufferedOutputStream(mSerialPort.getOutputStream()); startReadThread(); &#125; catch (Exception e) &#123; // 清理数据 close(); // 抛出异常 throw new OpenSerialPortException(e); &#125;&#125; 在打开串口后，开启一个线程循环读取数据。 读取与解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 默认读线程 */private class DefaultReadThread extends Thread &#123; private final byte[] mReceiveBuffer; private boolean mRunning = true; private final byte[] buffer; private int index; DefaultReadThread() &#123; // 接收收据缓存 mReceiveBuffer = new byte[16]; //多缓存一点，以防万一 buffer = new byte[256]; index = 0; &#125; @Override public void run() &#123; while (mRunning) &#123; try &#123; if (mInputStream.available() &gt; 0) &#123; int len = mInputStream.read(mReceiveBuffer); if (len &gt; 0) &#123; System.arraycopy(mReceiveBuffer, 0, buffer, index, len); index += len; Arrays.fill(mReceiveBuffer, (byte) 0); while (true) &#123; //查找数据头和数据尾 int start = -1; int end = -1; for (int i = 0; i &lt; index; i++) &#123; if (buffer[i] == SerialProtocol.HEAD1 &amp;&amp; i + 1 &lt; index &amp;&amp; buffer[i + 1] == SerialProtocol.HEAD2) &#123; start = i; &#125; if (start != -1 &amp;&amp; buffer[i] == SerialProtocol.END &amp;&amp; i + 1 &lt; index &amp;&amp; buffer[i + 1] == SerialProtocol.END)&#123; end = i + 1; &#125; if (end != -1) &#123; break; &#125; &#125; //说明前面有脏数据，把数据前移start位 if (start &gt; 0) &#123; for (int i = 0; i &lt; buffer.length &amp;&amp; i + start &lt; buffer.length; i++) &#123; buffer[i] = buffer[i + start]; &#125; start = 0; end = end - start; index -= start; &#125; //如果找到了 if (start == 0 &amp;&amp; end &gt; start) &#123; //先把数据写入真实数据区域 byte[] data = new byte[end - start + 1]; System.arraycopy(buffer, start, data, 0, data.length); //然后向左移动数据 for (int i = start; i &lt; buffer.length; i++) &#123; if (i + data.length &lt; buffer.length) &#123; buffer[i] = buffer[i + data.length]; &#125; else &#123; buffer[i] = 0; &#125; &#125; //把index前移 index -= data.length; //这个其实应该不会发生 index = Math.max(0, index); ReadBytes readBytes = new ReadBytes(data, bigEndian()); //将数据交给处理器来处理 SerialProtocol protocol = new SerialProtocol(readBytes); if (protocol.isValid()) &#123; // 解析协议数据 parseData(new ReadBytes(protocol.data, bigEndian())); &#125; &#125; else &#123; break; &#125; &#125; &#125; &#125; else &#123; // 暂停一点时间，免得一直循环造成CPU占用率过高 Thread.sleep(10); &#125; &#125; catch (Exception e) &#123; LogUtils.e(TAG, \"DefaultReadThread exception: \", e); &#125; &#125; &#125; /** * 关闭读线程 */ void close() &#123; mRunning = false; try &#123; this.interrupt(); &#125; catch (Exception e) &#123; LogUtils.e(TAG, \"DefaultReadThread close: \", e); &#125; &#125;&#125; 一般会制定通讯协议，一个有效包需要完整包含起始、终止、以及校验位等，通过 InputStream 读取到字节数组后按照协议进行解析数据。读取有几个注意点： 数据包可能有多个类型，有的包 x 个字节，有的包 y 个字节，如果底层硬件都是往一个串口发送数据，那么就要做好解析的流程。每次读取应该是 x、y 的最大公约数，这样不管是 x 包还是 y 包发过来，我读取 n 次之后都能组装成一个完整的包，进行解析。例如：x = 30，y = 40，那么最好就是每次读取 10 个字节，这样读3次能组装成一个 x 的包，读 4 次组装成一个 y 的包。当然也可以直接一口气读取最大的值，40。但是这样就会导致一个问题：如果我发的是 x 包，只有 30 个字节，mInputStream.read(mReceiveBuffer) 会一直读满 40 个字节才返回，那么就会出现前 30 个字节是 x 包，后 10 个字节是 y 包的一部分，这样在解析的时候反而增加了成本。所以，目前项目中采用的就是 16 作为最大公约数，依此定义最小的包 16 个字节，其他的包必须是 16 的倍数，例如 32、64、128 等等。 所有的数据会先读取到一个 buffer 中，通过解析起始、结束标记位，来取出一个完整的包，再将 buffer 的剩余位左移此包的长度。例如我读取一个 64 字节的包，在读取多次后，buffer 长度正好为 70（可能有脏数据导致 buffer 长度不为 16 的倍数），假设解析到 start = 2,end = 66，start 之前的 2 个字节应该作为脏数据被抛弃掉，先将 2-&gt;66 位置的字节组装成 byte 数组抛到上层去解析。同时 buffer 左移 66 位，buffer 中就会只剩下 3 个字节了。 byte 数组作为通用结构，硬件层一般是 c、c++，写入的字节一般是小端序，而 Java 一般是大端序，所以需要进行转换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class ReadBytes &#123; // 是否需要高低位转换 private final boolean needHighLowCovert; private final byte[] data; private final int len; private int position = 0; public ReadBytes(byte[] data) &#123; this(data, false); &#125; public ReadBytes(byte[] data, boolean needHighLowCovert) &#123; this.data = data; this.len = data.length; this.needHighLowCovert = needHighLowCovert; &#125; public final byte read() throws IndexOutOfBoundsException &#123; return data[position++]; &#125; public void reset() &#123; position = 0; &#125; /** * 读取无符号byte * * @return * @throws IndexOutOfBoundsException */ public final int readUnsignedByte() throws IndexOutOfBoundsException &#123; return read() &amp; 0xff; &#125; public final byte[] readBytes(int len) throws IndexOutOfBoundsException &#123; byte[] value = Arrays.copyOfRange(data, position, position + len); position += len; return value; &#125; public final boolean readBoolean() throws IndexOutOfBoundsException &#123; byte value = read(); return value == 1; &#125; public final int readShort() throws IndexOutOfBoundsException &#123; int value; if (needHighLowCovert) &#123; value = (data[position++] &amp; 0xff) | ((data[position++] &amp; 0xff) &lt;&lt; 8); &#125; else &#123; value = ((data[position++] &amp; 0xff) &lt;&lt; 8) | data[position++]; &#125; return value; &#125; public final int readInt() throws IndexOutOfBoundsException &#123; int value; if (needHighLowCovert) &#123; value = ((data[position++] &amp; 0xFF) | ((data[position++] &amp; 0xFF) &lt;&lt; 8) | ((data[position++] &amp; 0xFF) &lt;&lt; 16) | ((data[position++] &amp; 0xFF) &lt;&lt; 24)); &#125; else &#123; value = ((data[position++] &amp; 0xFF) &lt;&lt; 24) | ((data[position++] &amp; 0xFF) &lt;&lt; 16) | ((data[position++] &amp; 0xFF) &lt;&lt; 8) | (data[position++] &amp; 0xFF); &#125; return value; &#125; public final long readLong() throws IndexOutOfBoundsException &#123; if (needHighLowCovert) &#123; return (((long) (data[position++]) &amp; 0xFF) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 8) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 16) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 24) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 32) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 40) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 48) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 56) ); &#125; else &#123; return (((long) (data[position++] &amp; 0xFF) &lt;&lt; 56) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 48) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 40) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 32) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 24) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 16) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 8) | ((long) (data[position++] &amp; 0xFF))); &#125; &#125; public final float readFloat() throws IndexOutOfBoundsException &#123; return Float.intBitsToFloat(readInt()); &#125; public final double readDouble() throws IndexOutOfBoundsException &#123; return Double.longBitsToDouble(readLong()); &#125;&#125; 串口在进行调试时不太方便，需要设备连接硬件，有时候在项目初始阶段，硬件采买十分有限。串口无非是不停写入数据然后应用层解析，所以为了方便调试，可以采用 Socket 方式（例如蓝牙）连接另一个客户端（手机人人都有），进行模拟写入数据。Java 在写入数据时，可以使用buffer.order(ByteOrder.LITTLE_ENDIAN) 来模拟底层硬件的小端序写入，这样解析端无需进行修改。 123456789101112131415161718192021222324252627282930313233343536373839404142private BluetoothSocket createSocket() throws IOException &#123; BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(macAddress); BluetoothSocket socket = device.createRfcommSocketToServiceRecord(uuid); socket.connect(); return socket;&#125;public OutputStream connect() throws IOException &#123; socket = createSocket(); os = socket.getOutputStream(); return os;&#125;@Overridepublic void encode(OutputStream os) throws IOException &#123; byte[] bytes = toBytes(); os.write(bytes);&#125;/** * 按照协议组装模拟数据 */public byte[] toBytes() &#123; byte[] data = toData(); ByteBuffer buffer = ByteBuffer.allocate(data.length + 9); buffer.order(ByteOrder.LITTLE_ENDIAN); // 帧头，两字节 0xA5 0x5A buffer.put((byte) 0xA5); buffer.put((byte) 0x5A); int length = data.length + 5; // 帧长 帧长不包括帧（起始+EOF） // len=1（帧长）+数据长度+4（校验） // 所以=1 + 43 + 4 buffer.put((byte) length); buffer.put(data); // 校验4 CRC-32数据域校验结果，CRC参数见* buffer.putInt(0xFFFFFFFF); // EOF2 0xC3 0xC3 buffer.put((byte) 0xC3); buffer.put((byte) 0xC3); return buffer.array();&#125;","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"ViewPager 左右突出","date":"2020-05-09T08:29:19.000Z","path":"2020/05/09/viewpager-1/","text":"日常开发中经常会有如下需求： ViewPager 左右突出，实现起来非常简单：123456&lt;android.support.v4.view.ViewPager android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:clipToPadding=\"false\" android:paddingLeft=\"48dp\" android:paddingRight=\"48dp\" /&gt; 添加 padding、clipToPadding 即可。现在还有几个需求： 两边的 item 小一点，并且有透明度 item 之间的间距固定 滑动有动画效果 第 1点使用 scale 进行缩放即可，但是左边需要向右缩放，右边需要向左缩放，才能保证第 2 点。第 2 点使用 setPageMargin。第 3 点使用 setPageTransformer。 transformPage 有 2 个参数： page，View: Apply the transformation to this page position，float: Position of page relative to the current front-and-center position of the pager. 0 is front and center. 1 is one full page position to the right, and -1 is one page position to the left. 也就是左边的 View -1~0 变化，右边的 View 0~1 变化。下面问题来了，显示的页面并非在中间的时候缩放到最大，而是要滑动到左边的边缘才是最大。通过断点调试，发现 postion 值就没有出现过0，也就是从来没有滑到“正中间”。看到代码调用 transformPage 的地方：123456789101112131415161718protected void onPageScrolled(int position, float offset, int offsetPixels) &#123; ... if (mPageTransformer != null) &#123; final int scrollX = getScrollX(); final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = getChildAt(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (lp.isDecor) continue; final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth(); mPageTransformer.transformPage(child, transformPos); &#125; &#125; ...&#125; 传回来的 transformPos 在进行计算时，没有考虑 ViewPager 的 padding，一切似乎都对应上了。自己计算位置，最终代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647viewPager.pageMargin = DimenUtils.dp2px(10f)viewPager.setPageTransformer(false) &#123; page: View, _: Float -&gt; var position = getPositionConsiderPadding(view.itemView.schoolViewPager, page) if (position &lt; -1) &#123; position = -1f &#125; if (position &gt; 1) &#123; position = 1f &#125; val scale: Float val alpha: Float val pivotX: Float val pivotY: Float when &#123; position &lt; 0 -&gt; &#123; scale = 1f + position * (1 - ORIGIN_SCALE) alpha = (0.5f + 0.5f * (1 + position)) pivotX = width.toFloat() pivotY = height / 2f &#125; position &gt; 0 -&gt; &#123; scale = 1f - position * (1 - ORIGIN_SCALE) alpha = (0.5f + 0.5f * (1 - position)) pivotX = 0f pivotY = height / 2f &#125; else -&gt; &#123; scale = 1f alpha = 1f pivotX = width / 2f pivotY = height / 2f &#125; &#125; page.alpha = alpha page.pivotX = pivotX page.pivotY = pivotY page.scaleX = scale page.scaleY = scale&#125;/** * 根据 padding 计算真实的 position */private fun getPositionConsiderPadding(viewPager: ViewPager, page: View): Float &#123; val clientWidth = (viewPager.measuredWidth - viewPager.paddingLeft - viewPager.paddingRight).toFloat() return ((page.left - viewPager.scrollX - viewPager.paddingLeft) / clientWidth)&#125; 注：scale 动画可以设置 x、y 的参照点，代码设置为相对值，不是百分比，所以需要根据百分比映射到真实的位置。 参考：解决几个ViewPager 异常问题 | 深入剖析","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"记一次电信一键登录的“BUG”","date":"2020-01-22T08:34:56.000Z","path":"2020/01/22/telecom/","text":"马上就要过年了，这几天公司的人越来越少，而我打算坚守到最后一天，虽然事情比较少，但也能稍微自己看点东西，充充电。然而，项目发布的 App 在华为渠道被拒了，原因是：在登录页的隐私协议，不能默认勾选上。然后我看到了这样的代码：123456789101112&lt;CheckBox android:id=\"@+id/check_box\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:button=\"@null\" android:checked=\"true\" android:drawableLeft=\"@drawable/account__protocol_agree\" android:drawablePadding=\"7dp\" android:enabled=\"false\" android:text=\"同意\" android:textColor=\"#333333\" android:textSize=\"12dp\" /&gt; 登录页的 CheckBox 被禁用了，肯定也是点不了的。然后改一下，默认不选中，并添加相应的逻辑判断。1234567891011121314&lt;CheckBox android:id=\"@+id/check_box\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:button=\"@drawable/account__login_protocol_agree_bg\" android:text=\" 同意\" android:textColor=\"#333333\" android:textSize=\"12dp\" /&gt;final boolean isChecked = protocolCb.isChecked();if (!isChecked) &#123; MainThreadUtils.toast(\"请先勾选同意《用户使用协议》和《隐私协议》\"); return;&#125; 一切都很顺利，直到电信一键登录。电信一键登录调起的页面是由 sdk 提供的，但是开发者可以提供布局，项目中的如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"35dp\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:orientation=\"horizontal\"&gt; &lt;CheckBox android:id=\"@+id/check_box\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:button=\"@null\" android:checked=\"true\" android:drawableLeft=\"@drawable/account__protocol_agree\" android:drawablePadding=\"7dp\" android:enabled=\"false\" android:text=\"\" android:textColor=\"#333333\" android:textSize=\"12dp\" /&gt; &lt;!-- 底部隐私协议文本配置说明： 1、SDK默认配置： a、文案的前面部分\"登录即同意《天翼账号服务与隐私协议》\"不可修改， b、《天翼账号服务与隐私协议》的色值通过android:tag属性设置，点击事件由SDK处理 --&gt; &lt;TextView android:id=\"@+id/reg_china_mobile_agreement\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"登录即同意《天翼账号服务与隐私协议》\" android:textSize=\"12dp\" android:textColor=\"#333333\" android:tag=\"#1DACF9\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"和\" android:textColor=\"#333333\" android:textSize=\"12dp\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:orientation=\"horizontal\"&gt; &lt;TextView android:id=\"@+id/reg_user_agreement\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"《用户使用协议》\" android:textColor=\"#1DACF9\" android:textSize=\"12dp\" /&gt; &lt;TextView android:id=\"@+id/reg_user_privacy_agreement\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"《隐私协议》\" android:textColor=\"#1DACF9\" android:textSize=\"12dp\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 调用代码如下：12345678910111213141516171819202122232425262728293031323334public void openQuickLoginActivity(Context context, QuickLoginModel quickLoginModel) &#123; AccountAssistUtils.onEvent(\"电信sdk-一键登录页\"); AuthPageConfig.Builder configBuilder = new AuthPageConfig.Builder() //设置“登录界面”的布局文件ID .setAuthActivityLayoutId(R.layout.account__activity_quick_login_china_telecom) //设置“登录界面”的控件ID .setAuthActivityViewIds(R.id.title_bar_left, //导航栏返回按钮ID R.id.phone_number, //脱敏号码文本控件ID R.id.ct_account_brand_view, //品牌标识文本控件ID R.id.ct_account_login_btn, //登录按钮控件ID R.id.ct_account_login_loading, //登录加载中控件ID（必须为ImageView控件） R.id.btn_one_key_login, //登录按钮文本控件ID R.id.btn_normal_login, //其他登录方式控件ID R.id.check_box, //隐私协议勾选框控件ID R.id.reg_china_mobile_agreement) //“服务与隐私协议”文本控件ID; //设置隐私协议WebviewActivity的布局文件ID .setWebviewActivityLayoutId(R.layout.account__activity_quick_login_china_telecom_argument) //设置隐私协议界面的控件ID .setWebviewActivityViewIds(R.id.ct_account_webview_goback, //导航栏返回按钮ID R.id.ct_account_progressbar_gradient, //进度条控件ID（ProgressBar控件） R.id.ct_account_webview) //协议内容WebView控件ID .setExtendView1(R.id.reg_user_agreement, v -&gt; AccountAssistUtils.toUserAgreement(MucangConfig.getCurrentActivity())) .setExtendView2(R.id.reg_user_privacy_agreement, v -&gt; &#123; AccountAssistUtils.toUserPrivacyAgreement(MucangConfig.getCurrentActivity()); &#125;); AuthPageConfig authPageConfig = configBuilder.build(); CtAuth.getInstance().openAuthActivity(context, authPageConfig, new ResultListener() &#123; @Override public void onResult(String json) &#123; onGetResult(context, json, quickLoginModel); &#125; &#125;);&#125; 然后我将 CheckBox 也类似的改了一下，结果崩溃了：123456789101112131415161718192021222324252627282020-01-21 16:49:13.087 32472-32472/? E/AndroidRuntime: FATAL EXCEPTION: main Process: com.xxx.xxx.android, PID: 32472 android.content.res.Resources$NotFoundException: Resource ID #0x0 at android.content.res.ResourcesImpl.getValue(ResourcesImpl.java:299) at android.content.res.Resources.loadXmlResourceParser(Resources.java:2398) at android.content.res.Resources.getLayout(Resources.java:1292) at android.view.LayoutInflater.inflate(LayoutInflater.java:534) at android.view.LayoutInflater.inflate(LayoutInflater.java:483) at com.android.internal.policy.PhoneWindow.setContentView(PhoneWindow.java:520) at com.android.internal.policy.HwPhoneWindow.setContentView(HwPhoneWindow.java:328) at android.app.Dialog.setContentView(Dialog.java:735) at cn.com.chinatelecom.account.sdk.ui.a.onCreate(Unknown Source:29) at android.app.Dialog.dispatchOnCreate(Dialog.java:579) at android.app.Dialog.show(Dialog.java:397) at cn.com.chinatelecom.account.sdk.ui.a.a(Unknown Source:2) at cn.com.chinatelecom.account.sdk.ui.b.b(Unknown Source:14) at cn.com.chinatelecom.account.sdk.ui.b.onClick(Unknown Source:18) at android.view.View.performClick(View.java:7192) at android.view.View.performClickInternal(View.java:7166) at android.view.View.access$3500(View.java:824) at android.view.View$PerformClick.run(View.java:27592) at android.os.Handler.handleCallback(Handler.java:888) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:213) at android.app.ActivityThread.main(ActivityThread.java:8169) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1101) 说找不到资源文件，很懵逼，然后去查看 demo、相关文档，也没找到详细的说明。来来回回试了很多次，浪费了很多时间，也没找到问题所在，只要一改 CheckBox，必然崩溃。然后临近下班了，同事说帮我看看。然后定位异常，看到：1cn.com.chinatelecom.account.sdk.ui.a.onCreate 于是找到相关的包，尽管混淆了，但是也能看。12345678910111213141516171819202122232425262728293031package cn.com.chinatelecom.account.sdk.ui;public class a extends Dialog &#123; private cn.com.chinatelecom.account.sdk.ui.a.a a; private Context b; private AuthPageConfig c; private AuthViewConfig d; private TextView e; private View f; private View g; public a(Context var1, int var2) &#123; super(var1, var2); this.b = var1; &#125; protected void onCreate(Bundle var1) &#123; super.onCreate(var1); this.c = cn.com.chinatelecom.account.sdk.a.d.a().b(); this.d = cn.com.chinatelecom.account.sdk.a.d.a().c(); this.setContentView(this.c.k()); this.setCanceledOnTouchOutside(false); this.a(); if (this.d != null) &#123; this.c(); &#125; &#125; ...&#125; 然后异常报的找不到资源文件，那么可以合理猜测为 setContentView 时传入的参数无效，然后看到参数为 c.k。c 是 AuthPageConfig。然后再来看到 AuthPageConfig 的 k 参数是什么：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static class Builder &#123; private int a; private int b; private int c; private int d; private int e; private int f; private int g; private int h; private int i; private int j; private int k; private int l; private int m; private int n; private int o; private int p; private int q; private int r; private int s; private int t; private int u; private OnClickListener v; private OnClickListener w; private OnClickListener x; private boolean y; private boolean z; private int A; private int B; private int C; private int D; public AuthPageConfig.Builder setAuthActivityLayoutId(int var1) &#123; this.a = var1; return this; &#125; public AuthPageConfig.Builder setAuthActivityViewIds(int var1, int var2, int var3, int var4, int var5, int var6, int var7, int var8, int var9) &#123; this.b = var1; this.c = var2; this.d = var3; this.e = var4; this.f = var5; this.g = var6; this.h = var7; this.i = var8; this.j = var9; return this; &#125; public AuthPageConfig.Builder setPrivacyDialogLayoutId(int var1) &#123; this.k = var1; return this; &#125; ...&#125; 即通过setPrivacyDialogLayoutId方法来设置一个 Dialog 的布局。那么为什么会需要一个 Dialog 呢？而且是在改过 CheckBox 之后才会蹦。这个时候合理猜测：CheckBox 默认不勾选之后，登录需要提醒用户，sdk 内部则是使用 Dialog 来提醒用户。感觉完全说得通啊！于是再详细看 demo、文档：123456789101112131415161718192021222324252627282930313233343536373839private AuthPageConfig getAuthPageConfig()&#123; AuthPageConfig.Builder configBuilder = new AuthPageConfig.Builder() //设置“登录界面”的布局文件ID .setAuthActivityLayoutId(R.layout.ct_account_auth_activity) //设置“登录界面”的控件ID .setAuthActivityViewIds(R.id.ct_account_nav_goback , //导航栏返回按钮ID R.id.ct_account_desensphone , //脱敏号码文本控件ID R.id.ct_account_brand_view, //品牌标识文本控件ID R.id.ct_account_login_btn , //登录按钮控件ID R.id.ct_account_login_loading , //登录加载中控件ID（必须为ImageView控件） R.id.ct_account_login_text , //登录按钮文本控件ID R.id.ct_account_other_login_way , //其他登录方式控件ID R.id.ct_auth_privacy_checkbox , //隐私协议勾选框控件ID R.id.ct_auth_privacy_text //“服务与隐私协议”文本控件ID ) //设置隐私协议对话框的布局文件ID .setPrivacyDialogLayoutId(R.layout.ct_account_privacy_dialog) //设置隐私协议对话框的控件ID .setPrivacyDialogViewIds(R.id.ct_account_dialog_privacy , //“服务与隐私协议”文本控件ID R.id.ct_account_dialog_cancel , // 返回按钮控件ID R.id.ct_account_dialog_confirm) //确认按钮控件ID //设置隐私协议WebviewActivity的布局文件ID .setWebviewActivityLayoutId(R.layout.ct_account_privacy_webview_activity) //设置隐私协议界面的控件ID .setWebviewActivityViewIds(R.id.ct_account_webview_goback , //导航栏返回按钮ID R.id.ct_account_progressbar_gradient , //进度条控件ID（ProgressBar控件） R.id.ct_account_webview); //协议内容WebView控件ID //扩展一：添加View及点击事件 （可选） //.setExtendView1(view1 ,onClickListener1) //.setExtendView1(view2 ,onClickListener2) //.setExtendView1(view2 ,onClickListener2) //扩展二：配置登录Activity进入动画和退出动画 （可选） //.setStartActivityTransition(enterAnim ,exitAnim) //.setFinishActivityTransition(enterAnim ,exitAnim) AuthPageConfig authPageConfig = configBuilder.build(); return authPageConfig;&#125; 也看到了 setPrivacyDialogLayoutId、setPrivacyDialogViewIds 方法的调用，感觉猜测很合理，于是在调用的地方也加入了相应的代码：123456//设置隐私协议对话框的布局文件ID.setPrivacyDialogLayoutId(R.layout.account__dialog_privacy_agree)//设置隐私协议对话框的控件ID.setPrivacyDialogViewIds(R.id.account_dialog_privacy, R.id.account_dialog_cancel, R.id.account_dialog_confirm) 然后果然没蹦了，当不勾选 CheckBox 的时候，会弹出 Dialog 来提醒用户。至此，问题解决。 反思很尴尬，反过头来看问题其实很简单，但是自己却没有找出来，同事耐着性子查看混淆的代码，顺藤摸瓜找到根源，也就不到一小时时间。而我却花费大量时间在表面上，完全瞎猜，觉得没道理。在编译、打包的期间也没有做更多的思考，看到混淆的代码也没跟进去，十分肤浅！写下这边文章倒不是真的因为这个 BUG 有多么难解，而是记录下自己的“狼狈”状态，以后一定要改进，凡事多跟进，多思考，耐着性子解决问题。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"2019 年终总结","date":"2020-01-15T06:25:39.000Z","path":"2020/01/15/summary-2019/","text":"还有八天便是除夕了，又到了年终总结的时候了。2019 的总结，一个字：「难」。诉乐不诉苦，不管多难自己承受，「任何杀不死的，都会使我变得更为强大」。2019 还是有一些好事的。 电子锁我思想比较传统，网上能看到各种关于电子锁的负面评价，各种担忧，一直止步不前。2019 年我想通了，任何事情都有两面，自己权衡即可。索性换了电子锁，从此出门不用再带钥匙，出门忘带钥匙的尴尬再也不会发生（之前忘带钥匙让家人帮忙送钥匙的记忆依然铭记于心）。用到现在也没出现盗窃现象，也确实方便了很多，尤其是手里拿着快递的时候，极大提升了生活的幸福指数。 土豆2019 做了许多之前想做，但没做的事情。养猫算是 Top 1。6月份开始将土豆带回家，到现在也有半年多了，不知不觉每天铲屎的操作竟然持续了这么久，要是减肥能如此就好了。看着初来乍到的土豆慢慢成长成现在的样子，我只想感叹一句：岁月是把杀猪刀，猫也适用。现在变肥了，也没以前萌了，但我依然爱他。半年多的时间，土豆得了一次肠胃炎，打了几针后慢慢恢复了。前不久带他去做了绝育，现在正在恢复中，希望后面复查没什么大问题。他就像我的孩子，希望能一直健康快乐的成长。 国庆自驾游一直想去祖国的大西北，因为从没有去过，见过，所以内心的欲望非常强烈。和朋友一次偶然的对话，彻底地将内心的火苗点燃。从初步确定到最终出行，中间隔了 5 个月，能够出游真是十分难得。8 天的行程，5000 多公里，一路上经历许多平常体验不到的景色和危险。每隔一段时间，内心便会很失落，平凡的生活一点点磨平自己的棱角，需要这样的一趟旅程来缓解，来赋予生活新的意义。 女朋友是的，2019 我认识了将会和我携手一生的伴侣，实现了三年前定的目标。和她相处，让我感觉在「做自己」，我不用装模作样，让我很舒服。也正是这种感觉，让我们的感情迅速升温，婚纱照也拍了。现在我已然半只脚踩在了婚姻的“坟墓”中，但在我看来，这不算“坟墓”，任何问题都是可以解决的，我的下一段生活也一定会幸福美满。 工作最后来聊聊工作，年前最后一个季度加入到新的项目组，由于是公司最重要的项目，也是公司最直接的经济来源，项目成员都变忙了许多。大家忙前忙后，总算在过年前给公司交了一份满意的答卷，项目团队获得了年度最佳团队，奖励 20 万元。本以为自己也能获得表彰，拿一份奖项，然而并没有，就连绩效都是史上最低，有点失落。但也思考了这一年自己的工作成长，发现还是有一些事情是可以进步的，新的一年新的目标，奥里给！","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"TextView 自定义“ellipsize”","date":"2019-12-24T03:23:43.000Z","path":"2019/12/24/textview-suffix/","text":"日常开发中，经常有 TextView 最多显示 3 行，超出了就显示“…查看更多”，在网上找到一个十分方便使用的类，原理也很简单，摘录一下，以后开发类似需求再也不愁了~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442private const val logTag = \"TextViewLayout\"private val enableDebugLog = BuildConfig.DEBUGprivate fun log(any: Any?) &#123; if (enableDebugLog) &#123; LogUtils.d(logTag, any.toString()) &#125;&#125;/** * TextViewBuilder * ellipsize textView with custom suffix. * link: https://juejin.im/post/5d4a5fb66fb9a06b0517d7eb */class TextViewSuffixWrapper(val textView: TextView) &#123; private data class SuffixColor(val fromIndex: Int, val toIndex: Int, val color: Int?, val listener: View.OnClickListener? = null) var mainContent: CharSequence = textView.text set(value) &#123; collapseCache = null field = value &#125; var suffix: CharSequence? = null set(value) &#123; collapseCache = null field = value &#125; private var collapseCache: CharSequence? = null private var collapseLayoutCache: Layout? = null var isCollapsed: Boolean = false private set var enableCache = false var enableMaxLinesCheck = true var targetLineCount: Int = 2 var transition: Transition? = AutoTransition() var sceneRoot: ViewGroup = textView.parent as ViewGroup private val textWrapper: (text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence = &#123; text, suffix, suffixIndex -&gt; SpannableStringBuilder(text).apply &#123; suffixColorList.forEach &#123; val start = suffixIndex + it.fromIndex val end = suffixIndex + it.toIndex it.listener?.also &#123; listener -&gt; setSpan(object : ClickableSpan() &#123; override fun onClick(widget: View) &#123; listener.onClick(widget) &#125; &#125;, start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) textView.movementMethod = LinkMovementMethod.getInstance() &#125; it.color?.also &#123; color -&gt; setSpan(ForegroundColorSpan(color), start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) &#125; &#125; &#125; &#125; private val suffixColorList by lazy &#123; mutableListOf&lt;SuffixColor&gt;() &#125; init &#123; if (textView.layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; throw RuntimeException(\"textView's width can't be wrap_content. Only support match_parent or specified size\") &#125; &#125; fun suffixColor(fromIndex: Int, toIndex: Int, @ColorRes colorRes: Int) &#123; val color = ResourcesCompat.getColor(textView.resources, colorRes, textView.context.theme) suffixColorList.add(SuffixColor(fromIndex, toIndex, color, null)) &#125; fun suffixColor(fromIndex: Int, toIndex: Int, listener: View.OnClickListener) &#123; suffixColorList.add(SuffixColor(fromIndex, toIndex, null, listener)) &#125; fun suffixColor(fromIndex: Int, toIndex: Int, @ColorRes colorRes: Int, listener: View.OnClickListener) &#123; val color = ResourcesCompat.getColor(textView.resources, colorRes, textView.context.theme) suffixColorList.add(SuffixColor(fromIndex, toIndex, color, listener)) &#125; @JvmOverloads fun collapse(animation: Boolean = true) &#123; performCollapse( if (animation) &#123; transition &#125; else &#123; null &#125; ) &#125; @JvmOverloads fun toggle(animation: Boolean = true) &#123; if (isCollapsed) &#123; expand(animation) &#125; else &#123; collapse(animation) &#125; &#125; @JvmOverloads fun expand(animation: Boolean = true) &#123; performExpand( if (animation) &#123; this.transition &#125; else &#123; null &#125; ) &#125; private fun performExpand(transition: Transition?) &#123; isCollapsed = false textView.expand(mainContent = mainContent, transition = transition, sceneRoot = sceneRoot) &#125; private fun performCollapse(transition: Transition?) &#123; require(!(enableMaxLinesCheck &amp;&amp; textView.maxLines &lt; targetLineCount)) &#123; \"textView.maxLines($&#123;textView.maxLines&#125;) &lt; targetLineCount($targetLineCount)\" &#125; isCollapsed = true fun defaultCollapse() &#123; textView.maxLines = targetLineCount textView.ellipsize = TextUtils.TruncateAt.END val originText = textView.text textView.text = mainContent if (transition != null) &#123; textView.apply &#123; val layout = this.layout if (layout != null) &#123; val targetHeight = layout.height + paddingTop + paddingBottom text = originText maxLines = Int.MAX_VALUE layoutParams.height = targetHeight layoutParams = layoutParams transition.addListener(object : TransitionListenerAdapter() &#123; override fun onTransitionEnd(transition: Transition) &#123; transition.removeListener(this) layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT layoutParams = layoutParams maxLines = targetLineCount text = mainContent &#125; override fun onTransitionCancel(transition: Transition) &#123; transition.removeListener(this) &#125; &#125;) &#125; TransitionManager.beginDelayedTransition(sceneRoot, transition) &#125; &#125; &#125; if (suffix == null) &#123; defaultCollapse() &#125; else &#123; if (enableCache &amp;&amp; collapseCache != null &amp;&amp; collapseLayoutCache == textView.layout) &#123; if (collapseCache == mainContent) &#123; return &#125; if (transition != null) &#123; textView.setTextWithAnimator(content = collapseCache!!, transition = transition, sceneRoot = sceneRoot) &#125; else &#123; textView.maxLines = targetLineCount textView.ellipsize = TextUtils.TruncateAt.END textView.text = collapseCache &#125; &#125; else &#123; textView.collapse( mainContent = mainContent, suffix = suffix!!, targetLineCount = targetLineCount, transition = transition, sceneRoot = sceneRoot, onSuccess = &#123; text -&gt; collapseCache = text collapseLayoutCache = textView.layout &#125;, onFailed = &#123; defaultCollapse() &#125;, textWrapper = textWrapper ) &#125; &#125; &#125;&#125;@JvmOverloadsfun TextView.setTextWithAnimator( content: CharSequence, transition: Transition = AutoTransition(), sceneRoot: ViewGroup = this.parent as ViewGroup) &#123; val originText = this.text this.text = content val layout = this.layout if (layout != null) &#123; val targetHeight = layout.height + paddingTop + paddingBottom text = originText layoutParams.height = targetHeight layoutParams = layoutParams transition.addListener(object : TransitionListenerAdapter() &#123; override fun onTransitionEnd(transition: Transition) &#123; transition.removeListener(this) layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT layoutParams = layoutParams text = content &#125; override fun onTransitionCancel(transition: Transition) &#123; transition.removeListener(this) &#125; &#125;) &#125; TransitionManager.beginDelayedTransition(sceneRoot, transition)&#125;/** * collapse TextView * @param mainContent text * @param suffix suffix * @param targetLineCount targetLineCount * @param transition for animation. If is null, there will be no animation and it will take effect immediately. * @param onSuccess There may be asynchronous operations here, You can listen to the end event via onSuccess. * @param textWrapper You can wrap the text, such as changing the color through a SpannableString. */fun TextView.collapse( mainContent: CharSequence, suffix: CharSequence, targetLineCount: Int, transition: Transition? = AutoTransition(), sceneRoot: ViewGroup = this.parent as ViewGroup, onSuccess: ((text: CharSequence) -&gt; Unit)? = null, onFailed: ((text: CharSequence) -&gt; Unit)? = null, textWrapper: ((text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence)?) &#123; val originText = text setTextWithSuffix( mainContent = mainContent, suffix = suffix, targetLineCount = targetLineCount, onSuccess = &#123; result -&gt; if (transition == null) &#123; onSuccess?.invoke(result) &#125; else &#123; val targetText = text val targetHeight = layout.height + paddingTop + paddingBottom text = originText layoutParams.height = targetHeight layoutParams = layoutParams transition.addListener(object : TransitionListenerAdapter() &#123; override fun onTransitionEnd(transition: Transition) &#123; transition.removeListener(this) layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT layoutParams = layoutParams text = targetText onSuccess?.invoke(result) &#125; override fun onTransitionCancel(transition: Transition) &#123; transition.removeListener(this) &#125; &#125;) TransitionManager.beginDelayedTransition(sceneRoot, transition) &#125; &#125;, onFailed = &#123; this.text = mainContent this.maxLines = targetLineCount onFailed?.invoke(mainContent) &#125;, textWrapper = textWrapper )&#125;/** * expand TextView * @param mainContent text * @param transition for animation. If is null, there will be no animation and it will take effect immediately. */fun TextView.expand( mainContent: CharSequence, transition: Transition? = AutoTransition(), sceneRoot: ViewGroup = this.parent as ViewGroup) &#123; this.maxLines = Int.MAX_VALUE this.text = mainContent transition?.also &#123; TransitionManager.beginDelayedTransition(sceneRoot, it) &#125;&#125;fun TextView.setTextWithSuffix( mainContent: CharSequence, suffix: CharSequence, targetLineCount: Int, onSuccess: (text: CharSequence) -&gt; Unit = &#123;&#125;, onFailed: (text: CharSequence) -&gt; Unit = &#123; text -&gt; this.text = text maxLines = targetLineCount ellipsize = TextUtils.TruncateAt.END &#125;, textWrapper: ((text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence)?) &#123; val originText = text fun autoSet(index: Int) &#123; if (index &lt; 0) &#123; onFailed(originText) &#125; else &#123; text = if (index &gt;= mainContent.length) &#123; mainContent &#125; else &#123; val msg = \"$&#123;mainContent.substring(0, index)&#125;$suffix\" textWrapper?.invoke(msg, suffix, index) ?: msg &#125; onSuccess(text) &#125; &#125; if (layout == null) &#123; val listener = object : View.OnLayoutChangeListener &#123; override fun onLayoutChange( v: View?, left: Int, top: Int, right: Int, bottom: Int, oldLeft: Int, oldTop: Int, oldRight: Int, oldBottom: Int ) &#123; removeOnLayoutChangeListener(this) if (layout == null) &#123; onFailed(text) &#125; else &#123; post &#123; val start = System.currentTimeMillis() autoSet(binarySearch(mainContent, suffix, targetLineCount, textWrapper)) val end = System.currentTimeMillis() log(\"&gt;&gt;&gt;&gt;&gt;performance: $&#123;end - start&#125;ms\") &#125; &#125; &#125; &#125; addOnLayoutChangeListener(listener) requestLayout() &#125; else &#123; val start = System.currentTimeMillis() autoSet(binarySearch(mainContent, suffix, targetLineCount, textWrapper)) val end = System.currentTimeMillis() log(\"&gt;&gt;&gt;&gt;&gt;performance: $&#123;end - start&#125;ms\") &#125;&#125;/** * Note: binary search will change the text, so be sure to remember the case where the search failed. */private fun TextView.binarySearch( mainContent: CharSequence, suffix: CharSequence, targetLineCount: Int, textWrapper: ((text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence)?): Int &#123; var verifyCount = 0 val verifyCache = mutableMapOf&lt;Int, Int&gt;() fun verify(start: Int, end: Int): Int &#123; val key = (start shl 16) or end val hit = verifyCache[key] if (hit != null) &#123; log(\"verify: $end cached\") return hit &#125; verifyCount++ val tmp = mainContent.substring(start, end) val context = \"$tmp$suffix\" text = textWrapper?.invoke(context, suffix, end) ?: context val lineCount = this.lineCount log(\"verify: $end, lineCount = $lineCount\") verifyCache[key] = lineCount return lineCount &#125; if (layout == null) &#123; log(\"layout is null\") return -1 &#125; val verify = verify(0, mainContent.length) if (verify &lt;= targetLineCount) &#123; log(\"verify &lt;= targetLineCount, verify = $verify, targetLineCount = $targetLineCount\") text = mainContent return mainContent.length &#125; // Remove optimization. Some special characters will cause bug. // var left = this.layout.getLineEnd(targetLineCount - 2) // var right = this.layout.getLineEnd(targetLineCount - 1) var left = 0 var right = mainContent.length log(\"left = $left, right = $right\") while (left &lt;= right) &#123; val mid = (left + right) / 2 val pLineCount = verify(0, mid) var s = \"binarySearch: ($left, $mid, $right), pLineCount = $pLineCount\" if (pLineCount &lt; targetLineCount) &#123; s += \", targetLineCount = $targetLineCount, pLineCount &lt; targetLineCount\" left = mid + 1 &#125; else if (pLineCount == targetLineCount) &#123; val nLineCount = verify(0, mid + 1) s += \", nLineCount = $nLineCount\" if (nLineCount &lt; targetLineCount + 1) &#123; left = mid + 1 &#125; else if (nLineCount == targetLineCount + 1) &#123; log(\"success = $mid, verifyCount = $verifyCount\") return mid &#125; else &#123; // error impossible log(\"impossible\") break &#125; &#125; else &#123; right = mid - 1 &#125; log(\"$s, text = $&#123;mainContent.substring(0, mid) + suffix&#125;\") &#125; log(\"failed, verifyCount = $verifyCount\") return -1&#125; 使用：12345678TextViewSuffixWrapper(topicView.descTv).apply &#123; targetLineCount = 3 suffix = \"...查看全部\" suffix?.apply &#123; suffixColor(\"...\".length, length, R.color.main_title_text_color_checked) &#125; collapse(false)&#125; 还可以添加点击事件，点击后撑开，着实方便~ 参考：Android TextView用”查看更多”替代自带ellipsize","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"土豆历险记","date":"2019-12-18T06:58:46.000Z","path":"2019/12/18/cat-1/","text":"上上周末，带土豆去洗了一次澡。从领回家到现在，就洗过一次澡…洗完澡之后，在烘干机里瑟瑟发抖。 后面回到家，可神气了。嗯，然后没过几天，早晨起来铲屎的时候，土豆在我旁边颤抖，痉挛，然后吐了几口“水”出来了。当时赶着要上班，没办法，只把呕吐物处理了一下就出门了。然后下班回去后，又看到吐了一次。顿时心里发凉，从来没有给猫看病的经验，也不知道土豆现在是个什么样的情况，土豆要是能说话就好了。没有办法，当即地图查询附近的宠物医院，然后找了一家最近的，把土豆送过去。话不多说，检查先来一套，花费 280 块。根据检查结果，排除猫瘟的可能性，初步判断为肠胃炎。起初我还以为是洗澡给搞感冒了，但是隔了三天之久，可能性不大。土豆精神萎靡不振，也不进食，非常担心。根据检测结果，后面听医生的，给打了 3 针小针，合计 120 块，然后带回家观察。好运的是，土豆没有再吐了，但是仍然不进食，以前一天的量现在放几天都没怎么吃，水也喝得很少，无奈只能不停得给他喂营养膏。以前看到这玩意，土豆都是箭步冲过来，然后扒拉我，不停得叫，吃得贼香。现在给他送到嘴边，也只是非常淑女地吃几口。前后巨大的落差让我越发地担心土豆的病情。看到没吐之后，就没送到医院去看了。结果有一天，他拉完屎蹦到我桌上，屁股对着我，我一瞅：哎哟卧槽，怎么还有血！然后就又慌了，连忙送到医院。当时都过了晚上 8.30 了，医院还说过了下班的点，看病得加 120 块钱。好歹我嘴皮子能磨：这我是今天才知道，要不今天就算了吧？我后面肯定尽量早些送过来。医生：好吧。省了 120 块，嘿嘿嘿…嗯，送到医院后，医生：需要再做个检查，但是还是看你。前几天做得检查只能说明当时情况正常，不代表这几天有没有恶化。这话意思很明显，就是不给我明确的病情解析，让我瞎担心，然后掏钱给土豆做检查。但是我一个理科生，怎么能被如此忽悠！我：看情况应该是拉屎有问题，就做个便检吧，这几天土豆没怎么吃喝，也没去过外面，应该不会出现新的病情。然后就只做了一个便检，说情况正常，没有检测到寄生虫、病菌之类的，符合肠胃炎的特征，听完我就稍微放心了些。然后又和我说：土豆现在的情况还是不容乐观，建议打针或者输液，但是具体选择还是在你，我们只提供建议。mmp，听完这句话我内心就炸了：你作为一个医生，不为我提供专业的诊断，尽在这忽悠我，这有可能，那有可能，让我瞎操心，然后就好掉进你们的陷阱，你们说啥就是啥了吧。随便检查一下，打个针，400 块没了，你们就只能赚这种钱？虽然我是这样想，但是我并没有明说，我只是淡淡地说，今天太晚了，就不打针了，明天早上（周末了）我再送过来打针吧，然后就溜了。然后观察了一晚，突然发现土豆有进食的欲望了！诶(二声)，这是有慢慢恢复的趋势啊！然后第二天观察土豆精神还不错，略有进食，结合我们人生病的情况来看，我觉得应该是慢慢恢复了，索性就没送去输液了。然后下午医生联系我：土豆今天情况怎么样？我：看着还不错，我再观察观察。然后这医生就没叼我了。呵呵哒…还好这几天土豆恢复得不错，胃口越来越好，食量慢慢恢复到之前得水准，也越来越有精神了。截至今日，应该算恢复得差不多了。这次给猫治病的经历，给我上了一堂课，以前以为养猫很简单，就每天喂喂食物和水，然后铲铲屎就行了，但是给猫看病才是真正麻烦的问题，也是消费最贵的。给猫看病，需要有自己的判断力，不能被不良医院忽悠。就像人得了个感冒，医院却把你当癌症来治。同时，自己日常需要多补充些猫相关的知识，这样才能更好的照顾他们。后面再也不能喂他吃人吃的食物了，早晨在家吃个馒头、包子、火腿肠啊，就跑过来大眼睛瞪着你，然后不停的叫，就会弄一丢丢给他吃，这也许就是土豆得肠胃炎的根本原因，还是只喂猫粮、营养膏，不然生病了就得不偿失。再贴几张土豆这几天的照片： 参考对于患肠胃炎的猫咪应该如何调理？89%铲屎官都不知道的养猫知识！记录猫咪急性肠胃炎的诊断和治疗方法","tags":[{"name":"cat","slug":"cat","permalink":"http://lijia92.github.io/tags/cat/"}]},{"title":"记一次动画实践-续","date":"2019-12-18T03:28:39.000Z","path":"2019/12/18/anim-continue/","text":"嗯，这篇文章是接着上一篇的，因为需求“变”了。上一篇文章中已经实现了滑动动画效果，现在需求变为：当停止滑动时，判断当前状态，若满足一个阈值就直接展开或者收起，也就是动画进度为 0 或 1 的状态。如果只是单纯这种展开或者收起的效果，使用 layout_scrollFlags 的 snap 效果即可实现。layout_scrollFlags 有 5 种效果，摘录一片博客中的内容： scroll The view will be scroll in direct relation to scroll events. This flag needs to be set for any of the other flags to take effect. If any sibling views before this one do not have this flag, then this value has no effect. Child View 伴随着滚动事件而滚出或滚进屏幕。注意两点：第一点，如果使用了其他值，必定要使用这个值才能起作用；第二点：如果在这个 Child View 前面的任何其他 Child View 没有设置这个值，那么这个 Child View 的设置将失去作用。 enterAlways When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling. This is commonly referred to as the ‘quick return’ pattern. 快速返回模式。其实就是向下滚动时 Scrolling View 和 Child View 之间的滚动优先级问题。对比 scroll 和 scroll | enterAlways 设置，发生向下滚动事件时，前者优先滚动 Scrolling View，后者优先滚动 Child View，当优先滚动的一方已经全部滚进屏幕之后，另一方才开始滚动。 enterAlwaysCollapsed An additional flag for ‘enterAlways’ which modifies the returning view to only initially scroll back to it’s collapsed height. Once the scrolling view has reached the end of it’s scroll range, the remainder of this view will be scrolled into view. The collapsed height is defined by the view’s minimum height. enterAlways的附加值。这里涉及到 Child View 的高度和最小高度，向下滚动时，Child View 先向下滚动最小高度值，然后 Scrolling View 开始滚动，到达边界时，Child View 再向下滚动，直至显示完全。 exitUntilCollapsed When exiting (scrolling off screen) the view will be scrolled until it is ‘collapsed’. The collapsed height is defined by the view’s minimum height. 这里也涉及到最小高度。发生向上滚动事件时，Child View 向上滚动退出直至最小高度，然后 Scrolling View 开始滚动。也就是，Child View 不会完全退出屏幕。 snap Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it’s closest edge. For example, if the view only has it’s bottom 25% displayed, it will be scrolled off screen completely. Conversely, if it’s bottom 75% is visible then it will be scrolled fully into view. 简单理解，就是 Child View 滚动比例的一个吸附效果。也就是说，Child View 不会存在局部显示的情况，滚动 Child View 的部分高度，当我们松开手指时，Child View 要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似 ViewPager 的左右滑动。 给 bgView 添加使用 snap 效果：12345678&lt;ImageView android:id=\"@+id/bgView\" android:layout_width=\"match_parent\" android:layout_height=\"375dp\" android:layout_marginBottom=\"-217dp\" android:scaleType=\"fitXY\" android:src=\"@drawable/jiakao_ke3_exam_route_unbuy_banner\" app:layout_scrollFlags=\"scroll|snap\" /&gt; 运行后 bgView 一直是张开状态，收不起来。如果把 marginBottom 去掉则可以收起了。目测是必须要滑到 一半的距离 才可以收起。于是跑到源码里去看，研究了一阵没发现修改这个距离的办法。由于是原生提供，所以我更倾向这个方案。无奈界面的覆盖效果，必须使用 marginBottom 设置负值，所以只能另寻他法了。那么便只能自己监听事件，来做滑动了。自定义 CoordinatorLayout 判断上滑、下滑：12345678910111213141516171819202122232425262728293031323334class ExamVideoCoordinatorLayout(context: Context, attr: AttributeSet) : CoordinatorLayout(context, attr) &#123; var listener: ExamVideoScrollListener? = null private var originY = 0F private val scrollHandler = Handler() @SuppressLint(\"ClickableViewAccessibility\") override fun dispatchTouchEvent(event: MotionEvent): Boolean &#123; if (event.action == MotionEvent.ACTION_DOWN) &#123; originY = event.y scrollHandler.removeCallbacksAndMessages(null) &#125; else if (event.action == MotionEvent.ACTION_UP) &#123; val y = event.y if (y &gt; originY) &#123; scrollHandler.postDelayed(&#123; listener?.scrollDown() &#125;, 100L) &#125; else &#123; scrollHandler.postDelayed(&#123; listener?.scrollUp() &#125;, 100L) &#125; &#125; return super.dispatchTouchEvent(event) &#125;&#125;interface ExamVideoScrollListener &#123; fun scrollUp() fun scrollDown()&#125; 然后设置 listener：123456789101112131415161718192021222324252627282930coordinator.listener = object : ExamVideoScrollListener &#123; override fun scrollUp() &#123; appBarLayout.post &#123; val behavior = (appBarLayout?.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior if (behavior is AppBarLayout.Behavior) &#123; val topAndBottomOffset = behavior.topAndBottomOffset if (Math.abs(topAndBottomOffset) &gt; DimenUtils.dp2px(150F) * 0.2) &#123; appBarLayout.setExpanded(false, true) &#125; else &#123; appBarLayout.setExpanded(true, true) &#125; &#125; &#125; &#125; override fun scrollDown() &#123; appBarLayout.post &#123; val behavior = (appBarLayout?.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior if (behavior is AppBarLayout.Behavior) &#123; val topAndBottomOffset = behavior.topAndBottomOffset if (Math.abs(topAndBottomOffset) &lt; DimenUtils.dp2px(150F) * 0.8) &#123; appBarLayout.setExpanded(true, true) &#125; else &#123; appBarLayout.setExpanded(false, true) &#125; &#125; &#125; &#125;&#125; 通过判断 AppBarLayout 的 topAndBottomOffset 值，来执行 appBarLayout.setExpanded() 方法，第一个参数为 appBarLayout 是否打开，第二个参数为是否使用动画。使用此种方式，基本能实现效果，但是有小概率操作（手指 fling），会导致 AppBarLayout 处于中间态，目前还没发现好的解决办法，只能先妥协了~ 参考：Android 详细分析AppBarLayout的五种ScrollFlags","tags":[]},{"title":"记一次动画实践","date":"2019-12-12T03:48:19.000Z","path":"2019/12/12/anim/","text":"废话少说，先上效果图： Your browser does not support the video tag.得如何实现这样的效果呢？ 首先，将动画拆分几个独立的部分： 「芳草地考场」横轴从左侧移动到中间，纵轴移动到标题栏，字体同时变小； 「切换考场」纵轴移动到标题栏，距离右侧边距变斤，字体同时变小； 「标题栏」背景渐变，图标颜色变化； 「考场横向列表」缩小，左移靠边，同时能吸顶； 现在来考虑具体要怎么做。做开始想到的就是 CoordinatorLayout + CollapsingToolbarLayout 来实现，Google 后发现实现的效果与预期不同，又没有足够的时间去研究，所以抛弃了此方案，打算直接自己写。那么要如何写呢？动画无非是由一系列的状态组合起来的，当滑动 100dp 时，界面这样展示；当滑动 200dp 时，界面那样展示。思路就很明确了：直接监听页面滑动，根据滑动的距离，来展示界面所有的元素。那么剩下的，便是根据滑动距离，来做 4 个部分动画元素的展示了。最终实现的 xml 布局如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#F7FBFF\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appBarLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" app:elevation=\"0dp\"&gt; &lt;ImageView android:id=\"@+id/bgView\" android:layout_width=\"match_parent\" android:layout_height=\"375dp\" android:layout_marginBottom=\"-217dp\" android:scaleType=\"fitXY\" android:src=\"@drawable/jiakao_ke3_exam_route_unbuy_banner\" app:layout_scrollFlags=\"scroll\" /&gt; &lt;LinearLayout android:id=\"@+id/videoLl\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"12dp\" android:layout_marginTop=\"68dp\" android:layout_marginRight=\"-12dp\" android:background=\"@drawable/bg_white_corner_5dp\" android:orientation=\"vertical\" android:paddingBottom=\"12dp\" tools:ignore=\"MissingPrefix\"&gt; &lt;include android:id=\"@+id/tipView\" layout=\"@layout/exam_route_line_top_tip\" android:layout_width=\"match_parent\" android:layout_height=\"36dp\" android:layout_marginRight=\"12dp\" android:visibility=\"invisible\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/placeRv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:clipToPadding=\"false\" android:paddingRight=\"27dp\" /&gt; &lt;/LinearLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:clipToPadding=\"false\" android:paddingBottom=\"80dp\" android:scrollbars=\"none\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;include layout=\"@layout/layout_exam_video_unbuy_bottom\" /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;RelativeLayout android:id=\"@+id/titleRl\" android:layout_width=\"match_parent\" android:layout_height=\"68dp\" android:fitsSystemWindows=\"true\" app:layout_behavior=\".paid_video.behavior.ExamTitleBehavior\"&gt; &lt;ImageView android:id=\"@+id/backIv\" android:layout_width=\"50dp\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"1dp\" android:layout_marginTop=\"20dp\" android:scaleType=\"centerInside\" android:src=\"@drawable/core__title_bar_back_icon\" android:tint=\"#FFFFFFFF\" /&gt; &lt;TextView android:id=\"@+id/locationTv\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_alignParentRight=\"true\" android:layout_marginTop=\"20dp\" android:layout_marginRight=\"22dp\" android:gravity=\"center_vertical\" android:includeFontPadding=\"false\" android:text=\"北京\" android:textColor=\"#FFFFFFFF\" android:textSize=\"14dp\" /&gt; &lt;ImageView android:id=\"@+id/locationIv\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_marginTop=\"20dp\" android:layout_marginRight=\"5dp\" android:layout_toLeftOf=\"@id/locationTv\" android:src=\"@drawable/jiakao__ic_exam_route_video_dizhi\" android:tint=\"#FFFFFFFF\" /&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=\"@+id/titleTv\" android:layout_width=\"wrap_content\" android:layout_height=\"48dp\" android:layout_marginLeft=\"28dp\" android:layout_marginTop=\"230dp\" android:ellipsize=\"marquee\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:gravity=\"center\" android:marqueeRepeatLimit=\"marquee_forever\" android:maxWidth=\"200dp\" android:singleLine=\"true\" android:textColor=\"#000\" android:textSize=\"21sp\" android:textStyle=\"bold\" app:layout_behavior=\".paid_video.behavior.ExamPlaceNameBehavior\" tools:text=\"芳草地考场\" /&gt; &lt;TextView android:id=\"@+id/switchPlaceTv\" android:layout_width=\"106dp\" android:layout_height=\"32dp\" android:layout_gravity=\"right\" android:layout_marginTop=\"238dp\" android:layout_marginRight=\"15dp\" android:background=\"@drawable/bg_shape_ff8149_ff2803_r100\" android:gravity=\"center\" android:text=\"切换考场 &gt;\" android:textColor=\"#ffffff\" android:textSize=\"16sp\" app:layout_behavior=\".paid_video.behavior.SwitchPlaceBehavior\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 下面逐一来解析。 bgView 是最上面的背景图，高度 375dp，「考场横向列表」卡片需要覆盖一部分在上面，AppBarLayout 是继承自 LinearLayout 的，所以加了个 android:layout_marginBottom=”-217dp” 以此来实现覆盖效果。 当滑到最大值时，顶部的 tipView 与 placeRv 需要吸顶，所以二者组合为一个 LinearLayout，同时只给 bgView 设置 app:layout_scrollFlags=”scroll”，便可实现吸顶。因为整个界面是通栏，所以在动画结束状态，videoLl 需要设置一个 android:layout_marginTop=”68dp”，使其正好处于标题栏之下。参考Android 滑动吸顶效果。 「芳草地考场」、「切换考场」、「标题栏」需要在页面最上层展示，所以直接写到 CoordinatorLayout 最外层。 「芳草地考场」、「切换考场」 的 marginTop 都是依据设计稿写死的值，使其正好处于 AppBarLayout 的某个位置，不能轻易改。 NestedScrollView include 底部的列表布局，进行嵌套滑动。 ok，现在静态界面写好了，下面就是要根据页面滑动来进行元素展示了。CoordinatorLayout 直接子孩子可以直接使用 Behavior，这样可以将 4 个动画块分开，非直接子孩子则使用监听的方式。「芳草地考场」Behavior：1234567891011121314151617181920212223242526272829303132class ExamPlaceNameBehavior(context: Context, attr: AttributeSet) : CoordinatorLayout.Behavior&lt;TextView&gt;(context, attr) &#123; private val dp230 = DimenUtils.dp2px(230F) private val startLeftMargin = DimenUtils.dp2px(28F) private val topMarginGap = dp230 - DimenUtils.dp2px(20F) override fun layoutDependsOn(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; return dependency is AppBarLayout &#125; override fun onDependentViewChanged(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; if (dependency is AppBarLayout) &#123; val offset = abs(dependency.top) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; val maxMargin = (DimenUtils.getScreenWidth() - child.width) / 2 (child.layoutParams as CoordinatorLayout.LayoutParams).leftMargin = (startLeftMargin + (maxMargin - startLeftMargin) * progress).toInt() (child.layoutParams as CoordinatorLayout.LayoutParams).topMargin = (dp230 - topMarginGap * progress).toInt() child.isSelected = progress == 0F child.textSize = 21 - 4 * progress child.requestLayout() return true &#125; return false &#125;&#125; 「切换考场」Behavior：12345678910111213141516171819202122232425262728293031323334353637class SwitchPlaceBehavior(context: Context, attr: AttributeSet) : CoordinatorLayout.Behavior&lt;TextView&gt;(context, attr) &#123; private val dp15 = DimenUtils.dp2px(15F) private val dp32 = DimenUtils.dp2px(32F) private val dp106 = DimenUtils.dp2px(106F) private val dp238 = DimenUtils.dp2px(238F) private val widthGap = DimenUtils.dp2px(106F - 86F) private val heightGap = DimenUtils.dp2px(32F - 28F) private val rightMarginGap = DimenUtils.dp2px(15F - 12F) private val topMarginGap = DimenUtils.dp2px(238F - 30F) override fun layoutDependsOn(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; return dependency is AppBarLayout &#125; override fun onDependentViewChanged(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; if (dependency is AppBarLayout) &#123; val offset = abs(dependency.top) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; (child.layoutParams as ViewGroup.MarginLayoutParams).width = (dp106 - widthGap * progress).toInt() (child.layoutParams as ViewGroup.MarginLayoutParams).height = (dp32 - heightGap * progress).toInt() (child.layoutParams as ViewGroup.MarginLayoutParams).rightMargin = (dp15 - rightMarginGap * progress).toInt() (child.layoutParams as ViewGroup.MarginLayoutParams).topMargin = (dp238 - topMarginGap * progress).toInt() child.textSize = 16 - 2 * progress child.requestLayout() return true &#125; return false &#125;&#125; 「标题栏」Behavior：123456789101112131415161718192021222324252627282930class ExamTitleBehavior(context: Context, attr: AttributeSet) : CoordinatorLayout.Behavior&lt;RelativeLayout&gt;(context, attr) &#123; override fun layoutDependsOn(parent: CoordinatorLayout, child: RelativeLayout, dependency: View): Boolean &#123; return dependency is AppBarLayout &#125; override fun onDependentViewChanged(parent: CoordinatorLayout, child: RelativeLayout, dependency: View): Boolean &#123; if (dependency is AppBarLayout) &#123; val offset = abs(dependency.top) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; val activity = ActivityUtils.findActivity(child) child.setBackgroundColor(Color.argb((progress * 255).toInt(), 255, 255, 255)) if (progress &gt; 0.5) &#123; StatusBarUtils.setStatusBarTransparentBg(activity, true) child.backIv.setColorFilter(Color.parseColor(\"#333333\")) &#125; else &#123; child.backIv.setColorFilter(Color.parseColor(\"#ffffff\")) StatusBarUtils.setStatusBarTransparentBg(activity, false) &#125; return true &#125; return false &#125;&#125; 「考场横向列表」监听：1234567891011121314151617181920212223242526272829303132333435appBarLayout.addOnOffsetChangedListener(AppBarLayout.OnOffsetChangedListener &#123; _, y -&gt; val offset = abs(y) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; if ((placeRv.tag as? Float) != progress) &#123; if (ExamRouteLineTopTipModel.needClose()) &#123; (placeRv.layoutParams as ViewGroup.MarginLayoutParams).topMargin = (DimenUtils.dp2px(20F) - DimenUtils.dp2px(8F) * progress).toInt() &#125; else &#123; (placeRv.layoutParams as ViewGroup.MarginLayoutParams).topMargin = (DimenUtils.dp2px(56F) - DimenUtils.dp2px(48F) * progress).toInt() &#125; (videoLl.layoutParams as ViewGroup.MarginLayoutParams).leftMargin = (DimenUtils.dp2px(12F) * (1 - progress)).toInt() if (progress == 1F) &#123; if (tipView.visibility == View.INVISIBLE) &#123; tipView.visibility = View.VISIBLE &#125; videoLl.setBackgroundResource(R.drawable.white) &#125; else &#123; if (tipView.visibility == View.VISIBLE) &#123; tipView.visibility = View.INVISIBLE &#125; videoLl.setBackgroundResource(R.drawable.bg_white_corner_5dp) &#125; placeRv.tag = progress (placeRv.adapter as? ExamVideoUnbuyAdapter)?.setProgress(progress) &#125;&#125;) tipView 通过 ExamRouteLineTopTipModel.needClose() 判断是否需要展示，两种状态的 margin 不一致，需要区分开。另外，CoordinatorLayout 有子孩子变化，都会回调到 OnOffsetChangedListener，所以需要保存 progress，避免一直调用方法。因为需求太具体，文章写起来不宜碎碎念，就只帖了代码，记录一下，以后碰到类似需求，有思路去做。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"问题集锦","date":"2019-11-29T10:18:21.000Z","path":"2019/11/29/tips/","text":"换了个项目组，最近忙了很多，没空写什么东西，碎碎念贴点碰到的小问题。 文件校验应用内部有本地数据库，有版本校验，会不定时更新，在使用的时候会使用 md5 进行校验。当更新版本后，发现数据库更新一直失败，调试后发现是 md5 值不一致，一脸懵逼的状态。数据库文件由服务端下发，然后复制移动到目标工程，并没有改任何东西，为何会造成 md5 值不一致呢？最后定位问题：同事拿到数据库文件，为了确定版本是对的，打开 db 文件看了一眼，然后 SQLite 就会自动写入一些东西，导致 md5 值改变。 涨点姿势，以后应当注意。 移除权限现在项目中难免会集成某些三方库，基础库，这些库有些时候大而全的会申明许多并未用到的权限，项目在集成时需要移除这些权限。如何在不修改三方库、基础库的基础上移除呢？以蓝牙权限为例，在 AndroidManifest.xml 中声明：12&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" tools:node=\"remove\"/&gt; webp 加载为了达到某些页面效果，设计师会设计一些动态图，有时是 gif，有时是 webp。碰到的问题是 webp 的文件放到 xhdpi 文件夹会一直报错：unsolved reference，也不知道是什么原因。放到其他分辨率的文件夹下 就好了，暂时还不知道原因。 恢复“误删”的本地文件项目中有 Java、Kotlin 文件，当把 Java 文件转成 Kotlin 文件时，会生成新的 Git 记录，无法查看 .java 文件的历史提交记录。可以右键项目根目录，然后选择 Local History，然后可以搜索出 .java 文件对照着看。 Android Studio 代码错位莫名其妙 .java 文件展示了 .xml 的内容，文件全部错乱展示，为 Android Studio 编译错误导致。删除所有的编译文件：.idea、.gradle、build 文件夹，以及 /user/AndroidStudio3.5/system/caches 文件夹，然后重启。 View 设置背景当有这样一个 selector：12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:color=\"#4A5356\" android:state_selected=\"true\" /&gt; &lt;item android:color=\"@android:color/transparent\" /&gt;&lt;/selector&gt; 调用 view.setBackgroundResource 时会失败，可以使用 StateListDrawable，手动 addState。或者使用 shape：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_checked=\"true\"&gt; &lt;shape&gt; &lt;solid android:color=\"#333333\" /&gt; &lt;corners android:bottomLeftRadius=\"4dp\" android:topLeftRadius=\"4dp\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item android:right=\"-2dp\"&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;stroke android:width=\"1dp\" android:color=\"#333333\" /&gt; &lt;corners android:bottomLeftRadius=\"4dp\" android:topLeftRadius=\"4dp\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_checked=\"true\"&gt; &lt;shape&gt; &lt;solid android:color=\"#333333\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;stroke android:width=\"1dp\" android:color=\"#333333\" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_checked=\"true\"&gt; &lt;shape&gt; &lt;solid android:color=\"#333333\" /&gt; &lt;corners android:bottomRightRadius=\"4dp\" android:topRightRadius=\"4dp\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item android:left=\"-2dp\"&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;stroke android:width=\"1dp\" android:color=\"#333333\" /&gt; &lt;corners android:bottomRightRadius=\"4dp\" android:topRightRadius=\"4dp\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; selector 可以添加各种 item 实现不用的效果，item 内部可以使用 layer-list 来达到不同的效果覆盖。 TextView 走马灯123456789101112131415161718&lt;TextView android:id=\"@+id/titleTv\" android:layout_width=\"wrap_content\" android:layout_height=\"48dp\" android:layout_marginLeft=\"28dp\" android:layout_marginTop=\"230dp\" android:ellipsize=\"marquee\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:gravity=\"center\" android:marqueeRepeatLimit=\"marquee_forever\" android:maxWidth=\"200dp\" android:singleLine=\"true\" android:textColor=\"#000\" android:textSize=\"21sp\" android:textStyle=\"bold\" app:layout_behavior=\".paid_video.behavior.ExamPlaceNameBehavior\" tools:text=\"芳草地考场\" /&gt; 可以使用 titleTv.isSelected = true 来开启走马灯效果。","tags":[]},{"title":"十月","date":"2019-10-31T01:59:40.000Z","path":"2019/10/31/october/","text":"银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星。 十月，秋高气爽，中秋国庆，适合出游。一直没空写点东西，在十月的尾巴，还是写点东西吧。 早在 6、7 月份，便有了想去「西北大环线」的冲动。大学伊始到现在的几年里，去的地方也有一些了，山呀，水呀，都见过很多了，唯独大西北那种戈壁、荒漠的自然风光却只存在于想象里。在基友群里吹牛，说想去大西北，吹着吹着发现就这样组起队来了：去啊，去他妈的！老康、斌哥还是给力呀，行动力 Max。人员定了之后，初步聊了一下，后面就没怎么聊了，直到出发的前一天，感觉很梦幻：就这样出发了吗？总有种感觉会鸽掉。所幸没有。 Your browser does not support the video tag.这一路，我们的所见所闻，都深刻的印在了脑子里。经历了一些没有经历过的事情，平淡的人生在这一刻变得有意义。于我而言，如果每天都处于同样的生活环境里，迟早会崩坏掉，这趟旅行对我来说意义非凡，是我永远的瑰宝。这一趟来回有 5000 多公里，第一次连续驾驶这么长的时间，尽管很累，但却不敢闭眼睡觉的感觉还真是不好受呢；塔尔寺的藏传佛教貌似与我认知中的佛教不同，但是咱身上没那文化细胞，也就随便逛逛，不过来这边玩的妹纸还真是多啊；塔尔寺开往青海湖的路途真是美极了。行驶在蜿蜒的盘山公路上，映入眼帘的是电影里的画面，山路十八弯，山峰矗立，感觉很刺激。下山后一眼看不到尽头的笔直的公路，“一路向西”，放飞自我。碰到拦路的牛呀、羊呀，有种说不出的俏皮，青海湖就像海一样，看不到边际；日出见过好多次，在黑马河看日出倒显得比较平常了；在天空之境的映射下，一切都变得干净。网红打卡的圣地，妹纸披着大红色披风拍起照来真是好看，可惜同行的都是几个糙汉子，略微显得有些无趣了；连夜赶往敦煌的路上，国内排行第九的危险公路 215 国道，连续下坡 42 公里，一路上超级多的刹车印记触目惊心，好算夜幕遮住了我们的眼睛，让我们没有过于紧张。高速上的逆行车辆，后面回忆起也是一阵后怕。出门在外，安全第一；在鸣沙山，骑着骆驼，漫天黄沙，此情此景，必须来一首《沙漠骆驼》。激情滑沙，清澈月牙泉，感觉还不错；莫高窟应该是此行最无趣的景点了，体内确实没那种历史文化细胞，品位不来；后面几天玩的嘉峪关、张掖七彩丹霞、祁连草原，可能是累了的原因，大家玩的兴致都不是很高，审美疲劳了，不过《回道张掖》沙秀是真的不错，头一次看这样的表演艺术，感觉很震撼。祁连草原的星空也是令人向往，只是太特么冷了。最后出发返程，回家后看到新闻，就在祁连草原，我们走后几个小时，就开始下大雪了，和基友们越聊越怕，咱这一程还是比较幸运的~ 经过这次旅行，上半年的颓势一扫而净，这就是旅行的意义吧。后面要撸起袖子加油干咯~","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"无声视频合成音频（续）","date":"2019-09-19T08:30:39.000Z","path":"2019/09/19/media-mix2/","text":"之前有一个音视频合成的需求，还写了一篇文章无声视频合成音频。之前的需求是，视频整体时间控制在 10s（便于发布到朋友圈），现在朋友圈的限制改为 15s 了，所以产品决定不再限制视频的时长为 10s 了，改为最长 40s，若有发布到朋友圈的需求，则自己裁剪。大部分情况下，生成的视频长度会小于 15s，也不需要裁剪。需求调整后，之前文章里的音视频合成的方案就需要略作修改了。 说下之前的方案：利用录屏生成 10s 的无声视频，与正好 10s 的音频 aac 文件进行合成。之前的代码最终生成的文件长度为音视频文件的最大值（若视频为 10s，音频为 15s，则会生成 15s 的视频，视频最后 5s 一直展示视频的最后一帧，同时播放音乐）。现在调整视频时长后，产品定的需求是视频时长增加，然后音频循环播放。所以可能就是 24s 的无声视频合成 10s 的音频。所以之前的代码就得调整了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/** * 无声视频添加音频 * 参考代码：https://stackoverflow.com/questions/31572067/android-how-to-mux-audio-file-and-video-file * * audioTrack 的 mime type 只支持： * MediaFormat.MIMETYPE_AUDIO_AMR_NB, * MediaFormat.MIMETYPE_AUDIO_AMR_WB, * MediaFormat.MIMETYPE_AUDIO_AAC */private fun muxing(musicName: String, showToast: Boolean = true) &#123; val saveFile = File(DirUtils.getPublicMediaPath(), \"$saveName.mp4\") if (saveFile.exists()) &#123; saveFile.delete() PhotoHelper.sendMediaScannerBroadcast(saveFile) &#125; try &#123; val duration = getVideoDuration(mSaveFile!!.absolutePath) saveFile.createNewFile() val videoExtractor = MediaExtractor() videoExtractor.setDataSource(mSaveFile!!.absolutePath) val audioExtractor = MediaExtractor() val afdd = MucangConfig.getContext().assets.openFd(musicName) audioExtractor.setDataSource(afdd.fileDescriptor, afdd.startOffset, afdd.length) val muxer = MediaMuxer(saveFile.absolutePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4) videoExtractor.selectTrack(0) val videoFormat = videoExtractor.getTrackFormat(0) val videoTrack = muxer.addTrack(videoFormat) audioExtractor.selectTrack(0) val audioFormat = audioExtractor.getTrackFormat(0) val audioTrack = muxer.addTrack(audioFormat) var sawEOS = false val offset = 100 val sampleSize = 1000 * 1024 val videoBuf = ByteBuffer.allocate(sampleSize) val audioBuf = ByteBuffer.allocate(sampleSize) val videoBufferInfo = MediaCodec.BufferInfo() val audioBufferInfo = MediaCodec.BufferInfo() videoExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) muxer.start() // 每秒多少帧 val frameRate = videoFormat.getInteger(MediaFormat.KEY_FRAME_RATE) // 得出平均每一帧间隔多少微妙 val videoSampleTime = 1000 * 1000 / frameRate while (!sawEOS) &#123; videoBufferInfo.offset = offset videoBufferInfo.size = videoExtractor.readSampleData(videoBuf, offset) if (videoBufferInfo.size &lt; 0) &#123; sawEOS = true videoBufferInfo.size = 0 &#125; else &#123; videoBufferInfo.presentationTimeUs += videoSampleTime videoBufferInfo.flags = videoExtractor.sampleFlags muxer.writeSampleData(videoTrack, videoBuf, videoBufferInfo) videoExtractor.advance() &#125; &#125; var sawEOS2 = false var sampleTime = 0L while (!sawEOS2) &#123; audioBufferInfo.offset = offset audioBufferInfo.size = audioExtractor.readSampleData(audioBuf, offset) // 判断如果写满时长，则直接返回 if (audioBufferInfo.presentationTimeUs &gt;= duration) &#123; sawEOS2 = true audioBufferInfo.size = 0 &#125; else &#123; // 判断没有写满时长，且已经写完当前 Track，则重置到开始状态，同时累加 presentationTimeUs if (audioBufferInfo.size &lt; 0) &#123; sampleTime = audioBufferInfo.presentationTimeUs audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) continue &#125; &#125; audioBufferInfo.presentationTimeUs = audioExtractor.sampleTime + sampleTime audioBufferInfo.flags = audioExtractor.sampleFlags muxer.writeSampleData(audioTrack, audioBuf, audioBufferInfo) audioExtractor.advance() &#125; muxer.stop() muxer.release() videoExtractor.release() audioExtractor.release() afdd.close() // 删除无声视频文件 mSaveFile?.delete() &#125; catch (e: Exception) &#123; LogUtils.e(TAG, \"Mixer Error:\" + e.message) // 视频添加音频合成失败，直接保存视频 mSaveFile?.renameTo(saveFile) &#125; finally &#123; MainThreadUtils.post &#123; if (activity.isDestroyed) &#123; return@post &#125; if (mSaveFile != null) &#123; if (needInsertMediaDB) &#123; PhotoHelper.sendMediaScannerBroadcast(saveFile) &#125; if (showToast) &#123; ToastUtils.toast(\"已保存到相册\") &#125; &#125; listener?.finishRecord(saveFile.absolutePath) mSaveFile = null &#125; &#125;&#125;/** * 获取视频的时长，微秒 */private fun getVideoDuration(videoPath: String): Long &#123; val mmr = MediaMetadataRetriever() try &#123; mmr.setDataSource(videoPath) return java.lang.Long.parseLong(mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)) * 1000L &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; try &#123; mmr.release() &#125; catch (e: Throwable) &#123; LogUtils.e(TAG, e.toString()) &#125; &#125; return 0L&#125; 整体思路是这样的：先获取无声视频的长度，假设为 24s，然后 muxer.writeSampleData 写入所有的 videoTrack 数据，然后开始写入 audioTrack 的数据。当写完 10s 后，audioTrack 便结束了，但是此时才写入 10s，不足 24s，所以重新 seek 到初始位置，再继续写入。写到 20s 后，再写入 4s，判断满足视频时长 24s 了，则直接退出。需要多说一下的是：生成视频的音频轨道 audioExtractor 获取到的 presentationTimeUs 正好就是音频播放的长度，而视频轨道由于有关键帧、非关键帧导致 videoExtractor presentationTimeUs 只能是递增，但却不能保证是播放长度。所以在写入音频数据时，可以根据 presentationTimeUs 来判断当前写入了多少秒，若已经达到视频长度，则可以直接退出，从而保证写入音频的时长与视频的时长是一致的。另外，当 audioExtractor 读完后，返回的 size 为 -1，判断此时时长不足，则直接 seek 到初始位置，同时需要累加 presentationTimeUs，所以代码里用到了 sampleTime 来记录 presentationTimeUs 的值。muxer.writeSampleData 时 presentationTimeUs 必须是递增的。 在 stackoverflow 上也搜到了同样的问题 How to mux (merge) video&amp;audio, so that the audio will loop in the output video in case it’s too short in duration?，但是没有回答，于是舔着脸强行回答了一波，欢迎来点赞~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"博客图片迁移","date":"2019-09-12T08:05:05.000Z","path":"2019/09/12/adjust/","text":"早期博客图床使用的七牛图床，七牛图床被黄图给搞了，所以现在测试域名都只有一个月的使用期限，早些阵子就已经过期回收了，所以之前的测试域名绑定的图片全部失效了，2018-10-10 之前的博客图片全部看不了了，阿西吧~若要继续使用七牛图床，需要自己绑定加速域名，重新迁移才行。而绑定加速域名是需要已经备案过的，备案又需要实名制，而我的域名还没有实名制QAQ，不巧的是阿里域名根据工信部的条款，关闭了 .win 域名后缀的实名制认证，这就很尴尬了。然后一直等阿里云开放域名实名认证，等到现在也还没开放，今天下定决心把图片都迁移一下，不用七牛了。图片所在的旧 Bucket 测试域名被回收之后，就彻底看不到图片资源了，也下载不了，只能借助七牛官方工具 qshell 来进行相关操作。 qshell下载好相应平台的 qshell 工具，所用电脑为 Win7，所以以下示例均为 Windows 平台。设置用户名及 key：1qshell account &lt;AK&gt; &lt;SK&gt; &lt;Name&gt; 获取所有图片的文件名要从旧的的 Bucket 获取所有的文件名：1qshell listbucket blog-images -o list.txt blog-images 为 Bucket 的名称，list.txt 为输出文件。list.txt 内容是个表格，具有多列属性，第一列为名称，是我需要的，其他所有列都不需要，需要删除。因为 Windows 命令行很不好用，我的文件数量也比较少，就直接用的很傻的办法，Android Studio 多行编辑手动删除了，然后得到一个只包含文件名的文件：name.txt。 迁移到新的 Bucket新建一个 Bucket（last-backup） 会有一个月限期的测试域名，所以这一步，需要将测试域名过期的旧 Bucket 里的所有文件迁移到新的 Bucket（所属区域需要一致，华东、华南等）。1qshell batchcopy blog-images last-backup -i name.txt -s success.txt -e fail.txt 使用 batchcopy 指令，将旧 Bucket 的文件复制到新的 Bucket，-s 指定复制成功的输出文件，-e 指定复制失败的输出文件。最好指定一下，方便后面看哪些文件有问题，需要手动调整的。 从新 Bucket 下载文件此时，新的 Bucket 已经有了所有的资源了（可能会有少许文件复制失败，只能手动校对了），并且有可用的域名，所以此时所有的资源都是可以访问到的。将所有文件下载下来：1qshell qdownload -c 10 config.txt -c 指定同时下载的文件个数，config.txt 为下载的设置：12345&#123; \"dest_dir\": \"D:\\\\blog_images\", // 下载文件到哪里 \"bucket\": \"last-backup\", // bucket 名称 \"cdn_domain\": \"pxp8xxx5.bkt.clouddn.com\" // bucket 域名&#125; 上传到新的图床一般的图床都会保留文件上传时的文件名，对于带路径的也是一样，我这里选择的是腾讯云。从七牛下载下来的文件，会按照上传时添加的前缀，生成对应的文件夹，好在腾讯也是支持文件夹的，将所有的文件按照对应的路径上传到腾讯云这步就 ok 了。 替换域名之前 md 文件里写的旧的七牛的域名，替换成新的腾讯云的域名。直接 Sublime Text 全局搜索，替换就行。因为腾讯云支持文件夹上传，所以域名之后的路径其实都是一致的，只需要替换下域名即可，后面图片的路径保持不动即可，可以节约不少时间。部分图片会有问题，把所有文章过一遍，找到有问题的，手动修复一下就行了。 博客所有的图片终于都能看见了，虽然现在来看，早期的文章写得不怎么样，但这也是我成长的痕迹了。心里的一块石头终于落地了。","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"Android 保活设置适配","date":"2019-09-06T06:39:09.000Z","path":"2019/09/06/keepalive/","text":"随着 Android 开发的越来越规范，那些“黑科技”的保活手段基本没什么用了，所以只能通过引导，让用户自己去设置相关保活的选项，就像 Rom 的白名单。只不过白名单是系统帮你设置，没有白名单就得自己去引导了。保活相关的一般包含自启动和防睡眠，当然功能在各个 Rom 的描述不尽相同，不用纠结于此。针对各大厂商，做了一些准备工作，如下。 三星 Galaxy S10+：SM-G9750，Android 9 Galaxy Note8：SM-N9500，Android 8.0.0 Galaxy Note9：SM-N9600，Android 8.1.0 C7：Android 8，Sumsang Experience 版本 S8：Android 8，Sumsang Experience 版本（没有自启动） 智能管理器-&gt;电池-&gt;未监视的应用程序-&gt;添加应用程序：添加后，应用处于后台时系统不会休眠应用智能管理器-&gt;自动运行应用程序：打开允许后，若应用后台一段时间未使用，仍有可能自动停止 三星云测平台 小米 小米 MIX2：Android 9，MIUI 10.4.2 红米 NOTE7 Pro：Android 9 设置-&gt;授权管理-&gt;自启动管理-&gt;运行应用自启动设置-&gt;电量和性能-&gt;应用配置-&gt;设置应用的省电策略为无限制 小米云测平台 vivo X9：Android 6.0.1，Funtouch OS_3.0 Y75A：Android 7.1.1，Funtouch OS_3.2 X21：Android 8.1.0，Funtouch OS_4.0 iQOO：Android 9，Funtouch OS_9 NEXS：Android 10，Funtouch OS_10 开发板 设置-&gt;更多设置-&gt;权限管理-&gt;权限Tab-&gt;自启动设置-&gt;电池-&gt;后台高耗电-&gt;打开开关允许应用高耗电时继续允许 X6A：Android 5.0.2，Funtouch OS_2.5 i 管家-&gt;软件管理-&gt;权限管理-&gt;自启动管理i 管家-&gt;省电管理-&gt;后台高耗电-&gt;打开开关允许应用高耗电时继续允许 vivo 云测平台 oppo A73：Android 7.1.1，ColorOS v5.2.1 手机管家-&gt;权限隐私-&gt;自启动管理设置-&gt;电池-&gt;应用速冻-&gt;关闭速冻开关 oppo 云测平台需要开发者账号，还要银行卡、手持身份证等玩意，太麻烦，就没申请了，所以 oppo 看的比较少。 华为 Mate 9：Android 9，EMUI 9.1.0 P10：Android 9，EMUI 9.1.0 设置-&gt;应用-&gt;应用启动管理-&gt;关闭自动管理，允许自启动，后台活动设置-&gt;电池-&gt;更多电池设置-&gt;？（云真机显示的没有应用，不确定是否有开关） P10 Plus：Android 8.0，EMUI 8.0 手机管家-&gt;自启管理-&gt;允许自启动设置-&gt;电池-&gt;耗电排行-&gt;选中应用进入耗电详情-&gt;关闭高耗电提醒 Mate 9：Android 7.0，EMUI 5.0 手机管家-&gt;自启管理-&gt;允许自启动设置-&gt;电池-&gt;设置(右上角图标)-&gt;锁屏应用清理-&gt;关闭清理选项 华为云测平台 代码只看了几个主流平台，其实还想看看一加的，但是一加没找到云测平台，也没有一加真机，无奈作罢。下面上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222object KeepCompactUtil &#123; private val AUTO_START_INTENTS = arrayOf( // 小米 Intent().setComponent(ComponentName(\"com.miui.securitycenter\", \"com.miui.permcenter.autostart.AutoStartManagementActivity\")), // 华为 Intent().setComponent(ComponentName .unflattenFromString(\"com.huawei.systemmanager/.startupmgr.ui.StartupNormalAppListActivity\")), Intent().setComponent(ComponentName .unflattenFromString(\"com.huawei.systemmanager/.appcontrol.activity.StartupAppControlActivity\")), // 魅族 Intent().setComponent(ComponentName.unflattenFromString(\"com.meizu.safe/.SecurityCenterActivity\")), // 三星 Intent().setComponent(ComponentName(\"com.samsung.android.sm_cn\", \"com.samsung.android.sm.autorun.ui.AutoRunActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm_cn\", \"com.samsung.android.sm.ui.ram.AutoRunActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm_cn\", \"com.samsung.android.sm.ui.appmanagement.AppManagementActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm\", \"com.samsung.android.sm.autorun.ui.AutoRunActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm\", \"com.samsung.android.sm.ui.ram.AutoRunActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm\", \"com.samsung.android.sm.ui.appmanagement.AppManagementActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm_cn\", \"com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm\", \"com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity\")), Intent().setComponent(ComponentName.unflattenFromString( \"com.samsung.android.sm_cn/.app.dashboard.SmartManagerDashBoardActivity\")), Intent().setComponent(ComponentName.unflattenFromString( \"com.samsung.android.sm/.app.dashboard.SmartManagerDashBoardActivity\")), // oppo Intent().setComponent(ComponentName .unflattenFromString(\"com.coloros.safecenter/.startupapp.StartupAppListActivity\")), Intent().setComponent(ComponentName .unflattenFromString(\"com.coloros.safecenter/.permission.startupapp.StartupAppListActivity\")), Intent().setComponent(ComponentName(\"com.coloros.safecenter\", \"com.coloros.privacypermissionsentry.PermissionTopActivity\")), Intent().setComponent( ComponentName.unflattenFromString(\"com.oppo.safe/.permission.startup.StartupAppListActivity\")), // vivo Intent().setComponent(ComponentName .unflattenFromString(\"com.vivo.permissionmanager/.activity.BgStartUpManagerActivity\")), Intent().setComponent(ComponentName .unflattenFromString(\"com.iqoo.secure/.phoneoptimize.BgStartUpManager\")), Intent().setComponent(ComponentName .unflattenFromString(\"com.vivo.permissionmanager/.activity.PurviewTabActivity\")), Intent().setComponent(ComponentName .unflattenFromString(\"com.iqoo.secure/.ui.phoneoptimize.SoftwareManagerActivity\")), // 一加 Intent().setComponent(ComponentName .unflattenFromString(\"com.oneplus.security/.chainlaunch.view.ChainLaunchAppListActivity\")), // 乐视 Intent().setComponent( ComponentName.unflattenFromString(\"com.letv.android.letvsafe/.AutobootManageActivity\")), // HTC Intent().setComponent( ComponentName.unflattenFromString(\"com.htc.pitroad/.landingpage.activity.LandingPageActivity\")) ) private val BATTERY_INTENTS = arrayOf( // 小米 Intent().setComponent(ComponentName .unflattenFromString(\"com.miui.powerkeeper/.ui.HiddenAppsContainerManagementActivity\")), // 华为 Intent().setComponent(ComponentName .unflattenFromString(\"com.huawei.systemmanager/.power.ui.HwPowerManagerActivity\")), // 魅族 Intent().setComponent(ComponentName .unflattenFromString(\"com.meizu.safe/.SecurityCenterActivity\")), // 三星 Intent().setComponent(ComponentName(\"com.samsung.android.sm_cn\", \"com.samsung.android.sm.ui.battery.AppSleepListActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm_cn\", \"com.samsung.android.sm.ui.battery.BatteryActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm\", \"com.samsung.android.sm.ui.battery.AppSleepListActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm\", \"com.samsung.android.sm.ui.battery.BatteryActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.lool\", \"com.samsung.android.sm.battery.ui.BatteryActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.lool\", \"com.samsung.android.sm.ui.battery.BatteryActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm\", \"com.samsung.android.sm.ui.battery.BatteryActivity\")), Intent().setComponent(ComponentName(\"com.samsung.android.sm_cn\", \"com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity\")), // oppo Intent().setComponent(ComponentName .unflattenFromString(\"com.coloros.safecenter/.appfrozen.activity.AppFrozenSettingsActivity\")), Intent().setComponent(ComponentName(\"com.coloros.oppoguardelf\", \"com.coloros.powermanager.fuelgaue.PowerUsageModelActivity\")), Intent().setComponent(ComponentName(\"com.coloros.oppoguardelf\", \"com.coloros.powermanager.fuelgaue.PowerSaverModeActivity\")), Intent().setComponent(ComponentName(\"com.coloros.oppoguardelf\", \"com.coloros.powermanager.fuelgaue.PowerConsumptionActivity\")), Intent().setComponent(ComponentName .unflattenFromString(\"com.oppo.safe/.SecureSafeMainActivity\")), // vivo Intent().setComponent(ComponentName(\"com.vivo.abe\", \"com.vivo.applicationbehaviorengine.ui.ExcessivePowerManagerActivity\")), Intent().setComponent(ComponentName.unflattenFromString(\"com.iqoo.powersaving/.PowerSavingManagerActivity\")) ) var brandAliveEnumList: List&lt;BrandAliveEnum&gt; = object : ArrayList&lt;BrandAliveEnum&gt;() &#123; init &#123; add(BrandAliveEnum.Huawei) add(BrandAliveEnum.Xiaomi) add(BrandAliveEnum.Oppo) add(BrandAliveEnum.Vivo) add(BrandAliveEnum.Samsung) add(BrandAliveEnum.Meizu) add(BrandAliveEnum.LeEco) add(BrandAliveEnum.Smartisan) add(BrandAliveEnum.Lenovo) add(BrandAliveEnum.NONE) &#125; &#125; /** * @return 是否为三星s9 型号的手机 */ val isSamsungS9: Boolean get() = (\"samsung\".equals(Build.BRAND, ignoreCase = true) &amp;&amp; StringUtils.isNotEmpty(Build.MODEL) &amp;&amp; Build.MODEL.startsWith(\"SM-G9\")) val deviceEnum: BrandAliveEnum get() &#123; if (\"Huawei\".equals(Build.BRAND, ignoreCase = true) || \"HONOR\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Huawei &#125; if (\"vivo\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Vivo &#125; if (\"OPPO\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Oppo &#125; if (\"Xiaomi\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Xiaomi &#125; if (\"Meizu\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Meizu &#125; if (\"samsung\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Samsung &#125; if (\"smartisan\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Smartisan &#125; if (\"LeEco\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.LeEco &#125; if (\"Lenovo\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Lenovo &#125; if (\"oneplus\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Yijia &#125; if (\"Sony\".equals(Build.MANUFACTURER, ignoreCase = true)) &#123; return BrandAliveEnum.Sony &#125; if (\"LG\".equals(Build.MANUFACTURER, ignoreCase = true)) &#123; return BrandAliveEnum.LG &#125; if (\"Coolpad\".equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.NONE &#125; return if (\"ZTE\".equals(Build.BRAND, ignoreCase = true)) &#123; BrandAliveEnum.NONE &#125; else BrandAliveEnum.NONE &#125; // 自启动 fun daemonSet(activity: Activity): Boolean &#123; for (intent in AUTO_START_INTENTS) &#123; if (activity.packageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123; intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK try &#123; activity.startActivity(intent) return true &#125; catch (e: Exception) &#123; LogUtils.e(\"KeepCompactUtil\", e.toString()) continue &#125; &#125; &#125; return false &#125; // 防睡眠 fun noSleepSet(activity: Activity): Boolean &#123; for (intent in BATTERY_INTENTS) &#123; if (activity.packageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123; intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK try &#123; activity.startActivity(intent) return true &#125; catch (e: Exception) &#123; LogUtils.e(\"KeepCompactUtil\", e.toString()) continue &#125; &#125; &#125; return false &#125;&#125; 直接罗列所有的 Intent，按页面相关性从大到小排列。比如，A-&gt;B-&gt;C，设置页面在 C，但是有的手机不支持打开 C 和 B，Intent 排序为 C&gt;B&gt;A。通过 resolveActivity 判断系统是否能处理此 Intent，跳转成功则 ok，若跳转失败则继续遍历，找到能跳转的 Intent，如果遍历完也没有找到，则返回 false 给出相应提示。 小结oppo vivo 的手机有点恶心，每次安装 debug 包还要弹窗让输密码，然后还自己捣鼓了权限啥的，限制三方应用进行跳转。vivo：1Permission Denial: starting Intent &#123; flg=0x10000000 cmp=com.vivo.abe/com.vivo.applicationbehaviorengine.ui.ExcessivePowerManagerActivity &#125; from ProcessRecord&#123;306679b 16047:cn.xxx.android.xxx/u0a605&#125; (pid=16047, uid=10605) requires com.vivo.abe.permission.action.openhpactivity oppo：1java.lang.SecurityException: Permission Denial: starting Intent &#123; flg=0x10000000 cmp=com.coloros.safecenter/.startupapp.StartupAppListActivity &#125; from ProcessRecord&#123;2255367 30192:cn.xxx.android.xxx/u0a697&#125; (pid=30192, uid=10697) requires oppo.permission.OPPO_COMPONENT_SAFE 然后在 AndroidManifest 中添加相关的权限也无效的，因为只能系统应用申请，三方应用申请没用（oppo 同学内部询问大佬给出的回答）。针对 vivo，我选择跳到上一级页面，也可以跳，只不过需要用户手动再点一下。针对 oppo，我佛了，上一级页面也跳不了，只能到最初的设置页面，这跳到设置页面大多数用户都会一脸懵逼，所以干脆不跳了，直接返回 false，同时给好相应的引导。同时，申请了权限之后，好像 apk 安装会出问题（部分机型），反正没用，所以权限就不要加了。三星也值得说一下，一会是 sm，一会是 sm_cn，我也是佛了。一会是 ui.battery，一会是 battery.ui，索性直接进行排列组合搞了一波，所以三星的 Intent 就很多了。另外三星 S9 貌似是没有自启动的，所以可以考虑进行屏蔽。其实不屏蔽影响也不大，返回 false 给出提示即可，无奈老板的手机是 S9… 经过这次云测平台的使用，发现华为还是牛逼啊，三星也还不错，还支持 adb 命令（点个赞）。oppo vivo 就差太远了，小米更不用谈了，连可用的机型都没有。腾讯的 WeTest 机型倒是都有，但是要收费，这很腾讯。送的 30 分钟完全不够用好吗，而且每用一个机型至少 15 分钟，我的免费额度剩下 10 分钟就已经用不了了，无力吐槽。 参考 Intent跳转到[自启动]页面全网最全适配机型解决方案(持续更新) Denial permission OPPO_COMPONENT_SAFE backgroundable-android How to start Power Manager of all android manufactures to enable background and push notification? [WeTest]（https://wetest.qq.com/cloud/n/remotedevicelist?test=remote）","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"使用 LiveData 实现消息总线","date":"2019-09-02T05:46:54.000Z","path":"2019/09/02/livedata/","text":"作为 Android 开发，对消息总线总不会陌生，当需要告知某些界面进行一些操作的时候，都会通过发送消息来做。早期的可以有广播，或者回调的方式，但是写起来都会比较麻烦，所以才会出现 EventBus 这种三方库，它使用起来非常方便，极大的解耦了我们的代码，所以当它一出现就受到了广大开发者的青睐。那用了这么久的 EventBus，香确实是很香，但是感觉还可以有优化的地方： 只在界面可见的时候进行处理（生命周期感知功能）； 每次都得显式 register，unregister； 回调方法名称固定为 onEventMainThread 等等几个规定的名称，在 Android Studio 里会显示成 xxx is never used，警告也是很烦人的； 多个同类型消息不能只处理一次，这其实也和第 1 点呼应； 不同类型的消息，但是导致的业务操作其实是一致的，这种情景其实只需要处理一次即可，但 EventBus 做不到； 所以，在新出了 LiveData 之后，基于它的特性，是否可以进行改造呢？当然是可以的。 改造第一步基于 EventBus 的使用习惯，很容易改造出第一版：12345678910111213object LiveBus &#123; private val busMap by lazy &#123; ConcurrentHashMap&lt;Class&lt;*&gt;, MutableLiveData&lt;*&gt;&gt;() &#125; private fun &lt;T&gt; bus(clazz: Class&lt;T&gt;) = busMap.getOrPut(clazz) &#123; MutableLiveData&lt;T&gt;() &#125; @Suppress(\"UNCHECKED_CAST\") fun &lt;T&gt; with(clazz: Class&lt;T&gt;) = bus(clazz) as MutableLiveData&lt;T&gt; fun post(event: Any) &#123; with(event.javaClass).value = event &#125;&#125; 发送消息只需要：1LiveBus.post(\"Hello world!\") 接收消息：123LiveBus.with(String::class.java).observe(this, Observer &#123; // do something&#125;) 只需要 observe，不再需要注销，下面的代码再也不会出现了：12345@Overridepublic void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this);&#125; 写个 onDestroy 纯粹为了注销 EventBus。可以看到，基于 LiveData，第一版这样很简短的写法，已经就可以解决我上面的 4 个问题了！我可以在一个界面重复发送消息，但是只有在界面展示的时候，处理一次。在某些场景下，这种优化还是很有必要的，不然每次都在不可见的状态下还刷新数据，如果消息发送非常频繁，那就可能导致很大的性能问题了。 Sticky 改造使用第一版的代码，很容易就发现一个问题：订阅者会收到订阅之前发布的消息。这其实类似于 EventBus 提供的 Sticky 功能。这种默认功能，在大多数下情况下，是不适用的，所以也需要改造。导致这个问题的原因在 LiveData 的源码是有体现的：1234567891011121314151617181920private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData);&#125; 在 LiveData 的 considerNotify 方法中，如果 ObserverWrapper 的 mLastVersion 小于 LiveData 的 mVersion，就会去回调 mObserver 的 onChanged 方法。而每个新的订阅者，其 version 都是 -1，LiveData 一旦设置过其 version 是大于 -1 的（每次 LiveData 设置值都会使其 version 加 1），这样就会导致 LiveBus 每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。知道问题所在之后，便可以进行解决了：提供相同包名的 BusLiveData，进行改造。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package android.arch.lifecycleopen class BusLiveData&lt;T&gt; : MutableLiveData&lt;T&gt;() &#123; private val wrappers = mutableMapOf&lt;Observer&lt;T&gt;, BusWrapper&gt;() override fun observe(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observe(owner, wrapper) &#125; open fun observeSticky(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; super.observe(owner, observer) &#125; override fun observeForever(observer: Observer&lt;T&gt;) &#123; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observeForever(wrapper) &#125; fun observeStickyForever(observer: Observer&lt;T&gt;) &#123; super.observeForever(observer) &#125; override fun removeObserver(observer: Observer&lt;T&gt;) &#123; val key = if (observer is BusWrapper) &#123; super.removeObserver(observer) super.removeObserver(observer.observer) observer.observer &#125; else &#123; super.removeObserver(observer) observer &#125; wrappers.remove(key) &#125; inner class DefaultWrapper(observer: Observer&lt;T&gt;): BusWrapper(observer) &#123; override fun onChanged(t: T?) &#123; if (lastVersion &gt;= version) &#123; return &#125; lastVersion = version observer.onChanged(t) &#125; &#125; abstract inner class BusWrapper(val observer: Observer&lt;T&gt;): Observer&lt;T&gt; &#123; var lastVersion = version &#125;&#125; 注意包名为 android.arch.lifecycle。因为用到了 getVersion 方法，这个在 LiveData 里是包可见：123int getVersion() &#123; return mVersion;&#125; 在每次 observe 的时候，使用 LiveData 的 version 赋值一次，就可以解决问题了。同理，MediatorLiveData 的改造如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192@SuppressLint(\"RestrictedApi\")class BusMediatorLiveData&lt;T&gt; : BusLiveData&lt;T&gt;() &#123; private val mSources = SafeIterableMap&lt;BusLiveData&lt;*&gt;, Source&lt;*&gt;&gt;() /** * Starts to listen the given `source` LiveData, `onChanged` observer will be called * when `source` value was changed. * * * `onChanged` callback will be called only when this `MediatorLiveData` is active. * * If the given LiveData is already added as a source but with a different Observer, * [IllegalArgumentException] will be thrown. * * @param source the `LiveData` to listen to * @param onChanged The observer that will receive the events * @param &lt;S&gt; The type of data hold by `source` LiveData &lt;/S&gt; */ @MainThread fun &lt;S&gt; addSource(source: BusLiveData&lt;S&gt;, onChanged: Observer&lt;S&gt;) &#123; val e = Source(source, onChanged) val existing = mSources.putIfAbsent(source, e) if (existing != null &amp;&amp; existing.mObserver !== onChanged) &#123; throw IllegalArgumentException( \"This source was already added with the different observer\" ) &#125; if (existing != null) &#123; return &#125; if (hasActiveObservers()) &#123; e.plug() &#125; &#125; override fun observe(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; onActive() ArchTaskExecutor.getInstance().postToMainThread &#123; super.observe(owner, observer) &#125; &#125; /** * Stops to listen the given `LiveData`. * * @param source `LiveData` to stop to listen * @param &lt;S&gt; the type of data hold by `source` LiveData &lt;/S&gt; */ @MainThread fun &lt;S&gt; removeSource(source: BusLiveData&lt;S&gt;) &#123; @Suppress(\"NAME_SHADOWING\") val source = mSources.remove(source) source?.unplug() &#125; @CallSuper override fun onActive() &#123; for ((_, value) in mSources) &#123; value.plug() &#125; &#125; @CallSuper override fun onInactive() &#123; for ((_, value) in mSources) &#123; value.unplug() &#125; &#125; private class Source&lt;V&gt; internal constructor( internal val mLiveData: BusLiveData&lt;V&gt;, internal val mObserver: Observer&lt;V&gt; ) : Observer&lt;V&gt; &#123; internal var mVersion = mLiveData.version internal fun plug() &#123; mLiveData.observeStickyForever(this) &#125; internal fun unplug() &#123; mLiveData.removeObserver(this) &#125; override fun onChanged(v: V?) &#123; if (mVersion != mLiveData.version) &#123; mVersion = mLiveData.version mObserver.onChanged(v) &#125; &#125; &#125;&#125; 这个后面会用到。嗯，改造完成之后，将 LiveBus 里的 MutableLiveData 替换成 BusLiveData 就可以解决问题了。那么想要实现 EventBus 的 Sticky 效果便非常简单了：123open fun observeSticky(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; super.observe(owner, observer)&#125; 消息合并针对第 5 条，使用 EventBus 很容易出现如下代码：1234567891011121314//增加路线public void onEventMainThread(RouteCreateEvent event) &#123; onLoadFirst(false);&#125;//删除路线public void onEventMainThread(RouteDeleteEvent event) &#123; onLoadFirst(false);&#125;//更新路线public void onEventMainThread(RouteUpdateEvent event) &#123; onLoadFirst(false);&#125; 这在列表界面处理相关刷新的操作太常见了，感觉很恶心。所以，使用 LiveBus 如何改造呢？这就要用到上面说 MediatorLiveData 了。MediatorLiveData 类就是个自定义 LiveData，可以观察其他 LiveData 对象并且回调。使用 addSource 可以添加一个 LiveData，当任何一个 LiveData 发生改变时都能进行回调。所以当多个类型的消息界面都是统样的处理时，便可以使用 MediatorLiveData 了。稍微封装一下：123456789101112131415161718class SameActionMediator &#123; private val mediatorLiveData = BusMediatorLiveData&lt;Boolean&gt;() fun addSource(vararg source: BusLiveData&lt;*&gt;) &#123; source.forEach &#123; mediatorLiveData.addSource(it, Observer &#123; mediatorLiveData.postValue(true) &#125;) &#125; &#125; fun observe(owner: LifecycleOwner, onChange: (Boolean?) -&gt; Unit) &#123; mediatorLiveData.observe(owner, Observer &#123; onChange(it) &#125;) &#125;&#125; 使用时：12345val mediatorLiveData = SameActionMediator()mediatorLiveData.addSource(LiveBus.with(String::class.java), LiveBus.with(Int::class.java))mediatorLiveData.observe(this) &#123; // do something&#125; 注意 mediatorLiveData 必须使用 postValue，使用 setValue 导致 onChange 回调多次。看下 postValue 的实现：123456789101112131415161718192021222324protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125;private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125;&#125;; 可以看到，当连续多次调用 postValue 时，LiveData 只会更新 mPendingData 为最新的值，如果 postTask 为 true，就直接返回，所以 mPostValueRunnable 只会发送一次，从而避免 onChange 的多次调用。同时当 mPostValueRunnable 执行时，又会将 mPendingData 赋值为 NOT_SET，用于下次消息发送。 observeForever补充一下一个不常用的场景：常驻后台，当界面不可见也需要接受消息。123LiveBus.with(Float::class.java).observeForever &#123; // do something&#125; 这种就是消息只要一发送，就可以接受到了，可用于某些特殊场景。但是这种就有了内存泄漏的风险，当不需要时记得手动移除。 小结使用上述 4 个类：BusLiveData、BusMediatorLiveData、LiveBus、SameActionMediator，便可实现消息总线的整体功能了，同时有所优化。嗯，JetPack 真香啊~ 参考 Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus 【译】LiveData 使用详解 LiveBus","tags":[{"name":"JetPack","slug":"JetPack","permalink":"http://lijia92.github.io/tags/JetPack/"}]},{"title":"MotionLayout 使用介绍","date":"2019-08-13T08:18:16.000Z","path":"2019/08/13/cl-2/","text":"MotionLayout 是 ConstraintLayout 2.0 版本引入进来的，目前还在测试版本中，但感觉还挺有意思的，就写一篇记录一下。 MotionLayout 类继承自 ConstraintLayout 类，允许你为各种状态之间的布局设置过渡动画。由于 MotionLayout 继承了 ConstraintLayout，因此可以直接在 XML 布局文件中使用 MotionLayout 替换 ConstraintLayout。MotionLayout 是完全声明式的，你可以完全在 XML 文件中描述一个复杂的过渡动画而无需任何代码。 MotionLayout 与 ConstraintLayout 不同的是 MotionLayout 需要链接到一个 MotionScene 文件。使用 MotionLayout 的 app:layoutDescription 属性将 MotionLayout 链接到一个 MotionScene 文件。另外，MotionLayout 所有的直接子 View 需要指定 id，不然会报错：1All children of ConstraintLayout must have ids to use ConstraintSet. 简单使用 起始状态： 12345678910111213141516171819202122232425262728293031323334&lt;android.support.constraint.motion.MotionLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/motionLayout\" app:layoutDescription=\"@xml/activity_main_motion_scene\"&gt; &lt;TextView android:id=\"@+id/button\" android:layout_width=\"100dp\" android:layout_height=\"56dp\" android:text=\"这个View不动\" android:textColor=\"#fff\" android:gravity=\"center\" android:background=\"#f00\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"56dp\" android:layout_height=\"56dp\" android:src=\"@mipmap/ic_launcher\" android:background=\"@color/colorPrimary\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"1\"/&gt;&lt;/android.support.constraint.motion.MotionLayout&gt; 结束状态: 123456789101112131415161718&lt;android.support.constraint.motion.MotionLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/motionLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layoutDescription=\"@xml/activity_main_motion_scene\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"48dp\" android:layout_height=\"48dp\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" android:layout_marginTop=\"100dp\" app:layout_constraintTop_toTopOf=\"parent\"/&gt;&lt;/android.support.constraint.motion.MotionLayout&gt; MotionScene：文件名 activity_main_motion_scene.xml，存放在 res/xml 目录下。 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;Transition app:constraintSetStart=\"@layout/activity_main_scene1\" app:constraintSetEnd=\"@layout/activity_main_scene2\" app:duration=\"1000\"&gt; &lt;OnClick app:clickAction=\"toggle\" app:targetId=\"@id/image\" /&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 看下效果： 属性讲解MotionLayout 会自动检测这两个场景中具有相同 id 的 View 的属性差别，然后针对这些差别属性应用过渡动画。MotionLayout 除了支持一下的标准属性外，还支持全部的 ConstraintLayout 属性。 android:visibility android:alpha android:elevation android:rotation android:rotationX android:rotationY android:scaleX android:scaleY android:translationX android:translationY android:translationZ MotionScene 文件的根元素是 MotionScene。在 MotionScene 元素中使用 Transition 子元素来描述一个过渡，使用 Transition 元素的 app:constraintSetStart 属性指定起始场景的布局文件，使用 app:constraintSetEnd 指定结束场景的布局文件。在 Transition 元素中使用 OnClick 或者 OnSwip 子元素来描述过渡的触发条件。使用 app:duration 指定动画时间，app:motionInterpolator 指定差值器，取值有 linear、bounce 等等。 OnClick 元素的属性： app:targetId：Id 值，设置用来触发过渡的那个 View 的 Id，例如：@id/image。 app:clickAction：设置点击时执行的动作，有 5 个可选项： toggle：在 Start 场景和 End 场景之间循环的切换。 transitionToEnd：过渡到 End 场景。 transitionToStart：过渡到 Start 场景。 jumpToEnd：跳到 End 场景（不执行过渡动画）。 jumpToStart：跳到 Start 场景（不执行过渡动画）。 OnSwip 拖动操作，由于拖动操作涉及的交互较为复杂，这里就不讲述了，有兴趣的同学可以自己了解。 代码控制代码开启动画，切换到起始状态：1motionLayout.transitionToStart(); 同样，切换到终止状态：1motionLayout.transitionToEnd() 设置动画进度：1motionLayout.setProgress(progress) // 取值 0 ~ 1 监听动画：123456789101112131415161718motionLayout.setTransitionListener(object : MotionLayout.TransitionListener &#123; override fun onTransitionTrigger(p0: MotionLayout?, p1: Int, p2: Boolean, p3: Float) &#123; // Call when a trigger is fired &#125; override fun onTransitionStarted(p0: MotionLayout?, p1: Int, p2: Int) &#123; // Called when a drawer is about to start a transition. &#125; override fun onTransitionChange(p0: MotionLayout?, p1: Int, p2: Int, p3: Float) &#123; // Called when a drawer's position changes. &#125; override fun onTransitionCompleted(p0: MotionLayout?, p1: Int) &#123; // Called when a drawer has settled completely a state. &#125;&#125;) 在 MotionScene 文件中定义约束我们可以在 MotionScene 元素中使用 ConstraintSet 子元素定义一个场景约束集，并在 ConstraintSet 元素中使用 Constraint 元素定义单个 View 的属性约束。将 activity_main_motion_scene.xml 改成如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;MotionScene xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 定义 Start 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=\"@+id/activity_main_start\"&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=\"@id/image\" android:layout_width=\"56dp\" android:layout_height=\"56dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"1.0\"/&gt; &lt;/ConstraintSet&gt; &lt;!-- 定义 End 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=\"@+id/activity_main_end\"&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=\"@id/image\" android:layout_width=\"80dp\" android:layout_height=\"80dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.0\"/&gt; &lt;/ConstraintSet&gt; &lt;!-- Start 场景与 End 场景都是定义在 MotionScene 文件中的约束集 --&gt; &lt;Transition app:constraintSetStart=\"@id/activity_main_start\" app:constraintSetEnd=\"@id/activity_main_end\" app:duration=\"1000\"&gt; &lt;OnClick app:clickAction=\"toggle\" app:targetId=\"@id/image\"/&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 效果如下： 这种写法还支持自定义属性：在 Constraint 元素中使用 CustomAttribute 子元素来指定自定义属性。改成如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;MotionScene xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 定义 Start 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=\"@+id/activity_main_start\"&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=\"@id/image\" android:layout_width=\"56dp\" android:layout_height=\"56dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"1.0\"&gt; &lt;!-- 使用自定义属性 --&gt; &lt;CustomAttribute app:attributeName=\"backgroundColor\" app:customColorValue=\"@color/colorPrimary\"/&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;!-- 定义 End 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=\"@+id/activity_main_end\"&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=\"@id/image\" android:layout_width=\"80dp\" android:layout_height=\"80dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.0\"&gt; &lt;!-- 使用自定义属性 --&gt; &lt;CustomAttribute app:attributeName=\"backgroundColor\" app:customColorValue=\"@color/colorAccent\"/&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;!-- Start 场景与 End 场景都是定义在 MotionScene 文件中的约束集 --&gt; &lt;Transition app:constraintSetStart=\"@id/activity_main_start\" app:constraintSetEnd=\"@id/activity_main_end\" app:duration=\"1000\"&gt; &lt;OnClick app:clickAction=\"toggle\" app:targetId=\"@id/image\"/&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 效果如下： 所以如果有使用到 CustomAttribute，则最好将约束变化定义在 MotionScene xml 中。 小结利用 MotionLayout 实现了一个普遍的按钮点击动画：效果还不错，只是如果前后动画的插值器不一致，或有其他定制的需求时，MotionLayout 是否能满足呢？ 本文只是简单介绍了一下 MotionLayout 的使用，它其实还有很多东西，比如 OnSwipe，以及 app:transitionEasing、app:transitionPathRotate、app:drawPath 等一些比较有意思的属性，有空的时候可以再多看看。MotionLayout 当前还只是测试版，期待正式版本出来的那一天！","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"高德地图 Marker 聚合","date":"2019-08-05T06:36:57.000Z","path":"2019/08/05/handlerthread/","text":"高德地图有个官方 Demo用来实现 Marker 聚合，但不是在 SDK 里。项目里也有这个需求，但是比较简单，不用做到数量计算，只需要当 Marker 数量很多的的时候，只展示部分 Marker，显示了会覆盖的 Marker 则直接不显示。每次移动地图都会请求新的数据，然后来进行展示，为了避免移动地图导致频繁请求数据，可以做个简单的优化：移动后延迟一定时间再去请求数据，在延迟时间内再次移动地图，则取消上次请求的动作，重新请求。综合考虑，使用 HandlerThread 便是不二之选了，在这里记录一下，以后或许用得到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264class MarkerClusterController&lt;T : MarkerItem&gt;(val mapController: MapController, val adapter: MarkerDataAdapter&lt;T&gt;) : AMap.OnCameraChangeListener, AMap.OnMarkerClickListener &#123; companion object &#123; private const val TAG = \"MarkerClusterController\" private const val UPDATE_INTERVAL_TIME = 500L // 更新数据 private const val MSG_CLUSTER_DATA_UPDATE = 1 // 清空数据 private const val MSG_CLUSTER_MARKER_CLEAR = 2 &#125; private val amap = mapController.amap private val clusterHandlerThread: HandlerThread = HandlerThread(\"MarkerClusterThread\") private var clusterHandler: ClusterHandler // 更新过程中是否取消更新 var isCanceled = false private val makerUpdateManger = MarkerUpdateManger() init &#123; clusterHandlerThread.start() clusterHandler = ClusterHandler(clusterHandlerThread.looper) mapController.addCameraChangeListener(this) mapController.addOnMarkerClickListener(this) &#125; override fun onCameraChangeFinish(p0: CameraPosition) &#123; // 地图移动或者层级变化时更新数据 clusterHandler.sendDataUpdateMsg() &#125; override fun onCameraChange(p0: CameraPosition?) &#123; &#125; @Suppress(\"UNCHECKED_CAST\") override fun onMarkerClick(marker: Marker): Boolean &#123; val markerItem = marker.`object` as? MarkerItem return if (markerItem == null) &#123; false &#125; else &#123; adapter.onMarkerClick(markerItem, marker) &#125; &#125; fun initData() &#123; clusterHandler.sendEmptyMessage(MSG_CLUSTER_DATA_UPDATE) &#125; /** * 销毁数据，移除监听 */ fun onDestroy() &#123; isCanceled = true mapController.removeCameraChangeListener(this) mapController.removeMarkClickListener(this) clusterHandler.removeCallbacksAndMessages(null) clusterHandlerThread.quit() makerUpdateManger.clearMarker() &#125; /** * 清除某个类型的 Marker 集合 */ fun clearMarkers(type: MarkType) &#123; val iterator = makerUpdateManger.markerList.iterator() iterator.forEach &#123; val markerItem = it.`object` as? MarkerItem if (markerItem?.type == type) &#123; it.remove() makerUpdateManger.markerList.remove(it) &#125; &#125; &#125; /** * 移除某个 Marker * 高亮的 Marker 先移除再绘制 */ fun removeMarker(t: T?) &#123; if (t == null) &#123; return &#125; val iterator = makerUpdateManger.markerList.iterator() iterator.forEach &#123; if (it.`object` == t) &#123; it.remove() makerUpdateManger.markerList.remove(it) &#125; &#125; &#125; fun getMarkerList(): List&lt;Marker&gt; &#123; return makerUpdateManger.markerList &#125; fun updateMarkerList(tempList: MutableList&lt;T&gt;?) &#123; clusterHandler.post &#123; makerUpdateManger.updateMarkerList(tempList) &#125; &#125; /** * Marker 更新管理 */ inner class MarkerUpdateManger &#123; // 两个marker之间的最小距离阈值 private val defaultDistance = DimenUtils.dp2px(40f) val markerList = CopyOnWriteArrayList&lt;Marker&gt;() /** * 获取数据计算聚合 */ internal fun updateClustersData() &#123; isCanceled = false val visibleBounds = amap.projection.visibleRegion.latLngBounds val markerItemList = adapter.getMarkerData(visibleBounds) updateMarkerList(markerItemList) &#125; /** * 显示 MarkerList，先清空已显示的 */ fun updateMarkerList(tempList: MutableList&lt;T&gt;?) &#123; if (isCanceled) &#123; return &#125; // 还需要显示的不用移除 val showMarkerList = mutableListOf&lt;Marker&gt;() val newDrawList = mutableListOf&lt;MarkerItem&gt;() tempList?.sortByDescending &#123; it.zIndex &#125; tempList?.let &#123; list -&gt; if (isCanceled) &#123; return &#125; list.forEach &#123; item -&gt; if (getCluster(item.latLng, newDrawList)) &#123; newDrawList.add(item) &#125; &#125; &#125; val repeatList = mutableListOf&lt;MarkerItem&gt;() // 循环匹配保留还需要显示的，移除不需要显示的 markerList.forEach &#123; marker -&gt; val objectData = marker.`object` as MarkerItem if (newDrawList.contains(objectData)) &#123; repeatList.add(objectData) showMarkerList.add(marker) &#125; else &#123; marker.remove() &#125; &#125; // 剔除已绘制过的 newDrawList.removeAll(repeatList) markerList.clear() markerList.addAll(showMarkerList) addMarkerList(newDrawList) &#125; /** * 增加 MarkerList */ private fun addMarkerList(newList: List&lt;MarkerItem&gt;) &#123; newList.forEach &#123; addMarker(it) &#125; &#125; /** * 增加一个 Marker */ private fun addMarker(markerItem: MarkerItem) &#123; val marker = markerItem.createMarker(mapController.mapView) marker.`object` = markerItem markerList.add(marker) &#125; /** * 清除 Marker */ internal fun clearMarker() &#123; markerList.forEach &#123; it.remove() &#125; markerList.clear() &#125; /** * 当前点是否会被覆盖 * * @param latLng * @return */ private fun getCluster(latLng: LatLng, markerItem: List&lt;MarkerItem&gt;): Boolean &#123; for (item in markerItem) &#123; val clusterCenterPoint = item.latLng val distance = AMapUtils.calculateLineDistance(latLng, clusterCenterPoint).toDouble() val clusterDistance = defaultDistance * amap.scalePerPixel if (distance &lt; clusterDistance) &#123; return false &#125; &#125; return true &#125; &#125; /** * 集合Handler，保证 Marker 集合处理在同一子线程 */ private inner class ClusterHandler(looper: Looper) : Handler(looper) &#123; private var lastUpdateTime = 0L override fun handleMessage(msg: Message) &#123; when (msg.what) &#123; MSG_CLUSTER_DATA_UPDATE -&gt; &#123; makerUpdateManger.updateClustersData() &#125; MSG_CLUSTER_MARKER_CLEAR -&gt; &#123; makerUpdateManger.clearMarker() &#125; &#125; &#125; fun sendDataUpdateMsg() &#123; val currentTime = System.currentTimeMillis() if (currentTime - lastUpdateTime &lt; UPDATE_INTERVAL_TIME) &#123; return &#125; lastUpdateTime = currentTime isCanceled = true removeCallbacksAndMessages(null) sendEmptyMessageDelayed(MSG_CLUSTER_DATA_UPDATE, UPDATE_INTERVAL_TIME) &#125; &#125;&#125;/** * Marker 数据获取适配器 */interface MarkerDataAdapter&lt;T : MarkerItem&gt; &#123; fun getMarkerData(visibleBounds: LatLngBounds): MutableList&lt;T&gt;? fun onMarkerClick(markerItem: MarkerItem, marker: Marker): Boolean&#125;abstract class MarkerItem(val type: MarkType, val latLng: LatLng, var zIndex: Float = -1F) &#123; /** * 生成 Marker */ abstract fun createMarker(mapView: MapView): Marker&#125;","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"Android 实现大文件分片上传","date":"2019-07-12T07:57:19.000Z","path":"2019/07/12/multi-form/","text":"项目中有视频上传的功能，但一直没做断点续传，针对大视频上传不友好，最近的版本需求将断点续传加上了，服务端采用的是 multipart/form-data 编码方式来实现，那么客户端也依照这个方式来做就好了。 multipart/form-datamultipart/form-data 方式用于大数据 Post 请求，用做分片正好合适。它对数据有一定的格式，参照示例：12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"text\"title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 每部分都是以--boundary开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以--boundary--标示结束。 原生实现如果使用 Android 原生 HttpUrlConnection 来拼接数据，参照从原理角度解析Android （Java） http 文件上传贴出部分代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private static final String BOUNDARY = \"----WebKitFormBoundaryT1HoybnYeFOGFlBR\"; /** * * @param params * 传递的普通参数 * @param uploadFile * 需要上传的文件名 * @param fileFormName * 需要上传文件表单中的名字 * @param newFileName * 上传的文件名称，不填写将为uploadFile的名称 * @param urlStr * 上传的服务器的路径 * @throws IOException */public void uploadForm(Map&lt;String, String&gt; params, String fileFormName, File uploadFile, String newFileName, String urlStr) throws IOException &#123; if (newFileName == null || newFileName.trim().equals(\"\")) &#123; newFileName = uploadFile.getName(); &#125; StringBuilder sb = new StringBuilder(); /** * 普通的表单数据 */ for (String key : params.keySet()) &#123; sb.append(\"--\" + BOUNDARY + \"\\r\\n\"); sb.append(\"Content-Disposition: form-data; name=\\\"\" + key + \"\\\"\" + \"\\r\\n\"); sb.append(\"\\r\\n\"); sb.append(params.get(key) + \"\\r\\n\"); &#125; /** * 上传文件的头 */ sb.append(\"--\" + BOUNDARY + \"\\r\\n\"); sb.append(\"Content-Disposition: form-data; name=\\\"\" + fileFormName + \"\\\"; filename=\\\"\" + newFileName + \"\\\"\" + \"\\r\\n\"); sb.append(\"Content-Type: image/jpeg\" + \"\\r\\n\");// 如果服务器端有文件类型的校验，必须明确指定ContentType sb.append(\"\\r\\n\"); byte[] headerInfo = sb.toString().getBytes(\"UTF-8\"); byte[] endInfo = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes(\"UTF-8\"); System.out.println(sb.toString()); URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"POST\"); conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY); conn.setRequestProperty(\"Content-Length\", String .valueOf(headerInfo.length + uploadFile.length() + endInfo.length)); conn.setDoOutput(true); OutputStream out = conn.getOutputStream(); InputStream in = new FileInputStream(uploadFile); out.write(headerInfo); byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) != -1) out.write(buf, 0, len); out.write(endInfo); in.close(); out.close(); if (conn.getResponseCode() == 200) &#123; System.out.println(\"上传成功\"); &#125;&#125; 拼接好字符串之后，转成 byte 数组，然后写入到 http connection 中即可。 OkHttp 实现项目中有基于 OkHttp 封装网络请求，但是不支持 multipart/form-data，那么便根据 OkHttp 自己实现一个吧。12345678910111213141516171819202122232425262728293031// Http 请求 Clientprivate val client: OkHttpClient = OkHttpClient().newBuilder() .connectTimeout(0, TimeUnit.MILLISECONDS) .writeTimeout(60 * 1000, TimeUnit.MILLISECONDS) .readTimeout(60 * 1000, TimeUnit.MILLISECONDS) .build()/** * 分片上传，采用 OkHttp MultipartBody */fun uploadPart(data: ByteArray, uploadId: String, key: String, partNumber: Int, progressListener: ProgressListener?): String? &#123; val requestBody = VideoUploadRequestBody.create(MediaType.parse(\"video/mp4\"), data, progressListener) val multipartBody = MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(\"filename\", key, requestBody) .addFormDataPart(\"uploadId\", uploadId) .addFormDataPart(\"key\", key) .addFormDataPart(\"partNumber\", partNumber.toString()) .addFormDataPart(\"partSize\", data.size.toString()) .build() val url = RequestUtils.buildFullUrl(apiHost, \"/api/open/upload/part.htm\", signKey, extraParams) val request = Request.Builder() .url(url) .post(multipartBody) .build() val response = client.newCall(request).execute() return response.body()?.string()&#125; 利用 MultipartBody.addFormDataPart 可以很方便的添加参数，而不用自己拼接了。MultipartBody.FORM即对应multipart/form-data：1public static final MediaType FORM = MediaType.get(\"multipart/form-data\") 针对 client 返回的 response，想要获取数据只需要调用：1response.body()?.string() 但是此方法只能调用一次，调用之后 client 会关闭通道，这让我在调试返回结果的时候浪费不少时间。data 作为数据来源，可以从 File 中读取：12345678910111213141516171819202122232425262728293031/** * 获取某一片对应的二进制数据 * PART_SIZE：每一片的大小 * * @param partSize 当前第几片 * @param file 文件对象 * * @return 对应片段的二进制数据流 */private fun getPartData(partSize: Int, file: File): ByteArray? &#123; val result = ByteArray(PART_SIZE) var accessFile: RandomAccessFile? = null try &#123; accessFile = RandomAccessFile(file, \"r\") accessFile.seek((partSize - 1L) * PART_SIZE) return when (val readSize = accessFile.read(result)) &#123; -1 -&gt; null PART_SIZE -&gt; result else -&gt; &#123; val tempArray = ByteArray(readSize) System.arraycopy(result, 0, tempArray, 0, readSize) tempArray &#125; &#125; &#125; catch (e: IOException) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; IOUtils.close(accessFile) &#125; return null&#125; 至此，数据便能使用 multipart/form-data Post 到服务器了。 进度监听看到上述示例中的 VideoUploadRequestBody：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class VideoUploadRequestBody(val contentType: MediaType?, val data: ByteArray, val listener: ProgressListener?) : RequestBody() &#123; companion object &#123; @JvmStatic fun create(contentType: MediaType?, data: ByteArray, listener: ProgressListener?): RequestBody &#123; return VideoUploadRequestBody(contentType, data, listener) &#125; &#125; override fun contentType(): MediaType? &#123; return contentType &#125; @Throws(IOException::class) override fun contentLength(): Long &#123; return data.size.toLong() &#125; @Throws(IOException::class) override fun writeTo(sink: BufferedSink) &#123; var localSink = sink if (listener != null) &#123; localSink = Okio.buffer(CountSink(localSink)) &#125; localSink.writeAll(Okio.source(ByteArrayInputStream(data))) // 必须添加 flush，不然最后一片会上传失败 localSink.flush() &#125; private inner class CountSink(delegate: Sink) : ForwardingSink(delegate) &#123; internal var bytesWritten = 0L internal var contentLength = 0L @Throws(IOException::class) override fun write(source: Buffer, byteCount: Long) &#123; super.write(source, byteCount) if (contentLength == 0L) &#123; contentLength = contentLength() &#125; bytesWritten += byteCount listener?.onProgress(bytesWritten, contentLength, bytesWritten == contentLength) &#125; &#125;&#125; 继承 RequestBody，在每一次 write 的时候回调一下，BufferedSink writeAll 方法内部会每次写入 8192 字节。123456789101112131415@Overridepublic long writeAll(Source source) throws IOException &#123; if (source == null) &#123; throw new IllegalArgumentException(\"source == null\"); &#125; long totalBytesRead = 0; for (long readCount; (readCount = source.read(buffer, Segment.SIZE)) != -1; ) &#123; totalBytesRead += readCount; emitCompleteSegments(); &#125; return totalBytesRead;&#125;final class Segment &#123; /** The size of all segments in bytes. */ static final int SIZE = 8192;&#125; 所以每写入 8192 字节会回调一次，对于进度监听有特殊需求的，可自行修改 writeTo 方法。这个回调只是针对单片的，还需要一个针对整个文件的回调：123456789// 当前上传的是第几片private var currentPart = 0// 上传文件的 sizeprivate var size = 0Loverride fun onProgress(currentLength: Long, contentLength: Long, complete: Boolean) &#123; val progress = (currentPart - 1) * PART_SIZE + currentLength listener?.onProgress(progress, size, progress == size)&#125; 如此，整个文件上传的进度监听即实现了。注：要实现断点续传，则需要在每个分片上传完之后保存到本地数据库，然后续传的时候根据数据库保存的最新片段取出数据进行上传。 参考四种常见的 POST 提交数据方式从原理角度解析Android （Java） http 文件上传OkHttp踩坑记：为何 response.body().string() 只能调用一次？","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"记一次 ANR 寻根之旅","date":"2019-07-04T07:12:38.000Z","path":"2019/07/04/anr/","text":"最近项目升大版本，targetSdkVersion 从 Android 6.0（version 21） 直接升到 Adnroid 9.0（version 28），跨度有点大，但是没有像升到 Android 6.0 那样工作量大。升完之后，在小米5、小米4C 2款测试机上 App 启动直接无响应了，在我的小米 MIX 上没问题。于是测试机调试之旅开始了。。。在 SplashActivity onCreate 的方法里打断点进都进不去，有点懵，所以将目标定位到 Application 初始化了。看着 Application 相关初始化的代码，没发现什么大问题。打断点逐步调试，运行到某一行时直接就无响应了，后面的代码也不执行了，logcat 也看不到有用的信息，有点摸不着头脑。后面 Google 发现可以直接看到手机 ANR 的日志，路径为：/data/anr/traces.txt，于是很欢快的将日志导出到电脑：1adb pull /data/anr/traces.txt d:/test 然后看到 traces.txt：123456789101112131415161718192021222324252627282930313233343536373839----- pid 1928 at 2019-07-03 17:42:50 -----Cmd line: cn.xxx.xxx.xxxBuild fingerprint: 'Xiaomi/gemini/gemini:6.0.1/MXB48T/V8.0.10.0.MAACNDH:user/release-keys'ABI: 'arm'Build type: optimizedZygote loaded classes=4121 post zygote classes=1287Intern table: 54279 strong; 161 weakJNI: CheckJNI is on; globals=322 (plus 266 weak)Libraries: /data/app/cn.xxx.xxx.xxx-1/lib/arm/libBDSpeechDecoder_V1.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libbd_etts.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libbdtts.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libgnustl_shared.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libtnpn.so /system/app/WebViewGoogle/WebViewGoogle.apk!/lib/armeabi-v7a/libwebviewchromium.so /system/lib/libandroid.so /system/lib/libcompiler_rt.so /system/lib/libjavacrypto.so /system/lib/libjnigraphics.so /system/lib/libmedia_jni.so /system/lib/libmiuinative.so /system/lib/libqti_performance.so /system/lib/libsechook.so /system/lib/libwebviewchromium_loader.so /system/lib/libwebviewchromium_plat_support.so libjavacore.so (17)Heap: 24% free， 21MB/28MB; 47008 objects...\"main\" prio=5 tid=1 Waiting | group=\"main\" sCount=1 dsCount=0 obj=0x744885e0 self=0xf4f76500 | sysTid=1928 nice=-1 cgrp=bg_non_interactive sched=0/0 handle=0xf7194b34 | state=S schedstat=( 236711085 326769009 310 ) utm=17 stm=6 core=0 HZ=100 | stack=0xff4ef000-0xff4f1000 stackSize=8MB | held mutexes= at cn.xxx.android.core.glide.GlideProgressManager.getOkHttpClient(GlideProgressManager.java:36) - waiting on &lt;0x08da7fbe&gt; (a java.lang.Class&lt;cn.xxx.android.core.http.XXXHttpClient&gt;) at cn.xxx.android.core.glide.XXXAppGlideModule.registerComponents(XXXAppGlideModule.java:44) at com.bumptech.glide.GeneratedAppGlideModuleImpl.registerComponents(GeneratedAppGlideModuleImpl.java:38) at com.bumptech.glide.Glide.initializeGlide(Glide.java:273) at com.bumptech.glide.Glide.initializeGlide(Glide.java:223) at com.bumptech.glide.Glide.checkAndInitializeGlide(Glide.java:184) at com.bumptech.glide.Glide.get(Glide.java:168) - locked &lt;0x02e8781f&gt; (a java.lang.Class&lt;com.bumptech.glide.Glide&gt;) at cn.xxx.xxx.xxx.VygApplication.onTrimMemory(VygApplication.java:93) at android.app.ActivityThread.handleTrimMemory(ActivityThread.java:4420) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1548) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5458) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)... 日志很多，Cmd line 就是当前 ANR 应用的包名，通过日志，可以得到一些有效信息：123456789101112131415161718main：main标识是主线程，如果是线程，那么命名成“Thread-X”的格式，x 表示线程 id，逐步递增prio：线程优先级，默认是 5tid：tid 不是线程的 id，是线程唯一标识 IDgroup：是线程组名称sCount：该线程被挂起的次数dsCount：是线程被调试器挂起的次数obj：对象地址self：该线程 Native 的地址sysTid：是线程号(主线程的线程号和进程号相同)nice：是线程的调度优先级sched：分别标志了线程的调度策略和优先级cgrp：调度归属组handle：线程处理函数的地址state：是调度状态schedstat：从 /proc/[pid]/task/[tid]/schedstat 读出，三个值分别表示线程在 cpu 上执行的时间、线程的等待时间和线程执行的时间片长度，不支持这项信息的三个值都是 0utm：是线程用户态下使用的时间值(单位是 jiffies）stm：是内核态下的调度时间值core：是最后执行这个线程的 cpu 核的序号 找到 “main”，可以看到，在 Application 的 onTrimMemory 时调用了 Glide 的 get 方法，后面一系列操作导致的主线程变成 Waiting 状态了。12345678910@Overridepublic void onTrimMemory(int level) &#123; super.onTrimMemory(level); if (level == TRIM_MEMORY_UI_HIDDEN) &#123; Glide.get(this).clearMemory(); &#125; Glide.get(this).trimMemory(level);&#125; 最终会调用到 GlideAppModule 的 registerComponents 方法：123456789101112@Overridepublic void registerComponents(Context context， Glide glide， Registry registry) &#123; registry.replace(GlideUrl.class， InputStream.class， new OkHttpUrlLoader.Factory(GlideProgressManager.getOkHttpClient())); if (CollectionUtils.isNotEmpty(libraryGlideModuleList)) &#123; int size = libraryGlideModuleList.size(); for (int i = 0; i &lt; size; i++) &#123; libraryGlideModuleList.get(i).registerComponents(context， glide， registry); &#125; &#125;&#125; 然后看到 GlideProgressManager：12345678910111213141516static OkHttpClient getOkHttpClient() &#123; if (okHttpClient == null) &#123; okHttpClient = XXXHttpClient.getDefaultHttpClient().newBuilder() .addNetworkInterceptor(new Interceptor() &#123; @Override public Response intercept(@NonNull Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); return response.newBuilder() .body(new ProgressResponseBody(request.url().toString()， response.body()， LISTENER)) .build(); &#125; &#125;).build(); &#125; return okHttpClient;&#125; XXXHttpClient：123456789101112private static volatile OkHttpClient defaultHttpClient;public static OkHttpClient getDefaultHttpClient() &#123; if (defaultHttpClient == null) &#123; synchronized (MucangHttpClient.class) &#123; if (defaultHttpClient == null) &#123; defaultHttpClient = new OkHttpClient(); &#125; &#125; &#125; return defaultHttpClient;&#125; 很标准的 Double-Check 单例模式，感觉没啥大问题，但是为啥会导致 ANR 呢？因为升大版本，将绝大多数注意力都放到升级注意项了，比如 FileProvider 等等，但是正好基础库在大版本升级时，将 OkHttp 从 2.x 升到 3.x，上面的代码正时此时添加进来的，所以没升大版本一切正常。解决问题的话，将 Application 中 Glide 相关操作直接干掉就好了，Glide 内部有自己的内存控制策略，无需开发者关心了吧。写这篇文章主要是记录一下可以通过拉取 traces.text 日志来分析 ANR，但是为什么这样的代码导致了 ANR 还没研究透，待我研究好了再来更新此文。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"养猫一个星期后","date":"2019-06-28T08:40:21.000Z","path":"2019/06/28/cat/","text":"我有一个梦想：养一只二哈，或者柴犬、金毛也可以，哈哈。但是狗的话，天性好动，需要每天带出去溜溜（或许是狗溜我）。我现在一个人住，普遍情况下家里是没人的，养一只狗确实没太多的时间和精力。退而求其次，养只猫或许可行？猫的话，比较爱干净，也能一整天待在家里不需要你带出去溜，只要我在家的时间能陪陪他便好了。也做了很久的思想斗争，养不好怎么办，这不是耽误猫生吗？最后还是开悟了，人生不就是这样吗？要多多体验没经历过的事情，之前没养过猫，现在养一只，也是一种经历，会养慢慢学习总能变好的。早些日子就找过一家猫舍看过猫，也加了微信，总能在朋友圈看到各种各样的小猫咪，内心总是蠢蠢欲动。心动不如行动，就在上周日，我去猫舍买了一只美短虎斑，很调皮的一个小家伙，我给他取名「土豆」。 你看我，萌不萌？ 第一天刚到家的时候，这家伙很怂，就躲在沙发下面。 后面慢慢熟悉了，可以用逗猫棒把他吸引过来了。 被逗起来的猫还是很过瘾的。 Your browser does not support the video tag. 再然后他都敢往我电脑桌上爬了，“快来撸我，别玩电脑了！”。 胆子越来越大，才两个月大点的小猫咪，直接爬上了我近一米高的凳子。后面直接往下跳，估计是把腿摔疼了，破天荒的在我怀里安静了小半天，果然是初生牛犊不怕虎。 有一天竟然还爬到我的床上了，但是我现在还没能接受和猫咪一起睡，直接就把他丢下床去。 最近莫名喜欢玩我的拖鞋，让我很无语。 这几天，小猫咪适应的很好，现在吃喝拉撒都挺正常，一天喂两次猫粮，早晚各一次，水就看情况加。猫舍管家说，猫不喜欢吃隔夜的食物，所以我尽量都是每天都喂，一次少喂点。营养膏应该是猫最喜欢吃的实物了吧，吃营养膏的时候是他最乖的时候。 Your browser does not support the video tag. 最后上个撸猫视频，撸猫一时爽，一直撸一直爽。 Your browser does not support the video tag.","tags":[{"name":"cat","slug":"cat","permalink":"http://lijia92.github.io/tags/cat/"}]},{"title":"ConstraintLayout 真香","date":"2019-06-13T02:37:26.000Z","path":"2019/06/13/cl/","text":"ConstraintLayout 出来蛮久了，但是一直没怎么用，说是可以直接进行拖拽来实现布局，但是 xml 里全是写死的 dp，不实用。然后用代码吧，属性都贼长贼多，有些难记。最近同学强力安利，说多写写就熟悉了，于是项目新的布局基本都用 ConstraintLayout 来写了，刚开始写的时候确实比较慢，很多属性不知道，有些属性有什么用也不晓得，但是用了几天后，发现真好用！人类的本质啊，真香怪！ 基本属性 layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf 见名思意，都很直接明了，还是很方便使用的。和 RelativeLayout 很相似，但是还有着 LinearLayout 的特性，可以说是结合了两大布局的特性，用起来爽歪歪。用这些基础属性已经可以实现大部分的布局了，而且布局嵌套层级就一级。举个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;android.support.constraint.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"44dp\" android:paddingLeft=\"14dp\" android:paddingRight=\"4dp\" tools:background=\"#f00\"&gt; &lt;ImageView android:id=\"@+id/backIv\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" android:paddingLeft=\"6dp\" android:src=\"@drawable/vyg__icon_back_white\" android:tint=\"#fff\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;TextView android:id=\"@+id/catalogTv\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:paddingLeft=\"16dp\" android:paddingRight=\"16dp\" android:text=\"目录\" android:textColor=\"@color/vyg__white\" android:textSize=\"14sp\" android:visibility=\"gone\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" tools:visibility=\"gone\"/&gt; &lt;ImageView android:id=\"@+id/avatarIv\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" android:layout_marginLeft=\"12dp\" android:src=\"@drawable/vyg__user_avatar_default\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toRightOf=\"@id/backIv\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;TextView android:id=\"@+id/nameTv\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"8dp\" android:layout_marginRight=\"16dp\" android:ellipsize=\"end\" android:singleLine=\"true\" android:textColor=\"@color/vyg__363A3E\" android:textSize=\"13sp\" app:layout_constraintBottom_toTopOf=\"@+id/timeTv\" app:layout_constraintHorizontal_bias=\"0\" app:layout_constraintLeft_toRightOf=\"@+id/avatarIv\" app:layout_constraintRight_toLeftOf=\"@+id/followTv\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_chainStyle=\"packed\" tools:text=\"小孩子的故事小孩子的故事小孩子的故事小孩子的故事\"/&gt; &lt;TextView android:id=\"@+id/timeTv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"@color/vyg__A0A9B9\" android:textSize=\"11sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"@+id/nameTv\" app:layout_constraintTop_toBottomOf=\"@id/nameTv\" tools:text=\"2012-11-12\"/&gt; &lt;TextView android:id=\"@+id/followTv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/vyg__shape_f8e71c_r100\" android:drawablePadding=\"4dp\" android:gravity=\"center\" android:paddingBottom=\"6dp\" android:paddingLeft=\"12dp\" android:paddingRight=\"12dp\" android:paddingTop=\"6dp\" android:text=\"关注\" android:textColor=\"@color/vyg__font_363a3e\" android:textSize=\"14sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintRight_toLeftOf=\"@id/catalogTv\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_goneMarginRight=\"16dp\"/&gt; &lt;android.support.constraint.Group android:id=\"@+id/group\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"gone\" app:constraint_referenced_ids=\"avatarIv,nameTv,timeTv,followTv\" tools:visibility=\"visible\"/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 界面效果如下： goneMargin如上图的界面中，为了加大「目录」两字的点击相应区域，给它设置了左右 16dp 的 padding，但是某些情况下，这个「目录」不需要展示，设置为 GONE 之后「关注」按钮距离右边的距离就只剩 4dp 了，需要手动改为 16dp，这样就得写一句很蛋疼的代码：1(followTv.layoutParams as ViewGroup.MarginLayoutParams).rightMargin = DimenUtils.dp2px(16F) 但是利用 ConstraintLayout 之后，你会发现一句 xml 代码即可搞定，给「关注」设置如下属性1app:layout_goneMarginRight=\"16dp\" 当它依赖的 View 变为 GONE 时，仍然能保留 margin，ConstraintLayout 流弊！ chainStyle上述代码中有一个属性：1app:layout_constraintVertical_chainStyle=\"packed\" 可以将约束元素组成一个链，chainStyle 用来设置元素之间的效果。 weight经常有这种布局：12345678910111213141516171819202122&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt;&lt;/LinearLayout&gt; ConstraintLayout 利用 layout_constraintHorizontal_weight 或 layout_constraintVertical_weight 也可以轻而易举的实现。只有一个 View 占据宽度的 1/3，利用 LinearLayout 可以将 View 换成 Space：12345678910111213141516171819202122&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;Space android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;Space android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt;&lt;/LinearLayout&gt; 利用 ConstraintLayout 实现将会更简单：1234567891011121314151617&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"100dp\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_weight=\"\" app:layout_constraintWidth_percent=\"0.33\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 忽略除不断的小数- -。 Group经常会有这种需求：在某个场景下，展示哪些 View，在其他场景要隐藏这些 View，它们是同显示同隐藏的，一个两个 View 还好，如果 View 很多，写起来就很蛋疼了。用 Group 则会很简单。1234567&lt;android.support.constraint.Group android:id=\"@+id/group\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"gone\" app:constraint_referenced_ids=\"avatarIv,nameTv,timeTv,followTv\" tools:visibility=\"visible\"/&gt; 然后使用 group.visibility 即可设置 ids 里面所有 id 对应的 View 了。注：Group 只有在 1.1 及以上的版本才添加进来。再注：Group 添加后的 id 再针对子 View 单独操作 visibility 是无效的。代码：12345678910111213141516171819public void updatePreLayout(ConstraintLayout container) &#123; int visibility = this.getVisibility(); float elevation = 0.0F; if (VERSION.SDK_INT &gt;= 21) &#123; elevation = this.getElevation(); &#125; for(int i = 0; i &lt; this.mCount; ++i) &#123; int id = this.mIds[i]; View view = container.getViewById(id); if (view != null) &#123; view.setVisibility(visibility); if (elevation &gt; 0.0F &amp;&amp; VERSION.SDK_INT &gt;= 21) &#123; view.setElevation(elevation); &#125; &#125; &#125;&#125; 界面绘制时，Group 关联的所有 View 的 visibility 只会根据 Group 来，要么全看得见，要么全看不见。 constrainedWidth先看两张图： 文章 RecyclerView 处于微信图标的左侧，且从右边开始布局，嵌套布局很容易实现，看下约束布局如何实现：1234567891011121314151617181920212223242526272829303132333435&lt;android.support.constraint.ConstraintLayout android:id=\"@+id/articleRoot\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" android:layout_marginBottom=\"112dp\"&gt; &lt;ImageView android:id=\"@+id/wxIconIv\" android:layout_width=\"62dp\" android:layout_height=\"57dp\" android:layout_marginLeft=\"6dp\" android:paddingRight=\"8dp\" android:src=\"@drawable/vyg__article_icon_wx\" android:visibility=\"gone\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintHorizontal_bias=\"0\" app:layout_constraintLeft_toLeftOf=\"parent\"/&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/articleRv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"12dp\" android:layout_marginLeft=\"12dp\" app:layout_constrainedWidth=\"true\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintHorizontal_bias=\"1\" app:layout_constraintLeft_toRightOf=\"@+id/wxIconIv\" app:layout_constraintRight_toRightOf=\"parent\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 将控件的尺寸设置为 wrap_content，那么对控件设置的 maxWidth、minHeight 这些约束是不起作用的，而强制约束就用于使控件在设置 wrap_content 的情况下约束依然生效。 小结ConstraintLayout 还有很多我没用到特性，目前为止，我：真香！已经不想再用原始的三大布局了，嘿嘿嘿。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"RecyclerView 滑动小记","date":"2019-05-17T07:58:19.000Z","path":"2019/05/17/scroll-1/","text":"关于 RecyclerView 的滑动方法有很多： scrollToPosition scrollTo scrollBy smoothScrollBy smoothScrollToPosition 针对 LineaderLayoutManager 还有一个很重要的方法：scrollToPositionWithOffset，下面逐一进行说明。 scrollTo1234public void scrollTo(int x, int y) &#123; Log.w(TAG, \"RecyclerView does not support scrolling to an absolute position. \" + \"Use scrollToPosition instead\");&#125; 滑动到绝对位置，直接不支持。很皮~ scrollBy &amp; smoothScrollBy基于当前位置进行相对滑动。123456789101112131415public void scrollBy(int x, int y) &#123; if (mLayout == null) &#123; Log.e(TAG, \"Cannot scroll without a LayoutManager set. \" + \"Call setLayoutManager with a non-null argument.\"); return; &#125; if (mLayoutFrozen) &#123; return; &#125; final boolean canScrollHorizontal = mLayout.canScrollHorizontally(); final boolean canScrollVertical = mLayout.canScrollVertically(); if (canScrollHorizontal || canScrollVertical) &#123; scrollByInternal(canScrollHorizontal ? x : 0, canScrollVertical ? y : 0, null); &#125;&#125; 根据布局的方向进行滑动。scrollByInternal 为具体处理滑动的方法，这里不贴了，它会调用 dispatchOnScrolled：1234567891011121314151617181920212223void dispatchOnScrolled(int hresult, int vresult) &#123; mDispatchScrollCounter++; // Pass the current scrollX/scrollY values; no actual change in these properties occurred // but some general-purpose code may choose to respond to changes this way. final int scrollX = getScrollX(); final int scrollY = getScrollY(); onScrollChanged(scrollX, scrollY, scrollX, scrollY); // Pass the real deltas to onScrolled, the RecyclerView-specific method. onScrolled(hresult, vresult); // Invoke listeners last. Subclassed view methods always handle the event first. // All internal state is consistent by the time listeners are invoked. if (mScrollListener != null) &#123; mScrollListener.onScrolled(this, hresult, vresult); &#125; if (mScrollListeners != null) &#123; for (int i = mScrollListeners.size() - 1; i &gt;= 0; i--) &#123; mScrollListeners.get(i).onScrolled(this, hresult, vresult); &#125; &#125; mDispatchScrollCounter--;&#125; 会调用到 mScrollListener.onScrolled，也就是说可以与 ScrollListener 共同作用。这里先提一下，后面做详细说明。12345678910111213141516171819public void smoothScrollBy(int dx, int dy, Interpolator interpolator) &#123; if (mLayout == null) &#123; Log.e(TAG, \"Cannot smooth scroll without a LayoutManager set. \" + \"Call setLayoutManager with a non-null argument.\"); return; &#125; if (mLayoutFrozen) &#123; return; &#125; if (!mLayout.canScrollHorizontally()) &#123; dx = 0; &#125; if (!mLayout.canScrollVertically()) &#123; dy = 0; &#125; if (dx != 0 || dy != 0) &#123; mViewFlinger.smoothScrollBy(dx, dy, interpolator); &#125;&#125; 最终调用的是 mViewFlinger.smoothScrollBy，mViewFlinger 是 RecyclerView 内部的一个 Runnable，通过不停执行 postOnAnimation 来实现平滑滑动。 scrollToPosition &amp; smoothScrollToPosition滑动到指定 position，也是可以直接或者平滑滑动。最后调用到的还是 LayoutManager 中的方法：12345678public void scrollToPosition(int position) &#123; mPendingScrollPosition = position; mPendingScrollPositionOffset = INVALID_OFFSET; if (mPendingSavedState != null) &#123; mPendingSavedState.invalidateAnchor(); &#125; requestLayout();&#125; 改了属性直接 requestLayout。看下：smoothScrollToPosition1234567public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) &#123; LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()); linearSmoothScroller.setTargetPosition(position); startSmoothScroll(linearSmoothScroller);&#125; 创建了一个 LinearSmoothScroller 来进行滑动，滑动也是调用的 RecyclerView 内部的 ViewFlinger 来实现的，它也会调用到 dispatchOnScrolled 方法，所以也可以与 ScrollListener 共用。 scrollToPositionWithOffset12345678public void scrollToPositionWithOffset(int position, int offset) &#123; mPendingScrollPosition = position; mPendingScrollPositionOffset = offset; if (mPendingSavedState != null) &#123; mPendingSavedState.invalidateAnchor(); &#125; requestLayout();&#125; 与 scrollToPosition 几无二致，只不过带上了 offset。当 offset &gt; 0，目标元素会距离顶部多出 offset 的距离，小于 0 则会被盖住 offset 的距离。注意：当 mPendingScrollPositionOffset 为 INVALID_OFFSET 时，滑动表现是 SNAP_TO_ANY，否则为 SNAP_TO_START，下面来具体说说。 LinearSmoothScroller SNAP1234567891011121314151617181920212223242526272829/** * Align child view's left or top with parent view's left or top * * @see #calculateDtToFit(int, int, int, int, int) * @see #calculateDxToMakeVisible(android.view.View, int) * @see #calculateDyToMakeVisible(android.view.View, int) */public static final int SNAP_TO_START = -1;/** * Align child view's right or bottom with parent view's right or bottom * * @see #calculateDtToFit(int, int, int, int, int) * @see #calculateDxToMakeVisible(android.view.View, int) * @see #calculateDyToMakeVisible(android.view.View, int) */public static final int SNAP_TO_END = 1;/** * &lt;p&gt;Decides if the child should be snapped from start or end, depending on where it * currently is in relation to its parent.&lt;/p&gt; * &lt;p&gt;For instance, if the view is virtually on the left of RecyclerView, using * &#123;@code SNAP_TO_ANY&#125; is the same as using &#123;@code SNAP_TO_START&#125;&lt;/p&gt; * * @see #calculateDtToFit(int, int, int, int, int) * @see #calculateDxToMakeVisible(android.view.View, int) * @see #calculateDyToMakeVisible(android.view.View, int) */public static final int SNAP_TO_ANY = 0; 根据注释很清晰了，SNAP_TO_START 为左上角对齐，SNAP_TO_END 为 右下角对齐，SNAP_TO_ANY 则是不限制，只要显示完对应 postion 的 Item 即可。举个栗子：当前有 10个 Item。 处于列表顶部，调用 scrollToPosition(5)，列表会从顶部定位到第 6 个 Item，且第 6 个 Item 位于屏幕最下方。 处于列表底部，调用 scrollToPosition(5)，列表会从底部定位到第 6 个 Item，且第 6 个 Item 位于屏幕最上方。 处于列表中部，第 6 个 Item 可见时调用 scrollToPosition(5)，界面不会发生任何改变。 这也就是网上众多文章吐槽 RecycleView 定位不准的原因了。因为默认是 SNAP_TO_ANY，RecycleView 处理起来就是让目标 position 的 Item 在列表中完全可见。如果目标是从底部滑上来，那么当目标完全可见时，滑动就会终止了，所以目标处理可见列表的最底端，反之亦然。当目标本身就是完全可见的，便不会做任何处理。所以，如若有定位目标必须处于列表顶端的需求，则可以这样：12345678RecyclerView.SmoothScroller smoothScroller = new LinearSmoothScroller(context) &#123; @Override protected int getVerticalSnapPreference() &#123; return LinearSmoothScroller.SNAP_TO_START; &#125;&#125;;smoothScroller.setTargetPosition(position);layoutManager.startSmoothScroll(smoothScroller); 如果是底端则可以使用 SNAP_TO_END。 addOnScrollListener通常会有这种需求，监听 RecyclerView 滑动多少了，来改变标题栏的表现等需求。所以会有这样的代码：12345678910111213private val onScrollListener = object : RecyclerView.OnScrollListener() &#123; // 滑动的距离 private var offsetY = 0 override fun onScrolled(recyclerView: RecyclerView?, dx: Int, dy: Int) &#123; super.onScrolled(recyclerView, dx, dy) offsetY += dy if (offsetY &gt; DimenUtils.dp2px(100F)) &#123; // do something &#125; &#125;&#125; 当滑动距离超过 100dp 则进行某些处理。上文有可以与 ScrollListener 共同作用这一说法，下面进行说明。当设置了 onScrollListener 了之后，现在假设每个 Item 高度为 100， 现在处于第 2个 Item，那么 offsetY 的值为 100。现在分别执行下面几个操作： scrollBy(200)：基于当前位置直接滑动 200 单位，会回调 onScrolled，dy 为 200，所以 offsetY 为 300，符合预期。 smoothScrollBy(200)：大体与 scrollBy 一直，只不过是平滑滑动，会多几个中间值，但最终结果是一样的。 scrollToPosition(3)：直接定位到 position 为 3 的位置，最终会调用 onScrolled（重新 layout 调用，而不是滑动操作调用），dy 为 0，offsetY 仍然为 100，即当前已经显示在第 4 个 Item 了，结果 offsetY 仍然为 100，这是有问题的。 smoothScrollToPosition(3)：会平滑定位到 position 为 3 的位置，与 smoothScrollBy 表现类似，最终结果与 1、2 一致。 scrollToPositionWithOffset(3)：与 3 表现一致，只不过允许 offset。 鉴于文章长度，没有粘贴测试代码及 Log，只是把现象描述出来，需要细心看看。综上所述：平滑滑动或相对滑动的方法可以与 onScrollListener 结合使用，scrollToPosition 和 scrollToPositionWithOffset 则不能与 onScrollListener 结合使用。 scrollToPositionWithOffset &amp; onScrollListener如上图，是一个文章详情页。 需要监听 onScrollListener 来改变标题栏。 文章是个列表，文章详情为一个 Item，每一条评论为一个 Item，新增一条评论时需要定位到这条评论。 标题栏覆盖在列表之上。 直接使用 smoothScrollToPosition 会导致标题栏覆盖一部分评论，所以需要加上偏移。可惜上文得出的结论 scrollToPositionWithOffset 与 onScrollListener 无法结合使用。所以如何处理呢？这里我保持 onScrollListener 不变，针对偏移采用曲线救国的方法：给详情 Item 添加一个 layout_marginBottom=”-60dp”，给新增的一条评论添加 layout_marginBottom=”60dp”，这样当使用 smoothScrollToPosition 定位到最新一条评论时，它距离顶部有 60 dp 的距离，如此便不会被覆盖了。这个想法与Android 滑动吸顶效果是一致的，发现这个做法还真挺有用，哈哈~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android H5 与原生交互那点事","date":"2019-05-16T07:19:05.000Z","path":"2019/05/16/h5/","text":"鉴于 H5 丰富的表现力，产品决定将项目中的某个详情页改为 H5 展示，评论、点赞仍由原生实现，于是便需要原生与 H5 交互。之前对于这块少有涉及，恰巧合作的前端同事对于这块也不太熟悉，所以耗时良久。现在功能做得差不多了，稍微记录一下。 原生先看下 WebView 的设置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class VygWebView(context: Context, attr: AttributeSet) : BaseWebView(context, attr) &#123; private var callback: JSCallback? = null private var isDestroyed: Boolean = false init &#123; addJavascriptInterface(VygJavaScriptInterface(), \"voyagerApp\") setWebContentsDebuggingEnabled(true) settings.allowFileAccess = true settings.allowFileAccessFromFileURLs = true settings.allowUniversalAccessFromFileURLs = true &#125; /** * 注册js回调监听器 */ fun registerJSCallback(callback: JSCallback) &#123; this.callback = callback &#125; /** * 将消息发送给 WebView 来处理 */ fun sendMessageToWeb(message: String) &#123; if (isDestroyed) &#123; return &#125; if (Config.isDebug()) &#123; LogUtils.e(\"MessageParser\", \"sendMessageToWeb:$message\") &#125; val function = \"javascript:window.receiveMessage($message)\" if (MainThreadUtils.isMainThread()) &#123; loadUrl(function) &#125; else &#123; MainThreadUtils.post(Runnable &#123; if (isDestroyed) &#123; return@Runnable &#125; loadUrl(function) &#125;) &#125; &#125; override fun destroy() &#123; super.destroy() isDestroyed = true callback = null &#125; inner class VygJavaScriptInterface &#123; @JavascriptInterface fun sendMessage(message: String) &#123; if (isDestroyed) &#123; return &#125; callback?.onReceiveWebMessage(message) &#125; &#125; interface JSCallback &#123; fun onReceiveWebMessage(message: String) &#125;&#125; 所有的交互全部通过 Json 字符串来进行，双端协定对 Json 的解析规则。本地通过添加 VygJavaScriptInterface 实现 sendMessage 方法，来接受 H5 传递过来的消息，通过 sendMessageToWeb 向 H5 发送消息。定义消息体如下：12345678910111213141516171819202122232425262728class MessageEntity : Serializable &#123; /** * 消息id */ var id: String? = null /** * 消息类型 */ var type: String? = null /** * 版本号 */ var version: Int? = null /** * 消息内容 */ var content: Any? = null /** * 额外透传信息 */ var extraData: String? = null fun toJSONString(): String &#123; return JSON.toJSONString(this) &#125;&#125; 下面来看消息解析：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116abstract class MessageParser(private val activity: VygBaseActivity, private val webView: VygWebView, private val listener: MessageParser.MessageHandedListener?) : VygWebView.JSCallback &#123; private val TAG = \"MessageParser\" override fun onReceiveWebMessage(message: String) &#123; if (StringUtils.isEmpty(message)) &#123; return &#125; if (Config.isDebug()) &#123; LogUtils.e(TAG, message) &#125; parse(message) &#125; private fun parse(message: String) &#123; Config.execute &#123; try &#123; doParse(message) &#125; catch (t: Throwable) &#123; LogUtils.e(TAG, t.localizedMessage) &#125; &#125; &#125; /** * 这个json可能很大，放到异步去处理 */ @Throws(JSONException::class) private fun doParse(message: String) &#123; val obj = JSON.parseObject(message) val type = obj.getString(\"type\") if (StringUtils.isEmpty(type)) &#123; return &#125; val version = try &#123; obj.getInteger(\"version\") &#125; catch (t: Throwable) &#123; 1 &#125; val e = getEvents(type) if (e == null) &#123; MainThreadUtils.post(Runnable &#123; if (activity.hasDestroyed()) &#123; return@Runnable &#125; if (version != null &amp;&amp; version &gt; NATIVE_WEB_VERSION) &#123; // 提示更新 notifyUpdateApp() &#125; else &#123; // 什么也不做 &#125; &#125;) return &#125; val entity = MessageEntity() entity.type = type try &#123; entity.id = obj.getString(\"id\") &#125; catch (t: Throwable) &#123; &#125; entity.version = version try &#123; entity.extraData = obj.getString(\"extraData\") &#125; catch (t: Throwable) &#123; &#125; var content: String? = null try &#123; content = obj.getString(\"content\") &#125; catch (t: Throwable) &#123; &#125; if (StringUtils.isEmpty(content) || e.clazz == null) &#123; entity.content = null &#125; else &#123; // Content 为字符串类型直接赋值 if (String::class.java.isAssignableFrom(e.clazz)) &#123; entity.content = content &#125; else &#123; try &#123; entity.content = JSON.parseObject(content, e.clazz) &#125; catch (t: Throwable) &#123; LogUtils.e(TAG, t.localizedMessage) &#125; &#125; &#125; if (activity.hasDestroyed()) &#123; return &#125; MainThreadUtils.post(Runnable &#123; if (activity.hasDestroyed()) &#123; return@Runnable &#125; MessageHandler(e, entity, activity, webView).handle() listener?.onMessageHanded(entity) &#125;) &#125; protected abstract fun getEvents(type: String): Events? /** * 提示更新app */ private fun notifyUpdateApp() &#123; &#125; interface MessageHandedListener &#123; fun onMessageHanded(message: MessageEntity) &#125;&#125; getEvents 为根据消息 type 来取得具体的消息体 Content 类型及处理消息的类：12345678910111213public final class Events &#123; public final String eventName; public final Class&lt;?&gt; clazz; public final Class&lt;? extends MessageHandler.HandleCallback&gt; callback; public Events(String name, Class&lt;?&gt; clazz, Class&lt;? extends MessageHandler.HandleCallback&gt; callback) &#123; this.eventName = name; this.clazz = clazz; this.callback = callback; &#125;&#125; 看到消息处理类：12345678910111213141516class MessageHandler(private val events: Events, private val entity: MessageEntity, private val activity: VygBaseActivity, private val webView: VygWebView) &#123; private val TAG = \"MessageHandler\" fun handle() &#123; try &#123; events.callback?.newInstance()?.handleMessage(entity, entity.content, activity, webView) &#125; catch (t: Throwable) &#123; LogUtils.e(TAG, t.localizedMessage) &#125; &#125; interface HandleCallback &#123; fun handleMessage(entity: MessageEntity, obj: Any?, activity: VygBaseActivity, webView: VygWebView) &#125;&#125; 举例一个具体的消息处理类：1234567891011121314151617181920212223242526272829class LoadImageHandler : MessageHandler.HandleCallback &#123; private val TAG = \"LoadImageHandler\" override fun handleMessage(entity: MessageEntity, obj: Any?, activity: VygBaseActivity, webView: VygWebView) &#123; if (obj != null &amp;&amp; obj is LoadImageEntity) &#123; if (UriUtils.isNetUrl(obj.url)) &#123; AsImage.downloadFile(obj.url).loadListener(object : ImageLoadListener&lt;File&gt; &#123; override fun onLoadingStarted(imageUri: String?, view: View?) &#123; LogUtils.e(TAG, \"onLoadingStarted:$imageUri\") &#125; override fun onLoadingFailed(imageUri: String?, view: View?, t: Throwable?): Boolean &#123; LogUtils.e(TAG, \"onLoadingFailed:$imageUri\") return true &#125; override fun onLoadingComplete(imageUri: String?, view: View?, loaded: File?): Boolean &#123; loaded?.let &#123; obj.uri = \"file://\" + it.absolutePath webView.sendMessageToWeb(entity.toJSONString()) &#125; return true &#125; &#125;).download() &#125; &#125; &#125;&#125; 根据修改页面的业务，定义所有的 Event：123456789101112131415161718192021222324252627282930object ArticleEvents &#123; private val events = HashMap&lt;String, Events&gt;() operator fun get(eventName: String): Events? &#123; return events[eventName] &#125; init &#123; events[HTML_FINISH_LOAD] = Events(HTML_FINISH_LOAD, null, HtmlFinishLoadHandler::class.java) events[CONTENT_FINISH_LOAD] = Events(CONTENT_FINISH_LOAD, null, ContentFinishLoadHandler::class.java) events[PROTOCOL] = Events(PROTOCOL, String::class.java, ProtocolHandler::class.java) events[PLAY_VIDEO] = Events(PLAY_VIDEO, String::class.java, PlayVideoHandler::class.java) events[IMAGE_BROWSE] = Events(IMAGE_BROWSE, String::class.java, ImageBrowseHandler::class.java) events[LOAD_IMAGE] = Events(LOAD_IMAGE, LoadImageEntity::class.java, LoadImageHandler::class.java) &#125; object EventName &#123; const val HTML_FINISH_LOAD = \"htmlFinishLoad\" // H5 加载完 const val LOAD_ARTICLE_CONTENT = \"articleContent\" // 发送 Content 给 H5 填充 const val CONTENT_FINISH_LOAD = \"contentFinishLoad\" // Content 加载完 const val UPDATE_COMMENT_COUNT = \"updateCommentCount\" // 更新回复数 const val PROTOCOL = \"ProtocolPageJump\" // 协议 const val PLAY_VIDEO = \"playVideo\" // 播放视频 const val IMAGE_BROWSE = \"imgBrowse\" // 大图浏览 const val LOAD_IMAGE = \"loadImg\" // 加载图片 &#125;&#125; 消息解析这一套流程便完成了，根据 type 找到对应的消息处理类，然后传入 Content 进行处理。 H5H5 除了界面渲染之外，还需要根据约定实现相关的方法：1234567891011121314151617getNativeData: function() &#123; var me = this; window.receiveMessage = function(data) &#123; var type = data.type; var content = data.content; if (type == 'articleContent') &#123; me.handleArticleData(content); &#125; else if (type == 'loadImg') &#123; me.handleImgData(content); &#125; else if (type == 'updateCommentCount') &#123; me.handleReplyCount(content); &#125;else if(type == 'changeOffset')&#123; me.handleUploadImg(content) &#125; &#125;&#125; 然后调用原生方法时，也是组装好 Message，然后调用 sendMessage 方法即可：123456789// 个人中心$('[data-type=\"user\"]').click(function() &#123; var uid = $(this).attr('data-uid'); var wxToken = $(this).attr('data-wxToken'); var link = `https://voyager.nav.cn/user/homePage?id=$&#123;uid&#125;&amp;wxToken=$&#123;wxToken&#125;`; var params = JSON.stringify(&#123; id: 1, type: 'ProtocolPageJump', content: link &#125;); voyagerApp.sendMessage(params);&#125;) 至此两端的交互体系大体完成。 小坑 最好使用本地 html 文件来完成交互，可以比较方便的加载本地图片，前缀加上”file://“，同时 WebView 需要设置（具体效用尚未研究）： 123settings.allowFileAccess = truesettings.allowFileAccessFromFileURLs = truesettings.allowUniversalAccessFromFileURLs = true H5 调用本地方法需要 voyager.sendMessage，iOS 则是 voyager_sendMessage。 参考 Android：最全面的 Webview 详解 Android：你要的WebView与 JS 交互方式 都在这里了 Android：你不知道的 WebView 使用漏洞","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android 获取手机媒体数据那些事","date":"2019-05-09T11:06:56.000Z","path":"2019/05/09/media/","text":"在上一篇文章 ViewModel + LiveData 初探 中的场景中，有获取手机媒体数据的操作，界面上也要展示横竖屏，展示规则很简单：宽度不小于高度则定义为横屏，否则未竖屏。在我的小米 MIX2 上，不论手机如何拍照，返回的分辨率都是 4000:3000（根据相机设置中的画幅比例），不论你是横着拍还是竖着拍。所以当拿到 4000:3000 后就全部定义成横屏了，与实际不符。所以着手解决了一下，顺便整理下获取手机媒体数据的相关代码，方便日后使用。整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195object MediaDataUtils &#123; private const val TAG = \"MediaDataUtils\" private val QUERY_URI = MediaStore.Files.getContentUri(\"external\") //=============================== 查询系统相册中的视频、图片 ================================ private const val ORDER_BY = MediaStore.MediaColumns.DATE_MODIFIED + \" DESC\" private const val SELECTION_MEDIA_TYPE_WITHOUT_FOLDER = ( MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\" + \" AND \" + MediaStore.MediaColumns.SIZE + \"&gt;0\") private const val SELECTION_MEDIA_TYPE_WITH_FOLDER = ( MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\" + \" AND \" + \" bucket_id=?\" + \" AND \" + MediaStore.MediaColumns.SIZE + \"&gt;0\") private val PROJECTION = arrayOf( MediaStore.MediaColumns._ID, MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DATE_MODIFIED, MediaStore.MediaColumns.SIZE, MediaStore.MediaColumns.WIDTH, MediaStore.MediaColumns.HEIGHT, \"duration\") //=============================== 查询系统文件夹 ================================== private const val SELECTION_MEDIA_TYPE_FOLDER = ( MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\" + \" AND \" + MediaStore.MediaColumns.SIZE + \"&gt;0\" + \") GROUP BY (bucket_id\") private const val BUCKET_ORDER_BY = \"datetaken DESC\" private val FOLDER_PROJECTION = arrayOf( MediaStore.Files.FileColumns._ID, \"bucket_id\", \"bucket_display_name\", MediaStore.MediaColumns.DATA, \"COUNT(*) AS $COLUMN_COUNT\") /** * 获取具体文件 */ @WorkerThread @JvmStatic fun getMediaData(isVideo: Boolean, folderItem: FolderItem? = null): List&lt;MediaDataItem&gt;? &#123; if (!PermissionUtils.checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; return null &#125; val data = mutableListOf&lt;MediaDataItem&gt;() val pair = getQueryArgs(false, isVideo, folderItem) val cursor = MucangConfig.getContext().contentResolver.query( QUERY_URI, PROJECTION, pair.first, pair.second, ORDER_BY) if (cursor != null) &#123; try &#123; if (cursor.moveToFirst()) &#123; val nameIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DISPLAY_NAME) val pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA) val modifyIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATE_MODIFIED) val sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE) val widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH) val heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT) val durationIndex = cursor.getColumnIndex(\"duration\") do &#123; val file = MediaDataItem() file.isVideo = isVideo file.name = cursor.getString(nameIndex) file.path = cursor.getString(pathIndex) file.date = cursor.getLong(modifyIndex) file.size = cursor.getLong(sizeIndex) file.width = cursor.getInt(widthIndex) file.height = cursor.getInt(heightIndex) if (isVideo) &#123; if (file.width == 0 || file.height == 0) &#123; val widthHeight = readVideoPixel(file.path) if (widthHeight != null) &#123; file.width = widthHeight.first file.height = widthHeight.second &#125; &#125; &#125; else &#123; val widthHeight = readImagePixel(file.path) if (widthHeight != null) &#123; file.width = widthHeight.first file.height = widthHeight.second &#125; &#125; if (durationIndex &gt; -1) &#123; file.duration = (cursor.getLong(durationIndex) / 1000F + 0.5).toLong() &#125; data.add(file) &#125; while (cursor.moveToNext()) &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; cursor.close() &#125; &#125; return data &#125; /** * 获取文件夹 */ @WorkerThread @JvmStatic fun getFolderData(isVideo: Boolean): List&lt;FolderItem&gt;? &#123; if (!PermissionUtils.checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; return null &#125; val data = mutableListOf&lt;FolderItem&gt;() val pair = getQueryArgs(true, isVideo) val cursor = MucangConfig.getContext().contentResolver.query( QUERY_URI, FOLDER_PROJECTION, pair.first, pair.second, BUCKET_ORDER_BY) if (cursor != null) &#123; try &#123; if (cursor.moveToFirst()) &#123; // 全部文件夹 val allFolder = FolderItem() allFolder.id = ALL_FOLDER_ID if (isVideo) &#123; allFolder.name = \"全部视频\" &#125; else &#123; allFolder.name = \"全部照片\" &#125; allFolder.selected = true data.add(allFolder) var count = 0 val idIndex = cursor.getColumnIndex(\"bucket_id\") val pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA) val nameIndex = cursor.getColumnIndex(\"bucket_display_name\") val countIndex = cursor.getColumnIndex(AlbumLoader.COLUMN_COUNT) do &#123; val folder = FolderItem() folder.id = cursor.getString(idIndex) folder.path = cursor.getString(pathIndex) folder.name = cursor.getString(nameIndex) folder.count = cursor.getInt(countIndex) data.add(folder) count += folder.count if (StringUtils.isEmpty(allFolder.path)) &#123; allFolder.path = folder.path &#125; &#125; while (cursor.moveToNext()) data.first().count = count &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; cursor.close() &#125; &#125; return data &#125; /** * getMediaData 时调用，根据是否视频、是否查询文件夹返回查询参数 * * @return Pair：first-&gt;selection，second-&gt;args */ private fun getQueryArgs(isQueryFolder: Boolean, isVideo: Boolean, folderItem: FolderItem? = null): Pair&lt;String, Array&lt;String&gt;&gt; &#123; if (isQueryFolder) &#123; return if (isVideo) &#123; Pair(SELECTION_MEDIA_TYPE_FOLDER, arrayOf(MEDIA_TYPE_VIDEO.toString())) &#125; else &#123; Pair(SELECTION_MEDIA_TYPE_FOLDER, arrayOf(MEDIA_TYPE_IMAGE.toString())) &#125; &#125; if (folderItem?.id != null &amp;&amp; !folderItem.isAll()) &#123; return if (isVideo) &#123; Pair(SELECTION_MEDIA_TYPE_WITH_FOLDER, arrayOf(MEDIA_TYPE_VIDEO.toString(), folderItem.id!!)) &#125; else &#123; Pair(SELECTION_MEDIA_TYPE_WITH_FOLDER, arrayOf(MEDIA_TYPE_IMAGE.toString(), folderItem.id!!)) &#125; &#125; return if (isVideo) &#123; Pair(SELECTION_MEDIA_TYPE_WITHOUT_FOLDER, arrayOf(MEDIA_TYPE_VIDEO.toString())) &#125; else &#123; Pair(SELECTION_MEDIA_TYPE_WITHOUT_FOLDER, arrayOf(MEDIA_TYPE_IMAGE.toString())) &#125; &#125;&#125; 利用我的小米 MIX2 使用 18:9 画幅比例竖屏拍摄的一张照片，在我的 Rom 里显示的是 4000:2000，将这张照片放到同事的华为手机里，显示的分辨率则是另外一个数，但是华为 Rom 里获取的高宽比例是一致的，宽：高 = 1 : 2，所以在我的手机里识别成横屏照片，在华为手机里识别为竖屏照片。所以仅仅使用 MediaStore.MediaColumns.WIDTH、MediaStore.MediaColumns.HEIGHT 获取的宽高是不准确的，需要一个更好的方案：1234567891011121314151617181920212223242526272829303132/** * 读取图片的宽高信息，系统多媒体数据库保存的宽高信息是通过读取图片 ExifInterface 数据 * 某些手机拍照生成的 exif 数据不准，此处使用 BitmapDecode 的方式获取，经测试耗时可忽略不计 */@JvmStaticprivate fun readImagePixel(filePath: String?): Pair&lt;Int, Int&gt;? &#123; if (!FileUtils.exists(filePath)) &#123; return null &#125; try &#123; val options = BitmapFactory.Options() options.inJustDecodeBounds = true BitmapFactory.decodeFile(filePath, options) val width = options.outWidth val height = options.outHeight if (width &gt; 0 &amp;&amp; height &gt; 0) &#123; val exifInterface = ExifInterface(filePath) val orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL) // 如果图片的旋转角度为 90 或者 270，则宽高互换 if (orientation == ExifInterface.ORIENTATION_ROTATE_90 || orientation == ExifInterface.ORIENTATION_ROTATE_270) &#123; return Pair(height, width) &#125; return Pair(width, height) &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.message) &#125; return null&#125; 当照片数量很多（我的手机 2200+ 张照片）时，遍历完耗时大概在 3 ~ 4 秒，在接受范围内吧。另外对于小米 MIX2 拍摄的视频数据，获取的宽高会是 0，所以也需要一种方案获取比例：12345678910111213141516171819202122232425262728293031323334/** * 读取视频的宽高数据 * 需要根据拍摄方向进行转换，有点耗时平均五六十毫秒 */@JvmStaticprivate fun readVideoPixel(filePath: String?): Pair&lt;Int, Int&gt;? &#123; if (!FileUtils.exists(filePath)) &#123; return null &#125; val mmr = MediaMetadataRetriever() try &#123; mmr.setDataSource(filePath) val width = mmr.extractMetadata(android.media.MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)?.toInt() ?: 0 val height = mmr.extractMetadata(android.media.MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)?.toInt() ?: 0 val orientation = mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION).toInt() if (width &gt; 0 &amp;&amp; height &gt; 0) &#123; if (orientation == 90 || orientation == 270) &#123; return Pair(height, width) &#125; return Pair(width, height) &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.message) &#125; finally &#123; try &#123; mmr.release() &#125; catch (e: Throwable) &#123; LogUtils.e(TAG, e.message) &#125; &#125; return null&#125; 视频数量一般比较少，耗时问题暂时可以不考虑。使用此种方案后，照片、视频的横竖问题基本准确。Over~ 题外话当手机视频、照片数量特别多了之后，一次加载全部就耗时有些久了，手机里 50 多个视频耗时 2 秒多，2000 多张照片耗时 5 秒左右，所以需要调整成为分页加载。利用 limit + offset 来实现：1val order = ORDER_BY + \" limit \" + PAGE_SIZE + \" offset \" + (page - 1) * PAGE_SIZE 有了分页就可能出现重复数据了（第一页加载完后，又拍了 2 张照片，下一页加载的数据会有 2 条重复），所以要注意去重。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"ViewModel + LiveData 初探","date":"2019-04-24T09:29:38.000Z","path":"2019/04/24/jetpack/","text":"Google 已经推出 Lifecycle、ViewModel、LiveData 等一系列架构组件已经很久了，但是自己一直没尝试使用，仅仅就是了解一点点，没有紧跟技术潮流持续学习，说来十分羞愧了。最近接到一个需求，界面如下： 突发奇想：ViewModel 可以在一个界面共享数据，感觉是做这个需求的不二选择呀，于是乎便开始使用了。 添加依赖1implementation \"android.arch.lifecycle:extensions:1.1.1\" sync 之后报错：1Android dependency 'android.arch.lifecycle:runtime' has different version for the compile (1.0.3) and runtime (1.1.1) classpath. You should manually set the same version via DependencyResolution 查看依赖，发现 support 库有依赖 runtime:1.0.3：1234| | +--- com.android.support:support-v4:27.0.2| | | +--- com.android.support:support-compat:27.0.2| | | | +--- com.android.support:support-annotations:27.0.2| | | | \\--- android.arch.lifecycle:runtime:1.0.3 所以如果要使用 1.1.1 的 extensions 则需要将 runtime:1.0.3 升到 1.1.1，如果降版本使用低版本的 extensions 也是可以的，但是就无法使用最新的特性以及问题修复了。这里说下强升的几个方法： 根 build.gradle 添加： 12345678910allprojects &#123; ... configurations &#123; all &#123; resolutionStrategy &#123; force \"android.arch.lifecycle:runtime:1.1.1\" &#125; &#125; &#125;&#125; exclude support 的依赖： 12345implementation ('com.android.support:appcompat-v7:27.1.1') &#123; exclude group: 'android.arch.lifecycle'&#125;api \"android.arch.lifecycle:runtime:1.1.1\" implementation 改成 api： 1api \"android.arch.lifecycle:extensions:1.1.1\" 注意：需要注意 runtime:1.1.1 不会与 support-v4:27.0.2 产生冲突。网上没看到有人说会不兼容，所以姑且先忽略。 Android Architecture Components: Gradle sync error for dependency version 实践注意到设计稿里，拆分一下页面结构： 顶部状态栏，可以切换视频文件夹、照片文件夹 ViewPager 切换视频或者照片 第 x 段 RecyclerView 这里可以分为三个 Fragment，主页面一个，视频、照片各位一个，所以需要在三个 Fragment 里共享数据，方便操作。这里主页面 Fragment 称为 MainFragment，素材 Fragemnt 称为 MaterialFragent。参照官网的例子，写出的 ViewModel 如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MaterialViewModel : ViewModel() &#123; // 视频数据 val videoData: MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getMediaData(true)) &#125; &#125; &#125; // 视频文件夹 val videoFolder: MutableLiveData&lt;List&lt;FolderItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;FolderItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getFolderData(true)) &#125; &#125; &#125; // 照片数据 val pictureData: MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getMediaData(false)) &#125; &#125; &#125; // 照片文件夹 val pictureFolder: MutableLiveData&lt;List&lt;FolderItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;FolderItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getFolderData(false)) &#125; &#125; &#125; /** * 获取文件夹下的视频 */ fun getFolderVideo(folderItem: FolderItem) &#123; MucangConfig.execute &#123; videoData.postValue(MediaDataUtils.getMediaData(true, folderItem)) &#125; &#125; /** * 获取文件夹下的照片 */ fun getFolderPicture(folderItem: FolderItem) &#123; MucangConfig.execute &#123; pictureData.postValue(MediaDataUtils.getMediaData(false, folderItem)) &#125; &#125;&#125; 在 MaterialFragent 里需要监听素材数据的改变，来填充列表：123456789101112private fun initViewModel() &#123; // 因为要同页面共享数据，所以需要传 activity viewModel = ViewModelProviders.of(activity!!).get(MaterialViewModel::class.java) if (isVideo) &#123; viewModel.videoData &#125; else &#123; viewModel.pictureData &#125;.observe(this, Observer&lt;List&lt;MediaDataItem&gt;&gt; &#123; // 给 RecyclerView 的 adapter 设置数据 setData(it) &#125;)&#125; 根据是否是视频，来选择不同的 LiveData 来监听。注意到有几个操作： 底部的 Rv 默认选中第一个 Item，Item 可以点击切换选择状态。当前选择的 Item 可以匹配一个素材（视频或照片） 素材列表右上角的选择点击之后，则将素材与底部 Rv 当前选中的 Item 进行匹配，并且选中的素材下面出现红色条，代表当前素材已匹配到某一个 Item，若当前 Item 已匹配过素材，则进行替换，所以如果匹配过，则需要将旧的素材下面的红色条置为 GONE。同时 Rv 切换到下一个可选择素材的 Item（没有匹配过素材的 Item），最直观的感受就是绿色边框的切换。 当底部 Rv 所有素材全部匹配完之后，下面的选择完成按钮变成可点击。 针对以上几点，又新增了几个 LiveData：1234567891011121314// 当前给哪个 Item 选择素材lateinit var currentSegment: Segment/** * 同一个 Item 有重复选择视频或者照片，需要记录上一次选择的位置，用于更新界面取消选中 * * Pair：first-&gt;上一次选择的是否是视频，second-&gt;上一次选中的位置 */val changePos: MutableLiveData&lt;Pair&lt;Boolean, Int&gt;&gt; = MutableLiveData()/** * 当前的 Item 选择素材之后，需要更新背景图 */var currentPos: MutableLiveData&lt;Int&gt; = MutableLiveData() 在匹配一个 Item 之后，ViewModel 更新数据：12345678910111213141516171819202122232425/** * 填充模板 Item 选择的素材 */fun fillSegment(mediaDataItem: MediaDataItem) &#123; if (mediaDataItem == currentSegment.mediaDataItem) &#123; return &#125; if (currentSegment.mediaDataItem == null) &#123; currentSegment.mediaDataItem = mediaDataItem changePos.value = Pair(true, -1) &#125; else &#123; val currentMedia = currentSegment.mediaDataItem!! currentMedia.selected = false val index = if (currentMedia.isVideo) &#123; videoData.value?.indexOf(currentMedia) &#125; else &#123; pictureData.value?.indexOf(currentMedia) &#125; currentSegment.mediaDataItem = mediaDataItem changePos.value = Pair(currentMedia.isVideo, index ?: -1) &#125; currentPos.value = templateData.value?.video?.segments?.indexOf(currentSegment)&#125; 在 MainFragment 里监听 currentPos 数据的变化：1234567891011121314viewModel.currentPos.observe(this, Observer &#123; if (it != null &amp;&amp; it &gt; -1) &#123; val index = (segmentRv.adapter as SegmentAdapter).cycleValidIndex(it) // 没有未完成的 Segment 时可点击完成 if (index == -1) &#123; chooseCompleteTv.alpha = 1F chooseCompleteTv.isClickable = true &#125; else &#123; segmentRv.smoothScrollToPosition(index) chooseCompleteTv.alpha = 0.3F chooseCompleteTv.isClickable = false &#125; &#125;&#125;) SegmentAdapter 的方法 cycleValidIndex 自动循环下一个需要匹配素材的的 Item，当返回 -1 时代表所有 Item 都已经匹配素材，这时可以针对单一 Item 进行素材调整，不用做 index 自动循环了。1234567891011121314151617181920212223242526272829303132333435363738/** * 当前选中的 index，自动切换到下一个可用的 index */fun cycleValidIndex(pos: Int): Int &#123; var nextIndex = -1 run findIndex@&#123; val index = pos + 1 if (index &lt; dataList.lastIndex) &#123; for (i in index until dataList.size) &#123; if (dataList[i].mediaDataItem == null) &#123; nextIndex = i return@findIndex &#125; &#125; for (i in 0 until index) &#123; if (dataList[i].mediaDataItem == null) &#123; nextIndex = i return@findIndex &#125; &#125; &#125; else &#123; for (i in 0 until dataList.size) &#123; if (dataList[i].mediaDataItem == null) &#123; nextIndex = i return@findIndex &#125; &#125; &#125; &#125; if (nextIndex == -1) &#123; notifyItemChanged(pos) &#125; // 切换选择状态 chooseSegment(nextIndex) return nextIndex&#125; 在 MaterialFragment 监听上一个需要取消红色条的 LiveData：12345viewModel.changePos.observe(this, Observer &#123; if (it != null &amp;&amp; it.first == isVideo &amp;&amp; it.second &gt; -1) &#123; materialRv.adapter?.notifyItemChanged(it.second) &#125;&#125;) ok，实践就说到这里，基本实现需求了。 ViewModel 原理ViewModel 不会随着 Activity 的屏幕旋转而销毁，减少了维护状态的代码成本。另外，它可以在多个 Fragment 维护相同的数据，极大的减少了组件之间数据传递的代码成本。那么它是如何实现的呢？在说原理之前，需要了解一个知识点： setRetainInstance(boolean) 是 Fragment 中的一个方法。将这个方法设置为 true 就可以使当前 Fragment 在 Activity 重建时存活下来。 现在相信已经对原理的实现有自己的思路了：让 Activity 持有一个不可见的 Fragment(HolderFragment)，并让这个 HolderFragment 调用 setRetainInstance(boolean) 方法并持有 ViewModel ——这样当 Activity 因为屏幕的旋转销毁并重建时，该 Fragment 存储的 ViewModel 自然不会被随之销毁回收了。另外一个 Fragment 或者 Activity 是有可能持有多个 ViewModel 的，所以内部需要一个 HashMap 进行存储所有的 ViewModel。123456789101112131415161718192021@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public class HolderFragment extends Fragment implements ViewModelStoreOwner &#123; private ViewModelStore mViewModelStore = new ViewModelStore(); public HolderFragment() &#123; setRetainInstance(true); &#125;&#125;public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125;&#125; 看到相应的代码，是不是一目了然？然后看到 ViewModel 只会有一个实例的代码：1234567891011121314151617181920@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 如果 mViewModelStore 里存有 ViewModel 实例则直接返回，没有则进行 create，然后 put 到 mViewModelStore 中，很直截了当了。 总结篇幅所限，关于 LiveData 这里就不写了，核心原理是 LifeCycleOwner，这个网上的相关文章也挺多的。 参考： ViewModel OverView LiveData Overview Android官方架构组件ViewModel:从前世今生到追本溯源 Android Architecture Component之LiveData原理解析","tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://lijia92.github.io/tags/Jetpack/"}]},{"title":"CoordinatorLayout 滑动再探","date":"2019-04-16T06:11:55.000Z","path":"2019/04/16/coordinator-1/","text":"嗯，还是之前的路线详情的页面，新增了需求，导致界面结构又发生变化了。添加了一个途经点的列表，与打点列表并列，可以和横向滑动切换 Tab。之前写过一篇文章CoordinatorLayout + RecyclerView 处理滑动说的也是这个页面，这里再贴一下当前的 xml 布局： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/vyg__route_detail_map_action\"/&gt; &lt;cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout android:id=\"@+id/unFullScreenRoot\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"50dp\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/barLayout\" android:layout_width=\"match_parent\" android:layout_height=\"330dp\" android:background=\"@color/vyg__transparent\" app:elevation=\"0dp\"&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;cn.mucang.android.ui.widget.xrecyclerview.SafeRecyclerView android:id=\"@+id/detailRv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;/cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout&gt; &lt;include layout=\"@layout/vyg__route_detail_fullscreen\"/&gt; &lt;include layout=\"@layout/vyg__route_detail_title\"/&gt; &lt;include layout=\"@layout/vyg__route_detail_bottom\"/&gt;&lt;/RelativeLayout&gt; 基于这个布局，为了实现新增需求，改成了如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/vyg__route_detail_map_action\"/&gt; &lt;cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout android:id=\"@+id/unFullScreenRoot\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"50dp\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/barLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/vyg__transparent\" app:elevation=\"0dp\"&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"330dp\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;android.support.v4.widget.NestedScrollView android:id=\"@+id/headerContainer\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;cn.mucang.android.voyager.lib.framework.tab.CustomTabLayout android:id=\"@+id/tabLayout\" android:layout_width=\"match_parent\" android:layout_height=\"65dp\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.SafeViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;/cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout&gt; &lt;include layout=\"@layout/vyg__route_detail_fullscreen\"/&gt; &lt;include layout=\"@layout/vyg__route_detail_title\"/&gt; &lt;include layout=\"@layout/vyg__route_detail_bottom\"/&gt;&lt;/RelativeLayout&gt; 将旧布局中的路线详情 Header 单独抽出个布局，添加到 headerContainer 中。这里使用 NestedScrollView 进行包裹是因为 MyCoordinatorLayout 拦截了 onTouchEvent 始终返回 false，MyCoordinatorLayout 就只能处理自身实现了 NestedScrollingChild2 的 View 了，tabLayout 则是 Tab 栏。嗯，这样功能是能实现了，但是在这界面进行滑动的时候，总会感觉不流畅，而且在快速滑动的时候，还容易反弹。这是很好理解的，因为 MyCoordinatorLayout 重写 onTouchEvent 并且始终返回 false，可能就会导致事件的传递有问题，造成这种滑动不顺的感觉。那如果不使用 MyCoordinatorLayout，地图上按钮的点击事件如何传递下去呢？这就得想另外一个法子了。CoordinatorLayout 本身是一个增强型的 FrameLayout，增加了嵌套滑动的处理。所以另一种方式的布局就出来了：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_above=\"@+id/bottomActionLl\"&gt; &lt;include layout=\"@layout/vyg__route_detail_map_action\"/&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout android:id=\"@+id/barLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/vyg__transparent\" app:elevation=\"0dp\" app:layout_behavior=\"cn.mucang.android.voyager.lib.framework.widget.SnapAppBarLayoutBehavior\"&gt; &lt;View android:id=\"@+id/mapFakeView\" android:layout_width=\"match_parent\" android:layout_height=\"330dp\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;LinearLayout android:id=\"@+id/headerContainer\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:clickable=\"true\" android:orientation=\"vertical\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;cn.mucang.android.voyager.lib.framework.tab.CustomTabLayout android:id=\"@+id/tabLayout\" android:layout_width=\"match_parent\" android:layout_height=\"65dp\"/&gt; &lt;/cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.SafeViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;include layout=\"@layout/vyg__route_detail_fullscreen\"/&gt; &lt;include layout=\"@layout/vyg__route_detail_title\"/&gt; &lt;include layout=\"@layout/vyg__route_detail_bottom\"/&gt;&lt;/RelativeLayout&gt; 将地图布局直接被 CoordinatorLayout 包裹，弃用 MyCoordinatorLayout。当页面处于非全屏时，设置 mapFakeView 的 isClickable 为 false。那么 AppBarLayout 便不会消费地图上按钮的点击事件，事件就会传递到地图那一层进行处理了。在使用 CoordinatorLayout + AppBarLayout 时，会有一些滑动抖动的问题，和 AppBarLayout 无法拖动的问题，这些在网上都有案例。所以会有自定义的 AppBarLayout、Behavior：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * 解决 AppBarLayout 滑动抖动问题 */public class SnapAppBarLayoutBehavior extends AppBarLayout.Behavior &#123; private boolean isNestedFlinging = true; private boolean isFlinging; private boolean shouldBlockNestedScroll; public SnapAppBarLayoutBehavior() &#123; &#125; public SnapAppBarLayoutBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull AppBarLayout child, @NonNull View target, float velocityX, float velocityY) &#123; return false; &#125; @Override public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, AppBarLayout abl, View target, int type) &#123; if (!isNestedFlinging) &#123; super.onStopNestedScroll(coordinatorLayout, abl, target, ViewCompat.TYPE_NON_TOUCH); &#125; else &#123; if (type == ViewCompat.TYPE_TOUCH) &#123; super.onStopNestedScroll(coordinatorLayout, abl, target, ViewCompat.TYPE_NON_TOUCH); &#125; else &#123; super.onStopNestedScroll(coordinatorLayout, abl, target, ViewCompat.TYPE_TOUCH); &#125; &#125; isFlinging = false; shouldBlockNestedScroll = false; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, int dx, int dy, int[] consumed, int type) &#123; if (type == ViewCompat.TYPE_TOUCH) &#123; isNestedFlinging = false; &#125; if (type == ViewCompat.TYPE_NON_TOUCH) &#123; isFlinging = true; &#125; if (!shouldBlockNestedScroll) &#123; super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type); &#125; &#125; @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type) &#123; if (!shouldBlockNestedScroll) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, type); &#125; &#125; @Override public boolean onNestedFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull AppBarLayout child, @NonNull View target, float velocityX, float velocityY, boolean consumed) &#123; isNestedFlinging = true; return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed); &#125; @Override public boolean onInterceptTouchEvent(CoordinatorLayout parent, AppBarLayout child, MotionEvent ev) &#123; shouldBlockNestedScroll = false; if (isFlinging) &#123; shouldBlockNestedScroll = true; &#125; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; Object scroller = getSuperSuperField(this, \"mScroller\"); if (scroller != null &amp;&amp; scroller instanceof OverScroller) &#123; OverScroller overScroller = (OverScroller) scroller; overScroller.abortAnimation(); &#125; &#125; return super.onInterceptTouchEvent(parent, child, ev); &#125; private Object getSuperSuperField(Object paramClass, String paramString) &#123; Field field = null; Object object = null; try &#123; field = paramClass.getClass().getSuperclass().getSuperclass().getDeclaredField(paramString); field.setAccessible(true); object = field.get(paramClass); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125;/** * 解决 AppBarLayout 无法滚动的问题 */ class NestAppBarLayout : AppBarLayout &#123; constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet) : super(context, attrs) override fun onAttachedToWindow() &#123; super.onAttachedToWindow() compactAppbarNestScroll() &#125; private fun compactAppbarNestScroll() &#123; try &#123; ((this.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior as? AppBarLayout.Behavior) ?.setDragCallback(object : AppBarLayout.Behavior.DragCallback() &#123; override fun canDrag(appBarLayout: AppBarLayout): Boolean &#123; return true &#125; &#125;) &#125; catch (e: Exception) &#123; LogUtils.d(\"NestAppBarLayout\", e.message) &#125; &#125;&#125; 但是仍然有一个问题：当点击地图全屏按钮时，隐藏 barLayout 与 viewPager，只剩下 CoordinatorLayout 包裹一层地图。这个时候滑动地图下面可以滑动流畅，但是滑动上面被 AppBarLayout 盖住的一部分（即使不可见）则不流畅。然后监听 AppBarLayout 的 addOnOffsetChangedListener 方法会发现有回调。也就是说，即使 AppBarLayout 即使是 GONE，但是它仍然在消费触摸事件，这很令人费解。但是转念一想，好像也不无道理。CoordinatorLayout 是结合 Behavior 来进行处理嵌套滑动的，说明 Behavior 是具有事件处理能力的，在 Behavior 内没有对 View 是否可见进行控制则显得没那么重要了。这里看到 Behavior 中有一个是否可拖动的 Callback：123456789101112131415/** * Callback to allow control over any &#123;@link AppBarLayout&#125; dragging. */public static abstract class DragCallback &#123; /** * Allows control over whether the given &#123;@link AppBarLayout&#125; can be dragged or not. * * &lt;p&gt;Dragging is defined as a direct touch on the AppBarLayout with movement. This * call does not affect any nested scrolling.&lt;/p&gt; * * @return true if we are in a position to scroll the AppBarLayout via a drag, false * if not. */ public abstract boolean canDrag(@NonNull AppBarLayout appBarLayout);&#125; 想来 NestAppBarLayout 里设置 canDrag 一直返回 true 是为了解决 AppBarLayout 无法拖动的问题了，所以要解决我现在的问题就很简单了：123456789101112private fun compactAppbarNestScroll() &#123; try &#123; ((this.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior as? AppBarLayout.Behavior) ?.setDragCallback(object : AppBarLayout.Behavior.DragCallback() &#123; override fun canDrag(appBarLayout: AppBarLayout): Boolean &#123; return appBarLayout.visibility == View.VISIBLE &#125; &#125;) &#125; catch (e: Exception) &#123; LogUtils.d(\"NestAppBarLayout\", e.message) &#125;&#125; 当 AppBarLayout 不可见时，当然是不能拖动的了。至此，整个页面的滑动又如丝般顺滑了~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android 滑动吸顶效果","date":"2019-03-12T06:06:58.000Z","path":"2019/03/12/scroll/","text":"啥也不说，先上个图：往上滑动的时候，有两点： 透明度渐变显示个人主页标题栏，这个是覆盖在最上层的标题栏 当 Tab 栏滑动到主页下面时，固定不动了，下面的布局继续滑动 看下布局：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:clickable=\"true\" android:focusable=\"true\"&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout android:id=\"@+id/barLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" app:elevation=\"0dp\" app:layout_behavior=\"cn.mucang.android.voyager.lib.framework.widget.SnapAppBarLayoutBehavior\"&gt; &lt;!-- 用户头像、简介 --&gt; &lt;include layout=\"@layout/profile_fragment_header\"/&gt; &lt;!-- Tab 栏 --&gt; &lt;include layout=\"@layout/ucenter_fragment_tab\"/&gt; &lt;/cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;LinearLayout android:id=\"@+id/titleLl\" android:layout_width=\"match_parent\" android:layout_height=\"72dp\" android:background=\"@color/vyg__transparent\" android:clickable=\"true\" android:gravity=\"center_vertical\" android:paddingTop=\"24dp\"&gt; &lt;ImageView android:id=\"@+id/backIv\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" android:layout_marginLeft=\"12dp\" android:paddingLeft=\"6dp\" android:src=\"@drawable/vyg__icon_back\"/&gt; &lt;TextView android:id=\"@+id/titleTv\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"16dp\" android:layout_marginRight=\"16dp\" android:layout_weight=\"1\" android:ellipsize=\"end\" android:gravity=\"center\" android:singleLine=\"true\" android:textColor=\"@color/vyg__transparent\" android:textSize=\"18sp\"/&gt; &lt;Space android:layout_width=\"32dp\" android:layout_height=\"32dp\" android:layout_marginRight=\"12dp\"/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; profile layout 的根布局有设置：1app:layout_scrollFlags=\"scroll\" 使其能跟着界面一起滑动，那下面的 Tab 栏需要在滑动到标题栏下面的时候停止滑动，吸附在上面。如果没有标题栏，就不会有这篇文章了。加上标题栏之后，相当于：往上滑动，scroll 的布局滑出界面，然后 Tab 栏滑动到距离顶部一个标题栏的高度后固定不动，如果拿去标题栏，应该是还能看到一部分 scroll 布局的内容的。也就是说需要固定的布局距离顶部有一段距离。起初想着这种需求能否利用 CoordinatorLayout、layout_scrollFlags 来实现，但是找了找，并没有发现类似功能的 Api。后面突发奇想：AppBarLayout 里面包裹了两个布局，给下面的 Tab 栏布局设置个 marginTop，这样应该就可以距离顶部一段距离了，然后给上面的距离设置个负数的 marginBottom，一正一负正好抵消，或许有作用？想没用，直接上代码：1234// 距离顶部的高度为 状态栏的高度 + 标题栏的高度（固定 48dp）val titleHeight = statusBarHeight + DimenUtils.dp2px(48F)(profileHeaderRl.layoutParams as AppBarLayout.LayoutParams).bottomMargin = -titleHeight(userHomeTabScroll.layoutParams as AppBarLayout.LayoutParams).topMargin = titleHeight 然后试了一下效果，还真有用！因缺思厅！","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"记录微信分享的一个坑","date":"2019-03-05T09:47:01.000Z","path":"2019/03/05/wechat-tip/","text":"今天碰到一个问题，社区里帖子有的可以分享到微信，有的不行，单独调试获取分享的数据，发现并无不同。生成分享数据的代码如下：1234567891011WXMediaMessage mediaMessage = new WXMediaMessage(programObject);mediaMessage.title = shareData.getTitle();mediaMessage.description = shareData.getContent();mediaMessage.thumbData = Utils.readMiniProgramThumbImageFileData(shareData.getShareImagePath());//发送请求SendMessageToWX.Req req = new SendMessageToWX.Req();req.transaction = String.valueOf(listenerId);req.message = mediaMessage;// 目前支持会话req.scene = SendMessageToWX.Req.WXSceneSession;doSendReq(req); shareData 是客户端单独组织的一个 Model。起初怀疑是 thumbData 太大导致的，结果后面可以分享的帖子生成的 thumbData 所占的字节还要大一些。。。然后试着分享到微博、QQ 等其他平台，发现也可以分享成功，唯独微信分享给朋友或朋友圈不行。偶然的发现一个帖子分享到微博也会失败，而微博客户端给出了“内容不符合规范”类似大意的提示，于是猜测可能是 description 导致。于是分别调试了不同帖子的数据，发现不能分享的帖子生成的 description length 都是 2000+，而可以分享的帖子生成的才 1000+，没有超过 2000，于是预测是 description 超长导致的。最后调试进行截取，超长的则取前 100 个字符，发现问题解决。问题比较简单，但是调试的时候很坑，因为分享失败的帖子竟然连 WxEntryActivity 里的 onResp 都不回调，所以压根无法知道失败的原因，只能对比数据靠猜测，于是便记录一下，以后碰到这类问题便知道如何解决了。总结一下：微信分享传的 description 参数不能过长（测试 1800 以下是可以分享的），否则会分享失败，而且回调里的 onResp 都不会调用。","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"最近的几点感悟","date":"2019-02-27T02:14:14.000Z","path":"2019/02/27/feeling/","text":"一直有读公众号的习惯，关注了 MacTalk、Fenng、王信文等一些大咖，也读过不少文章，有一些还是蛮有感慨的，希望自己能每天变得更好一点。 抽纸办公桌上的抽纸用完了，打算自己再带一份来（公司发的会在瞬间被员工抢光，实在抢不过…）。但是我没有背包上班的需求，每天都是赤手空空的，单独拿一抽纸走在路上会感觉很奇怪。于是我下意识的是找我们的产品（和他关系还不错，他每天背包带电脑上下班）让他帮我带一份，钱微信转给他。当我准备这样做的时候，我发现我不知道怎么开口，“你家抽纸多少钱一份？”、“你帮我带一份抽纸吧？”，想想就感觉好智障啊，还好我没有这样做。没有背包上班的习惯，就挑一天背个包上班，带上抽纸，有什么难的吗？并不难。麻烦吗？也并不麻烦，背个包而已。可为什么我会下意识的先让别人来帮我，现在想想还挺可怕的。力所能及的事情就不要麻烦别人了，即使对别人来说就是举手之劳，但是这可能会消费你的「社会信用」。 任务分配项目组三个开发，需求下来时会评估需求及时间，然后分配任务。在之前我都是会选“知道怎么做的任务”，因为害怕完不成拖进度，拿 C 评级。但是这样久了连我自己都觉得厌烦了。“又要做xxx详情页，真没意思”，自己都厌烦了，都觉得无聊了，为什么还不愿意改变一下呢？每天重复同样的工作有什么意义呢？最近的几个版本迭代，我开始挑选自己没做过的，觉得有挑战性的任务了。对自己有信心，即使接到任务的时候无从下手，但是随着慢慢摸索，总能找到对的路。碰到问题就去解决，不知道怎么解决就 Google，你得相信你做的事情总会有人也在做。永远挑选高于自身水平一点的任务去做，这样才能进步。当然，不能太高，那会打击自己的自信心。 阅读理解和刚认识的朋友聊天，谈到自己的上班作息。聊天记录是这样： ：那早上一般几点上班？：8点半：我们9点到9点半，不过我下班肯定比你晚，你几点下班？：我们五点半，我们一天上7个小时：我们8个小时，吃饭加午休，一个半小时，一般都是7 8点才下班：你不是说到九点半 听到九点半后，我有点诧异，没有立即回复，于是我往上拉查看聊天记录，发现确实有一句话会产生这样的歧义：我们9点到9点半。正常来看本身就可以有两种理解： 上班的时间是9点到9点半，弹性半小时 上下班的时间是早上9点到晚上9点半 其实结合上下文可以理解为我表述的意思应该是第一种理解。可是，一万个读者有一万个哈姆雷特，你无法知道他人的想法是什么样的。即使是面对一部电梯，有的人也会认为按钮的功能是“让电梯上或者下”，而有的人会认为是表达“我想上或者我想下”。当然，这个电梯问题有正确答案：当你在电梯最底下一层时，是没有向下的按钮的。但是大多数情景都是没有正确答案的，因为每个人的经历不同，想法不同。最后我回复了两句： ：早上上班时间最晚是九点半，最早九点：不是早上9点到晚上9点半，我没说清楚 这放在之前，我可能就会觉得对方怎么这么“蠢”，哈哈哈有点自大。写到这里，我又想起来之前的一个事情。 人物：A 和他女朋友 A’，A 的同学 B。事情：A’ 对 A 说想和闺蜜一起看一部电影，叫啥来着忘了，然后 A 把这事告诉了 B，B 说：这个电影国外上映了的，网上有资源，不是什么大片，可以就网上看。然后 A 把 B 的话转述给了 A’，然后 A’ 表示可以，然后问 A 要电影。于是 B 给 A 发了一个电影的下载链接，A 转发给 A’，然后 A’ 就生气了。生气的理由就是：我要的是电影啊，你给我一个下载链接我怎么看？ 这个事情刚发生的时候我觉得很不可思议，但是现在我慢慢的接受并理解。每个人的生活轨迹不同，所受的教育也不同，每个人都是独特的，世上没有完全一样的树叶，你的想法在别人看来未必就是对的。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"Android 动画序列的实现","date":"2019-02-02T06:19:14.000Z","path":"2019/02/02/animation/","text":"老规矩，上需求：这个 Gif 里有众多的动画效果，怎么实现呢？ 拆分效果整体的动画效果大致可以分为 3 个： 右上角小车移动的动画 图片缩放动画及文字展示的动画 左侧 Logo 及底部文字的动画 拆分完之后，依次来实现。 小车轨迹动画项目基于高德地图，小车绘制的路线必须是实际路线的样子，然后车头还要跟着路线进行旋转，里面的细节还是挺多的。 如何绘制路线？使用高德自带的 Api 很难实现这样的效果，所以采取的方案是：利用高德地图绘制出路线，然后将路线中的 GPS 点映射成为屏幕中的坐标点，这些坐标点是基于 Android 手机屏幕的，所以可以直接传入到 Path 中，然后利用 Path 进行绘制，这样绘制出来的图形遍与真实的路线一致了。 小车如何移动旋转？小车的移动显然与路线的绘制保持一致，小车的中心点即是路线最新画出来的点。至于角度，则是根据前面 N 个点的平均点，与后面 N 个点的平均点进行连线所形成的的夹角来得到。1234567891011121314151617181920val pastCenter = Point() // 过去 N 个点的平均点var totalX = 0var totalY = 0for (index in startIndex..newIndex) &#123; totalX += traceDataList!![index].x totalY += traceDataList!![index].y&#125;pastCenter.x = totalX / (newIndex - startIndex + 1)pastCenter.y = totalY / (newIndex - startIndex + 1)val lastCenter = Point() // 未来 N 个点的平均点totalX = 0totalY = 0for (index in newIndex..endIndex) &#123; totalX += traceDataList!![index].x totalY += traceDataList!![index].y&#125;lastCenter.x = totalX / (endIndex - newIndex + 1)lastCenter.y = totalY / (endIndex - newIndex + 1)val angle = (lastCenter.y - pastCenter.y).toFloat() / (lastCenter.x - pastCenter.x) 求得角度之后，将其转化为 Canvas 使用的角度进行绘制小车 Bitmap 即可。 图片缩放动画，文字展示的动画Gif 演示图中有 5 张图片，对应了 5 个文字展示动画。 第一张图对应里程、时间动画。 第二张图对应速度、海拔动画。 第三、四张图对应描述文字动画。 第五张图对应推广文字动画。 将每张图的动画仔细拆分： 第一张图：里程文字 alpha 渐变 -&gt; 里程数据从右往左展示 -&gt; 时间文字 alpha 渐变 -&gt; 时间数据从右往左展示。 第二张图：速度文字从上往下展示 -&gt; 速度数据从左往右展示 -&gt; 海拔文字从上往下展示 -&gt; 海拔数据从左往右展示。 第三、四张图：整体从左往右逐渐揭露展示。 第五张图：整体 alpha 渐变。 那么如何将这么些动画组织起来呢？它就像事件流一样，1 执行完了执行 2，2 执行完了执行 3。。。Android View 提供一个 animate() 方法，它会返回一个 ViewPropertyAnimator 对象，它提供了很多动画方法进行调用，并且有点像建造者模式，可以链式调用，最后写起来就像这样：12345678910111213141516171819202122232425262728293031323334/** * 展示里程、时间动画 */private fun startFirstPageAnimation() &#123; firstView.distanceLl.animate() .alphaBy(0F) .alpha(1F) .withEndAction &#123; firstView.distanceTv.animate() .translationXBy(firstView.distanceTv.measuredWidth.toFloat()) .translationX(0F) .withEndAction &#123; firstView.timeLl.animate() .alphaBy(0F) .alpha(1F) .withEndAction &#123; firstView.timeTv.animate() .translationXBy(firstView.timeTv.measuredWidth.toFloat()) .translationX(0F) .withEndAction &#123; hideView(firstView) &#125; .setDuration(240L) .start() &#125; .setDuration(240L) .start() &#125; .setDuration(240L) .start() &#125; .setDuration(240L) .start()&#125; 顺带贴一下 firstView 的布局：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout android:id=\"@+id/firstAnimationRoot\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"right|bottom\" android:layout_marginBottom=\"24dp\" android:layout_marginRight=\"24dp\" android:gravity=\"right\" android:orientation=\"vertical\" tools:background=\"#c000ffff\"&gt; &lt;LinearLayout android:id=\"@+id/distanceLl\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center_vertical\"&gt; &lt;View android:layout_width=\"24dp\" android:layout_height=\"1dp\" android:background=\"@color/vyg__white\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"4dp\" android:text=\"总里程\" android:textColor=\"@color/vyg__white\" android:textSize=\"8sp\"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/distanceTv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"@color/vyg__white\" android:textSize=\"22sp\" tools:text=\"8765KM\"/&gt; &lt;LinearLayout android:id=\"@+id/timeLl\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"14dp\" android:gravity=\"center_vertical\"&gt; &lt;View android:layout_width=\"24dp\" android:layout_height=\"1dp\" android:background=\"@color/vyg__white\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"4dp\" android:text=\"总时间\" android:textColor=\"@color/vyg__white\" android:textSize=\"8sp\"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/timeTv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"@color/vyg__white\" android:textSize=\"12sp\" tools:text=\"01:23:89\"/&gt;&lt;/LinearLayout&gt; 利用 withEndAction 方法很方便的在动画结束后执行某个操作，而不用加监听。但是这样动画多了就会产生「回调地狱」，看起来不太舒服…但是也没想到其他好的方法，姑且只能这样了。第二张图动画代码也和这个类似就不帖了。看下第三张揭露动画：12345678910111213141516171819202122232425/** * 展示文字描述动画 */private fun startDescPageAnimation(view: View) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; val animator = ViewAnimationUtils.createCircularReveal(view, 0, 0, 0F, DimenUtils.dp2px(240F).toFloat()) animator.duration = 160L animator.start() animator.removeAllListeners() animator.addListener(object : AnimatorListenerAdapter() &#123; override fun onAnimationEnd(animation: Animator?) &#123; hideView(view) &#125; &#125;) &#125; else &#123; view.animate() .alphaBy(0F) .alpha(1F) .withEndAction &#123; hideView(view) &#125; .setDuration(160L) .start() &#125;&#125; 直接使用的 createCircularReveal 来创建动画，若是在 5.0 以下，则直接展示个 alpha 渐变动画。最后一张图的动画就是 alpha 渐变，也没啥好说的。 ok，每一页的动画都准备好了，如何将他们组织起来呢？首先，需要将每一页元素添加到界面上进行展示。如果需求是固定的 5 组图文，可以直接将布局写死到代码里，可是数量不是固定的。图片是根据路线的数据来取的。 如果没有图片，则返回默认三张图，并展示 1、2、5 对应的文本动画。 如果只有一张或三张，则使用返回的图片，并展示 1、2、5 对应的文本动画。 如果只有两张，则使用返回的图片，并展示 1、2 对应的文本动画。 如果有大于三张，则使用返回的图片，固定展示 1、2、5 的文本动画，多的图片展示 3、4 的动画。 所以：图片的数量和下面展示的文本数量并不是一致的，要将图片动画和文本动画拆开。为了统一控制，最好保持一个动画触发入口。再看到 Gif 图，基本上文本动画执行完准备消失时，图片动画开始。所以我的做法是：统一一个入口，管理文本动画，当文本动画要消失时，触发图片动画。若数量不对应，则不执行图片动画。下面贴代码： 图片容器添加所有的图片 12345678910111213141516/** * 填充图片内容 */private fun fillPicContent(picList: MutableList&lt;Any&gt;) &#123; picContainer.removeAllViews() picList.forEach &#123; val imageView = ImageView(context) imageView.scaleType = ImageView.ScaleType.CENTER_CROP if (it is VygImage) &#123; AsImage.show(it.detail).into(imageView) &#125; else &#123; AsImage.show(it).into(imageView) &#125; picContainer.addView(imageView, 0) &#125;&#125; 文本容器添加所有的文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 填充文本内容 */private fun fillTextContent(route: VygRoute, picList: MutableList&lt;Any&gt;) &#123; firstView.timeTv.text = route.showTime firstView.distanceTv.setTextWithEmpty(route.distance / 1000.00, \"%.1fkm\") secondView.speedTv.setTextWithEmpty(route.avgSpeed.toDouble(), \"%.1fkm/h\") secondView.altTv.setTextWithEmpty(route.maxAlt, \"%.0fm\") textContainer.removeAllViews() textContainer.addView(firstView, 0) textContainer.addView(secondView, 0) val picSize = picList.size /* * 1 张或 3 张图片，展示 1、2、5 的样式 * 2 张，，展示 1、2 的样式 * 4 张或以上，固定展示 1、2、5，中间 3、4 展示图片打点描述的样式 */ if (picSize == 1 || picSize == 3) &#123; showTime = (BASE_DURATION - LAST_PAGE_DURATION - 2 * HIDE_DURATION) / 3 textContainer.addView(lastView, 0) &#125; else if (picSize == 4) &#123; showTime = (BASE_DURATION - LAST_PAGE_DURATION - DESC_PAGE_DURATION - 3 * HIDE_DURATION) / 4 val desc = LayoutInflater.from(context).inflate(R.layout.vyg__route_video_share_desc_page, textContainer, false) textContainer.addView(desc, 0) textContainer.addView(lastView, 0) setPointDesc(picList, 2, desc, route) &#125; else if (picSize == 5) &#123; showTime = (BASE_DURATION - LAST_PAGE_DURATION - DESC_PAGE_DURATION * 2 - 4 * HIDE_DURATION) / 5 val desc1 = LayoutInflater.from(context).inflate(R.layout.vyg__route_video_share_desc_page, textContainer, false) val desc2 = LayoutInflater.from(context).inflate(R.layout.vyg__route_video_share_desc_page, textContainer, false) textContainer.addView(desc1, 0) textContainer.addView(desc2, 0) textContainer.addView(lastView, 0) setPointDesc(picList, 2, desc1, route) setPointDesc(picList, 3, desc2, route) &#125; else &#123; showTime = (BASE_DURATION - HIDE_DURATION) / 2 &#125;&#125; showTime 为文本动画执行完之后的展示时间，因为动画总时长为 10 秒，文本内容越多，每个文本展示的时间就越短，所以需要计算 showTime，展示时间到了之后就进行隐藏：123456789101112131415161718192021/** * 展示隐藏动画 */private fun hideView(view: View) &#123; handler.postDelayed(&#123; if (!isPlaying) &#123; return@postDelayed &#125; showPicAnimation() view.animate() .alphaBy(1F) .alpha(0F) .setDuration(600L) .withEndAction &#123; textAnimationIndex-- startAnimation() &#125; .start() &#125;, showTime)&#125; 隐藏的时候触发图片动画：123456789101112131415161718192021222324/** * 展示图片缩放动画 */private fun showPicAnimation() &#123; picAnimationIndex-- if (picAnimationIndex == 0) &#123; return &#125; val view = picContainer.getChildAt(picAnimationIndex) view?.let &#123; it.pivotX = 0F it.pivotY = picContainer.measuredHeight / 2F it.animate() .scaleXBy(1F) .scaleX(0F) .scaleYBy(1F) .scaleY(0F) .alphaBy(1F) .alpha(0F) .setDuration(HIDE_DURATION) .start() &#125;&#125; textAnimationIndex 为当前展示文本动画的 index，picAnimationIndex 为当前展示图片动画的 index。然后提供一个入口，触发所有的动画：1234567891011121314151617181920212223242526272829303132333435363738394041/** * 播放动画 */fun play() &#123; isPlaying = true picAnimationIndex = picContainer.childCount textAnimationIndex = textContainer.childCount - 1 resetAnimationStatus() startLeftAnimation() startAnimation()&#125;/** * 开始动画 */private fun startAnimation() &#123; if (!isPlaying) &#123; return &#125; if (textAnimationIndex &lt; 0 || textAnimationIndex &gt;= textContainer.childCount) &#123; textAnimationIndex = 0 animationEnded() return &#125; val view = textContainer.getChildAt(textAnimationIndex) when (view) &#123; firstView -&gt; &#123; startFirstPageAnimation() &#125; secondView -&gt; &#123; startSecondPageAnimation(textAnimationIndex != 0) &#125; lastView -&gt; &#123; startLastPageAnimation() &#125; else -&gt; &#123; startDescPageAnimation(view) &#125; &#125;&#125; 通过取文本容器的孩子，判断是什么 View 来执行相应的动画，那么第二部分的动画就算是完成了。 左侧 Logo 动画这个在第二部分动画完成之后便不是什么问题了：12345678910111213141516171819202122232425262728293031323334353637/** * 展示左侧 Logo、时间、起点动画 */private fun startLeftAnimation() &#123; leftRoot.bgView.animate() .translationXBy(dpMinus44) .translationX(0F) .setDuration(160L) .start() handler.postDelayed(&#123; leftRoot.logoTv.animate() .translationYBy(dpMinus118) .translationY(0F) .withEndAction &#123; leftRoot.dayTv.animate() .translationYBy(dp22) .translationY(0F) .setDuration(400L) .start() leftRoot.dateTv.animate() .translationYBy(dpMinus8) .translationY(0F) .withEndAction &#123; leftRoot.endCityLl.animate() .alphaBy(0F) .alpha(1F) .setDuration(240L) .start() &#125; .setDuration(400L) .start() &#125; .setDuration(160L) .start() &#125;, 80L)&#125; 如何停止播放所有的动画执行时间为 10 秒，当动画开始后，切换到别的 Tab 或页面时，动画应该停止播放，并且恢复到初始状态，然后点击播放按钮能正常从头开始播放。为了解决这个问题，引入一个变量记录当前正在播放动画的 View，利用 withStartAction 方法即可。12345678firstView.distanceLl.animate() .alphaBy(0F) .alpha(1F) .withStartAction &#123; currentAnimationView = firstView.distanceLl &#125; .setDuration(240L) .start() 当页面切换时，停止动画并重置所有的 View 的状态：1234567891011121314151617181920212223242526272829/** * 播放停止重置界面展示 */private fun resetInitStatus() &#123; currentAnimationView?.animate()?.cancel() leftRoot.bgView.translationX = 0F leftRoot.logoTv.translationY = 0F leftRoot.endCityLl.alpha = 1F leftRoot.dayTv.translationY = 0F leftRoot.dateTv.translationY = 0F var picView = picContainer.getChildAt(picAnimationIndex) picView?.animate()?.cancel() picView = picContainer.getChildAt(picContainer.childCount - 1) picView?.scaleX = 1F picView?.scaleY = 1F picView?.alpha = 1F val view = textContainer.getChildAt(textAnimationIndex) view?.animate()?.cancel() view?.visibility = View.INVISIBLE firstView.visibility = View.VISIBLE firstView.alpha = 1F firstView.distanceLl.alpha = 1F firstView.distanceTv.translationX = 0F firstView.timeLl.alpha = 1F firstView.timeTv.translationX = 0F&#125; 小结 View 的逐渐显示效果，可以在 View 外层套一层 ViewGroup，然后利用 translate 来实现。 animate() 后面的动画使用 alphaBy、translationXBy 等方法时，需要在动画开始的时候将 View 对应的属性设置成相应的值，否则动画会错误的执行（提前结束等）。 动画很多，做的时候要细心，将动画一个个拆分开来，然后逐一攻破。 优化点：能否将 animate() 改造成 RxJava 类似的调用链，避免回调地狱呢？","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android 绘制中国地图","date":"2019-01-25T06:07:52.000Z","path":"2019/01/25/china-map/","text":"最近的版本有这样一个需求： 有 3 个要素： 中国地图 高亮省区 中心显示数字 面对这样一个需求，该如何实现呢？ 高德地图因为项目是基于高德地图来做的，所以很自然而然的想到了高德。但是当查阅高德地图相关 Api 后，发现并没有能够实现这样需求的方法，所以只能另寻他法了。 图片叠加让设计师出图，实现第一个要素开发成本极低。至于高亮省区，也是继续让设计师出图，与全国地图分辨率保持一致，为每个省区设计一张高亮的图，其他地方透明，这样算下来设计师得出 35 张图。若不考虑性能，将图片无脑叠加倒也可以实现。但是作为 Android 开发都知道，这样的一张不算小的图片加载到手机里，占用的内存怕是个庞然大物，更别谈极端情况下要叠加 35 张这样的大图了。优化下叠加方案：将高亮的省区做成小图，一个包含了省区所有区域的矩形，省区内部高亮，其他区域透明，这样图变小了，但是就得计算小图相对于全国大图的相对位置，对于每个小图都得计算一个比例。同时，绘制高亮省区时可以每次都只取2张图进行叠加，叠加完后释放一张图再加载另一张图，而不用一次性全部加载在内存中。这种方案想想是 ok 的，但是感觉依然还是很麻烦。于是继续探索~ SVG Path其实网上有很多文章也是有类似的需求，简单搜一下就发现了 SVG 这个解决方案了。看了一眼，便决定就是它了！SVG：可缩放矢量图形（英语：Scalable Vector Graphics，SVG）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式。元素是 SVG 基本形状中最强大的一个，它不仅能创建其他基本形状，还能创建更多其他形状。 SVG Path 用 Android 绘制这里先贴一下我找的北京市的 Path 数据：123&lt;svg height=\"475\" width=\"565\"&gt; &lt;path id=\"Beijing\" d=\"M421.139,189.75L420.782,186.894L419.95,184.989L425.045,182.863L425.426,181.18L424.23699999999997,176.413H422.56899999999996L415.90299999999996,172.964L412.21299999999997,176.654C412.21299999999997,176.654,411.08799999999997,183.239,411.381,181.534C411.66999999999996,179.82999999999998,407.688,185.822,407.688,185.822L407.094,190.108L407.926,192.371L412.807,191.537L416.5,192.608L418.284,190.941L421.139,189.75Z\"/&gt;&lt;/svg&gt; 这里要注意一点：SVG Path 里的数据都是在一个固定宽高的矩形里的坐标集合，所以当 Android View 与 SVG 的宽高不一致时，需要进行缩放。注意下面代码中的 scale 属性：123456789101112131415161718192021222324252627282930/** * 计算地图边界 * 1.黑龙江是中国最东，最北的省份 * 2.新疆是中国最西的省份 * 3.海南是中国最南的省份 */private fun computeBounds() &#123; val hljRF = RectF() xPaths[HEILONGJIANG_CODE]?.computeBounds(hljRF, true) val hnRF = RectF() xPaths[HAINAN_CODE]?.computeBounds(hnRF, true) mapWidth = hljRF.right mapHeight = hnRF.bottom&#125;override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec) val speSize = View.MeasureSpec.getSize(widthMeasureSpec) scale = speSize / mapWidth setMeasuredDimension(speSize, (speSize * mapHeight / mapWidth).toInt())&#125;override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) // 缩放画布 canvas.scale(scale, scale) ...&#125; 再来看到 Path 里有一些 M、L、Z 等字符，这些都是 Path 元素里的指令，后面紧跟的数字即是坐标。 M x,y 移动指令，映射 Path 中的 moveToL x,y 画直线指令，映射 Path 中的 lineToH x 画水平线指令，映射 Path 中的 lineTo，不过要使用上一个坐标的 yV y 画垂直线指令，映射 Path 中的 lineTo，不过要使用上一个坐标的 xC x1,y1,x2,y2,x,y 三次贝塞尔曲线指令，映射 Path 中的 cubicToS x2,y2,x,y 跟在 C 指令后面使用，用 C 指令的结束点做控制点，映射 cubicToQ x1,y1,x,y 二次贝塞尔曲线指令，映射 quadToT x,y 跟在 Q 指令后面使用，使用 Q 的 x,y 做控制点，映射 quadToZ path 关闭指令，映射 close 注意小写指令为使用相对坐标，下面 2 行 Path 得到的结果是一样的：12M421.139,189.75L420.782,186.894M421.139,189.75l-0.357,-2.856 基于 Android Path 实现不了小写指令的那种效果，所以只能使用大写指令。这里贴一下一个将 SVG Path 转成 Android Path 的工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 仅限大写指令转换 */public class SvgPathToAndroidPath &#123; private int svgPathLenght = 0; private String svgPath = null; private int mIndex; private List&lt;Integer&gt; cmdPositions = new ArrayList&lt;&gt;(); /** * M x,y * L x,y * H x * V y * C x1,y1,x2,y2,x,y * Q x1,y1,x,y * S x2,y2,x,y * T x,y * */ public Path parser(String svgPath) &#123; this.svgPath = svgPath; svgPathLenght = svgPath.length(); mIndex = 0; Path lPath = new Path(); lPath.setFillType(Path.FillType.WINDING); //记录最后一个操作点 PointF lastPoint = new PointF(); findCommand(); for (int i = 0; i &lt; cmdPositions.size(); i++) &#123; Integer index = cmdPositions.get(i); switch (svgPath.charAt(index)) &#123; case 'M': &#123; String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); lPath.moveTo(lastPoint.x, lastPoint.y); &#125; break; case 'L': &#123; String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); lPath.lineTo(lastPoint.x, lastPoint.y); &#125; break; case 'H': &#123;//基于上个坐标在水平方向上划线，因此y轴不变 String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[0]), lastPoint.y); lPath.lineTo(lastPoint.x, lastPoint.y); &#125; break; case 'V': &#123;//基于上个坐标在水平方向上划线，因此x轴不变 String ps[] = findPoints(i); lastPoint.set(lastPoint.x, Float.parseFloat(ps[0])); lPath.lineTo(lastPoint.x, lastPoint.y); &#125; break; case 'C': &#123;//3次贝塞尔曲线 String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[4]), Float.parseFloat(ps[5])); lPath.cubicTo(Float.parseFloat(ps[0]), Float.parseFloat(ps[1]), Float.parseFloat(ps[2]), Float.parseFloat(ps[3]), Float.parseFloat(ps[4]), Float.parseFloat(ps[5])); &#125; break; case 'S': &#123;//一般S会跟在C或是S命令后面使用，用前一个点做起始控制点 String ps[] = findPoints(i); lPath.cubicTo(lastPoint.x,lastPoint.y,Float.parseFloat(ps[0]), Float.parseFloat(ps[1]), Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); lastPoint.set(Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); &#125; break; case 'Q': &#123;//二次贝塞尔曲线 String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); lPath.quadTo(Float.parseFloat(ps[0]), Float.parseFloat(ps[1]), Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); &#125; break; case 'T': &#123;//T命令会跟在Q后面使用，用Q的结束点做起始点 String ps[] = findPoints(i); lPath.quadTo(lastPoint.x,lastPoint.y,Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); lastPoint.set(Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); &#125; break; break; case 'Z': &#123;//结束 lPath.close(); &#125; break; &#125; &#125; return lPath; &#125; private String[] findPoints(int cmdIndexInPosition) &#123; int cmdIndex = cmdPositions.get(cmdIndexInPosition); String pointString = svgPath.substring(cmdIndex + 1, cmdPositions.get(cmdIndexInPosition + 1)); return pointString.split(\",\"); &#125; private void findCommand() &#123; cmdPositions.clear(); while (mIndex &lt; svgPathLenght) &#123; char c = svgPath.charAt(mIndex); if ('A' &lt;= c &amp;&amp; c &lt;= 'Z') &#123; cmdPositions.add(mIndex); &#125; ++mIndex; &#125; &#125;&#125; 实现 利用工具类获取每个省区的 Android Path，全部绘制一遍，即可绘制出全国地图（优化：高亮的省区这一步不绘制，避免绘制两次）。 针对高亮省区，调整画笔颜色再绘制一遍即可。 显示数量：这个目前没想到什么好方法，只能让设计师参照地图宽高比标出每个中心点的位置，就像这样：然后手动算出每个点的横纵坐标占比，再进行绘制。绘制数量计算坐标时仍要考虑 scale 属性。 参考 Android 上绘制中国省份地图 SVG 转 Android Canvas Path","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Fragment 问题小结","date":"2019-01-10T06:49:12.000Z","path":"2019/01/10/fragment/","text":"ViewPager 用来做多 Tab 处理已经是十分常见的了，ViewPager 需要一个 Fragment List 来生成 Adapter，这些 Fragment 有时是完全一样的，界面元素、展示风格都一致，只是数据源不一致。通过抽象的思想，很容易写出基类，类似这样：123456789abstract class BaseListFragment : BaseFragment&lt;MyData&gt;() &#123; override fun requestHttpData(pageModel: PageModel?): MutableList&lt;MyData&gt; &#123; return getData() &#125; abstract fun getData(): MutableList&lt;MyData&gt;&#125; 然后在创建 Fragment List 时，使用匿名类实现getData()方法来获取数据。就像这样：1234567891011121314151617181920viewPager.adapter = object : FragmentPagerAdapter(fragmentManager) &#123; override fun getItem(position: Int): BaseListFragment &#123; when (position) &#123; 0 -&gt; &#123; if (fragment == null) &#123; fragment = object : BaseListFragment() &#123; override fun getData(): MutableList&lt;MyData&gt; &#123; // 获取数据 &#125; &#125; &#125; return fragment!! &#125; ... &#125; &#125; ...&#125; 但是这样会编译不过： Fragments should be static such that they can be re-instantiated by the system, and anonymous classes are not static. 然后加上@SuppressLint(&quot;ValidFragment&quot;)注解，可以编译过了，但是运行的时候仍然报错。 Fragment null must be a public static class to be properly recreated from instance state. 异常是在BackStackRecord.doAddOp()抛出的，看到源码：123456789101112131415161718192021222324252627282930313233343536private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123; final Class fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123; throw new IllegalStateException(\"Fragment \" + fragmentClass.getCanonicalName() + \" must be a public static class to be properly recreated from\" + \" instance state.\"); &#125; fragment.mFragmentManager = mManager; if (tag != null) &#123; if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException(\"Can't change tag of fragment \" + fragment + \": was \" + fragment.mTag + \" now \" + tag); &#125; fragment.mTag = tag; &#125; if (containerViewId != 0) &#123; if (containerViewId == View.NO_ID) &#123; throw new IllegalArgumentException(\"Can't add fragment \" + fragment + \" with tag \" + tag + \" to container view with no id\"); &#125; if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123; throw new IllegalStateException(\"Can't change container ID of fragment \" + fragment + \": was \" + fragment.mFragmentId + \" now \" + containerViewId); &#125; fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; addOp(new Op(opcmd, fragment));&#125; 抛出异常的 3 个条件： 匿名类 访问域不是 Public 是 成员类，但是访问域不是 Static 抛出来的异常也很明显了：Fragment 必须 public static 的类，以便系统可以用初始状态重建。这也和 Fragment newIntance 使用 setArguments 不谋而合。12345678public static MyFragment newInstance() &#123; MyFragment fragment = new MyFragment(String param1, String param2); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment;&#125; Fragmnet 经常会被销毁重新实例化，Android Framework 只会调用 Fragment 无参的构造函数。如果直接将参数放到构造函数里，那么 Framework 在重建 Fragment 就会丢失这些参数了。再看下 Fragment 的实例化：12345678910111213141516171819202122232425262728293031323334public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123; try &#123; Class&lt;?&gt; clazz = sClassMap.get(fname); if (clazz == null) &#123; // Class not found in the cache, see if it's real, and try to add it clazz = context.getClassLoader().loadClass(fname); sClassMap.put(fname, clazz); &#125; Fragment f = (Fragment) clazz.getConstructor().newInstance(); if (args != null) &#123; args.setClassLoader(f.getClass().getClassLoader()); f.setArguments(args); &#125; return f; &#125; catch (ClassNotFoundException e) &#123; throw new InstantiationException(\"Unable to instantiate fragment \" + fname + \": make sure class name exists, is public, and has an\" + \" empty constructor that is public\", e); &#125; catch (java.lang.InstantiationException e) &#123; throw new InstantiationException(\"Unable to instantiate fragment \" + fname + \": make sure class name exists, is public, and has an\" + \" empty constructor that is public\", e); &#125; catch (IllegalAccessException e) &#123; throw new InstantiationException(\"Unable to instantiate fragment \" + fname + \": make sure class name exists, is public, and has an\" + \" empty constructor that is public\", e); &#125; catch (NoSuchMethodException e) &#123; throw new InstantiationException(\"Unable to instantiate fragment \" + fname + \": could not find Fragment constructor\", e); &#125; catch (InvocationTargetException e) &#123; throw new InstantiationException(\"Unable to instantiate fragment \" + fname + \": calling Fragment constructor caused an exception\", e); &#125;&#125; 看吧，很清晰了，用的反射取到默认的构造函数，然后创建实例，使用 setArguments 设置参数。小结一下： 不能使用匿名 Fragment 不能使用非 public static 的 Fragment 参数传递使用 setArguments 那么再回到题头：基类已经有了，怎么样减少类的创建呢？不想再写多个子类。我的方法是：写一个通用类，在 Fragment 创建后，setAction 来设置 getData 操作。123456789101112class CommonListFragment : BaseFragment&lt;MyData&gt;() &#123; private var getData: (() -&gt; MutableList&lt;MyData&gt;)? = null override fun requestHttpData(pageModel: PageModel?): MutableList&lt;MyData&gt;? &#123; return getData?.invoke() &#125; fun setAction(action: () -&gt; MutableList&lt;MyData&gt;) &#123; getData = action &#125;&#125; 题外话遇到 Activity 后台被杀，然后自动重建的问题。12345678910111213141516171819202122class DetailActivity : BaseActivity() &#123; private var fragment: DetailFragment? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.fragment_container_activity) try &#123; val bundle = savedInstanceState ?: intent.extras val showShareGuide = bundle.getBoolean(KEY_SHOW_SHARE_GUIDE, false) fragment = DetailFragment.newInstance(showShareGuide) supportFragmentManager.beginTransaction().replace(R.id.container, fragment).commit() &#125; catch (e: Exception) &#123; ToastUtils.toast(e.message) finish() &#125; &#125; override fun onSaveInstanceState(outState: Bundle?) &#123; super.onSaveInstanceState(fragment?.arguments) &#125;&#125; 通过 setArguments 设置 KEY_SHOW_SHARE_GUIDE 参数到 DetailFragment，然后操作界面后把 KEY_SHOW_SHARE_GUIDE 从 true 置为了 false。App 进入后台被杀之后，重建回来的 KEY_SHOW_SHARE_GUIDE 会还是 true。将 onSaveInstanceState 改为如下，问题解决。1234override fun onSaveInstanceState(outState: Bundle?) &#123; outState?.putBoolean(KEY_SHOW_SHARE_GUIDE, fragment?.arguments?.getBoolean(KEY_SHOW_SHARE_GUIDE) ?: false) super.onSaveInstanceState(outState)&#125;","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"极客时间推广课程","date":"2018-12-25T09:02:12.000Z","path":"2018/12/25/geek/","text":"前些日子购买了一波极客时间的几门课程，贴下二维码，扫码购买返现互惠~ Android 开发高手课： 程序员的数学基础课： 数据结构与算法之美：","tags":[{"name":"学习","slug":"学习","permalink":"http://lijia92.github.io/tags/学习/"}]},{"title":"Android 高德地图 SDK 使用小记","date":"2018-12-21T05:47:30.000Z","path":"2018/12/21/amap/","text":"最近的项目是基于高德地图 SDK 来实现的，使用中有一些值得记录的 Tip，便有了这篇博客。 Logo使用高德地图 SDK，是不能去掉「高德地图」 Logo的，只能设置它显示的位置。1mapView.getMap().getUiSettings().setLogoPosition(position); position：位置参数。屏幕左下角：AMapOptions.LOGO_POSITION_BOTTOM_LEFT；底部居中：AMapOptions.LOGO_POSITION_BOTTOM_CENTER；右下：AMapOptions.LOGO_MARGIN_RIGHT。如果想要隐藏 Logo，可以使用如下代码：1mapView.getMap().getUiSettings().setLogoBottomMargin(-50); 设置负值可以让 Logo 显示在屏幕之外。 刻度尺显示刻度尺：1mapView.getMap().getUiSettings().setScaleControlsEnabled(true); 刻度尺的位置是在「高德地图」 Logo 的上面的，可以通过设置 Logo 来改变刻度尺的位置，也可以通过如下代码来设置刻度尺的位置：1234567891011121314/** * 调整地图比例尺的位置 * * @param translationX 正数往右移，负数往左移 * @param translationY 正数往下移，负数往上移 */public void changeScaleControlsPosition(float translationX, float translationY) &#123; View mapViewChild = mapView.getChildAt(0); if (mapViewChild instanceof ViewGroup) &#123; View scaleView = ((ViewGroup) mapViewChild).getChildAt(3); scaleView.setTranslationX(translationX); scaleView.setTranslationY(translationY); &#125;&#125; 代码中的0、3都是硬编码，升级 SDK 时需要兼容测试。 Polyline 与底图之间加蒙层需求是这样的：绘制的 Ployline、Marker 与底图之间有个蒙层，如何来实现？翻到一篇文章写了高德地图覆盖物的层级压盖关系： 1、基础底图（包括底图、底图道路、卫星图等）；2、地形图图层（GroundOverlay）；3、热力图图层（HeatMap）；4、实时路况图图层（BaiduMap.setTrafficEnabled(true);）；5、百度城市热力图（BaiduMap.setBaiduHeatMapEnabled(true);）；6、底图标注（指的是底图上面自带的那些POI元素）；7、几何图形图层（点、折线、弧线、圆、多边形）；8、标注图层（Marker），文字绘制图层（Text）；9、指南针图层（当地图发生旋转和视角变化时，默认出现在左上角的指南针）；10、定位图层（BaiduMap.setMyLocationEnabled(true);）；11、弹出窗图层（InfoWindow）；12、自定义View（MapView.addView(View);）； 所以，在底图和几何图层图层、标注图层之间，还可以使用GroundOverlay。所以可以使用如下代码添加中间图层以达到某些显示效果：12345678val view = View(context)view.layoutParams = FrameLayout.LayoutParams(1, 1)view.setBackgroundColor(Color.parseColor(\"#C1000000\"))val options = GroundOverlayOptions()options.image(BitmapDescriptorFactory.fromView(view))options.positionFromBounds(aMap.projection.visibleRegion.latLngBounds)options.zIndex(1F)aMap.addGroundOverlay(options) 地图显示所有的元素地图默认显示北京，当我们绘制了 Polyline 或者 Marker，想让地图全部显示全的时候，可以使用如下代码：12345val boundsBuilder = LatLngBounds.Builder()for (i in 0 until markers.size()) &#123; boundsBuilder.include(markers.get(i).getPosition())&#125;aMap.animateCamera(CameraUpdateFactory.newLatLngBounds(boundsBuilder.build(), 15)) // 第二个参数为四周留空宽度 也可以使用newLatLngBoundsRect(LatLngBounds latlngbounds, int paddingLeft, int paddingRight, int paddingTop, int paddingBottom)方法，分别来设置四周的留空宽度。 多”InfoWindow”展示高德地图 Marker 可绑定一个 Infowindow，但是全局只能有一个 Infowindow 显示，所以如果要展示多个 Infowindow，只能使用其他方式。给 Marker 设置 icon，有个工厂类BitmapDescriptorFactory来提供。所以可以自己填充 View，然后通过 fromView 设置到 Marker 上。看到 fromView 的源码：1234567891011121314151617181920212223242526272829303132public static BitmapDescriptor fromView(View var0) &#123; try &#123; Context var1 = s.a; if (var1 != null) &#123; FrameLayout var2 = new FrameLayout(var1); var2.addView(var0); var2.setDrawingCacheEnabled(true); Bitmap var3 = ev.a(var2); BitmapDescriptor var4 = fromBitmap(var3); return var4; &#125; else &#123; return null; &#125; &#125; catch (Throwable var5) &#123; return null; &#125;&#125;public static Bitmap a(View var0) &#123; try &#123; b(var0); var0.destroyDrawingCache(); var0.measure(MeasureSpec.makeMeasureSpec(0, 0), MeasureSpec.makeMeasureSpec(0, 0)); var0.layout(0, 0, var0.getMeasuredWidth(), var0.getMeasuredHeight()); Bitmap var1 = var0.getDrawingCache(); return var1 != null ? var1.copy(Config.ARGB_8888, false) : null; &#125; catch (Throwable var2) &#123; he.c(var2, \"Utils\", \"getBitmapFromView\"); var2.printStackTrace(); return null; &#125;&#125; 可以看到是生成一个 FrameLayout 添加我们自定义的 View，然后利用 drawingCache 来生成 bitmap，最后设置到 Marker 上。所以一旦 View 设置到 Marker 上，这个 View 便“死”了，如果要改变 Marker 的样式，则只能重新生成 View 然后再次设置。所以，对于有样式修改需求的 Marker，要记录生成 View 的参数。 屏幕位置、地图位置映射贴一下文档说明： Marker 覆盖点击多个 Marker 覆盖显示在地图上，点击 Marker 覆盖重叠的部分，并不是视觉上最上层的 Marker 在响应（Marker 的 zIndex 值一致），一直是最后绘制的 Marker 在响应。通过设置 Marker 的 zIndex 可以解决这个问题。1234567891011private var zIndex = 0F get() &#123; field++ return field &#125;override fun onMarkerClick(marker: Marker): Boolean &#123; marker.zIndex = zIndex // do something... return true&#125; 自定义地图 需要展示上图效果的地图，可以使用自定义地图实现。 进入官网自定义地图页面，可以自定义地图展示样式，然后保存，后面可以在自己的自定义样式界面进行使用。 针对 Android 下载下来的是一个 zip 文件，6.6.0 版本及以后会有 2 个文件，style.data、style_extra.data。然后使用地图加载：1234567891011121314151617181920212223242526272829303132val options = CustomMapStyleOptions()options.styleDataPath = copyCustomStyleFile(\"style.data\")options.styleExtraPath = copyCustomStyleFile(\"style_extra.data\")options.isEnable = true/** * 拷贝自定义样式文件到私有文件目录 */private fun copyCustomStyleFile(fileName: String): String? &#123; var outputStream: FileOutputStream? = null var inputStream: InputStream? = null var file: File? = null try &#123; inputStream = controller.mapView.context.assets.open(\"map/footprint/$fileName\") val b = ByteArray(inputStream!!.available()) inputStream.read(b) file = File(DirUtils.getMapPath(), fileName) if (file.exists()) &#123; file.delete() &#125; file.createNewFile() outputStream = FileOutputStream(file) outputStream.write(b) &#125; catch (e: Exception) &#123; LogUtils.e(\"ShareInfoMapPresenter\", e.toString()) &#125; finally &#123; IOUtils.close(inputStream) IOUtils.close(outputStream) &#125; return file?.absolutePath&#125; Polyline Click 和 Map Click 冲突当 AMap setOnPolylineClickListener 又设置 setOnMapClickListener，点击 Polyline 还会响应到 onMapClick，调试后发现 Polyline 的点击事件在前，所以可以这样处理一下：123456789101112131415@Overridepublic void onMapClick(LatLng latLng) &#123; if (clickPolyline) &#123; clickPolyline = false; return; &#125; // do something&#125;@Overridepublic void onPolylineClick(Polyline polyline) &#123; clickPolyline = true; // do something&#125; 参考文档：Android地图SDK简介参考手册","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"CoordinatorLayout + RecyclerView 处理滑动","date":"2018-12-12T02:25:19.000Z","path":"2018/12/12/recyclerview-scroll/","text":"先看一下设计稿：最底层是个地图，再上面有一些按钮，最上层是路线信息 UI，页面可以滑动，滑动时地图和按钮不动，自然而然想到的 RecyclerView 来实现。早些时候只有 2 个按钮，使用了一种很笨拙的方式，与之前写过的一篇文章类似：一个关于Android滑动“因缺斯厅”的想法。这种方式，相当于有四层：地图-&gt;按钮-&gt;RecyclerView-&gt;与按钮相同位置的View，但是是透明的。界面布局就像这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/vyg__background_gray\" android:orientation=\"vertical\"&gt; &lt;!-- 底层地图 --&gt; &lt;include layout=\"@layout/vyg__base_map_view\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/vyg__route_map_height\"/&gt; &lt;!-- 地图上的按钮 --&gt; &lt;LinearLayout android:id=\"@+id/mapLayerLl\" style=\"@style/vyg__map_action\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"12dp\" android:layout_marginTop=\"84dp\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;ImageView android:layout_width=\"20dp\" android:layout_height=\"20dp\" android:scaleType=\"centerInside\" android:src=\"@drawable/vyg__map_icon_layer\"/&gt; &lt;TextView android:id=\"@+id/mapLevelTv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"14级\" android:textColor=\"@color/vyg__font_333\" android:textSize=\"10sp\"/&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=\"@+id/fullIv\" style=\"@style/vyg__map_action\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"12dp\" android:layout_marginTop=\"184dp\" android:scaleType=\"centerInside\" android:src=\"@drawable/vyg__map_icon_fullscreen\"/&gt; &lt;LinearLayout android:id=\"@+id/fullTrendLl\" style=\"@style/vyg__map_action\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"12dp\" android:layout_marginTop=\"134dp\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;ImageView android:layout_width=\"20dp\" android:layout_height=\"20dp\" android:scaleType=\"centerInside\" android:src=\"@drawable/vyg__route_icon_trend\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"趋势图\" android:textColor=\"@color/vyg__font_333\" android:textSize=\"10sp\"/&gt; &lt;/LinearLayout&gt; &lt;!-- 列表 RecyclerView --&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/detailRv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"50dp\" android:clipToPadding=\"false\"/&gt; &lt;!-- 最上层的透明点击 View --&gt; &lt;ImageView android:id=\"@+id/exitFullIv\" style=\"@style/vyg__map_action\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"12dp\" android:layout_marginTop=\"140dp\" android:scaleType=\"centerInside\" android:src=\"@drawable/vyg__map_icon_fullscreen_exit\" android:visibility=\"gone\"/&gt; &lt;View android:id=\"@+id/trendView\" android:layout_width=\"44dp\" android:layout_height=\"44dp\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"12dp\" android:layout_marginTop=\"134dp\"/&gt; &lt;View android:id=\"@+id/mapLayerView\" android:layout_width=\"44dp\" android:layout_height=\"44dp\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"12dp\" android:layout_marginTop=\"84dp\"/&gt;&lt;/RelativeLayout&gt; 通过给透明 View 设置点击事件，来实现点击按钮的效果。但是要考虑一点：在界面滑动的时候，RecyclerView 会覆盖到地图上的按钮，这个时候最顶层的透明 View 点击区域应该是要变化的。所以早些时候有了这样的代码：1234567891011121314151617181920212223trendView.setOnTouchListener &#123; _, event -&gt; if (event.action == MotionEvent.ACTION_UP) &#123; val y = event.y // 102 = 280（地图高度） - 134（trendView.marginTop）- 44（trendView.height） if (trendView.height + DimenUtils.dp2px(102F) - y &gt; offsetY) &#123; switchTrend() &#125; &#125; true&#125;mapLayerView.setOnTouchListener &#123; _, event -&gt; if (event.action == MotionEvent.ACTION_UP) &#123; val y = event.y // 152 = 280（地图高度） - 84（mapLayerView.marginTop）- 44（mapLayerView.height） if (mapLayerView.height + DimenUtils.dp2px(152F) - y &gt; offsetY) &#123; showLayerSwitchDialog() &#125; &#125; true&#125; 一堆 XML 中固定宽高的 dp，十分影响阅读，而且后续每加一个按钮都得这样：先地图上面覆盖一个按钮，然后在 RecyclerView 上层再覆盖一个相同位置透明的 View，并通过 setOnTouchListener 计算滑动位置来实现点击事件，十分繁杂。这次新版需求出来，直接多了3 4个按钮，再这样做我可能会死，只能思考另外的实现方案了。 其实核心思路是，在 RecyclerView 上面添加一个透明的 View，这样便能看到底层的地图和按钮了，但是又不能影响地图上按钮的点击。不幸的是 RecyclerView 会吃掉所有的点击事件，导致事件无法传达至底层的按钮，所以才会有了上面的那种思路。重写 RecyclerView 的 onTouchEvent 返回 false，本身不处理事件，这样底层按钮可以点击了，但是滑动有问题，也不可取。看网上说也有 NestedScrollView + RecyclerView 的，但是这样的话 RecyclerView 的复用机制貌似就没有了，因为它需要测量全部子 View。最后想到的便是 CoordinatorLayout + RecyclerView 了，尝试了一波，可以实现需求！看下调整后的 XML：1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/vyg__route_detail_map_action\"/&gt; &lt;cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout android:id=\"@+id/unFullScreenRoot\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"50dp\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/barLayout\" android:layout_width=\"match_parent\" android:layout_height=\"330dp\" android:background=\"@color/vyg__transparent\" app:elevation=\"0dp\"&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/detailRv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;/cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout&gt;&lt;/RelativeLayout&gt; 地图和底层按钮在 vyg__route_detail_map_action 中，然后上层使用 CoordinatorLayout + RecyclerView。透明的 AppBarLayout 在 RecyclerView 上面，使其能看到底层的地图，当滑动时，CoordinatorLayout 会先消费滑动，将 AppBarLayout 往上滑，直至 AppBarLayout 完全消失，RecyclerView 覆盖整个页面。当 AppBarLayout 尚未完全消失时，点击 AppBarLayout，因为其本身没有处理点击事件，所以事件最后会返回到 CoordinatorLayout 的 onTouchEvent，如果不复写，它会返回 true，直接消费点击事件，但是我需要的是不消费点击事件，这样事件就会传递到底层的按钮去响应。所以重写了一下 CoordinatorLayout：12345678class MyCoordinatorLayout(context: Context, attributeSet: AttributeSet) : CoordinatorLayout(context, attributeSet) &#123; @SuppressLint(\"ClickableViewAccessibility\") override fun onTouchEvent(ev: MotionEvent?): Boolean &#123; super.onTouchEvent(ev) return false &#125;&#125; 直接强制返回 false，目前没有发现不良影响。至此，方案完美落幕。地图上的按钮你想加多少就加多少，做不好算我输！","tags":[]},{"title":"无声视频合成音频","date":"2018-11-23T02:02:03.000Z","path":"2018/11/23/media-mix/","text":"上篇文章，通过 MediaProjectionManager 结合 MediaRecorder 进行录屏并生成视频文件。新版本需求产品提了个：视频增加背景音乐，音频文件内置在 Apk 中。那么，怎么生成带音频的视频呢？通过调研发现，在用 MediaPlayer 进行录屏时，可以添加音频源，但是基本是使用麦克风录音，无法指定音频文件。代码如下：12345678910111213141516171819202122232425/** * 初始化 MediaRecorder */@RequiresApi(Build.VERSION_CODES.LOLLIPOP)private fun initRecorder() &#123; mSaveFile = File(DirUtils.getPublicMediaPath(), \"$saveName.tmp\") if (mSaveFile!!.exists()) &#123; mSaveFile!!.delete() &#125; mMediaRecorder = MediaRecorder() mMediaRecorder?.setVideoSource(MediaRecorder.VideoSource.SURFACE) // 使用麦克风录音 mMediaRecorder?.setAudioSource(MediaRecorder.AudioSource.MIC) mMediaRecorder?.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4) mMediaRecorder?.setOutputFile(mSaveFile!!.absolutePath) mMediaRecorder?.setVideoSize(mVideoWidth, mVideoHeight) mMediaRecorder?.setVideoEncoder(MediaRecorder.VideoEncoder.H264) mMediaRecorder?.setVideoEncodingBitRate(VIDEO_BIT_RATE) mMediaRecorder?.setVideoFrameRate(VIDEO_FRAME_RATE) try &#123; mMediaRecorder?.prepare() &#125; catch (e: IOException) &#123; LogUtils.e(TAG, e.toString()) &#125;&#125; 使用此种方案，通过代码mMediaRecorder?.setAudioSource(MediaRecorder.AudioSource.MIC)指定麦克风音频源。可以在录屏开始时，使用 MediaPlayer 进行音乐播放，那么麦克风就可以录入音频了，可是如果此时背景很嘈杂，或者有人说话也会给录进去，需求是只能包含音频文件里的音频，不能有其他的声音，所以此种方案不可行。所以换个思路：将无声视频与音频进行合成，生成一个有声视频。调研了一波，发现了可用的代码，整理如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 无声视频添加音频 * 参考代码：https://stackoverflow.com/questions/31572067/android-how-to-mux-audio-file-and-video-file * * audioTrack 的 mime type 只支持： * MediaFormat.MIMETYPE_AUDIO_AMR_NB, * MediaFormat.MIMETYPE_AUDIO_AMR_WB, * MediaFormat.MIMETYPE_AUDIO_AAC */private fun muxing(musicName: String) &#123; val saveFile = File(DirUtils.getPublicMediaPath(), \"$saveName.mp4\") if (saveFile.exists()) &#123; saveFile.delete() &#125; try &#123; saveFile.createNewFile() val videoExtractor = MediaExtractor() videoExtractor.setDataSource(mSaveFile!!.absolutePath) val audioExtractor = MediaExtractor() val afdd = MucangConfig.getContext().assets.openFd(musicName) audioExtractor.setDataSource(afdd.fileDescriptor, afdd.startOffset, afdd.length) val muxer = MediaMuxer(saveFile.absolutePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4) videoExtractor.selectTrack(0) val videoFormat = videoExtractor.getTrackFormat(0) val videoTrack = muxer.addTrack(videoFormat) audioExtractor.selectTrack(0) val audioFormat = audioExtractor.getTrackFormat(0) val audioTrack = muxer.addTrack(audioFormat) var sawEOS = false var frameCount = 0 val offset = 100 val sampleSize = 1000 * 1024 val videoBuf = ByteBuffer.allocate(sampleSize) val audioBuf = ByteBuffer.allocate(sampleSize) val videoBufferInfo = MediaCodec.BufferInfo() val audioBufferInfo = MediaCodec.BufferInfo() videoExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) muxer.start() // 每秒多少帧 val frameRate = videoFormat.getInteger(MediaFormat.KEY_FRAME_RATE) // 得出平均每一帧间隔多少微妙 val videoSampleTime = 1000 * 1000 / frameRate while (!sawEOS) &#123; videoBufferInfo.offset = offset videoBufferInfo.size = videoExtractor.readSampleData(videoBuf, offset) if (videoBufferInfo.size &lt; 0) &#123; sawEOS = true videoBufferInfo.size = 0 &#125; else &#123; videoBufferInfo.presentationTimeUs += videoSampleTime videoBufferInfo.flags = videoExtractor.sampleFlags muxer.writeSampleData(videoTrack, videoBuf, videoBufferInfo) videoExtractor.advance() frameCount++ &#125; &#125; var sawEOS2 = false var frameCount2 = 0 while (!sawEOS2) &#123; frameCount2++ audioBufferInfo.offset = offset audioBufferInfo.size = audioExtractor.readSampleData(audioBuf, offset) if (audioBufferInfo.size &lt; 0) &#123; sawEOS2 = true audioBufferInfo.size = 0 &#125; else &#123; audioBufferInfo.presentationTimeUs = audioExtractor.sampleTime audioBufferInfo.flags = audioExtractor.sampleFlags muxer.writeSampleData(audioTrack, audioBuf, audioBufferInfo) audioExtractor.advance() &#125; &#125; muxer.stop() muxer.release() videoExtractor.release() audioExtractor.release() afdd.close() // 删除无声视频文件 mSaveFile?.delete() &#125; catch (e: Exception) &#123; LogUtils.e(TAG, \"Mixer Error:\" + e.message) // 视频添加音频合成失败，直接保存视频 mSaveFile?.renameTo(saveFile) &#125; finally &#123; MainThreadUtils.post &#123; listener?.finishRecord() if (mSaveFile != null) &#123; val intent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) intent.data = Uri.fromFile(saveFile) MucangConfig.getContext().sendBroadcast(intent) ToastUtils.toast(\"已保存到相册\") &#125; mSaveFile = null &#125; &#125;&#125; 注意代码中的videoSampleTime，如果不加这个，代码在部分机型上会合成失败。 这里重点关注下bufferInfo.presentationTimeUs = mediaExtractor.getSampleTime()因为mediaExtractor的提取顺序应该是dts的顺序不是pts的顺序，如果视频中存在b帧则getSampleTime不可能递增的，所以bufferInfo.presentationTimeUs=mediaExtractor.getSampleTime()可能会报错，前面说了这个值必须递增。如果不存在b帧，pts==dts，使用没问题。 参考： android - How to mux audio file and video file? MediaMuxer和MediaExtractor","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"录制仿 Keep 轨迹动画视频","date":"2018-10-18T09:01:32.000Z","path":"2018/10/18/screen-record/","text":"最近 Keep 更新了一个轨迹动画的分享，可以生成一个看起来高大上的视频。项目产品也提出了一样的需求，便参照着实现了一波。效果如下（虚拟机跑动画就已经很卡了，然后还要录 gif 就更卡了，凑合看~）： 整体思路就是： Android 原生播放动画（基于高德地图实现） 录制屏幕生成视频 播放动画无非就是一次画一条线，连起来就像一个点一直在往前面爬的效果了。然后请求录制屏幕，输出到一个文件，最后保存为视频即可。Android 录屏核心思路是使用系统 Api MediaProjectionManager，需要 Android 5.0 以上才可以使用。鉴于目前市场 Android 5.0 的手机已经很少了，所以便直接使用 MediaProjectionManager 了。使用步骤： mMediaProjectionManager.createScreenCaptureIntent() 申请录屏权限（因为要保存文件所以需要申请 WRITE_EXTERNAL_STORAGE 权限） 用户同意之后，初始化 VirtualDisplay 创建 MediaRecorder，设置好相关参数，核心设置视频源为 SURFACE： setVideoSource(MediaRecorder.VideoSource.SURFACE) 录制结束后释放资源，保存文件 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 录屏帮助类，仅限 Android 5.0 及以上使用 */class ScreenRecorder(val activity: Activity, val listener: VideoRecordListener?, private val saveName: String) &#123; private val REQUEST_MEDIA_PROJECTION_CODE = 1000 /** * 录制视频的分辨率、比特率、帧率 */ private var mVideoWidth: Int private var mVideoHeight: Int private val VIDEO_BIT_RATE = 12 * 1024 * 1024 private val VIDEO_FRAME_RATE = 60 @RequiresApi(Build.VERSION_CODES.LOLLIPOP) private var mMediaProjectionManager = activity.getSystemService(Context.MEDIA_PROJECTION_SERVICE) as? MediaProjectionManager private var mMediaRecorder: MediaRecorder? = null private var mVirtualDisplay: VirtualDisplay? = null private var mMetrics = DisplayMetrics() private var mSaveFile: File? = null init &#123; activity.windowManager.defaultDisplay.getMetrics(mMetrics) mVideoWidth = mMetrics.widthPixels mVideoHeight = mMetrics.heightPixels &#125; /** * 开始录制 */ @RequiresApi(Build.VERSION_CODES.LOLLIPOP) fun startRecord() &#123; PermissionUtils.requestPermissions(activity, PermissionsCallback &#123; if (it.grantedAll) &#123; listener?.beforeRecord() StartForResult.from(activity).startForResult(mMediaProjectionManager!!.createScreenCaptureIntent(), REQUEST_MEDIA_PROJECTION_CODE) &#123; requestCode, resultCode, data -&gt; if (requestCode == REQUEST_MEDIA_PROJECTION_CODE &amp;&amp; resultCode == Activity.RESULT_OK) &#123; initRecorder() MainThreadUtils.postDelayed(&#123; val mp = mMediaProjectionManager!!.getMediaProjection(resultCode, data) mVirtualDisplay = mp.createVirtualDisplay(\"ScreenCapture\", mVideoWidth, mVideoHeight, mMetrics.densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, mMediaRecorder?.surface, null, null) mMediaRecorder?.start() listener?.startRecord() &#125;, 300) &#125; else &#123; listener?.cancelRecord() &#125; &#125; &#125; else &#123; ToastUtils.toast(\"录屏需要写存储权限\") &#125; &#125;, Manifest.permission.WRITE_EXTERNAL_STORAGE) &#125; /** * 录制中断，删除视频文件 */ fun interruptRecord() &#123; releaseRecorder() if (mSaveFile != null) &#123; ToastUtils.toast(\"视频保存失败\") &#125; mSaveFile?.delete() mSaveFile = null &#125; /** * 结束录制 */ fun finishRecord() &#123; releaseRecorder() if (mSaveFile != null) &#123; val newFile = File(DirUtils.getPublicMediaPath(), \"$saveName.mp4\") // 录制结束后修改后缀为 mp4 mSaveFile!!.renameTo(newFile) val intent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) intent.data = Uri.fromFile(newFile) MucangConfig.getContext().sendBroadcast(intent) ToastUtils.toast(\"已保存到相册\") &#125; mSaveFile = null &#125; /** * 释放资源 */ private fun releaseRecorder() &#123; mMediaRecorder?.stop() mMediaRecorder?.release() mMediaRecorder = null mVirtualDisplay?.release() mVirtualDisplay = null &#125; /** * 初始化 MediaRecorder */ @RequiresApi(Build.VERSION_CODES.LOLLIPOP) private fun initRecorder() &#123; mSaveFile = File(DirUtils.getPublicMediaPath(), \"$saveName.tmp\") if (mSaveFile!!.exists()) &#123; mSaveFile!!.delete() &#125; mMediaRecorder = MediaRecorder() mMediaRecorder?.setVideoSource(MediaRecorder.VideoSource.SURFACE) mMediaRecorder?.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4) mMediaRecorder?.setOutputFile(mSaveFile!!.absolutePath) mMediaRecorder?.setVideoSize(mVideoWidth, mVideoHeight) mMediaRecorder?.setVideoEncoder(MediaRecorder.VideoEncoder.H264) mMediaRecorder?.setVideoEncodingBitRate(VIDEO_BIT_RATE) mMediaRecorder?.setVideoFrameRate(VIDEO_FRAME_RATE) try &#123; mMediaRecorder?.prepare() &#125; catch (e: IOException) &#123; LogUtils.e(\"ScreenRecorder\", e.toString()) &#125; &#125; interface VideoRecordListener &#123; /** * 录制开始时隐藏不必要的UI */ fun beforeRecord() /** * 开始录制 */ fun startRecord() /** * 取消录制 */ fun cancelRecord() &#125;&#125;","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"startActivityForResult 的封装使用","date":"2018-10-10T08:59:25.000Z","path":"2018/10/10/start-for-result/","text":"startActivityForResult 相信大家都用过，调用和返回结果是分散开的，使用起来最好还是封装一下比较好。这里利用一个空的 Fragment 进行封装，代码比较简单。封装的回调类 StartForResultListener：12345678public interface StartForResultListener &#123; /** * StartActivityForResult回调，同&#123;@link android.app.Activity#onActivityResult(int, int, Intent)&#125; */ void onActivityResult(int requestCode, int resultCode, Intent data);&#125; 接收回调的 Fragment：12345678910111213141516public class StartForResultFragment extends Fragment &#123; private StartForResultListener mListener; public void setListener(StartForResultListener listener) &#123; mListener = listener; &#125; @Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (mListener != null) &#123; mListener.onActivityResult(requestCode, resultCode, data); mListener = null; &#125; &#125;&#125; 封装入口类 StartForResult：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StartForResult &#123; private static final String TAG = \"StartForResult\"; private static final String FRAG_TAG = \"__start_for_result\"; private StartForResultFragment mFragment; public static StartForResult from(Activity activity) &#123; return new StartForResult(activity); &#125; private StartForResult(Activity activity) &#123; if (!isActivityValid(activity)) &#123; LogUtils.e(TAG, \"Activity is null or has finished\"); return; &#125; mFragment = (StartForResultFragment) activity.getFragmentManager().findFragmentByTag(FRAG_TAG); if (mFragment == null) &#123; mFragment = new StartForResultFragment(); activity.getFragmentManager() .beginTransaction() .add(mFragment, FRAG_TAG) .commitAllowingStateLoss(); activity.getFragmentManager().executePendingTransactions(); &#125; &#125; public void startForResult(Intent intent, int requestCode, StartForResultListener listener) &#123; if (requestCode &lt;= 0 || listener == null) &#123; LogUtils.w(TAG, \"RequestCode should in &gt;0 and listener should not be null\"); &#125; if (mFragment == null) &#123; LogUtils.w(TAG, \"Please check you activity state\"); return; &#125; mFragment.setListener(listener); mFragment.startActivityForResult(intent, requestCode); &#125; @SuppressWarnings(\"RedundantIfStatement\") private static boolean isActivityValid(Activity activity) &#123; if (activity == null || activity.isFinishing()) &#123; return false; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1 &amp;&amp; activity.isDestroyed()) &#123; return false; &#125; return true; &#125;&#125; 使用时，仅需要传入一个 Activity：123StartForResult.from(activity).startForResult(intent, REQUEST_CODE_FOR_PIC) &#123; requestCode, resultCode, data -&gt; // 处理返回的结果&#125; 这样，逻辑不在分散，在哪里调用在哪里处理结果，不用再跳来跳去了~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android 开发减少 shape 文件","date":"2018-09-27T09:15:17.000Z","path":"2018/09/27/shape/","text":"作为一名 Android 开发者，对于 shape 文件肯定不会陌生。但是，用时一时爽，到后面遇到缩包要求时，或者强迫症开发者不希望有重复的 shape 文件，便是有苦说不出了。通常，我们定义 shape 文件可能会根据业务来，代表这个 shape 文件在哪里用到，举个栗子：vyg__route_search_bg_selector.xml，开发人员看到这个 shape 文件可以知道是在路线搜索页面用到的。可是这样命名，当开发人员各自独立开发时，可能会有一大堆业务相关的 shape 文件，可能会和其他开发人员相关业务重复了。所以后面我们干脆改成这样了：vyg__shape_r2_f7f7f7.xml，代表 2dp 的 radius，然后填充色是 #F7F7F7。如果项目设计师严格按照一套标准来设计所有的背景，这样命名一套 shape 文件可以做到复用了。可如果设计师经常换人，或者不够专业等等其他原因，这里一个颜色，那里又是另外一个颜色，或者把 2dp 的圆角变成 4dp，如此下来，shape 文件依然会很多。就像这样： 现在做的项目还是个新项目，看着这日益增多的 shape 文件感觉还是得采取点措施处理一下。本着不重复造轮子的原则，Google 了一波，发现这是广大开发者都面对过的一个问题，目前看到的有几个方案。 自定义View通过自定义 View 或 ViewGroup，解析对应的 xml 属性，来生成相应的 BackgroundDrawable，这种方式不太灵活，即使用到 Android 自带的 TextView 等控件也得在 xml 中声明自定义的 View，比较蛋疼。最新的 support 包里也出了一个 Material Button，可以来设置简单的 shape 属性，和这个类似。 参考：是时候跟 shape 标签说拜拜了Material Button 代码生成通过代码直接生成相应的 BackgroundDrawable，然后设置到 View 上。比如这样：1234FSelector.with(tvtext1) .addDrawable().circleAngle(dp2px(15)).bgColor(getColors(R.color.clr_fb720e)) .create() .bind(); 这种显然也不行的，每个 View 要设置背景得写多少这种代码？还不如直接写 shape 得了。 参考：解放双手,提高编码效率,减少大量的selecor文件 BackgroundLibrary有没有一种更好的方式呢？找了一阵子，终于找到了个还比较满意的：BackgroundLibrary针对这个库，作者也写了篇文章进行相关的说明，还不错。无需自定义View，彻底解放shape，selector吧引入只需要在BaseActivity里添加如下代码：1BackgroundLibrary.inject(this) 然后直接在 xml 中声明对应的属性即可。通过这种方式，比较省心，也没有其他不必要的依赖，已经可以应付绝大多数场景了。用的是 Google 提供的 Api，没有使用到反射，针对高版本可能的非 SDK 接口限制的问题也不存在。缺点就是不能实时预览，也没有属性提示，熟悉后问题不大。实现原理作者也说了：通过低入侵的方式，加入一个自定义的 LayoutInflater.Factory，去解析添加的自定义属性，然后生成系统提供的 GradientDrawable、RippleDrawable、StateListDrawable 即可。目前来看算是最好的方案了，先用着，后面有问题再跟进，给作者点个赞~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"「小米MIX2」全面屏适配","date":"2018-09-13T02:53:11.000Z","path":"2018/09/13/phone-adapt/","text":"有这样一个需求：作为一个 Android 开发者，首先想到的就是用 PopupWindow 来实现。底部阴影的高度固定，剩余的高度全部填充到 PopupWindow，然后调用 PopupWindow 的 showAsDropDown 让它在应用标题栏下面显示就行了。 首先适配全面屏，在 AndroidManifest.xml 中添加如下代码：1&lt;meta-data android:name=\"android.max_aspect\" android:value=\"2.1\" /&gt; 大体代码如下：123456789class FilterPopup(val context: Activity) : PopupWindow(context) &#123; init &#123; val root = View.inflate(context, R.layout.popup, null) as LinearLayout width = ViewGroup.LayoutParams.MATCH_PARENT height = ViewGroup.LayoutParams.WRAP_CONTENT contentView = root // 省略...&#125; 本以为就结束了，结果在我的「小米MIX2」手机上显示有问题，底部会有一条白边，十分难受。于是我尝试把 height 设置成 MATCH_PARENT，白边是没了，但是整个 PopupWindow 占据了整个屏幕的高度，直接覆盖住了应用的标题栏。于是我开始设置 root 的 paddingTop 为标题栏的高度，嗯，显示刚刚好。可是在全国加点击事件时就尴尬了：点击事件给 PopupWindow 吃掉了。如果只有一个按钮，可以在 PopupWindow 上面覆盖个同样位置的 View fake 一下，可是标题栏还有搜索，想想比较麻烦就打消这个念头了。设置 MATCH_PARENT 不行，我直接设置真正的高度行不行呢？参照界面：1height = 屏幕高度 - 状态栏高度 - 标题栏高度 - 导航栏高度（如果有显示导航栏） 获取屏幕高度：1context.resources.displayMetrics.heightPixels 获取状态栏高度：1Resources.getSystem().getDimensionPixelSize(Resources.getSystem().getIdentifier(\"status_bar_height\", \"dimen\", \"android\")); 标题栏高度是写死的 48dp。然后就是判断是否有导航栏，有也要减去导航栏的高度：1234567891011121314151617fun getNavigationBarHeight(wm: WindowManager): Int &#123; if (!isNavigationBarShow(wm)) &#123; return 0 &#125; val resources = context.resources val resourceId = resources.getIdentifier(\"navigation_bar_height\", \"dimen\", \"android\") return resources.getDimensionPixelSize(resourceId)&#125;fun isNavigationBarShow(wm: WindowManager): Boolean &#123; val display = wm.defaultDisplay val size = Point() val realSize = Point() display.getSize(size) display.getRealSize(realSize) return realSize.y != size.y&#125; 嗯，如果一切真这么顺利就不会有这篇文章了。首先获取屏幕高度就一直是错误的。方法返回 2030，可「小米MIX2」的高度是 2160 像素，差了 130。只能用如下方法才能获取到 2160：123val outMetrics = DisplayMetrics()context.windowManager.defaultDisplay.getRealMetrics(outMetrics)outMetrics.heightPixels 关于刚刚的 130，经查阅正好是导航栏的高度。可我手机当前是全面屏手势的模式，没有显示导航栏，所以，还得判断是否是全面屏。又查阅了一番：12345678910111213141516171819202122232425262728293031/** * 判断设备是否存在NavigationBar * * @return true 存在, false 不存在 */public static boolean deviceHasNavigationBar() &#123; boolean haveNav = false; try &#123; Class&lt;?&gt; windowManagerGlobalClass = Class.forName(\"android.view.WindowManagerGlobal\"); Method getWmServiceMethod = windowManagerGlobalClass.getDeclaredMethod(\"getWindowManagerService\"); getWmServiceMethod.setAccessible(true); Object iWindowManager = getWmServiceMethod.invoke(null); Class&lt;?&gt; iWindowManagerClass = iWindowManager.getClass(); Method hasNavBarMethod = iWindowManagerClass.getDeclaredMethod(\"hasNavigationBar\"); hasNavBarMethod.setAccessible(true); haveNav = (Boolean) hasNavBarMethod.invoke(iWindowManager); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return haveNav;&#125;public static boolean miuiNavigationGestureEnabled(Context context) &#123; try &#123; return Settings.Global.getInt(context.getContentResolver(), \"force_fsg_nav_bar\") != 0; &#125; catch (Settings.SettingNotFoundException e) &#123; e.printStackTrace(); &#125; return false;&#125; 获取导航栏高度的方法返回的值倒是准确的，可是 isNavigationBarShow 方法则是一直返回的 true，即使我当前是全面屏手势模式，没有显示导航栏。最后整合一下：123456789val outMetrics = DisplayMetrics()context.windowManager.defaultDisplay.getRealMetrics(outMetrics)var height = outMetrics.heightPixels - SystemUtils.getStateBarHeight() - DimenUtils.dp2px(48)if (SystemUtils.deviceHasNavigationBar() &amp;&amp; !SystemUtils.miuiNavigationGestureEnabled(context)) &#123; height -= SystemUtils.getNavigationBarHeight(context.windowManager)&#125;this.height = height 如此在我手机上，能够完美运行了。但是针对其他厂商的全面屏，还需要判断 Rom 类型，再判断是否开启全面屏手势，本文在此不做详细描述，可自行 Google。这里贴下 oppo 手机全面屏是否开启的方法：1234567private static final String NAVIGATION_GESTURE = \"navigation_gesture_on\";private static final int NAVIGATION_GESTURE_OFF = 0;public static boolean vivoNavigationGestureEnabled(Context context) &#123; int val = Settings.Secure.getInt(context.getContentResolver(), NAVIGATION_GESTURE, NAVIGATION_GESTURE_OFF); return val != NAVIGATION_GESTURE_OFF;&#125; 但是这样针对不同的 Rom 要做很多种判断，总感觉不靠谱。后面找到一种方式来判断是否展示导航栏：1234567891011121314/** * 判断是否显示导航栏 */private fun isNavigationBarExist(activity: Activity): Boolean &#123; val vp = activity.window.decorView as? ViewGroup if (vp != null) &#123; for (i in 0 until vp.childCount) &#123; if (vp.getChildAt(i).id != NO_ID &amp;&amp; \"navigationBarBackground\" == activity.resources.getResourceEntryName(vp.getChildAt(i).id)) &#123; return true &#125; &#125; &#125; return false&#125; 经测试，在我的 MIX2 及同事的华为手机上，展示正常，在一些测试机上展示也 ok，便先采取这种方式了。 参考：MIX2 获取屏幕高度Bug判断用户是否打开了全面屏手势Android获取系统的硬件信息、系统版本以及如何检测ROM类型Android APP适配全面屏手机的技术要点Android全面屏虚拟导航栏适配","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"关于使用 kotlin 碰到的一个坑（三）","date":"2018-08-22T03:30:31.000Z","path":"2018/08/22/kotlin-question3/","text":"近期整理代码，出现了一个空指针异常，其源头为 MapController 类的一个方法：123456789public void addOnMarkerClickListener(AMap.OnMarkerClickListener onMarkerClickListener) &#123; if (onMarkerClickListener == null) &#123; throw new NullPointerException(\"onMarkerClickListener can not null\"); &#125; if (onMarkerClickListeners == null) &#123; onMarkerClickListeners = new HashSet&lt;&gt;(); &#125; onMarkerClickListeners.add(onMarkerClickListener);&#125; 然后看到 kotlin 代码：123456789101112131415class MapControllerTest1(val mapController: MapController) &#123; init &#123; init() &#125; private val onMarkClickListener = OnMarkerClickListener &#123; false &#125; private fun init() &#123; // do other things ... mapController.addOnMarkerClickListener(onMarkClickListener) &#125;&#125; 说明在执行 init 时 onMarkClickListener 为 null。编译 kotlin 代码到 Java 代码看看：12345678910111213141516171819202122public final class MapControllerTest1 &#123; private final OnMarkerClickListener onMarkClickListener; @NotNull private final MapController mapController; private final void init() &#123; this.mapController.addOnMarkerClickListener(this.onMarkClickListener); &#125; @NotNull public final MapController getMapController() &#123; return this.mapController; &#125; public MapControllerTest1(@NotNull MapController mapController) &#123; Intrinsics.checkParameterIsNotNull(mapController, \"mapController\"); super(); this.mapController = mapController; this.init(); this.onMarkClickListener = (OnMarkerClickListener)null.INSTANCE; &#125;&#125; 可以看到 init 方法是在设置 onMarkClickListener 之前执行的，所以会报空指针异常。将代码改成如下：123456789101112131415class MapControllerTest1(val mapController: MapController) &#123; private val onMarkClickListener = OnMarkerClickListener &#123; false &#125; init &#123; init() &#125; private fun init() &#123; // do other things ... mapController.addOnMarkerClickListener(onMarkClickListener) &#125;&#125; 此时便不会报空指针异常了。编译到 Java 代码查看：12345678910111213141516171819202122public final class MapControllerTest1 &#123; private final OnMarkerClickListener onMarkClickListener; @NotNull private final MapController mapController; private final void init() &#123; this.mapController.addOnMarkerClickListener(this.onMarkClickListener); &#125; @NotNull public final MapController getMapController() &#123; return this.mapController; &#125; public MapControllerTest1(@NotNull MapController mapController) &#123; Intrinsics.checkParameterIsNotNull(mapController, \"mapController\"); super(); this.mapController = mapController; this.onMarkClickListener = (OnMarkerClickListener)null.INSTANCE; this.init(); &#125;&#125; 先赋值 onMarkClickListener，才执行 init，很显然不会报异常了。我们可以理解 init 为初始化代码块，若换成 Java 代码，则不论 onMarkerClickListener 在何处声明，都不会抛异常。1234567891011121314151617181920public class MapControllerTest2 &#123; private MapController mapController; public MapControllerTest2(MapController mapController) &#123; this.mapController = mapController; init(mapController); &#125; private void init(MapController mapController) &#123; mapController.addOnMarkerClickListener(onMarkerClickListener); &#125; private AMap.OnMarkerClickListener onMarkerClickListener = new AMap.OnMarkerClickListener() &#123; @Override public boolean onMarkerClick(Marker marker) &#123; return false; &#125; &#125;;&#125; 给我的感觉就是 Kotlin 初始化顺序与 Java 不同了。查看到 Koltin 文档，看到这样一段： 主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：12345678910111213class InitOrderDemo(name: String) &#123; val firstProperty = \"First property: $name\".also(::println) init &#123; println(\"First initializer block that prints $&#123;name&#125;\") &#125; val secondProperty = \"Second property: $&#123;name.length&#125;\".also(::println) init &#123; println(\"Second initializer block that prints $&#123;name.length&#125;\") &#125;&#125; 划重点：初始化块按照它们出现在类体中的顺序执行。所以在 init 之后声明的变量在 init 中是调用不了的。将代码改成如下，会直接就编译不过：123456789101112131415class MapControllerTest1(val mapController: MapController) &#123; init &#123; init() mapController.addOnMarkerClickListener(onMarkClickListener) &#125; private val onMarkClickListener = OnMarkerClickListener &#123; false &#125; private fun init() &#123; // do other things ... &#125;&#125; 此时会提示：Variable ‘onMarkClickListener’ must be initialized。只是凑巧我将 addOnMarkerClickListener 放到了另外一个函数体里面，导致编译通过，规避了这个问题。所以在写 Kotlin 的时候要注意代码的顺序！ 再摘一段比较重要的： 请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：123456789class Constructors &#123; init &#123; println(\"Init block\") &#125; constructor(i: Int) &#123; println(\"Constructor\") &#125;&#125; 执行结果：12Init blockConstructor 试了一下，将代码改成如下：12345678910111213141516171819class MapControllerTest1(val mapController: MapController) &#123; private var onMarkClickListener: OnMarkerClickListener? = null init &#123; init() mapController.addOnMarkerClickListener(onMarkClickListener) &#125; constructor(mapController: MapController, param: Int) : this(mapController) &#123; onMarkClickListener = OnMarkerClickListener &#123; false &#125; &#125; private fun init() &#123; // do other things ... &#125;&#125; 确实会抛异常。 文档很重要呀~ 参考：类与继承","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://lijia92.github.io/tags/Kotlin/"}]},{"title":"Android 保活实践","date":"2018-08-16T05:55:56.000Z","path":"2018/08/16/keep-alive/","text":"作为 Android 开发者，当提到“保活”时，心中的滋味可谓是五味杂陈。互联网上也有各种“黑科技”来达到相应的目的。若是普通的应用，我是十分拒绝进行保活的，当用户不需要你了，还要偷偷地活着，做一些事情。最近参与开发的一款 App 是跟地图相关的，有着「录轨迹」的功能，当用户开启录制功能后，即使退出应用到后台，也是期望能够继续录制的，所以便研究了一番保活，并实践了一下，最后效果也还不错。说下总体方案：1 像素 Activity 、音频播放、前台服务。 首先，监听锁屏相关的广播：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class ScreenReceiver &#123; private static final String TAG = \"ScreenReceiver\"; private Context mContext; // 锁屏亮屏广播接收器 private ScreenBroadcastReceiver mScreenReceiver; // 屏幕状态改变回调接口 private ScreenStateListener mStateReceiverListener; public ScreenReceiver(Context mContext) &#123; this.mContext = mContext; &#125; public void register(ScreenStateListener mStateReceiverListener) &#123; this.mStateReceiverListener = mStateReceiverListener; // 动态启动广播接收器 this.mScreenReceiver = new ScreenBroadcastReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_ON); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(Intent.ACTION_USER_PRESENT); mContext.registerReceiver(mScreenReceiver, filter); &#125; public void unRegister() &#123; mContext.unregisterReceiver(mScreenReceiver); &#125; public class ScreenBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); LogUtils.e(TAG, \"ScreenBroadcastReceiver onReceive() action: \" + action); if (mStateReceiverListener == null) &#123; return; &#125; if (Intent.ACTION_SCREEN_ON.equals(action)) &#123; // 亮屏 mStateReceiverListener.onScreenOn(); &#125; else if (Intent.ACTION_SCREEN_OFF.equals(action)) &#123; // 息屏 mStateReceiverListener.onScreenOff(); &#125; else if (Intent.ACTION_USER_PRESENT.equals(action)) &#123; // 解锁 mStateReceiverListener.onUserPresent(); &#125; &#125; &#125; public interface ScreenStateListener &#123; /** * 屏幕亮屏 */ void onScreenOn(); /** * 屏幕息屏 */ void onScreenOff(); /** * 用户解锁 */ void onUserPresent(); &#125;&#125; 保活管理类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class KeepAliveManager &#123; public static final String BUSINESS_NAME_RECORD = \"BUSINESS_NAME_RECORD\"; @StringDef(&#123;BUSINESS_NAME_RECORD&#125;) @Retention(RetentionPolicy.SOURCE) public @interface KeepAliveName &#123;&#125; private static KeepAliveManager keepAliveManager = new KeepAliveManager(); private ScreenReceiver screenReceiver; private MediaPlayer mMediaPlayer; /** * 记录需要保活的业务功能名称 * 优点: * 1、不同业务的生命周期不同，避免不同业务之间需要通知当前状态、状态变更 * 2、当没有业务需要保活app时，自动关闭保活 * 3、用HashSet是因为它不允许add相同元素，如果添加相同元素也只会保存一份 */ private Set&lt;String&gt; needAliveBusinessName = new HashSet&lt;&gt;(); private KeepAliveManager() &#123; &#125; public static KeepAliveManager getInstance() &#123; return keepAliveManager; &#125; /** * 在需要保活的业务启动时 开启 */ public void start(@KeepAliveName String businessName) &#123; needAliveBusinessName.add(businessName); if (screenReceiver != null) &#123; //不需要重复保活 return; &#125; screenReceiver = new ScreenReceiver(MucangConfig.getContext()); screenReceiver.register(new ScreenReceiver.ScreenStateListener() &#123; @Override public void onScreenOn() &#123; ScreenManager.getInstance().finishActivity(); &#125; @Override public void onScreenOff() &#123; ScreenManager.getInstance().startActivity(); playMusic(); &#125; @Override public void onUserPresent() &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.stop(); &#125; &#125; &#125;); &#125; public void stop(@KeepAliveName String businessName) &#123; needAliveBusinessName.remove(businessName); // 当没有业务功能需要保活时，需要退出保活监听 if (needAliveBusinessName.size() == 0) &#123; if (screenReceiver != null) &#123; screenReceiver.unRegister(); screenReceiver = null; &#125; &#125; &#125; private void playMusic() &#123; mMediaPlayer = MediaPlayer.create(MucangConfig.getContext(), R.raw.silent); mMediaPlayer.setLooping(true); mMediaPlayer.start(); &#125;&#125; 很简单的一个单例类，调用 start 方法传入对应的业务启动保活，保活只会在锁屏时开启。当没有处于需要保活的业务场景时，则不会启动保活。然后看到 ScreenManager：1234567891011121314151617181920212223242526272829303132333435363738public class ScreenManager &#123; private static final String TAG = \"ScreenManager\"; private Context mContext; private static ScreenManager mScreenManager; private WeakReference&lt;Activity&gt; mActivityRef; private ScreenManager() &#123; mContext = MucangConfig.getContext(); &#125; public static ScreenManager getInstance() &#123; if (mScreenManager == null) &#123; mScreenManager = new ScreenManager(); &#125; return mScreenManager; &#125; public void setSingleActivity(Activity mActivity) &#123; mActivityRef = new WeakReference&lt;&gt;(mActivity); &#125; public void startActivity() &#123; LogUtils.e(TAG, \"start LockScreenActivity...\"); Intent intent = new Intent(mContext, LockScreenActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(intent); &#125; public void finishActivity() &#123; LogUtils.e(TAG, \"finish LockScreenActivity...\"); if (mActivityRef != null) &#123; Activity mActivity = mActivityRef.get(); if (mActivity != null) &#123; mActivity.finish(); &#125; &#125; &#125;&#125; 主要功能就是启动、关闭一个 1 像素的 Activity。看下 LockScreenActivity：123456789101112131415161718192021222324252627282930313233/** * 自定义锁屏activity * 注: * 1、锁屏时启动，用于将可能处于后台的进程拉到前台，降低被 Low Memory Killer 清理的概率 * 2、若此时本应用的进程已经处于前台进程，再加强一下也有利于保活 */public class LockScreenActivity extends FragmentActivity &#123; private static final String TAG = \"LockScreenActivity\"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); LogUtils.e(TAG, \"LockScreenActivity onCreate()\"); Window mWindow = getWindow(); mWindow.setGravity(Gravity.LEFT | Gravity.TOP); WindowManager.LayoutParams attrParams = mWindow.getAttributes(); attrParams.x = 0; attrParams.y = 0; attrParams.height = 1; attrParams.width = 1; mWindow.setAttributes(attrParams); ScreenManager.getInstance().setSingleActivity(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); LogUtils.e(TAG, \"LockScreenActivity onDestroy()\"); &#125;&#125; 同时，录制轨迹的服务使用 startForeground 方式。12345678public class RecordService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); startForeground(1, createNotification(\"记录轨迹中\", \"正在后台记录轨迹\")); &#125;&#125; 结合以上代码，可以达到不错的保活效果了。可以看到，代码比较克制，只在特定需要保活的业务场景才开启保活，绝不会在后台不经用户同意做一些“恶心”的事情。另外，锁屏播放无声音乐会比较耗电，需要优化，可以在一段时间内播放一次。同时播放音乐可能会与有些音乐、视频 App 的播放冲突，从而达不到保活效果，这些都是可优化的方向。 参考：Android 进程保活招式大全","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android 列表 Header 吸顶效果","date":"2018-07-23T07:19:58.000Z","path":"2018/07/23/sticky-header/","text":"现在 Android 开发中列表 Header 吸顶效果比较常见了，针对 ListView、RecyclerView 都有多种实现方式。之前开发也碰到过，都是用的三方库或者框架。今天主要写下直接利用 Android 原生来进行实现。页面大致如下： 针对本文的场景，相当于一个 HEADER 对应一组 Image。所以，最好是有个 Map 结构，然后每个 Image item 都能清楚的知道自己所属哪个 HEADER。12345678910111213141516171819202122class MatchedImageAdapter(val map: LinkedHashMap&lt;HEADER, List&lt;Image&gt;&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123; private val dataList = ArrayList&lt;Any&gt;() private var currentKey: HEADER? = null init &#123; map.forEach &#123; dataList.add(it.key) dataList.addAll(it.value) &#125; &#125;&#125;/** * path 图片地址 * key 对应的 HEADER * date 时间 * selected 是否选中 */class Image(val path: String?, var key: HEADER?, var date: Long = 0, var lat: Double = 0.0, var lng: Double = 0.0, var selected: Boolean = false) : Serializable 然后按照这个结构，利用泛型，来实现列表多 Type 效果。123456789private val dataList = ArrayList&lt;Any&gt;()override fun getItemViewType(position: Int): Int &#123; return if (dataList[position] is Header) &#123; TYPE_HEADER &#125; else &#123; TYPE_IMAGE_ITEM &#125;&#125; 另外，针对图片 Item 的网格布局，直接使用 GridLayoutManager 的 spanSize 就能达到效果。12345678910val layoutManager = GridLayoutManager(context, MAX_COUNT)layoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() &#123; override fun getSpanSize(position: Int): Int &#123; return if (adapter!!.getItemViewType(position) == HEADER) &#123; 1 &#125; else &#123; 3 &#125; &#125;&#125; 看到 Header 有个“选择”按钮是可以点击的，所以就有了本文。不用支持点击的话，可以直接使用 ItemDecoration 来达到吸顶效果了。如果要支持点击效果，我采取的方案是：在 RecyclerView 上面盖一层 Header，然后用过滑动监听来设置 Header 的偏移，从而达到吸顶效果。那么核心便是滑动的监听了：1234567891011121314151617181920212223242526272829303132333435matchedImageRv.addOnScrollListener(object : RecyclerView.OnScrollListener() &#123; override fun onScrolled(recyclerView: RecyclerView?, dx: Int, dy: Int) &#123; if (CollectionUtils.isEmpty(adapter!!.getDataList())) &#123; return &#125; // 获取到视图中第一个可见的item的position val firstVisiblePosition = layoutManager.findFirstVisibleItemPosition() if (firstVisiblePosition &lt; 0 || firstVisiblePosition &gt;= adapter!!.getDataList().size) &#123; return &#125; // 获取第一个 item 的 VH val viewHolder = matchedImageRv.findViewHolderForLayoutPosition(firstVisiblePosition) ?: return // 记录当前位置的数据 currentHeader = adapter!!.getDataList()[firstVisiblePosition] // 是否应该平移 HEADER val shouldTranslationY = shouldTranslationY(firstVisiblePosition) // 根据高度及 top 值判断是否需要设置 translationY val height = autoMatchHeader.height if (shouldTranslationY &amp;&amp; viewHolder.itemView.height + viewHolder.itemView.top &lt; height) &#123; val translationY = viewHolder.itemView.height + viewHolder.itemView.top - height autoMatchHeader.translationY = translationY.toFloat() &#125; else &#123; autoMatchHeader.translationY = 0f &#125; // 更新悬浮 Header 信息 refreshHeader() &#125;&#125;) 看下 shouldTranslationY 的代码：123456789101112131415161718/** * 只有下一行数据是 Header，才应该进行平移 */fun shouldTranslationY(position: Int): Boolean &#123; if (adapter!!.getDataList()[position] is HEADER) &#123; return false &#125; for (i in 0 until 3) &#123; if (position + 1 + i &lt; adapter!!.getDataList().size) &#123; val data = adapter!!.getDataList()[position + 1 + i] if (data is HEADER) &#123; return true &#125; &#125; &#125; return false&#125; position 是当前位置，如果当前位置是 HEADER，那么下一行数据肯定不是 HEADER，直接返回 false。如果当前位置是图片 item，那么往下数 3 个，一定能得到下一行数据的类型。中途有可能被 HEADER 类型截断，从而直接返回。然后结合高度，top 值，来判断是否需要设置 translationY，从而达到吸顶效果。然后看下覆盖 HEADER 的点击事件设置：123456789autoMatchHeader.selectAllTv.setOnClickListener &#123; val header = if (currentHeader is Image) &#123; (currentHeader as Image).key &#125; else &#123; currentHeader &#125; as HEADER adapter!!.onAllClick(header, adapter!!.getDataList().indexOf(header))&#125; 通过滑动获取当前位置的数据 currentHeader，然后改变这个 currentHeader 对应数据中的具体分组的数据。写的有点乱，但是要点都写出了，over~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"关于使用 kotlin 碰到的一个坑（二）","date":"2018-07-19T07:01:49.000Z","path":"2018/07/19/kotlin-question2/","text":"最近新做的项目，有点性能问题，今天集中弄了下性能优化，又发现了一个 kotlin 中的坑。其实也不算是坑，只是使用不熟练而已。 介绍下场景：项目有用到高德地图，高德地图的 MapView 需要在 Activity 或者 Fragment 的声明周期中进行调用，就像这样：1234567891011121314151617181920212223242526272829@Overridepublic void onCreate(Bundle savedInstanceState) &#123; mapView = contentView.findViewById(R.id.map_view); mapView.onCreate(savedInstanceState);&#125;@Overridepublic void onResume() &#123; super.onResume(); mapView.onResume();&#125;@Overridepublic void onPause() &#123; super.onPause(); mapView.onPause();&#125;@Overridepublic void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); mapView.onDestroy();&#125; 然后在我写的某个 Fragment 中用到了 MapView，是用 kotlin 写的。发现每次打开这个页面，内存占用只增不减，在排除了其他因素之后，将问题定位到了高德地图的回收上。1234override fun onDestroy() &#123; super.onDestroy() downloadMap?.onDestroy()&#125; 这是 Fragment 里的 onDestroy 调用，断点到这里，发现 downloadMap 总是为 null。这是为啥呢？这个 downloadMap 就是定义到 xml 中的 MapView 呀。1234&lt;com.amap.api.maps.MapView android:id=\"@+id/downloadMap\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 后面网上查阅资料，发现问题的本质：kotlin 在 Fragment 中使用 xml 中 id 直接使用控件，也是使用了 findViewById ，同时进行缓存。释放缓存的操作在 onDestroyView 里，所以在 onDestroy 里，使用 xml id 获取的控件已经全部被置空了，所以无法使用。 AndroidStudio 中可以直接打开 kotlin Bytecode，进行反编译查看编译后的代码，Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode -&gt; Decompile，看到编译后的代码：123456789101112131415161718192021222324252627282930313233343536373839public void onDestroy() &#123; super.onDestroy(); MapView var10000 = (MapView) this._$_findCachedViewById(id.downloadMap); if (var10000 != null) &#123; var10000.onDestroy(); &#125;&#125;public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View) this._$_findViewCache.get(var1); if (var2 == null) &#123; View var10000 = this.getView(); if (var10000 == null) &#123; return null; &#125; var2 = var10000.findViewById(var1); this._$_findViewCache.put(var1, var2); &#125; return var2;&#125;public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125;&#125;// $FF: synthetic methodpublic void onDestroyView() &#123; super.onDestroyView(); this._$_clearFindViewByIdCache();&#125; 果不其然，所以在 onDestroy 中我执行 MapView 的 onDestroy 时 MapView 已经为 null 了，从而导致内存一直占用，无法释放。那么在 Activity 中是否存在这样的问题呢？答案是不存在。Activity 中也会生成 _$_clearFindViewByIdCache 方法，但是没有地方调用。 结论：在利用 Kotlin 编写的 Fragemnt 中，如果有些特殊的 View 需要处理销毁事件，需要写在 onDestroyView 中，并且在 super 调用之前。这里的 View 必须是直接通过 kotlin 利用 id 从 xml 获取的 View，如果是自己手动写 findViewById 的方式则不会出现这个问题。若是在 Activity 中则没有限制。 参考：Kotlin 为什么不用findViewById","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://lijia92.github.io/tags/Kotlin/"}]},{"title":"关于使用 kotlin 碰到的一个坑（一）","date":"2018-07-11T09:58:49.000Z","path":"2018/07/11/kotlin-question/","text":"今天碰到个问题，起初看的时候一脸懵逼，后面追溯问题根源，发现是 kotlin 里的一个坑。看下代码：12345678override fun showRoadCondition(list: List&lt;MyObject&gt;) &#123; val size = Math.ceil(list.size / 8.0).toInt() for (i in (0 until size)) &#123; val min = Math.min((i + 1) * 8, list.size) val subList = list.subList(i * 8, min).toList() as ArrayList&lt;MyObject&gt; &#125; // 其他代码...&#125; 这样一个方法，需要将列表的数据，根据 8 个一组进行划分。subList 生成的一个 List 不是我们平常使用的 List，所以后面加上了 kotlin 自带的 toList() 方法，来转化成真正的 List。这段代码在大多数情况下都没有什么问题，但是当 list 的长度为 9、17、25等等时就会崩溃。所报异常为：1java.util.Collections$SingletonList cannot be cast to java.util.ArrayList 很显然，强制转换的异常。起初真的是一脸懵逼啊，后面只能耐心解决问题，看到代码容易发现 toList 应该是问题所在。看下其源码：12345678910111213/** * Returns a [List] containing all elements. */public fun &lt;T&gt; Iterable&lt;T&gt;.toList(): List&lt;T&gt; &#123; if (this is Collection) &#123; return when (size) &#123; 0 -&gt; emptyList() 1 -&gt; listOf(if (this is List) get(0) else iterator().next()) else -&gt; this.toMutableList() &#125; &#125; return this.toMutableList().optimizeReadOnlyList()&#125; 当 size == 1 时调用的 listOf，继续跟：1234567/** * Returns an immutable list containing only the specified object [element]. * The returned list is serializable. * @sample samples.collections.Collections.Lists.singletonReadOnlyList */@JvmVersionpublic fun &lt;T&gt; listOf(element: T): List&lt;T&gt; = java.util.Collections.singletonList(element) 一目了然了，当 size 为 1 时，toList 方法会生成一个 singletonList，而这个 List 无法转化成 ArrayList，从而导致崩溃。嗯，我的内心也是崩溃的…后面将 toList 改成 toMutableList 即可。123456/** * Returns a [MutableList] filled with all elements of this collection. */public fun &lt;T&gt; Collection&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123; return ArrayList(this)&#125; 题外话关于 kotlin 的 var 变量，我们可能经常需要可以为 null 的类型。比如：1var data: List&lt;MyObject&gt;? = null 可以通过 ? 进行判空，或者直接使用 ?.let{} 在非 null 的时候执行某些代码。也可以加上 ?:run {} 来执行为 null 时的操作：1234567var data: List&lt;MyObject&gt;? = nulldata?.let &#123; maskView.visibility = View.VISIBLE&#125; ?: kotlin.run &#123; maskView.visibility = View.GONE&#125;","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://lijia92.github.io/tags/Kotlin/"}]},{"title":"Git data stream error","date":"2018-06-22T04:38:56.000Z","path":"2018/06/22/git-quesition/","text":"今天使用 Git 碰到个问题，在此小记一下。场景：git stash当前工作区，然后git pull --rebase: 然后执行git stash pop时报错。 执行git status也报错： Google 之后大致是因为 Git 记录一些文件的版本指针被损坏了。这个损坏可能不是人为的，可能你正在 push 或者 pull 一些文件的时候，电脑突然断电或者关机了，就可能会导致这个异常发生。至于为什么在我的场景中出现了这个问题，就不得而知了。下面来解决它，执行指令git fsck --full： 可以看到有问题的指针引用。这串字符串的前 2 位是你的.git/objects/文件夹下对应的文件夹目录，然后cd ./fe删除掉这个字符串，rm e91c5f...。 删除掉之后，回到工作目录，继续执行git fsck --full。 可以看到没有错误状态的 blob 或者 commit 了。此时 git 已经可以正常使用了。 再补充一下，指针的 hash 值可能由于某些原因出错了，需要重新生成 hash 值。1git hash-object -w spec/routing/splits_routing_spec.rb spec/routing/splits_routing_spec.rb 为对应的文件。 参考： git commit stopped working - Error building trees 在使用 Git pull 时候报错 error: inflate","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"常用代码和指令小结","date":"2018-05-28T09:23:32.000Z","path":"2018/05/28/practical-cmd/","text":"这篇文章主要总结一下日常开发中常用的一些代码和指令。 ADB 指令设置调试 App有些时候需要在应用启动的时候直接调试，如果设好断点然后Debug App重新编译运行会很慢，通过如下指令可以直接设置调试 App，然后设置断点后自动继续。1adb shell am set-debug-app -w com.example.appdebugsample 开启 GPU 过度绘制GPU 过度绘制的作用就不用多说了，直接指令开启，方便快捷。12adb shell setprop debug.hwui.overdraw showadb shell setprop debug.hwui.overdraw false INSTALL_FAILED_TEST_ONLY安装 Apk 出现这样的错误。看下 adb install 的所有参数：1234567891011121314app installation: install [-lrtsdg] PACKAGE install-multiple [-lrtsdpg] PACKAGE... push package(s) to the device and install them -l: forward lock application -r: replace existing application -t: allow test packages -s: install application on sdcard -d: allow version code downgrade (debuggable packages only) -p: partial application install (install-multiple only) -g: grant all runtime permissions uninstall [-k] PACKAGE remove this app package from the device '-k': keep the data and cache directories adb install 加上 -t 参数即可安装成功。1adb install -d -r \"apk path\" 降版本覆盖安装。1adb ( -s 设备名 ) install ( -r ) 文件名称.apk 当有多个设备时，使用 -s来指定设备，使用 -r 指定是否覆盖安装。 查看应用信息1adb shell dumpsys package com.example.appdebugsample 网络调试1234## 电脑USB连接手机adb tcpip 5555## 断掉USBadb connect 10.10.28.35（connect后面跟上手机的ip地址） 断开连接1adb disconnect 显示Task栈内activity信息1adb shell dumpsys activity activities | sed -En -e '/Running activities/,/Run #0/p' 快速获取当前Activity的名称：1adb shell dumpsys window windows | grep -E 'mCurrentFocus|mFocusedApp' --color=always Git 指令1git fetch origin branchname:branchname 拉取远程分支到本地分支或者创建本地新分支1git checkout origin/remoteName -b localName 获取远程分支remoteName 到本地新分支localName，并跳到localName分支1git push -u origin branchname 推送本地分支到远程分支1git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt; 重命名分支12345git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern&gt;] [-x | -X] [--] &lt;path&gt;...-d # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。-f # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。-i # 进入交互模式-n # 查看将要被删除的文件，并不实际删除文件 通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：1git clean -n 想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果clean.requireForce为false可以不加-f选项）：1git clean -f 想删除当前工作目录下的未跟踪文件以及文件夹运行：1git clean -df tag ：123456git tag tagName // 轻量级 tag，不带标注git tag -a tagName -m 'tag 说明' // 带标注的 taggit push origin --tags // 推送本地所有 tag 到远程仓库git push origin tagName // 推送某个 taggit tag -d tagName // 删除某个 taggit push origin :refs/tags/oldName 修复当前提交的错误：1git commit --amend 并不是直接修改原 commit 的内容，而是生成一条新的 commit。 123git stash applygit stash apply stash@&#123;2&#125;git config [–local|–global|–system] -l 本地所有修改的，没有的提交的，都返回到原来的状态：1git checkout . windows AS 安装 git for windows 2.16.2，cmd 控制台乱码。网上找了好多解决办法，都没法解决。最后只有降 git 版本。 http://blog.csdn.net/QasimCyrus/article/details/65628752 错误码定义的错误码如果无法做到每个 code 对应一个描述语，那么在 Toast 或 Dialog 展示错误时带上错误码，eg：ToastUtils.showShort(mContent, “登录失败（错误码：-8）”)，这样根据 -8 这个 code 很容易定位到问题。 适配全面屏在 AndroidManifest.xml 中添加最大屏幕高宽比：1&lt;meta-data android:name=\"android.max_aspect\" android:value=\"2.1\" /&gt; Android 标准接口中，支持应用声明其支持的最大屏幕高宽比（maximum aspect ratio）。具体声明如下，其中的 ratio_float 被定义为是高除以宽，以16:9为例，ratio_float = 16/9 = 1.778 (18.5:9则为2.056)。若开发者没有声明该属性，ratio_float 的默认值为1.86，小于2.056，因此这类应用在三星S8上，默认不会全屏显示，屏幕两边会留黑。 列表边界留白Android 上 ListView、GridView、RecyclerView 默认行都是置顶的，这样会很丑。一般为了解决这个问题都会在首行或尾行加上一个隐藏的View，那样实在是太麻烦了。 设置 ListView 或 GridView 的 android:clipToPadding ＝ false， 然后通过 paddingTop 和 paddingBottom 设置距离就好了。 TextView drawableRightTextView 在添加 drawableRight 等属性时，即使设置了居中也会有不对齐的现象，给它设置一个 includeFontPadding 为 false 的属性就好了。123456789101112&lt;TextView android:id=\"@+id/topic_detail_reward_amount_tv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginRight=\"12dp\" android:drawablePadding=\"4dp\" android:drawableRight=\"@drawable/saturn__income_coin\" android:gravity=\"center_vertical\" android:includeFontPadding=\"false\" android:textColor=\"#FF6B00\" android:textSize=\"15sp\" tools:text=\"+200\" /&gt; SeekBar 去掉滑块 thumb 周围的阴影，使用android:background=&quot;@null&quot;： 123456789&lt;com.xxxxxxx.widget.CustomSeekBar android:id=\"@+id/sb_light_bar\" android:layout_width=\"wrap_content\" android:layout_height=\"190.0px\" android:layout_centerInParent=\"true\" android:maxHeight=\"6dp\" android:background=\"@null\" android:progressDrawable=\"@drawable/video_light_seekbar\" android:thumb=\"@drawable/sele\" /&gt; seekbar默认两边会有间隙，导致不能符合预期效果。同时滑块可能会因为太大而显示不全，添加属性: 12345android:paddingStart=\"0dp\"android:paddingEnd=\"0dp\"&lt;!-- 滑块偏移 --&gt;android:thumbOffset=\"0dp\" thumb 的 icon 四周透明，但是显示效果不透明 1android:splitTrack=\"false\" https://www.jianshu.com/p/d7eb29d3d5c4 进度颜色控制： 第一进度条、第二进度条的位置不能更换，更换后第一进度条不能正常显示。 背景色不能添加clip标签，添加后不能正常显示。 第一、第二进度条若要正常显示，需要添加clip标签。 通过调整paddingLeft、paddingRight与thumbOffset来控制thumb的起点对齐、左右被遮盖。12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 背景色 --&gt; &lt;item android:id=\"@android:id/background\"&gt; &lt;shape&gt; &lt;solid android:color=\"#ececec\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 第二进度条，用于缓冲显示（？） --&gt; &lt;!--&lt;item android:id=\"@android:id/secondaryProgress\"&gt;--&gt; &lt;!--&lt;clip&gt;--&gt; &lt;!--&lt;shape&gt;--&gt; &lt;!--&lt;solid android:color=\"#dcdcdc\" /&gt;--&gt; &lt;!--&lt;/shape&gt;--&gt; &lt;!--&lt;/clip&gt;--&gt; &lt;!--&lt;/item&gt;--&gt; &lt;!-- 第一进度条，用于显示已执行的进度 --&gt; &lt;item android:id=\"@android:id/progress\"&gt; &lt;clip&gt; &lt;shape&gt; &lt;solid android:color=\"#86e7de\" /&gt; &lt;/shape&gt; &lt;/clip&gt; &lt;/item&gt;&lt;/layer-list&gt; https://www.jianshu.com/p/7f00c5361094 结合音乐一般是以秒为单位来设置播放进度。使用 1000d 浮点数进行运算，然后再用rint取最近的整数进行返回，这样显示的进度更平缓。对于暂停、续播，当检查播放器有暂停进度时，在续播开始时先 setProgress 一下。eg：1234seekBar.setMax(duration);double position = SingleAudioPlayer.getInstance().getCurrentPosition();seekBar.setProgress((int) Math.rint(position / 1000d));","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"快速画 UML 图","date":"2018-05-08T05:57:45.000Z","path":"2018/05/08/uml/","text":"这几天有个内部的技术分享，是公司要求的一个流程，需要针对某个功能模块进行讲解。在制作 PPT 的过程中，需要画 UML 图。起初使用的ProcessOn，画出来之后感觉没啥效果，类之间的关系不能明确表现出来，而且制作很麻烦，得自己一天天敲文字，调位置。后面接触到PlantUML，可以直接使用类似 Markdown 的模式进行编辑，然后直接渲染成一张图片，简直不要太舒服，所以很想分享给大家！ 看下两个软件作图的比较：ProcessOn：PlantUML：高下立判啊！当然，在用 PlantUML 绘图时又重新仔细思考了下类的结构，所以两张图在结构上不一样。使用 PlantUML，后续若需要维护，修改起来十分方便！但是貌似有个缺点：不能表示内部类,或者是我还没找到使用的方式。 顺道帖下 UML 图推荐的几种类关系。 继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 实现指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性； 依赖可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用； 关联他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量； 聚合聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 组合组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 对于继承、实现这两种关系没多少疑问，他们体现的是一种类与类、或者类与接口间的纵向关系；其他的四者关系则体现的是类与类、或者类与接口间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准备定位是很难的，前面也提到，这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系；但总的来说，后几种关系所表现的强弱程度依次为：组合&gt;聚合&gt;关联&gt;依赖。 参考Markdown 绘制 UML 图 – PlantUML + GravizoPlantUML 在线作图网址UML中几种类间关系","tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://lijia92.github.io/tags/奇技淫巧/"}]},{"title":"关于重构的一些实践","date":"2018-05-07T02:11:43.000Z","path":"2018/05/07/refactor/","text":"关于本文即将阐述的一些东西，其实我也不知道算不算得上重构，姑且就算吧。重构，是软件开发者始终绕不过的一道坎，尤其当你接手一个“年迈”项目的时候。首先介绍下项目背景：Android Core 是所有 Lib、App 都有依赖的。近期 Core 做了一次大版本升级，将许多Deprecated标记的方法、类都删掉了，同时内部代码做了重构，有些 Api、类名都有相应的修改。那么现在作为图中的 Saturn(Lib) 这个位置，在引用新版本的 Core 之后，如何重构代码，使之能够正常工作？下面针对我碰到的几个点，做一下说明。 包名修改重构针对迁移包路径的，算是改动量最小的了。直接全局搜索相应的包名，进行替换即可。注意：这里千万不要加上 import ，因为很有可能 Core 中自定义 View 也更换了包名，同时在 xml 中有引用，加上 import 是搜不出 xml 中的引用的。举个例子：cn.xxx.android.ui.framework.view.commonview.CommonViewPager -&gt; cn.xxx.android.core.widget.CommonViewPager。某某 xml 中：12345&lt;cn.xxx.android.ui.framework.view.commonview.CommonViewPager android:id=\"@+id/view_pager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_below=\"@+id/divider\" /&gt; 注意去掉图中的 import！ @Deprecated 类或方法删除一般我们标记一个类或者方法为 @Deprecated 时，都会指出它的替代方案，就像这样：这种情况就很简单了，根据替代方案进行相应修改即可。但是这个比较依赖人工注释，如若有同事忘记写这个了，那么就很头疼了：你不知道用什么方法来替代它。若能询问到标记 @Deprecated 的同事那也还好，万一同事离职了或他自己都忘记了，那如何处理呢？ 读懂代码，自己寻找替代方案 从 Core 中 copy 一份到自己的代码中 方案一只有在业务简单，逻辑清晰的情况下适用，当业务十分复杂，逻辑阅读起来也比较费力时，方案一的工作量就很庞大了。这个时候选择方案二合适点，后续有空再来优化。当然，这个后续有空可能就和明天一样，哈哈哈… 功能模块整个删除Core 之前有一套网络请求模块，在升级后，使用了另外一套，两套是完全不同的东西。但是在 Saturn 中很多网络请求仍然使用着旧的那套东西。碰到这种情况，目前想到的就只有 copy 了。其实对这种升级，我是很厌烦的，因为它完全不考虑兼容，强制所有用到 Core 的都进行整改，也不考虑其他同事的工作量，虽然它已经标记为 @Deprecated 很久了。 自定义 View碰到自定义 View 也给删除的，若没有替代方案，也只能 copy 代码了。但是自定义 View 的 copy 要多一步：资源文件。很多自定义 View 有自定义的属性或者样式之类的，这就要求你在 copy 代码同时，也要 copy 相应的资源文件。这里有个坑：Saturn 作为一个 Lib，如果原封不动的直接将文件 copy 过来，那么考虑一下 Venus。Venus 在兼容 Core 升级的时候，很有可能和 Saturn 采用同样的做法，那么两份相同的资源文件就会导致冲突了。这个冲突不是 Saturn 自身能测试得到的，只有在 Mercury App 进行集成的时候才会暴露出来。所以最好提前考虑一下，针对资源文件加上独有的前缀。比如：123456789101112131415161718192021222324&lt;declare-styleable name=\"RoundCornerButton\"&gt; &lt;attr name=\"round_button_radius\" format=\"dimension\" /&gt; &lt;attr name=\"round_button_radius_lt\" format=\"dimension\" /&gt; &lt;attr name=\"round_button_radius_rt\" format=\"dimension\" /&gt; &lt;attr name=\"round_button_radius_lb\" format=\"dimension\" /&gt; &lt;attr name=\"round_button_radius_rb\" format=\"dimension\" /&gt; &lt;attr name=\"round_button_bg_color\" format=\"color\" /&gt; &lt;attr name=\"round_button_elevation\" format=\"dimension\" /&gt; &lt;attr name=\"round_button_stroke_color\" format=\"color\" /&gt; &lt;attr name=\"round_button_stroke_width\" format=\"dimension\" /&gt;&lt;/declare-styleable&gt;&lt;!-- 改成如下 --&gt;&lt;declare-styleable name=\"saturn__RoundCornerButton\"&gt; &lt;attr name=\"saturn__radius\" format=\"dimension\" /&gt; &lt;attr name=\"saturn__radius_lt\" format=\"dimension\" /&gt; &lt;attr name=\"saturn__radius_rt\" format=\"dimension\" /&gt; &lt;attr name=\"saturn__radius_lb\" format=\"dimension\" /&gt; &lt;attr name=\"saturn__radius_rb\" format=\"dimension\" /&gt; &lt;attr name=\"saturn__bg_color\" format=\"color\" /&gt; &lt;attr name=\"saturn__elevation\" format=\"dimension\" /&gt; &lt;attr name=\"saturn__stroke_color\" format=\"color\" /&gt; &lt;attr name=\"saturn__stroke_width\" format=\"dimension\" /&gt;&lt;/declare-styleable&gt; 为了完全避免冲突，最好样式名、自定义属性名都加上前缀，如果过长可适当删减，同时记得修改自定义 View 中的引用。12345678910111213141516171819202122232425262728293031323334public RoundCornerButton(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); // 获取自定义的属性,设置相应背景 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.saturn__RoundCornerButton); try &#123; float allRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius, 0); float ltRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_lt, 0); float rtRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_rt, 0); float lbRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_lb, 0); float rbRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_rb, 0); int color = typedArray.getColor(R.styleable.saturn__RoundCornerButton_saturn__bg_color, 0); int strokeColor = typedArray.getColor(R.styleable.saturn__RoundCornerButton_saturn__stroke_color, 0); int strokeWidth = typedArray.getDimensionPixelOffset(R.styleable. saturn__RoundCornerButton_saturn__stroke_width, 0); float elevation = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__elevation, 0); drawable = new GradientDrawable(); drawable.setColor(color); if (allRadius == 0) &#123; drawable.setCornerRadii(new float[]&#123;ltRadius, ltRadius, rtRadius, rtRadius, rbRadius, rbRadius, lbRadius, lbRadius&#125;); &#125; else &#123; drawable.setCornerRadius(allRadius); &#125; if (strokeColor != 0) &#123; drawable.setStroke(strokeWidth, strokeColor); &#125; ViewCompat.setBackground(this, drawable); changeElevation(elevation); &#125; catch (Exception e) &#123; LogUtils.d(\"exception\", e); &#125; finally &#123; typedArray.recycle(); &#125;&#125; 小结针对这种重构，小结一下： 有替代方案直接上替代方案。 没有替代方案，在时间充足的情况下，可尝试读懂代码，自己寻找替代方案；若时间不充足则只能 copy 代码了。 注意自定义 View 相关内容。 在开发过程中，碰到 @Deprecated 标记的类或者方法尽早整改吧，不然万一哪天版本升级这个类或者方法没了，在量大的情况下，就很蛋疼了。 Saturn 作为一个 Lib，在对外提供 SDK 的情况下，最好不要删除、改变现有方法，尽量提供新的方法保证兼容。","tags":[{"name":"重构","slug":"重构","permalink":"http://lijia92.github.io/tags/重构/"}]},{"title":"使用 Charles 进行手机抓包","date":"2018-05-03T08:41:22.000Z","path":"2018/05/03/charles/","text":"开发中，我们经常会有抓包的需求。通过抓包，能一目了然请求的参数以及返回的数据是否符合预期，在定位问题的时候有很大的帮助作用。这里便写一下自己认为还不错的一个抓包工具Charles。 下载这个根据系统版本自行谷歌、百度吧。 连接 运行 Charles，点击 Proxy -&gt; Proxy Settings，设置代理端口（一般默认8888），然后勾选 Enable 的选项，点击 OK 结束设置。 运行 cmd 输入指令查看电脑 ip。 打开手机 Wlan 设置，将 Wifi 的代理设置成步骤 2 中的 ip 地址，及步骤 1 中的端口。 确定之后，电脑 Charles 就会弹出对话框，询问是否允许代理，勾选 Allow。 有些情况下，可能我们设置手机 Wlan 代理之后，一直不弹对话框。可能是 ip 已经存在导致的。点击 Proxy -&gt; Access Control Settings，可以进行连接设备的设置。 确认连接 OK 之后，手机上的网络请求都会走代理，到电脑的 Charles 上了，然后通过 Charles 就能看到具体的网络请求信息了。 断点可能某些情况下，我们需要手动修改 Request 或 Reponse 的值，这就需要断点了。 打开 Charles 调试开关。 右键需要断点的请求，勾选 Breakpoints。 可能这个请求带有 sign 这样的唯一参数，导致后面所有的请求都会不太一样，这时可以编辑断点，去掉相应的参数。 手机执行请求，Charles 会先拦截到 Request，这时可以修改请求的参数等等。修改结束之后点击下面的 Execute 发送请求。图中实例的请求没有传递什么参数，所以没什么数据。 请求返回成功之后会自动拦截返回的 Reponse，这时可以查看请求的内容，以及返回的具体 Reponse，也可进行相应的修改。 小结整个工具使用起来比较简单方便，也能实现基本的手机抓包需求，推荐使用。就是如果不注册的话，会经常在启动也暂停几秒到十几秒不等，可以购买支持一下，当然网上也有免费的激活账号，可以自行查阅。 Https 抓包公司生产环境的接口都是 https 的，不做配置就抓不到了。这里说一下小米手机配置 https 抓包的操作。 电脑 Charles 软件安装 SSL 证书。 手机下载 SSL 证书：浏览器打开图里的地址，下载文件，记录好下载路径。 打开手机安全与隐私设置，小米手机在「系统安全」设置中，然后选择「加密与凭据」，再选「从存储设备安装」。这时会打开文件管理器（可能需要先启用「文件」应用）。然后选择刚刚下载的路径，选择 pem 证书文件即可。 问题电脑升级到 win10 之后，抓包无效了，需要配置下网络入站规则。设置 -&gt; 网络和 Internet -&gt; windows 防火墙 -&gt; 高级设置 -&gt; 入站规则找到 Charles 相关的，找不到则新建一个规则，并允许连接。","tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://lijia92.github.io/tags/奇技淫巧/"}]},{"title":"Java HashSet 的原理","date":"2018-04-12T06:49:04.000Z","path":"2018/04/12/hashset/","text":"项目里有用到 HashSet 数据结构，之前几乎没怎么用过，只是了解一点，不能存放重复的元素。但是一直没有看过代码。今天基于这个契机，看了下代码研究了下内在原理。颇有感触，在此记录一下。 当看到 HashSet 的代码时，瞅了一眼，算上注释竟然不足 400 行。可以说，整个 HashSet 最重要的便是它的构造函数了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private transient HashMap&lt;E,Object&gt; map;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;/** * Constructs a new set containing the elements in the specified * collection. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor * (0.75) and an initial capacity sufficient to contain the elements in * the specified collection. * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and default load factor (0.75). * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;/** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.) The backing * HashMap instance is a LinkedHashMap with the specified initial * capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @param dummy ignored (distinguishes this * constructor from other int, float constructor.) * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 怎么样，一目了然了吧？HashSet 特喵的就是用的 HashMap 来实现的。那么 HashSet 如何避免元素被重复添加呢？看下 add 方法：123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 简短得不能再短。看下 PRESENT 是什么：12// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object(); 看到这就清楚了。这个 PRESENT 对象全局就只会有一个，当我们的 obejct 作为 map 的 key 时，通过 map 的 put 方法进行添加。如果 object 是一样的，那么 key 就是一样，map 通过这个 key 会找到 PRESENT 对象，这个对象和我们 add 传入的是一个对象，那么 map 就会认为元素已经存在，不再进行重复插入了。如此便实现了 Set 集合的不重复元素功能。 最后看下 HashSet 的迭代器：123public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 意料之中！ 所以啊，在做某些东西的时候，可以先思考，如何利用现有的东西。某些构思、想法真的是很奇妙，多看源码！！！","tags":[{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"}]},{"title":"异步任务的原生实现","date":"2018-03-28T09:14:56.000Z","path":"2018/03/28/async-task-model/","text":"现在谈到异步任务，相信大多数开发者都会直接选择 RxJava，但是仍然会有不用 RxJava 的项目。这种情况下如何来做异步任务呢？ 其实不论是 RxJava 抑或是 Android 自带的 AysncTask，内部实现原理都是 Thread + Handler。如果线程想要返回 Result，那么只能使用 Callable来实现子线程，AsyncTask 便是使用的 Callable。 下面说下项目中的使用场景：一个界面由一个列表构成，但列表的构成十分复杂，item type 很多，需要请求多个网络接口来返回所需要的数据。网络接口请求互相独立，没有依赖关系，可使用多线程进行请求。如果使用 Android 提供的 AsyncTask，则在 doInBackground 依次执行网络接口，就丧失了多线程的优势，当然你也可以在 doInBackground 再起子线程执行网络请求，然后在返回的时候使用阻塞，等到所有接口执行完毕才返回，原理其实是一样的。 下面说下项目中的做法： 创建一个全局的线程池，用来执行异步任务。 12private static ExecutorService es;es = Executors.newFixedThreadPool(10); 封装一个任务队列类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class BatchTask &#123; private List&lt;Future&gt; futureList; private TaskCallback callback; public BatchTask(TaskCallback callback) &#123; futureList = new LinkedList&lt;&gt;(); this.callback = callback; &#125; public BatchTask addTask(Callable task) &#123; if (task != null) &#123; futureList.add(es.submit(task)); &#125; return this; &#125; public void getResult() &#123; for (Future future : futureList) &#123; try &#123; if (callback != null) &#123; callback.onCallback(future.get()); &#125; &#125; catch (Exception e) &#123; LogUtils.d(BatchTask.class.getSimpleName(), e); &#125; &#125; &#125; public interface TaskCallback &#123; void onCallback(Object object); &#125; public static class MyTaskCallback implements TaskCallback &#123; private List&lt;Object&gt; dataList; public MyTaskCallback() &#123; this.dataList = new ArrayList&lt;&gt;(); &#125; @Override public void onCallback(Object object) &#123; if (object == null) &#123; return; &#125; if (object instanceof List) &#123; List list = (List) object; if (CollectionUtils.isNotEmpty(list)) &#123; dataList.addAll(list); &#125; &#125; else &#123; dataList.add(object); &#125; &#125; public List&lt;Object&gt; getDataList() &#123; return dataList; &#125; &#125;&#125; 添加任务： 12345678batchTask = new BatchTask();batchTask.addTask(task1);batchTask.addTask(task2);...batchTask.getResult();callback.getDataList(); 使用的时候，先创建一个子线程，然后调用 addTask，线程池就会去执行这个任务了，但是当要获取 Result 时，由于 future.get() 是一个阻塞方法，它会一直等待任务执行结束才会返回结果，所以返回的数据顺序和我们 addTask 的顺序一致。同时使用一个 dataList 来接受这些返回的结果，这样的话在拿到数据之后不用再手动进行排序了。然后利用 Handler 将数据发送到主线程进行展示即可。可以看出来，就和 AsyncTask 差不多！ 其实就和开头说的一样，异步任务的实质就是 Thread + Handler。只不过目前有一些封装的异步任务库，导致对其底层实现的原理不是很清晰。现在这个项目里，就是使用原生的一些东西，看起来就更加明朗、深刻了。当然了，原生的或者 AsyncTask 写起来确确实实不如 RxJava 来得简洁方便了，尤其涉及到多任务、数据变换的时候。所以，能用 RxJava 就还是用 RxJava 吧。","tags":[{"name":"code","slug":"code","permalink":"http://lijia92.github.io/tags/code/"}]},{"title":"面试资料整理","date":"2018-03-23T09:25:20.000Z","path":"2018/03/23/interview/","text":"离职之后，从深圳回到武汉，当然还是得找工作的。这里就整理一下我看过的有帮助的的一些资料。面试的时候可能一些知识你都知道，但是不成章法，不能流利的说出来，这里就得多加练习了。自己对照着面试题目进行回答，练习口才。 面试超详细Android面试的准备与经历分享 | 百度(offer)阿里、腾讯、百度、华为、京东、搜狗和滴滴最新面试题汇集我所经历的Android面试BAT大厂面试题整理 HanlderAndroid Handler消息机制实现原理Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ 线程池Android开发——Android中常见的4种线程池 透过单例模式看 Java 并发那些年，我们一起写过的“单例模式”Java 并发编程：volatile的使用及其原理漫画：什么是 CAS 机制？漫画：什么是CAS机制？（进阶篇）漫画：什么是volatile关键字？Java 中的多线程你只要看这一篇就够了 Java 中的枚举java枚举类型的实现原理从一道面试题开始说起 枚举、动态代理的原理 JVM 内存模型 &amp; GCJVM结构、GC工作机制详解 BinderBinder的设计和框架为什么 Android 要采用 Binder 作为 IPC 机制？ 类的加载机制 &amp; 插件化Android动态加载基础 ClassLoader工作机制Android中的ClassLoader热修复入门：Android 中的 ClassLoader 集合Java 8系列之重新认识HashMapLinkedHashMap 的实现原理图解HashMap(一)/)Android内存优化（使用SparseArray和ArrayMap代替HashMap） 事件分发：安卓自定义View进阶-事件分发机制原理安卓自定义View进阶-事件分发机制详解 自定义 View：给高级 Android 工程师的进阶手册安卓自定义View教程目录","tags":[{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"}]},{"title":"好久不见","date":"2018-03-16T08:07:56.000Z","path":"2018/03/16/long-time-no-see/","text":"好久没更新博客了，今天抽空写点东西。最近一篇博客，讲的是怎么拷贝代码，那为什么会有这样一篇文章呢？ 嘿嘿，2018 年 2 月 9 号，我离职了。在公司呆了有段时间了，觉得公司技术其实是很不错的，可惜发展不太好。前期融资的钱烧得差不多了，却仍然没有创造合理的商业模式进行营利，导致公司很难运营下去，也很难继续拉到投资。公司开始拖欠工资，后面很多员工都陆续离职了。我呢，想着可能还有点机会，一直继续干。但是坚持到年底仍然没什么起色，心灰意冷，就只能离职了。 2017 年是我在深圳呆的第 3 个年头了，前面 2 年同学之间经常吃吃喝喝打打照面，觉得深圳就是家，不会有孤独感。但是 17 年开始，同学谈朋友的谈朋友，忙的忙，一些同学一年下来见不到 2 回，每逢周末屋子里经常就我 1 个，已经 1 个人看了不下 20 场电影了，强烈的孤独感油然而生。 孤独是一个人的旅行，我们必须经历，成为更好的自己。 经历过孤独之后，有没有成为更好的自己我不知道，我只知道：我想家了。家里的父母日渐年迈，自己却不曾在家照顾，从大学开始就基本是一年才回一次家，内心满是歉疚，回家吧，回家吧。 2017 年经历的一些都不是什么好事：行情的饱和、创业的艰辛、朋友间的来来去去…但这些既然发生了，那就是我该要去经历的，一帆风顺也不见得是什么好事。 年轻的时候，总想着能干出一番大事，但经历过一些事情之后，却觉得平平淡淡才是真。今年看一部电影《天才少女》，一位智力过人的天才少女，母亲自杀，最后由舅舅和外婆来争夺抚养权。舅舅只想让孩子过普通人生活，外婆要将小女孩培养成数学天才。两种价值观的冲突，你很难说哪种是对的，哪种是错的。 教育就像悖论，等到当事人明白什么是最适合自己的方式的时候，已经在他人安排好的人生路上走得太久，无法回头。 想想现在自己脚下的路是他人安排的吗？不，不是的，这就够了。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"解锁拷贝代码的新姿势","date":"2018-01-22T07:13:26.000Z","path":"2018/01/22/code-copy/","text":"作为程序员，我们总会有各种拷贝代码的需求，例如现场部署，基友探讨，亦或是 公司电脑 -&gt; 自家电脑 等等。最最无脑的就是直接硬盘拷贝了，复制代码文件夹或压缩文件，直接拷贝到自己的硬盘或 U 盘里。但是作为安卓开发，如果要拷贝安卓代码，那就很费劲了。因为 Android Studio 会生成各种与代码无关的文件，尤其是 build 文件夹，有些时候代码可能就一两百兆，但是 build 文件夹就能有大几百兆甚至上 G 了。当然我们可以先 clean，然后再拷贝，但是如果项目复杂，多个工程多个 Module 互相依赖的，那就得每个 Module 都执行一遍 clean 了，想想那有多繁杂。 现在大多的代码版本控制都是采用的 Git，我们需要的其实就只是代码文件，其他的一概不需要，而 Git 内部的 .gitignore 不是正好对应我们的需求吗？所以，我们得从版本控制的角度来拷贝代码。相信大多数公司项目的代码都是私有仓库，只能在公司内网访问到。但我们可以给代码添加远程仓库 origin，这个 origin 可以指到 Github 或自己搭建的 Git 服务器，但是如果是公司代码是不建议这么做的，泄密了嘛～若是自己写的小工具，三方库倒是没什么影响，但这也不是本文要说的重点。 今天就说一下利用 Git 拷贝代码的新姿势，SVN 或其他版本控制工具不在此文范围之内。其实就是一个 Git 命令：git bundle。 来看看一个简单的例子。 假设你有一个包含两个提交的仓库：123456789101112$ git logcommit 9a466c572fe88b195efd356c3f2bbeccdb504102Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Wed Mar 10 07:34:10 2010 -0800 second commitcommit b1ec3248f39900d2a406049d762aa68e9641be25Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Wed Mar 10 07:34:01 2010 -0800 first commit 然后利用git bundle指令来打包：123456$ git bundle create repo.bundle HEAD masterCounting objects: 6, done.Delta compression using up to 2 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 441 bytes, done.Total 6 (delta 0), reused 0 (delta 0) 然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。 在使用 bundle 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。 你可以将这个 repo.bundle 文件通过邮件或者U盘传给别人。 另一方面，假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。 你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。123456$ git clone repo.bundle repoInitialized empty Git repository in /private/tmp/bundle/repo/.git/$ cd repo$ git log --oneline9a466c5 second commitb1ec324 first commit 如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 -b master 或者其他被引入的分支，否则 Git 不知道应该检出哪一个分支。 如此，拿着生成的打包文件便可随时随地的拷贝代码了。 另外，我们可以只打包部分 commit。现在假设你提交了 3 个修订，并且要用邮件或者U盘将新的提交放在一个包里传回去。123456$ git log --oneline71b84da last commit - second repoc99cf5b fourth commit - second repo7011d3d third commit - second repo9a466c5 second commitb1ec324 first commit 首先我们需要确认我们希望被打包的提交区间。 和网络协议不太一样，网络协议会自动计算出所需传输的最小数据集，而我们需要手动计算。 当然你可以像上面那样将整个仓库打包，但 最好仅仅打包变更的部分 —— 就是我们刚刚在本地做的 3 个提交。 为了实现这个目标，你需要计算出差别。 就像我们在 提交区间 介绍的，你有很多种方式去指明一个提交区间。 我们可以使用 origin/master..master或者master ^origin/master之类的方法来获取那 3 个在我们的 master 分支而不在原始仓库中的提交。 你可以用 log 命令来测试。1234$ git log --oneline master ^origin/master71b84da last commit - second repoc99cf5b fourth commit - second repo7011d3d third commit - second repo 这样就获取到我们希望被打包的提交列表，让我们将这些提交打包。 我们可以用 git bundle create 命令，加上我们想用的文件名，以及要打包的提交区间。123456$ git bundle create commits.bundle master ^9a466c5Counting objects: 11, done.Delta compression using up to 2 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (9/9), 775 bytes, done.Total 9 (delta 0), reused 0 (delta 0) 现在在我们的目录下会有一个 commits.bundle 文件。 如果我们把这个文件发送给我们的合作者，她可以将这个文件导入到原始的仓库中，即使在这期间已经有其他的工作提交到这个仓库中。 当她拿到这个包时，她可以在导入到仓库之前查看这个包里包含了什么内容。 bundle verify 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。123456$ git bundle verify ../commits.bundleThe bundle contains 1 ref71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/masterThe bundle requires these 1 ref9a466c572fe88b195efd356c3f2bbeccdb504102 second commit../commits.bundle is okay 如果打包工具仅仅把最后两个提交打包，而不是三个，把指令中 commit 改为 7011d3d，原始的仓库是无法导入这个包的，因为这个包缺失了必要的提交记录。这时候 verify 的输出类似：123$ git bundle verify ../commits-bad.bundleerror: Repository lacks these prerequisite commits:error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo 而我们的第一个包是合法的，所以我们可以从这个包里提取出提交。 如果你想查看这边包里可以导入哪些分支，同样有一个命令可以列出这些顶端：12$ git bundle list-heads ../commits.bundle71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master verify 子命令同样可以告诉你有哪些顶端。 该功能的目的是查看哪些是可以被拉入的，所以你可以使用 fetch 或者 pull 命令从包中导入提交。 这里我们要从包中取出 master 分支到我们仓库中的 other-master 分支：123$ git fetch ../commits.bundle master:other-masterFrom ../commits.bundle * [new branch] master -&gt; other-master 可以看到我们已经将提交导入到 other-master 分支，以及在这期间我们自己在 master 分支上的提交。12345678$ git log --oneline --decorate --graph --all* 8255d41 (HEAD, master) third commit - first repo| * 71b84da (other-master) last commit - second repo| * c99cf5b fourth commit - second repo| * 7011d3d third commit - second repo|/* 9a466c5 second commit* b1ec324 first commit 因此，当你在没有合适的网络或者可共享仓库的情况下，git bundle 很适合用于共享或者网络类型的操作。 小插曲注意打包命令git bundle create commits.bundle master ^9a466c5中的 ^ 符号，做了几次实验，若没有这个符号，打出来的包都可以通过验证。并且这个包是包含了所有提交的 bundle，没有增量 commits，所以这个符号在打增量 commits 包时一定不能忘。12345➜ git git:(master) ✗ git bundle verify 6.bundle这个包中含有这个引用：31814aab295f73d45130b7278c4b03656f1d75cd refs/heads/master这个包记录一个完整历史。6.bundle 可以 之前买了凯哥的《Git 原理详解及实用指南》，第二章里有一个图：之前一直搞不懂偶尔那条线是怎么来实现的，加群询问也没什么答案，现在算是知道了。同事之间直接利用打包指令，生成打包文件，利用这个文件来直接交互。 关于 Git 的更多讲述，请参考官方文档。","tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://lijia92.github.io/tags/奇技淫巧/"}]},{"title":"2017","date":"2018-01-19T15:14:57.000Z","path":"2018/01/19/summary-2017/","text":"已然 2018 年了，想想过去的一年里，竟然没有一丁点想要写下来的东西。曾经满腔热血，不甘平凡的我，竟也被岁月磨平了棱角变得平淡，无趣。但理想总是该缅怀一下的，或许某一天你会有了力量，风雨兼程，勇往前行。 《理想》作曲 : 赵雷作词 : 赵雷一个人住在这城市为了填饱肚子就已精疲力尽还谈什么理想那是我们的美梦 梦醒后 还是依然奔波在风雨的街头有时候想哭就把泪 咽进一腔热血的胸口 公车上我睡过了车站一路上我望着霓虹的北京我的理想把我丢在这个拥挤的人潮车窗外已经是一片白雪茫茫 又一个四季在轮回而我一无所获的坐在街头只有理想在支撑着那些麻木的血肉 理想今年你几岁你总是诱惑着年轻的朋友你总是谢了又开 给我惊喜又让我沉入失望的生活里 公车上我睡过了车站一路上我望着霓虹的北京我的理想把我丢在这个拥挤的人潮车窗外已经是一片白雪茫茫 又一个四季在轮回而我一无所获的坐在街头只有理想在支撑着那些麻木的血肉 理想今年你几岁你总是诱惑着年轻的朋友你总是谢了又开 给我惊喜又让我沉入失望的生活里 又一个年代在变换我已不是无悔的那个青年青春被时光抛弃已是当父亲的年纪 理想永远都年轻你让我倔强地反抗着命运你让我变得苍白却依然天真的相信花儿会再次的盛开 阳光之中 到处可见奔忙的人们被拥挤着 被一晃而飞的光阴忽略过","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"Kotlin 结合 RxJava 使用杂谈","date":"2018-01-11T09:01:36.000Z","path":"2018/01/11/talk/","text":"相信现在越来越多的开发者都在使用 RxJava 和 Kotlin，当二者相遇，写出来的代码堪称优雅！ 我对 Kotlin 的并没有很特别的感觉，它就类似于 Swift 相比于 OC，大量的语法糖着实能使写代码的效率变高，但是是否能左右 Android 开发的现状还未可知。 我之前写过这样一段话，在使用 Kotlin 的这段时间里，我对它的看法慢慢改变了。尤其引入 RxJava 后，结合 Lambda 表达式，写起代码简直像要飞起来！ 早些时候，我们查询数据，调用网络接口都是通过 Thread + Handler，或者 Android 自己封装的 AsyncTask，再或者 CursorLoader 等等，只要涉及要到异步，代码写起来都十分繁琐。首先你得实现 AsyncTask 或 CursorLoader 的接口，然后在子线程写数据读取的逻辑，然后通过 Handler 或者发送广播来通知界面显示。噢，现在想起来就觉得头大。然后 RxJava 的出现解放了我们，引入 RxJava 后，整个操作都变得十分简单，代码逻辑也十分清晰，相信用过的人都知道。然后结合 Kotlin 的语法糖，写起代码来简直不要太爽！举个栗子： M 层封装的数据操作： 12345678910fun queryAllSkuValue(): Observable&lt;List&lt;SKUValue&gt;&gt; &#123; return Observable .create(ObservableOnSubscribe&lt;List&lt;SKUValue&gt;&gt; &#123; e -&gt; read &#123; srvMgr -&gt; e.onNext(srvMgr.skuService.queryAllSKU().toList()) &#125; e.onComplete() &#125;) .compose(applySchedulers())&#125; Presenter 调用接口，获取数据，处理数据： 12345678910111213fun querySkuBean() &#123; compositeDisposable.add( skuProvider.queryAllSkuValue() .map &#123; SkuBean.newSkuBean(it) &#125; .subscribe(&#123; view?.showProductSkuBean(it) &#125;, &#123; view?.showError(msgOrError(it, \"数据查询失败\")) &#125;) )&#125; 可以看到，RxJava 结合 Kotlin 使我们的代码异常干净，清晰。RxJava 的 map、flatMap 等等的操作符，结合起 Lambda 表达式，真的太简洁了！当然，如果仅仅是 Lambda，你使用 Java 8 也是可以的。但是 Kotlin 还提供了很多其他的特性，之前也写文章说过。我之前小看了 Kotlin，它提供的很多操作符不仅可以减少代码量，也可以提高阅读性。比如 filter 操作符：12345678910111213141516171819202122232425262728293031// 代码1private void searchCuisineByCategory(String sortText) &#123; List&lt;Product&gt; productList = new ArrayList&lt;&gt;(); if (CONDITION_ALL.equalsIgnoreCase(sortText)) &#123; productList.addAll(getProductList()); &#125; else &#123; for (ProductBean productBean : mCuisineBeanList) &#123; String categoryName = productBean.product.type; if (!TextUtils.isEmpty(categoryName) &amp;&amp; categoryName.equals(sortText)) &#123; productList.add(productBean.product); &#125; &#125; &#125; mSoldOutAdapter.setProductList(productList);&#125;// 代码2fun searchByCategory(sortText: String) &#123; val list = ArrayList&lt;Product&gt;() if (CONDITION_ALL.equals(sortText, ignoreCase = true)) &#123; list.addAll(productList) &#125; else &#123; productList .filter &#123; val categoryName = it.type sortText == categoryName &#125; .mapTo(list) &#123; it &#125; &#125; view?.showProductList(list)&#125; 代码有些许调整，但是业务逻辑都是筛选。对比代码，显然代码2的清晰多了。代码1通过循环遍历列表，然后查找对应条件的数据，你必须跟入到代码内部才知道这段代码的意义。而代码2，当你看到 filter 就能知道：哦，这是个筛选条件，用于过滤数据，就能一下明白代码的含义。可能刚开始使用时需要先了解一下，但是当熟悉后，就能一下子读懂代码的含义了。其实说白了，Kotlin 提供那么多操作符，就是来精简代码的，让你看到这个操作符就能一下明白代码的大致意思了。当然这仅仅是个例子，就在昨天的开发场景中，我使用了大量的 RxJava 以及 Kotlin，写代码的心情十分愉悦！但是目前对于 RxJava 还不算特别掌握，此篇文章只是随便谈一谈，后续会再专门写写 RxJava。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"Android 获取 BuildConfig 信息","date":"2018-01-04T01:36:15.000Z","path":"2018/01/04/build-config/","text":"项目开发中，我们的 App 这个 Module 定义了3个 buildType：1234567891011buildTypes &#123; release &#123; buildConfigField(\"Integer\", \"HOST_TYPE\", '0') &#125; debug &#123; buildConfigField(\"Integer\", \"HOST_TYPE\", '1') &#125; beta &#123; buildConfigField(\"Integer\", \"HOST_TYPE\", '2') &#125;&#125; 通过参数 HOST_TYPE 来指定数据的环境。debug 为内网测试版，beta 为外网测试版，release 为正式版本。项目有3个产品线：手机、POS机、收银机，Module 的依赖是这样的：App 作为 Application，其他作为 Library。 现在需要在收银机登录页打上版本的标识，方便调试（因为经常搞混…）。例如 v3.1.0(debug)，v3.1.0(beta)，正式版本则是 v3.1.0。那么现在就需要在收银机 Module 中获取 BuildConfig 的信息，一个是 BuildConfig.DEBUG，以及 BuildConfig.BUILD_TYPE。但是无论我 App 切换成 debug，beta，还是 release，收银机中获取到的值都是BuildConfig.DEBUG = false，BuildConfig.BUILD_TYPE = &quot;release&quot;。可以看出来，BuildConfig 信息是根据当前 Module 来的，每个 Module 的 BuildConfig 是各自进行配置的。而作为 Library Module，我们直接把 debug 给忽略了，所以 Library Module 一直是 release 版本。123456variantFilter &#123; variant -&gt; def buildType = variant.buildType.name if (buildType.contains(\"debug\")) &#123; setIgnore(true) &#125;&#125; 那么 如何在 Library Module 获取 App Module 中的 BuildConfig 信息呢？ 方案一Library Module 进行与 App Module 一样的 buildType 设置。然后 App 的依赖就像这样：12345dependencies &#123; releaseCompile project(path: ':Library', configuration: 'release') debugCompile project(path: ':Library', configuration: 'debug') betaCompile project(path: ':Library', configuration: 'beta')&#125; 这当然可以解决问题，但是 Library 添加多个编译类型无疑会加长编译时间，而且所有 buildVariant 都得进行配置，侵入性太强，不可取。 方案二使 Library Module 能够 import 到外层真正运行 App 的 BuildConfig，如下：12345678910111213141516171819202122public class AppUtils &#123; private static Boolean isDebug = null; public static boolean isDebug() &#123; return isDebug == null ? false : isDebug.booleanValue(); &#125; public static void syncIsDebug(Context context) &#123; if (isDebug == null) &#123; try &#123; String packageName = context.getPackageName(); Class buildConfig = Class.forName(packageName + \".BuildConfig\"); Field DEBUG = buildConfig.getField(\"DEBUG\"); DEBUG.setAccessible(true); isDebug = DEBUG.getBoolean(null); &#125; catch (Throwable t) &#123; // Do nothing &#125; &#125; &#125;&#125; 通过反射得到真正执行的 Module 的 BuildConfig，在自己的 Application 内调用：1AppUtils.syncIsDebug(getApplicationContext()); 这样看起来达到目的了。但仔细想想会发现这种解决方案还是有问题，因为 BuildConfig.java 的 packageName 是 Module 的 Package Name，即 AndroidManifest.xml 中的 package 属性，而 context.getPackageName() 得到的是应用的 applicationId，这个 applicationId 通过 build.gradle 是可以修改的。所以当 build.gradle 中的 applicationId 与 AndroidManifest.xml 中的 package 属性不一致时，上面的反射查找类路径便会出错。而恰恰项目中利用了 gradle 配置的 applicationId，所以此方案也不可取。 方案三AppCommon 中新建一个类，利用这个类保存 App Module 中的 BuildConfig 信息。12345678910111213141516171819202122232425public class BuildTypeHelper &#123; /** * 是否可调试 */ private static boolean mIsDebug = false; /** * 编译类型：debug、beta、release */ private static String mBuildType = \"\"; public static void init(boolean isDebug, String buildType) &#123; mIsDebug = isDebug; mBuildType = buildType; &#125; public static String getBuildType() &#123; return mBuildType; &#125; public static boolean isDebug() &#123; return mIsDebug; &#125;&#125; 然后在 App Module 中的 Application 初始化时进行赋值：12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); BuildTypeHelper.init(BuildConfig.DEBUG, BuildConfig.BUILD_TYPE); &#125;&#125; 然后在 Library Module 中取值使用：12345if (BuildTypeHelper.isDebug()) &#123; mVersionTv.setText(String.format(\"v%s(%s)\", AppUtils.getCurrentVersionName(this), BuildTypeHelper.getBuildType()));&#125; else &#123; mVersionTv.setText(String.format(\"v%s\", AppUtils.getCurrentVersionName(this)));&#125; 再说一点如果只是想获取 BuildConfig.DEBUG，可以使用 ApplicationInfo.FLAG_DEBUGGABLE。我们反编译 Debug 包和 Release 包对比看看有没有其他的区别，会发现他们 AndroidManifest.xml 中 Application 节点的 android:debuggable 值是不同的。Debug 包值为 true，Release 包值为 false，这是编译自动修改的。123456789101112131415public class AppUtils &#123; private static Boolean isDebug = null; public static boolean isDebug() &#123; return isDebug == null ? false : isDebug.booleanValue(); &#125; public static void syncIsDebug(Context context) &#123; if (isDebug == null) &#123; isDebug = context.getApplicationInfo() != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; &#125; &#125;&#125; 在自己的 Application 内调用进行初始化：1AppUtils.syncIsDebug(getApplicationContext()); 这样以后调用 AppUtils.isDebug() 即可判断是否是 Debug 版本，比如在上面的 LogUtils 中。同时适用于 Module 是 Lib 和 applicationId 被修改的情况，比 BuildConfig.DEBUG 靠谱的多。这个方案有个注意事项就是自己 App Module 中不能主动设置 android:debuggable，否则无论 Debug 还是 Release 版会始终是设置的值。当然本身就没有自动设置的必要。但是因为本例中还需要获取 BuildConfig.BUILD_TYPE，所以没有采取此方案。 参考Android Debug 版本判断及为什么 BuildConfig.DEBUG 始终为 falseAndroidStudio多模块编译之子模块的调试","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"关于 MVP 模式的一点思考（续）","date":"2017-12-22T02:04:41.000Z","path":"2017/12/22/mvp-2/","text":"之前有一个关于 MVP 的疑惑：1个 Presenter 能否对应多个 View？，在我的这篇文章中有写过。现在回过头来仔细想想，感觉有点不对劲：1个 Presenter 为什么会有对应多个 View 的需求呢？那篇文章中的使用场景是： 我有 A B C 三个页面，我有一个 Presenter，用来处理一个数据类型的增删改查，但是界面上，A界面只需要查询，B界面只需要删除，C界面只需要增和改。 我们都知道，Presenter 是用来抽离 Activity 或 Fragment 中的业务代码的，何为业务代码？就是这个页面涉及到的业务逻辑。关于数据的增删改查，那是 M 应该做的事，而绝不是 Presenter 该去处理的。 所以，Presenter 应当只对应一个 View，如果有界面复用 Presenter 的情况，那我们得考虑为什么会有这种情况呢？复用 Presenter 代表着业务逻辑是一致的，不同的页面理当有着不同的业务逻辑。当然，这里说的业务是简单，最小颗粒化的业务，如果一个页面十分复杂，Presenter 中集合了大量业务代码，那么在某些小的页面是有可能复用 Presenter 中的部分业务代码的。所以这种情况下，Presenter 会对应多个 View，那么这个场景使用上篇文章中的做法是可以的：复用 Presenter，将 View 抽离，利用继承实现多个界面的定制需求，但不会是上篇文章中的那种使用场景。 为什么会有上篇文章中的场景呢？因为目前项目中的 Presenter 做了 M 该做的事，举个栗子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class PrinterPresenter extends AbsPresenter implements IPrinterPresenter, LoaderManager.LoaderCallbacks&lt;Cursor&gt; &#123; private IView mView; private AddOrUpdatePrinterTask mAddOrUpdateTask; private DeletePrinterTask mDeleteTask; public PrinterPresenter(@NonNull IView view) &#123; super(view); this.mView = view; &#125; @Override public void loadTemplates() &#123; mLoaderManager.initLoader(AppConst.LOADER_ID.PRINTER_TEMPLATE, bundle, this); &#125; @Override public void loadPrinters() &#123; mLoaderManager.initLoader(AppConst.LOADER_ID.PRINTER_INFO, null, this); &#125; @Override public void destroyLoader() &#123; mLoaderManager.destroyLoader(AppConst.LOADER_ID.PRINTER_INFO); mLoaderManager.destroyLoader(AppConst.LOADER_ID.ALL_INVENTORY_TYPE_ID); &#125; @Override public void savePrinter(PrinterInfo printerInfo) &#123; mAddOrUpdateTask = new AddOrUpdatePrinterTask(mContext, printerInfo); mAddOrUpdateTask.execute(); &#125; @Override public void deletePrinter(PrinterInfo printerInfo) &#123; mDeleteTask = new DeletePrinterTask(mContext, printerInfo); mDeleteTask.execute(); &#125; @Override public void onDestroyView() &#123; mView = null; destroyLoader(); super.onDestroyView(); &#125; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) &#123; CursorLoader cursorLoader = null; if (id == AppConst.LOADER_ID.PRINTER_INFO) &#123; cursorLoader = new CursorLoader(mContext, MMRContract.Printer.getContentUri(mContext.getPackageName()), null, null, null, null); &#125; else if (id == AppConst.LOADER_ID.PRINTER_TEMPLATE) &#123; cursorLoader = new CursorLoader(mContext, MMRContract.Printer.getTemplateContentUri(mContext.getPackageName()), null, selection, new String[]&#123;version, logoVersion&#125;, null); &#125; return cursorLoader; &#125; @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) &#123; int id = loader.getId(); switch (id) &#123; case AppConst.LOADER_ID.PRINTER_INFO: if (mView != null &amp;&amp; mView instanceof IPrinterInfoView) &#123; ((IPrinterInfoView) mView).showPrinters(printerList); &#125; break; case AppConst.LOADER_ID.ALL_INVENTORY_TYPE_ID: if (mView != null &amp;&amp; mView instanceof IPrinterSetView) &#123; ((IPrinterSetView) mView).showAllCategories(categories); &#125; break; case AppConst.LOADER_ID.PRINTER_TEMPLATE: // do something break; &#125; &#125; @Override public void onLoaderReset(Loader loader) &#123; &#125; private class AddOrUpdatePrinterTask extends AsyncTask&lt;Void, Void, Uri&gt; &#123; // 添加或更新打印机异步任务 &#125; private class DeletePrinterTask extends AsyncTask&lt;Void, Void, Integer&gt; &#123; // 删除打印机异步任务 &#125;&#125; 代码做了精简，表达出意思即可。可以看到，Presenter 实现了 LoaderManager.LoaderCallbacks 接口，（项目中数据的获取大部分是采用的 CursorLoader 来实现的），然后看到对应的 ContentProvider，根据不同的 uri 进行相应的增删改查：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class PrinterProviderHelper extends BaseProviderHelper &#123; private UriMatcher mUriMatcher; private static final int CODE_PRINTER = 1; private static final int CODE_PRINTER_TEMPLATE = 2; private static final int CODE_PRINTER_ACTIVE_INFO = 3; public PrinterProviderHelper(Context ctx, String authority) &#123; super(ctx); mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); mUriMatcher.addURI(authority, MMRContract.Printer.PATH_PRINTER_TEMPLATE, CODE_PRINTER_TEMPLATE); mUriMatcher.addURI(authority, MMRContract.Printer.PATH_PRINTER, CODE_PRINTER); &#125; @Override public int match(Uri uri) &#123; return mUriMatcher.match(uri); &#125; @Override protected Uri insert(ServiceManager serviceManager, Uri uri, ContentValues values) &#123; if (serviceManager == null) &#123; return null; &#125; switch (mUriMatcher.match(uri)) &#123; case CODE_PRINTER: // 实际添加打印机的方法 int result = serviceManager.getPrinterInfoService().addOrUpdatePrinter(printerInfo); break; default: break; &#125; return super.insert(serviceManager, uri, values); &#125; @Override protected Cursor query(ServiceManager serviceManager, Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; if (serviceManager == null) &#123; return null; &#125; switch (mUriMatcher.match(uri)) &#123; case CODE_PRINTER: // 实际查询打印机信息的方法 PrinterInfo[] printerInfo = serviceManager.getPrinterInfoService().queryPrinterInfo(); break; case CODE_PRINTER_TEMPLATE: // 查询打印机模板的方法 break; default: break; &#125; return cursor; &#125; @Override protected int delete(ServiceManager serviceManager, Uri uri, String selection, String[] selectionArgs) &#123; if (serviceManager == null) &#123; return 0; &#125; PrinterInfoService printerInfoService = serviceManager.getPrinterInfoService(); switch (mUriMatcher.match(uri)) &#123; case CODE_PRINTER: // 实际删除删除打印机的方法 int result = serviceManager.getPrinterInfoService().deletePrinter(mac) return result; default: break; &#125; return super.delete(serviceManager, uri, selection, selectionArgs); &#125;&#125; 可以看到，PrinterProviderHelper 才是我们的 M 层，但是它并没有对数据的操作进行封装，仅仅提供了最底层的方法，数据操作的封装反而写到了 Presenter 里，这就是不合理的地方，导致了前面出现的场景：A 界面只需要查询，B 界面只需要删除，C 界面只需要增和改，而增删改查的接口都封装在了 Presenter 里面，以至于出现需要复用 Presenter 的伪需求。理论上应该由 M 封装数据操作，然后 P 持有 M 的引用，进行方法调用即可。就像这样：12345678910111213141516171819202122232425262728293031class M &#123; PrinterInfo[] getPrinterInfo()&#123; // 封装获取打印机方法 &#125; int addOrUpdatePrinter(PrinterInfo info)&#123; // 封装添加打印机方法 &#125; int deletePrinter(String mac)&#123; // 封装删除打印机方法 &#125; ...&#125;class P &#123; private M m; PrinterInfo[] getPrinterInfo()&#123; return m.getPrinterInfo(); &#125; int addOrUpdatePrinter(PrinterInfo info)&#123; return m.addOrUpdatePrinter(info); &#125; int deletePrinter(String mac)&#123; return m.deletePrinter(mac); &#125;&#125; 如此这般， A B C 3个界面对应各自的 P，对于数据的操作只需要持有 M 进行方法调用就好了，那么关于 View 接口的定制也是一对一的，不会出现多的 do nothing 的方法了。其实这在Google 中的 MVP 架构演示中就已经表达出来了。只不过来到公司项目的中 Presenter 就是这样实现的，加上大多数时候程序员都是以功能优先，很少有时间真正去思考一些东西。至于数据操作涉及的异步线程的切换，使用 CursorLoader、AsyncTask 亦或是 RxJava 都是可以的，这就看项目实际情况了。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://lijia92.github.io/tags/设计模式/"}]},{"title":"Kotlin - 代码篇","date":"2017-12-21T03:15:32.000Z","path":"2017/12/21/kotlin-code/","text":"写过几个星期的 Kotlin 代码了，再也不用 findViewById 了，使用起来稍微简洁一点。今天小结一下，基础用法就不多说了，直接写几点我感触较深的。 空安全当使用Java开发的时候，我们的代码大多是防御性的。如果我们不想遇到 NullPointerException，我们就需要在使用它之前不停地去判断它是否为 null。Kotlin，则是空安全的，我们可以通过一个安全调用操作符 (写做 ? )来明确地指定一个对象是否能为空。12345678910111213141516// 这里不能通过编译. Artist 不能是 nullvar notNullArtist: Artist = null// Artist 可以是 nullvar artist: Artist? = null// 无法编译, artist可能是 null,我们需要进行处理artist.print()// 只要在artist != null时才会打印artist?.print()// 智能转换. 如果我们在之前进行了空检查,则不需要使用安全调用操作符调用if (artist != null) &#123; artist.print()&#125;// 只有在确保 artist 不是 null 的情况下才能这么调用，否则它会抛出异常artist!!.print()// 使用 Elvis操作符 来给定一个在是 null 的情况下的替代值val name = artist?.name ?: \"empty\" 关于 Elvis操作符 其实是三目条件运算符的简略写法。可以这样理解： A ?: B 等价于 if(A == null) B A?.B ?: C 等价于 if(A != null) A.B else C 变量所有的变量都需要由 val 或 var 来修饰，val 代表不可变变量，初始化后无法被修改，而 var 代表可变变量，后面允许被修改。在 Kotlin 中，一个非抽象的属性在构造函数执行完之前需要被赋值，如果声明的时候带上了 ? 表示可以为空，那么之后使用时就得各种?或!!操作符了，极其不便。很多时候，我们的赋值肯定不为空，但是依赖 Activity 或 Fragment 等 Android 组件的生命周期，无法直接赋值。这个时候有 2 种做法： 使用 lazyinit：1234567private lateinit var tableRegionAdapter: CommonMetaAdapteronCreate()&#123; ... // 进行初始化 tableRegionAdapter = CommonMetaAdapter(mActivity)&#125; lateinit修饰符所修饰的属性必须是非空类型，而且不能是原生类型（Int、Float、Char等），而且该修饰符只能用于类体中，不能在主构造函数中，也不能修饰局部变量，并且只可用于 var 类型变量。 by lazy：1private val menus: Array&lt;String&gt; by lazy &#123; arrayOf(MENU_PRINT_MANAGE) &#125; by lazy是使用了属性委托的方式，来实现懒初始化，用于修饰 val 变量。只会在第一次调用的时候进行初始化，后续调用时直接返回同样的值。当变量仅仅初始化一次并且全局共享，且更多的是内部使用时应该使用这种模式。属性委托中还有一种声明非空属性的方法：1private val menus by Delegates.notNull&lt;Array&lt;String&gt;&gt;() 利用Delegates.notNull可直接声明非空变量，并在其他地方进行初始化。关于属性委托的更多信息，请参考委托属性。注意：val 修饰的变量并不代表就是常量，具体请参考Kotlin中常量的探究。 静态方法之前的 Java 代码使用 Activity 跳转的时候经常在目标 Activity 中定义 navigateTo 方法，就像这样：12345678910public class DeliverActivity extends AppBarActivity &#123; public static final String EXTRA_KEY_MANIFEST = \"extra.manifest\"; public static void navigateToForResult(Fragment fragment, int requestCode, Manifest manifest) &#123; Intent intent = new Intent(fragment.getActivity(), DeliverActivity.class); intent.putExtra(EXTRA_KEY_MANIFEST, manifest); fragment.startActivityForResult(intent, requestCode); &#125;&#125; 这样我们定义的 EXTRA_KEY_MANIFEST 设为 private，只有 DeliverActivity 类能使用，避免定义成 public 影响到其他类。所有的变量都是内部消化，跳转时不用进行拷贝。而 Kotlin 中没有静态方法这一说，可以使用 伴生对象 来实现静态： Kotlin允许我们去定义一些行为与静态对象一样的对象。尽管这些对象可以用众所周知的模式来实现，比如容易实现的单例模式。我们需要一个类里面有一些静态的属性、常量或者函数，我们可以使用 companion object。这个对象被这个类的所有对象所共享，就像Java中的静态属性或者方法。 使用起来就是这样：123456789101112131415161718192021class ChooseDiningTableActivity : AppBarActivity() &#123; companion object StaticDiningTable &#123; val EXTRA_RESULT = \"extra.result\" private val EXTRA_TABLE_LIST = \"extra.tableList\" private val EXTRA_TABLE_REGION_LIST = \"extra.tableRegionList\" private val EXTRA_PEOPLE_COUNT = \"extra.peopleCount\" fun navigateTo(fragment: BaseFragment, requestCode: Int, tableList: ArrayList&lt;DiningTable&gt;, tableTypeList: ArrayList&lt;TableRegion&gt;, peopleCount: Int) &#123; val intent = Intent(fragment.context, ChooseDiningTableActivity::class.java) intent.putExtra(EXTRA_TABLE_LIST, tableList) intent.putExtra(EXTRA_TABLE_REGION_LIST, tableTypeList) intent.putExtra(EXTRA_PEOPLE_COUNT, peopleCount) fragment.startActivityForResult(intent, requestCode) &#125; &#125;&#125;// 使用跟 Java 调用静态方法一样ChooseDiningTableActivity.navigateTo(this, REQUEST_CODE_FOR_CHOOSE_TABLE, diningTableList, tableTypeList, item.customerNumber) 高阶函数高阶函数是将函数用作参数或返回值的函数，就有点像 c++ 中的函数指针。当你提供一个方法，方法执行完之后接收一个回调，然后执行回调中的方法，这种场景想必大家都遇到过。一般就是定义一个接口，然后传入一个接口实现类进去，就像 setOnClickListener 一样。但是高阶函数就省去了接口这一步，直接传入一个函数作为参数，进行回调。举个栗子：12345public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123; for (item in this) destination.add(transform(item)) return destination&#125; 使用时：1234567891011override fun showTableRegions(tableRegionList: MutableList&lt;TableRegion&gt;) &#123; val allRegion = CommonMetaBean() allRegion.name = ALL_TABLE_REGION val list = ArrayList&lt;CommonMetaBean&gt;() list.add(allRegion) tableRegionList.mapTo(list) &#123; CommonMetaBean(it.regionID, it.regionName) &#125; tableRegionAdapter.setDataList(list) tableRegionAdapter.notifyDataSetChanged()&#125; 集合操作符 mapTo 接收一个函数 transform 作为参数，将自身的 item 转化为另外一个对象，然后 add 到 destination 目标集合中。一个有用的约定：如果函数字面值只有一个参数， 那么它的声明可以省略（连同 -&gt;），其名称是 it。 就像我实例中的代码一样。再举个很实用的例子：列表定义 Adapter，如果有点击事件，我们一般会在 Adapter 中定义一个接口，然后在 Adapter 初始化的时候传入接口的实现类，就像这样：123456789101112131415161718class Adapter extends BaseAdapter &#123; public Adapter(Context context, OnFunctionClickListener listener) &#123; mListener = listener; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; holder.moreIv.setOnClickListener(v -&gt; &#123; if (mListener != null) &#123; mListener.onFunctionClick(data); &#125; &#125;); &#125; public interface OnFunctionClickListener &#123; onFunctionClick(Object obj); &#125;&#125; 当使用 Kotlin 之后，我们可以直接忽略接口的定义，直接传入一个匿名函数，就可以实现这样的功能了，简单很多，就像这样：123456789101112131415161718class LogTimeAdapter(private val context: Context, dataList: ArrayList&lt;TimeBean&gt;, private val onClick: (TimeBean) -&gt; Unit) : RecyclerView.Adapter&lt;LogTimeAdapter.ViewHolder&gt;() &#123; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; val timeBean = dataList[position] val timeDesc = DateUtils.getDateString(timeBean.beginTime.toInt()) + \" 至 \" + DateUtils.getDateString(timeBean.endTime.toInt()) with(holder.itemView) &#123; // 注意这里，onClick 是在构造函数中直接传入的匿名函数，省去了接口的定义 setOnClickListener &#123; onClick(timeBean) &#125; &#125; &#125; override fun getItemCount(): Int = dataList.size class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)&#125; lambdaKotlin 的使用是离不开 lambda 表达式的。最典型的例子：1view.setOnClickListener() &#123; toast(\"Hello world!\") &#125; 请注意，如果 lambda 是该调用的唯一参数，则调用中的圆括号可以完全省略：1view.setOnClickListener &#123; toast(\"Hello world!\") &#125; 如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：1map.forEach &#123; _, value -&gt; println(\"$value!\") &#125; 关于 lambda 一个简短的概述： lambda 表达式总是被大括号括着； 其参数（如果有的话）在 -&gt; 之前声明（参数类型可以省略）； 函数体（如果存在的话）在 -&gt; 后面。 如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。因此，下两个片段是等价的：123456789ints.filter &#123; val shouldFilter = it &gt; 0 shouldFilter&#125;ints.filter &#123; val shouldFilter = it &gt; 0 return@filter shouldFilter&#125; 其他 默认任何类都是基础继承自 Any (与java中的 Object 类似)，但是我们可以继承其它类。所有的类默认都是不可继承的(final)，所以我们只能继承那些明确声明 open 或者 abstract 的类: 12open class Animal(name: String)class Person(name: String, surname: String) : Animal(name) 拓展函数： 12345fun Fragment.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123; Toast.makeText(getActivity(), message, duration).show()&#125;fragment.toast(\"Hello world!\") 扩展函数并不是真正地修改了原来的类，它是以静态导入的方式来实现的。扩展函数可以被声明在任何文件中，因此有个通用的实践是把一系列有关的函数放在一个新建的文件里。 集合操作符：forEach、max、filter、mapTo等等，Kotlin 中的集合为我们提供了很多的操作符，但是你大可不必去背它。当我们用 Java 写出一些集合操作的代码时， Android Studio 会智能识别我们的代码，然后提示可以被哪些操作符给替代，这个时候转一下就好了。 其他操作符：Kotlin 还提供了很多其他的操作符，let、with、apply等等，这些操作符都可以简化我们的代码。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://lijia92.github.io/tags/Kotlin/"}]},{"title":"Java 中的 Comparator","date":"2017-12-20T08:04:13.000Z","path":"2017/12/20/comparator/","text":"最近写过一个界面，涉及到排序。用到了 Collections 中的 sort 方法：123456789101112131415Collections.sort(mData, new Comparator&lt;BookMemberReport&gt;() &#123; @Override public int compare(BookMemberReport lhs, BookMemberReport rhs) &#123; if (sortFlag == SORT_FLAG_SALE_DESCENDING) &#123; return (int) (rhs.saleAmount - lhs.saleAmount); &#125; else if (sortFlag == SORT_FLAG_SALE_ASCENDING) &#123; return (int) (lhs.saleAmount - rhs.saleAmount); &#125; else if (sortFlag == SORT_FLAG_COUNT_DESCENDING) &#123; return rhs.orderCount - lhs.orderCount; &#125; else if (sortFlag == SORT_FLAG_COUNT_ASCENDING) &#123; return lhs.orderCount - rhs.orderCount; &#125; return 0; &#125;&#125;); Collections 根据传入的 Comparator 进行排序。刚开始写的时候通过不停的试，把正确的结果给试出来了。但是对于其原理却不是很清晰，今天便稍微扒一扒其源码。 1234567891011121314public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; if (list.getClass() == ArrayList.class) &#123; Arrays.sort(((ArrayList) list).elementData, 0, list.size(), (Comparator) c); return; &#125; Object[] a = list.toArray(); Arrays.sort(a, (Comparator)c); ListIterator&lt;T&gt; i = list.listIterator(); for (int j=0; j&lt;a.length; j++) &#123; i.next(); i.set((T)a[j]); &#125;&#125; 跟到 Arrays.sort() 方法：12345678910public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a); &#125; else &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); &#125;&#125; 在 else 分支中还有一个分支，看到 userRequested：12345678910/** * Old merge sort implementation can be selected (for * compatibility with broken comparators) using a system property. * Cannot be a static boolean in the enclosing class due to * circular dependencies. To be removed in a future release. */static final class LegacyMergeSort &#123; // Android-changed: Never use circular merge sort. private static final boolean userRequested = false;&#125; 所以所有的排序应该都是走的 TimSort 分支。但是这不影响研究 Comparator 接口的原理，进入到 legacyMergeSort：12345678/** To be removed in a future release. */private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) &#123; T[] aux = a.clone(); if (c==null) mergeSort(aux, a, 0, a.length, 0); else mergeSort(aux, a, 0, a.length, 0, c);&#125; 继续跟进：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Src is the source array that starts at index 0 * Dest is the (possibly larger) array destination with a possible offset * low is the index in dest to start sorting * high is the end index in dest to end sorting * off is the offset into src corresponding to low in dest * To be removed in a future release. */private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off, Comparator c) &#123; int length = high - low; // Insertion sort on smallest arrays if (length &lt; INSERTIONSORT_THRESHOLD) &#123; for (int i=low; i&lt;high; i++) for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--) swap(dest, j, j-1); return; &#125; // Recursively sort halves of dest into src int destLow = low; int destHigh = high; low += off; high += off; int mid = (low + high) &gt;&gt;&gt; 1; mergeSort(dest, src, low, mid, -off, c); mergeSort(dest, src, mid, high, -off, c); // If list is already sorted, just copy from src to dest. This is an // optimization that results in faster sorts for nearly ordered lists. if (c.compare(src[mid-1], src[mid]) &lt;= 0) &#123; System.arraycopy(src, low, dest, destLow, length); return; &#125; // Merge sorted halves (now in src) into dest for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123; if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0) dest[i] = src[p++]; else dest[i] = src[q++]; &#125;&#125; 看到第一个 if 语句，看到 INSERTIONSORT_THRESHOLD 变量：123456/** * Tuning parameter: list size at or below which insertion sort will be * used in preference to mergesort. * To be removed in a future release. */private static final int INSERTIONSORT_THRESHOLD = 7; 即只要是数组个数小于 7 的，直接走 if 语句进行排序，然后返回。重点：1234for (int i=low; i&lt;high; i++) for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--) swap(dest, j, j-1);return; 即第 j-1 个元素跟 j 进行比较，通过 compare 返回的值，如果大于 0，则进行交换。看到 compare 接口：123456789101112/** * @param o1 the first object to be compared. * @param o2 the second object to be compared. * @return a negative integer, zero, or a positive integer as the * first argument is less than, equal to, or greater than the * second. * @throws NullPointerException if an argument is null and this * comparator does not permit null arguments * @throws ClassCastException if the arguments' types prevent them from * being compared by this comparator. */int compare(T o1, T o2); 所以很清晰了，如果 compare 返回的值大于 0，那么就会将这 2 个元素交换，即将大元素放在前面进行降序，反之则是正序。文中代码基于 Android-25，Android-26 中已经剔除 LegacyMergeSort。1234567891011public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a); &#125; else &#123; // Android-changed: LegacyMergeSort is no longer supported // if (LegacyMergeSort.userRequested) // legacyMergeSort(a, c); // else TimSort.sort(a, 0, a.length, c, null, 0, 0); &#125;&#125; 虽然分析选取的代码并不会执行，但是丝毫不影响研究 Comparator 的原理。无论源码怎么变化，只要 Comparator 接口不变，那么它的原理便会始终是这样的。抛弃复杂的，选取简单的，使源码阅读起来更为快捷。好了，简单的阅读完了，可以阅读一下复杂的 TimSort.sort 了。","tags":[{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"}]},{"title":"Support 库，注意你的版本号","date":"2017-12-15T09:18:29.000Z","path":"2017/12/15/support-version/","text":"项目开发，引进了一个新的三方库，导致之前能运行的代码出现问题，错误堆栈：12345678910111213141516171819FATAL EXCEPTION: mainProcess: com.lijia.app.catering.dev, PID: 29387java.lang.NoClassDefFoundError: android.support.v4.animation.AnimatorCompatHelper at android.support.v7.widget.DefaultItemAnimator.resetAnimation(DefaultItemAnimator.java:514) at android.support.v7.widget.DefaultItemAnimator.animateAdd(DefaultItemAnimator.java:217) at android.support.v7.widget.SimpleItemAnimator.animateAppearance(SimpleItemAnimator.java:114) at android.support.v7.widget.RecyclerView.animateAppearance(RecyclerView.java:3243) at android.support.v7.widget.RecyclerView.access$800(RecyclerView.java:147) at android.support.v7.widget.RecyclerView$4.processAppeared(RecyclerView.java:436) at android.support.v7.widget.ViewInfoStore.process(ViewInfoStore.java:249) at android.support.v7.widget.RecyclerView.dispatchLayoutStep3(RecyclerView.java:3098) at android.support.v7.widget.RecyclerView.dispatchLayout(RecyclerView.java:2917) at android.support.v7.widget.RecyclerView.onLayout(RecyclerView.java:3283) at android.view.View.layout(View.java) at android.view.ViewGroup.layout(ViewGroup.java) at android.widget.LinearLayout.setChildFrame(LinearLayout.java) at android.widget.LinearLayout.layoutVertical(LinearLayout.java) at android.widget.LinearLayout.onLayout(LinearLayout.java) ... 即是在 v4 包中找不到类：AnimatorCompatHelper。Google 了一下，发现这个类在 v4 包版本 26 以上就被剔除了，而 RecyclerView 引用了这个类。所以先查看下依赖，来看看自己依赖的 v4 版本。执行命令：1./gradlew app:dependencies --configuration cateringDevCompile 因为我的 buildVariant 很多，这里利用 configuration 参数指定一个 variant，缩减编译的时间。给出的 Log 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546cateringDevCompile - Classpath for compiling the cateringDev sources.\\--- project :ui-jch +--- org.jetbrains.kotlin:kotlin-android-extensions-runtime:1.2.0 | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.2.0 | \\--- org.jetbrains:annotations:13.0 +--- project :ui-common-portrait | +--- project :appcommon | | +--- com.yanzhenjie:recyclerview-swipe:1.0.2 | | | \\--- com.android.support:recyclerview-v7:23.4.0 | | | +--- com.android.support:support-annotations:23.4.0 -&gt; 26.1.0 | | | \\--- com.android.support:support-v4:23.4.0 -&gt; 26.1.0 (*) | | +--- com.jph.takephoto:takephoto_library:3.0.1 | | | +--- com.android.support:support-v4:24.0.0 -&gt; 26.1.0 (*) | | | +--- com.soundcloud.android.crop:lib_crop:1.0.0 | | | | +--- com.android.support:support-v4:23.0.1 -&gt; 26.1.0 (*) | | | | \\--- com.android.support:support-annotations:23.0.1 -&gt; 26.1.0 | | | \\--- com.darsh.multipleimageselect:multipleimageselect:1.0.4 | | | +--- com.android.support:appcompat-v7:23.1.1 -&gt; 26.1.0 | | | | +--- com.android.support:support-annotations:26.1.0 | | | | +--- com.android.support:support-v4:26.1.0 (*) | | | | +--- com.android.support:support-vector-drawable:26.1.0 | | | | | +--- com.android.support:support-annotations:26.1.0 | | | | | \\--- com.android.support:support-compat:26.1.0 (*) | | | | \\--- com.android.support:animated-vector-drawable:26.1.0 | | | | +--- com.android.support:support-vector-drawable:26.1.0 (*) | | | | \\--- com.android.support:support-core-ui:26.1.0 (*) | | | \\--- com.github.bumptech.glide:glide:3.6.0 | | +--- me.alzz:kosp:1.0.0 | | | +--- org.jetbrains.kotlin:kotlin-stdlib-jre7:1.1.51 -&gt; 1.2.0 | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.2.0 (*) | | | \\--- com.android.support:appcompat-v7:26.1.0 (*) | | +--- com.lijia.lib:modservice:7.1.0-SNAPSHOT | | | +--- com.lijia:useragent:7.1.0-SNAPSHOT | | | | +--- com.lijia.lib:modcore:7.1.0-SNAPSHOT | | | | | +--- com.android.support:support-annotations:25.0.1 -&gt; 26.1.0 | | | | | \\--- com.lijia.lib:common:7.1.0-SNAPSHOT | | | | | +--- com.android.support:design:23.2.1 -&gt; 23.3.0 | | | | | | +--- com.android.support:appcompat-v7:23.3.0 -&gt; 26.1.0 (*) | | | | | | +--- com.android.support:support-v4:23.3.0 -&gt; 26.1.0 (*) | | | | | | \\--- com.android.support:recyclerview-v7:23.3.0 -&gt; 23.4.0 (*) | | | | | \\--- com.tencent.bugly:crashreport:latest.release -&gt; 2.6.6.1 | | | | \\--- com.lijia.lib:common:7.1.0-SNAPSHOT (*) | | +--- com.lijia.lib:webserver:7.0.0 | | \\--- org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0 (*) | \\--- com.tencent.mm.opensdk:wechat-sdk-android-without-mta:1.4.0(*) - dependencies omitted (listed previously) 分析可以看到自己依赖的 support 库都是 23 24版本的，所以不会导致问题，但是加上依赖me.alzz:kosp之后，依赖的 support v7 版本是 26.1.0，而 v7 库又依赖了 v4 库，所以 v4 库被升到了 26.1.0，但是用到的 Recycleview 在 design 包中，版本号是 23.3.0，依赖的一个库com.yanzhenjie:recyclerview-swipe将其升到了 23.4.0，所以 Recycleview 的版本和 support-v4 的版本是对应不上的，才导致的这个问题。所以将依赖的 design 包升级到 26 即可解决问题。1compile 'com.android.support:design:26.1.0' 出现这个问题的原因就是 support 各种库的版本不一致。一般不容易出现这个问题，但是我的项目 进行模块化，将代码分为了很多模块，对应到不同的工程，不同的 Module，导致 gradle 文件是分散的，经常改了这处忘了那处。这里写下这篇文章也是加深下印象，也给自己提个醒，以后一定要注意 support 库的版本号，不然有可能导致崩溃。 题外话gradle 插件升级 3.0.0 之后执行查找依赖变化了，执行命令后返回的 Log 如下：12cateringDevCompile - Compile dependencies for 'cateringDev' sources (deprecated: use 'cateringDevImplementation' instead). (n)No dependencies 换成：1./gradlew app:dependencies --configuration cateringDevImplementation 返回的 Log 如下：1234cateringDevImplementation - Implementation only dependencies for 'cateringDev' sources. (n)\\--- project ui-jch (n)(n) - Not resolved (configuration is not meant to be resolved) 无法直观的看到依赖树，这个时候直接去掉 configuration，然后执行，可以看到所有编译的依赖树，然后选取你要的 buildVariant 即可，比如：1./gradlew app:dependencies --configuration cateringDevDebugCompileClasspath","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Kotlin - 配置篇","date":"2017-12-05T10:05:32.000Z","path":"2017/12/05/kotlin-config/","text":"最近随着 Google 的大力推荐，越来越多开发者开始使用 Kotlin 了。其实我对 Kotlin 的并没有很特别的感觉，它就类似于 Swift 相比于 OC，大量的语法糖着实能使写代码的效率变高，但是是否能左右 Android 开发的现状还未可知。我接触 Kotlin 的主要原因是：业务代码太无聊啦。相信很多开发者都跟我有同样的感触，在一个公司待久了，技术框架摸透之后，后面的开发就基本是纯业务开发了，写界面，写业务代码，对于技术提升没有什么实质的帮助，就是真正的码农。为了改变这一现状，我不断在新需求中使用一些新的技术，比如 RxJava、Retrofit 等等，说是新技术其实也不新了，都出来都很久了，只是自己在项目中没有用到，接触得不多。在新需求中引入这些技术，可以边开发边学习，解决写业务代码的无聊，还能拓宽视野，学习新知识。虽然不一定会成为主流，但学习一下总是没问题的，因此开始接触 Kotlin。这篇文章主要先讲讲 Kotlin 的配置。 Kotlin 插件最新的 Android Studio 已默认装了 Kotlin 插件了，在旧版本可自己手动安装 Kotlin 插件。 安装插件后，选择一个 Java 文件，点击 Code -&gt; Convert Java File To Kotlin File，即可转换成 Kotlin 文件了。 配置 Kotlin 环境在 kt 文件中，随便使用一下 Kotlin 的特性，例如 List 的 filter 操作符，然后报错按下 Alt + Enter 弹出的方框中就有配置 Kotlin 的选项。如上图，选择要配置的 Module，确定后就会有自动配置了。项目根目录的 build.gradle 中：12345678910111213buildscript &#123; // kotlin 版本 ext.kotlin_version = '1.2.0' repositories &#123; jcenter() google() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0' // 依赖 kotlin 插件 classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" &#125;&#125; 然后 Module 的 build.gradle 中：12345apply plugin: 'kotlin-android'dependencies &#123; implementation \"org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version\"&#125; 当然，你可以自己做这些配置。注意到apply plugin: &#39;kotlin-android&#39;，这个配置是针对 Module 的。如果有多个 Module 都需要用到 Kotlin，则每个 Module 都需要做这个配置。比如 app -&gt; library -&gt; core，app、library 中都使用了 kotlin，那么 app、library 2个 Module 都需要配置apply plugin: &#39;kotlin-android&#39;，否则会提示找不到符号:xxx（xxx为 Kotlin 编写的类）。 Kotlin 拓展Kotlin 团队研发的可以让开发更简单的插件是 Kotlin Android Extensions。这个插件可以自动绑定 View，再也不用 findViewById 了。要使用这个插件，在 Module 的 build.gradle 中配置：1apply plugin: 'kotlin-android-extensions' 然后一行代码导入即可直接使用布局中的 View。1import kotlinx.android.synthetic.main.＜布局＞.* 假设当前布局文件是activity_main.xml，我们只需要引入kotlinx.android.synthetic.main.activity_main.*。导入完成后即可调用在 xml 文件中以视图控件命名属性的对应扩展，比如下例：1234&lt;TextView android:id=\"@+id/hello\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\"/&gt; 然后 activity 中可以直接如下使用：1hello.text = \"Hello World!\" 再也不用 findViewById 了。当然你如果引用 ButterKnife 也可以省去 findViewById，只不过实现方式不一样。如此使用需要注意生命周期，在 view 还没创建时调用肯定是会失败的。注意到import kotlinx.android.synthetic.main.＜布局＞.*中的main，这是因为大多数时候我们的布局都是在 main 文件夹下，当我们定义了多种 buildVariant 时，就像Gradle 多版本管理（续）中写到的一样，那么我们就会有很多文件夹来分别对应这些 buildVariant 以实现多版本控制的需求了。那么这个时候我们的布局就不是在main文件夹中了。此时我们需要开启 Experimental Mode。123androidExtensions &#123; experimental = true&#125; 然后选择对应的 buildVariant，我们可以直接导入对应的布局了。 参考Kotlin 中文教程《Kotlin for android developers》中文版翻译","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://lijia92.github.io/tags/Kotlin/"}]},{"title":"Android 约束布局的使用","date":"2017-11-20T02:00:12.000Z","path":"2017/11/20/constraint/","text":"习惯了用 LinearLayout、RelativeLayout 等布局，但是在某些界面的优化上这些布局很难做到。说下我项目中的实际例子：一件商品有品名、数量、单价、金额等几条属性，要显示在一行。 注意，图中金额属性没有显示全，但这不是本文要写的内容。当文本过长显示不下，这是个历史难题。 本文要讲述的是如何利用约束布局来优化界面的显示。看到图中，我们通长使用 LinearLayout 的 weight 属性，给每一列设置一个 weight，相信大多数人都是这么做的，就像这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:paddingBottom=\"@dimen/margin_x_x_small\" android:paddingLeft=\"@dimen/padding_middle_large\" android:paddingRight=\"@dimen/padding_middle_large\" android:paddingTop=\"@dimen/margin_x_x_small\"&gt; &lt;LinearLayout android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"8\" android:orientation=\"horizontal\"&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/product_count_tv\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"2\" android:gravity=\"center_vertical|end\" android:maxLines=\"1\" android:textColor=\"@color/font_main\" android:textSize=\"@dimen/font_body\" tools:text=\"4000.00\" /&gt; &lt;LinearLayout android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"4\" android:gravity=\"center\" android:layout_gravity=\"center_vertical\" android:orientation=\"vertical\" android:paddingLeft=\"@dimen/margin_small\"&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/total_amount_tv\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"4\" android:gravity=\"end|center_vertical\" android:maxLines=\"1\" android:paddingLeft=\"@dimen/margin_small\" android:textColor=\"@color/font_main\" android:textSize=\"@dimen/font_body\" tools:text=\"4000.00\" /&gt;&lt;/LinearLayout&gt; 示例中的比例是8:2:4:4，标题与流水使用相同的比例。第一列与标题左对齐，后面几列与标题右对齐，这样写出来的界面效果会比较整洁。但是存在一种情况：商品名称很短，但是数量却很多。就像上图所示。那么数量所占的 2 / 18 的比例是无法显示出1000000这个数量的，商品名称又很短导致浪费很多空间，但是图中却完美显示了。原因就在于 约束布局，这也是本文的重点。直接贴出使用约束布局的XML：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"55dp\" android:paddingBottom=\"@dimen/margin_x_x_small\" android:paddingLeft=\"@dimen/padding_middle_large\" android:paddingRight=\"@dimen/padding_middle_large\" android:paddingTop=\"@dimen/margin_x_x_small\"&gt; &lt;View android:id=\"@+id/view_mask1\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintHorizontal_weight=\"8\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toLeftOf=\"@+id/view_mask2\" /&gt; &lt;View android:id=\"@+id/view_mask2\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintHorizontal_weight=\"2\" app:layout_constraintLeft_toRightOf=\"@+id/view_mask1\" app:layout_constraintRight_toLeftOf=\"@+id/view_mask3\" /&gt; &lt;View android:id=\"@+id/view_mask3\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintHorizontal_weight=\"4\" app:layout_constraintLeft_toRightOf=\"@+id/view_mask2\" app:layout_constraintRight_toLeftOf=\"@+id/view_mask4\" /&gt; &lt;View android:id=\"@+id/view_mask4\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintHorizontal_weight=\"4\" app:layout_constraintLeft_toRightOf=\"@+id/view_mask3\" app:layout_constraintRight_toRightOf=\"parent\" /&gt; &lt;com.makeramen.roundedimageview.RoundedImageView android:id=\"@+id/product_icon_iv\" android:layout_width=\"45dp\" android:layout_height=\"45dp\" android:scaleType=\"center\" app:riv_corner_radius=\"@dimen/round_view_circular\" /&gt; &lt;LinearLayout android:id=\"@+id/product_name_ll\" android:layout_width=\"0dp\" android:layout_height=\"45dp\" android:layout_marginLeft=\"@dimen/margin_x_x_x_small\" android:layout_marginRight=\"@dimen/margin_x_x_x_small\" android:gravity=\"center_vertical\" android:orientation=\"vertical\" app:layout_constraintLeft_toRightOf=\"@+id/product_icon_iv\" app:layout_constraintRight_toLeftOf=\"@+id/product_count_tv\"&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/product_count_tv\" android:layout_width=\"0dp\" android:layout_height=\"45dp\" android:ellipsize=\"end\" android:gravity=\"center_vertical|end\" android:maxLines=\"1\" android:textColor=\"@color/font_main\" android:textSize=\"@dimen/font_body\" app:layout_constraintRight_toRightOf=\"@+id/view_mask2\" tools:text=\"4000.00\" /&gt; &lt;LinearLayout android:id=\"@+id/product_price_ll\" android:layout_width=\"0dp\" android:layout_height=\"45dp\" android:layout_marginLeft=\"@dimen/margin_x_x_x_small\" android:layout_marginStart=\"@dimen/margin_x_x_x_small\" android:gravity=\"center\" android:orientation=\"vertical\" app:layout_constraintLeft_toRightOf=\"@+id/product_count_tv\" app:layout_constraintRight_toRightOf=\"@+id/view_mask3\"&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/total_amount_tv\" android:layout_width=\"0dp\" android:layout_height=\"45dp\" android:layout_marginLeft=\"@dimen/margin_x_x_x_small\" android:layout_marginStart=\"@dimen/margin_x_x_x_small\" android:ellipsize=\"end\" android:gravity=\"end|center_vertical\" android:maxLines=\"1\" android:textColor=\"@color/font_main\" android:textSize=\"@dimen/font_body\" app:layout_constraintLeft_toRightOf=\"@+id/product_price_ll\" app:layout_constraintRight_toRightOf=\"@+id/view_mask4\" tools:text=\"40000.00\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 可以看到约束布局的一些属性：layout_constraintLeft_toRightOf。布局的左边在谁的右边，字面意思，很好理解。其他类似的还有 layout_constraintRight_toRightOf 、layout_constraintRight_toLeftOf等等。看到上面最上层有几个 view_mask，这是用来做对齐的，因为标题和流水没有在一个布局里。商品列与 view_mask1 左对齐，其他几列与相应的 view_mask 右对齐。然后看一下布局的宽度属性，我都是设置的0dp，这是因为在约束布局里，0dp代表MATCH_CONSTRAINT，它会利用约束自动设置控件的宽度。那么MATCH_PARENT去哪了？官网做了如下说明： Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”. MATCH_CONSTRAINT则是实现本文效果的核心。我并不需要给每列属性设置宽度，我需要的仅仅是：品名在数量的左边，数量在品名的右边，当品名字符串很长时，它可以无限接近数量字符串，直到没有剩余空间。虽然只是一点小小的优化，但是能改进某些情况下界面的显示效果，好处还是有的，今后还是多尝试用用约束布局，但是我是肯定不会用拖拽来实现布局的╮(╯▽╰)╭。 参考：拒绝拖拽 使用ConstraintLayout优化你的布局吧","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Retrofit 学习小结","date":"2017-11-15T10:40:56.000Z","path":"2017/11/15/retrofit-code/","text":"之前的一篇文章Retrofit初识尝试用了下 Retrofit。说来惭愧，到现在才写这篇文章。由于项目中没有使用的缘故，一直停留在了解的程度。最近自己学习做了个Gank客户端，一点点学习当前主流的技术，今天研究了下 Retrofit 的源码，颇有感触，便记录下来。 使用关于正常的使用，参考之前的那篇文章。这里再写一下结合 RxJava 的使用。 定义接口： 12345678public interface GankService &#123; @GET(\"day/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;\") Observable&lt;GankDailyResult&gt; getDailyData(@Path(\"year\") int year, @Path(\"month\") int month, @Path(\"day\") int day); @GET(\"data/&#123;type&#125;/&#123;count&#125;/&#123;page&#125;\") Observable&lt;GankCategoryResult&gt; getCategoryData(@Path(\"type\") String type, @Path(\"count\") int count, @Path(\"page\") int page);&#125; 初始化 Retrofit，生成代理对象： 12345678Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_GANK_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client(okHttpClient.build()) .build();mService = retrofit.create(GankService.class); 调用接口： 123456789101112GankRequestManager.getInstance().getCategory(type, PAGE_SIZE, mPage) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;GankCategoryResult&gt;() &#123; @Override public void accept(GankCategoryResult gankCategoryResult) throws Exception &#123; mPage++; if (mView != null) &#123; mView.showList(type, gankCategoryResult.results); &#125; &#125; &#125;); 动态代理在项目中我们只定义了接口，并没有实现，后面却能直接调用接口，这不得不借助 Java 的动态代理特性。Retrofit 即是使用动态代理来生成代理对象：12345678910111213141516171819202122232425public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 通过Proxy.newProxyInstance来生成代理对象，当调用接口时，会回调到 invoke 方法中，然后生成 OkHttpCall 对象，用于后面真正的发起网络请求。OkHttpCall 是 okhttp 的核心类，这里不做过多讲述。 Android 通过 Handler 回调主线程普通调用 Retrofit 的形式是这样的：12345678910call.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; &#125;&#125;); 回调中即是在主线程，我们可以用于更新 UI，这是如何做到的呢？回到 Retrofit 的构建：12345678910111213141516171819202122232425public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(\"Base URL required.\"); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly);&#125; platform 是如何生成的呢？看到 Retrofit.Builder：123456789101112Builder(Platform platform) &#123; this.platform = platform; ...&#125;public Builder() &#123; this(Platform.get());&#125;Builder(Retrofit retrofit) &#123; ...&#125; 再来看 Platform：123456789101112131415private static Platform findPlatform() &#123; try &#123; Class.forName(\"android.os.Build\"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName(\"java.util.Optional\"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform();&#125; 显然，在 Android 中会返回 Android（）：12345678910111213141516static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); return new ExecutorCallAdapterFactory(callbackExecutor); &#125;s MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 看到没， Android platform 会初始化一个绑定 MainLooper 的 Handler，很清晰了。1234567891011121314151617181920212223242526@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, \"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;);&#125; 回调中的 Runnable 则是由 Handler 发出的，显然是在主线程了。 CallAdapterFactory使用 RxJava，会有 RxJava2CallAdapter 类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465final class RxJava2CallAdapter&lt;R&gt; implements CallAdapter&lt;R, Object&gt; &#123; private final Type responseType; private final @Nullable Scheduler scheduler; private final boolean isAsync; private final boolean isResult; private final boolean isBody; private final boolean isFlowable; private final boolean isSingle; private final boolean isMaybe; private final boolean isCompletable; RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync, boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) &#123; this.responseType = responseType; this.scheduler = scheduler; this.isAsync = isAsync; this.isResult = isResult; this.isBody = isBody; this.isFlowable = isFlowable; this.isSingle = isSingle; this.isMaybe = isMaybe; this.isCompletable = isCompletable; &#125; @Override public Type responseType() &#123; return responseType; &#125; @Override public Object adapt(Call&lt;R&gt; call) &#123; Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125; if (scheduler != null) &#123; observable = observable.subscribeOn(scheduler); &#125; if (isFlowable) &#123; return observable.toFlowable(BackpressureStrategy.LATEST); &#125; if (isSingle) &#123; return observable.singleOrError(); &#125; if (isMaybe) &#123; return observable.singleElement(); &#125; if (isCompletable) &#123; return observable.ignoreElements(); &#125; return observable; &#125;&#125; 通过 adapt 方法来生成目标的对象。使用 RxJava 则是生成 Observable。返回的 observable 只有在发生订阅关系时才会调用请求。1234567891011121314151617181920212223@SchedulerSupport(SchedulerSupport.NONE)@Overridepublic final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, \"observer is null\"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\"); // 请求真正发生的地方 subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\"); npe.initCause(e); throw npe; &#125;&#125; subscribeActual 则是请求真正发生的地方：1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 通过 RxJava2CallAdapter 返回的 observable 是 CallEnqueueObservable 或 CallExecuteObservable：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126final class CallEnqueueObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123; private final Call&lt;T&gt; originalCall; CallEnqueueObservable(Call&lt;T&gt; originalCall) &#123; this.originalCall = originalCall; &#125; @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; // Since Call is a one-shot type, clone it for each new observer. Call&lt;T&gt; call = originalCall.clone(); retrofit2.adapter.rxjava2.CallEnqueueObservable.CallCallback&lt;T&gt; callback = new retrofit2.adapter.rxjava2.CallEnqueueObservable.CallCallback&lt;&gt;(call, observer); observer.onSubscribe(callback); // 异步调用 call.enqueue(callback); &#125; private static final class CallCallback&lt;T&gt; implements Disposable, Callback&lt;T&gt; &#123; private final Call&lt;?&gt; call; private final Observer&lt;? super Response&lt;T&gt;&gt; observer; boolean terminated = false; CallCallback(Call&lt;?&gt; call, Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; this.call = call; this.observer = observer; &#125; @Override public void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response) &#123; if (call.isCanceled()) return; try &#123; observer.onNext(response); if (!call.isCanceled()) &#123; terminated = true; observer.onComplete(); &#125; &#125; catch (Throwable t) &#123; if (terminated) &#123; RxJavaPlugins.onError(t); &#125; else if (!call.isCanceled()) &#123; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; &#125; &#125; @Override public void onFailure(Call&lt;T&gt; call, Throwable t) &#123; if (call.isCanceled()) return; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; @Override public void dispose() &#123; call.cancel(); &#125; @Override public boolean isDisposed() &#123; return call.isCanceled(); &#125; &#125;&#125;final class CallExecuteObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123; private final Call&lt;T&gt; originalCall; CallExecuteObservable(Call&lt;T&gt; originalCall) &#123; this.originalCall = originalCall; &#125; @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; // Since Call is a one-shot type, clone it for each new observer. Call&lt;T&gt; call = originalCall.clone(); observer.onSubscribe(new retrofit2.adapter.rxjava2.CallExecuteObservable.CallDisposable(call)); boolean terminated = false; try &#123; // 同步调用 Response&lt;T&gt; response = call.execute(); if (!call.isCanceled()) &#123; observer.onNext(response); &#125; if (!call.isCanceled()) &#123; terminated = true; observer.onComplete(); &#125; &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); if (terminated) &#123; RxJavaPlugins.onError(t); &#125; else if (!call.isCanceled()) &#123; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; &#125; &#125; private static final class CallDisposable implements Disposable &#123; private final Call&lt;?&gt; call; CallDisposable(Call&lt;?&gt; call) &#123; this.call = call; &#125; @Override public void dispose() &#123; call.cancel(); &#125; @Override public boolean isDisposed() &#123; return call.isCanceled(); &#125; &#125;&#125; 异步调用 call.enqueue，同步调用 call.execute，这也正是 okhttp 的使用方法，所以 Retrofit 的核心仍是 okhttp，只不过做了更好的封装。 当我们不使用 RxJava 时，会有默认的 ExecutorCallAdapterFactory 类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, \"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125;&#125; 还有一个 DefaultCallAdapterFactory，只有在callbackExecutor == null的条件才会创建这个类：12345678910111213141516171819202122232425262728final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123; static final CallAdapter.Factory INSTANCE = new retrofit2.DefaultCallAdapterFactory(); @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return call; &#125; &#125;; &#125;&#125;CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; return retrofit2.DefaultCallAdapterFactory.INSTANCE;&#125; 通过适配器模式，可是适配各种使用场景，当我们有特定的需求，自定义 CallAdapterFactory 即可。Converter 也是类似的原理。当配置多个 Converter 或者 CallAdapter 时，只有第一个生效。如下代码 RxJava2CallAdapterFactory 生效。12.addCallAdapterFactory(RxJava2CallAdapterFactory.create()).addCallAdapterFactory(Java8CallAdapterFactory.create()) 设计模式Retrofit 中使用到的设计模式不可谓不多。 建造者模式：这个模式相信大家都很熟悉了。Retrofit 算是比较复杂的一个类了，直接创建一个 Retrofit 将会在碰到这些用不到的方法上困惑，建造者模式提供了一个很好的思路。 装饰模式：不管内部多么复杂，在使用时只需要围绕 Retrofit 类就够了。简化了开发者的学习成本，易于使用。另外封装了系统内部类的关系，对内是高内聚的，对外是松耦合的。 代理模式：动态代理创建接口实现类，接口的调用都由 OkHttpCall 来执行。 工厂模式：源码中可是有不少的 Factory。 适配器模式：CallAdapter 通过泛型定义 adapt 方法，开发者可自定义 CallAdapter 实现 adapt 方法来返回自己想要的对象。1T adapt(Call&lt;R&gt; call); 当然，不止于这几种模式，只是这几种是我能直观感受到的，再一次感叹 Retrofit 设计的妙处！ 设计模式的魅力便在于此，尽管它很复杂，但是开发者使用起来却很简单，也很容易拓展实现自定义需求，好的框架应当如此，努力学习吧！","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"在硬件设备上运行应用","date":"2017-11-01T06:39:22.000Z","path":"2017/11/01/device/","text":"最近做收银机上的软件，之前都是用无线调试，有个功能需要要测一下断网的情况，然后断网后无线调试就不能用了。然后接上 USB，通过 Android Studio 能看到设备但无法使用。 然后通过 adb devices 能看到设备，但是提示权限不允许，并且提示到官网来解决。跟到网站中可以看到 如果您在 Ubuntu Linux 上开发，则需要为想要在开发中使用的每一种设备类型添加一个包含 USB 配置的 udev 规则文件。 这个便是问题所在了，跟着描述进行操作后面便可以使用 USB 调试了。 以 root 身份登录，并创建此文件：/etc/udev/rules.d/51-android.rules。使用下面的格式将各个供应商添加到文件中：1SUBSYSTEM==\"usb\", ATTR&#123;idVendor&#125;==\"0bb4\", MODE=\"0666\", GROUP=\"plugdev\" 在本例中，供应商 ID 为 HTC 的 ID。MODE 赋值指定读/写权限，GROUP 则定义哪个 Unix 组拥有设备节点。 注：取决于您的环境，规则语法可能稍有不同。如有需要，请查阅适用于您的系统的 udev 文档。有关规则语法的概述，请参阅编写 udev 规则的指南。 现在，请执行：1chmod a+r /etc/udev/rules.d/51-android.rules 然后文中还附上了 USB 供应商 ID 表。 公司 USB 供应商 ID Acer 502 ASUS 0b05 Dell 413c Foxconn 489 Fujitsu 04c5 Fujitsu Toshiba 04c5 Garmin-Asus 091e Google 18d1 Haier 201E Hisense 109b HP 03f0 HTC 0bb4 Huawei 12d1 Intel 8087 K-Touch 24000 KT Tech 2116 Kyocera 482 Lenovo 17ef LG 1004 Motorola 22b8 MTK 0e8d NEC 409 Nook 2080 Nvidia 955 OTGV 2257 Pantech 10a9 Pegatron 1d4d Philips 471 PMC-Sierra 04da Qualcomm 05c6 SK Telesys 1f53 Samsung 400000000 Sharp 04dd Sony 054c Sony Ericsson 0fce Sony Mobile Communications 0fce Teleepoch 2340 Toshiba 930 ZTE 19d2 当你不知道自己的 USB 设备属于哪个供应商时，可以通过lsusb指令查看所有的 USB 设备，然后拔掉 USB，再次执行指令，然后对比一下看少了哪条记录，就能知道 USB 设备的 idVendor 了。 可以看到是Qualcomm -&gt; 05c6。当知道供应商时直接查询表格就可以了。 题外话本来不想贴表格的，觉得 Markdown 弄表格贼麻烦，但是还是搜了一下，找到一个比较方便的方法。Markdown 快速生成表格第三种方式很简单，先粘到 excel 中，然后执行 exe， Linux 下只需要在指令前面加个 wine 即可（安装过 wine 环境）。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Gradle 多版本管理（续）","date":"2017-10-24T02:20:01.000Z","path":"2017/10/24/gradle-app-2/","text":"之前写过一篇Gradle多版本管理，主要是通过productFlavors来控制产品版本。这篇文章将结合buildTypes来说一下多版本管理。在正常开发中，我们一般会有至少 2 个环境：Debug、Release，即测试环境和生产环境。显然这 2 个环境要用 2 套不同的数据，那么在我们的 App 里必然就需要有个地方来控制这个环境。当然，我们可以在 Debug 的时候用 Debug 环境，然后当要发版时手动改成 Release 环境，但是这很麻烦，很难排除忘记修改的情况，那么等待重新编译将是个很漫长的过程。其实Gradle可以很好的解决这个问题：利用 buildTypes 来控制编译类型。buildTypes 默认会有 debug、release 2 个类型，当然我们还可以添加自己的。比如有个beta环境，用于外网测试。当对接一些三方平台的接口时，有的只能用外网，那么只能整一套外网的测试环境了，比如美团外卖。好，现在假设我们有 debug、beta、release 3 个 buildTypes，然后 pad、phone、custom ３个 productFlavors，接下来就是针对这些环境做配置了： 1234567891011121314151617181920212223242526272829303132333435363738394041signingConfigs &#123; lijia &#123; keyAlias 'lijia' keyPassword '123456' storeFile file('../lijia.jks') storePassword '123456' &#125;&#125;buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' buildConfigField(\"Integer\", \"HOST_TYPE\", '0') signingConfig signingConfigs.lijia &#125; debug &#123; buildConfigField(\"Integer\", \"HOST_TYPE\", '1') &#125; beta &#123; buildConfigField(\"Integer\", \"HOST_TYPE\", '2') signingConfig signingConfigs.lijia &#125;&#125;productFlavors &#123; // pad版 pad &#123; applicationId \"com.study.lijia.gradleapp.pad\" &#125; // 手机版 phone &#123; applicationId \"com.study.lijia.gradleapp.phone\" &#125; // 定制版 custom &#123; applicationId \"com.study.lijia.gradleapp\" &#125;&#125; 除了 debug 版不需要签名，其他的编译版本都需要签名。这里随便生成一个，配置在 grandl e中。可以看到我们通过buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#39;2&#39;)来进行配置HOST_TYPE，配置好了后需要在应用启动的时候进行设置。一般放在 Application 中：12345678910public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 设置编译类型 AppCore.setType(BuildConfig.HOST_TYPE); &#125;&#125; 然后 AppCore 根据 HOST_TYPE 来读取、操作不同环境的数据。123456789101112131415161718192021222324public class AppCore &#123; private final static int TYPE_RELEASE = 0; private final static int TYPE_DEBUG = 1; private final static int TYPE_BETA = 2; private static int mHostType = TYPE_DEBUG; public static void setType(int type) &#123; mHostType = type; &#125; public static String getContentFromCore() &#123; if (mHostType == TYPE_RELEASE) &#123; return \"Hello World From Release\"; &#125; else if (mHostType == TYPE_DEBUG) &#123; return \"Hello World From Debug\"; &#125; else if (mHostType == TYPE_BETA) &#123; return \"Hello World From Beta\"; &#125; return \"Hello World\"; &#125;&#125; 然后选择 release 版本运行会显示Hello World From Release，其他版本也会显示对应的字符串。那么我们在打包的时候直接打包 Release Build Variant 就行了。当 Debug 或 Beta 进行调试时，选择 Debug（Beta）Build Variant 即可，通过配置可以减少程序员可能造成的错误。当然，如果只是场景比较简单，你也可以直接代码里写if (BuildConfig.DEBUG)。另外如果 Release 版本出问题后面进行跟踪时， Release 的包默认是会混淆优化资源的，而且不可调试，只能改配置。但是如果是根据 Gradle 配置的，我可以直接在 debug 版本里设置 release 的值：1234567release &#123; buildConfigField(\"Integer\", \"HOST_TYPE\", '0')&#125;debug &#123; buildConfigField(\"Integer\", \"HOST_TYPE\", '0') // 设置和 release 一样的值，运行跟踪问题&#125; 另外一般接入三方 SDK 的时候都会有很多平台的 so，x86 平台一般只是虚拟机用到，在 release 版本中是不需要的，那么就可以配置，在 release 版本中去除 x86，这样也可以减小包的体积。1234567891011121314151617buildTypes &#123; release &#123; ndk &#123; abiFilters 'armeabi', 'armeabi-v7a' &#125; &#125; debug &#123; ndk &#123; abiFilters 'armeabi', 'armeabi-v7a', 'x86' &#125; &#125; beta &#123; ndk &#123; abiFilters 'armeabi', 'armeabi-v7a', 'x86' &#125; &#125;&#125; 通过buildTypes与productFlavors二者结合可以构建出很多的版本，而且可以进行很灵活的配置。文中例子３个 buildTypes，３个 productFlavors，那么就会有3 * 3 = 9个Build Variant了。当然这只是一个Module的配置，当我们Module很多时，上层 App 定义产品 Build Variant，然后依赖 Module 的不同 Build Variant，这样下来我们可以构建各种各样的版本来适应各种需求定制了。再说个项目中用到的场景。业务越做越广，涉及到商家之前的合作也越来越多。很多商家有自己的定制需求，比如换 Logo 啊，换启动图标啊，等等，总不能需求来一个我们就手动改下资源，然后打包吧。所以通过 Gradle 配置好了 Build Variant 了，然后不同的变种下面放置不同的资源，达到打包含不同资源（或其他定制需求）的包的目的。12345678910111213141516buildTypes &#123; retail &#123; &#125; catering &#123; &#125; takeout &#123; &#125;&#125;publishNonDefault trueproductFlavors &#123; mmr &#123;&#125; xgt &#123;&#125; efs &#123;&#125;&#125; 这是我们项目中配置的，然后区分文件夹放置不同的资源： 注意这种配置并不是只有3 * 3 = 9个变种，而是有１５个。buildTypes 默认包含 debug，release，尽管我们没有显示的配置，所以应该是5 * 3 = 15个变种。当不需要某些变种时，可以直接忽略掉：12345678910111213141516variantFilter &#123; variant -&gt; def ignoreVariants = [ \"xgtTakeout\", \"efsTakeout\", \"efsCatering\", ] def buildType = variant.buildType.name // To check for a certain build type, use variant.buildType.name == \"&lt;buildType&gt;\" if (buildType.contains(\"debug\") || buildType.contains(\"release\")) &#123; // Gradle ignores any variants that satisfy the conditions above. setIgnore(true) &#125; else if (ignoreVariants.contains(variant.name)) &#123; setIgnore(true) &#125;&#125; 重新编译，就可以看到变种只剩６个了。Gradle 的功能真的是太强大了，需要持续学习。","tags":[{"name":"gradle","slug":"gradle","permalink":"http://lijia92.github.io/tags/gradle/"}]},{"title":"Android 中的 ClassLoader","date":"2017-10-19T11:26:14.000Z","path":"2017/10/19/classloader/","text":"今天发现了一个在对象序列化时的错误。123456789101112131415161718192021222324252627282930313233343536E/Parcel: Class not found when unmarshalling: com.lijia.study.InventoryDetailjava.lang.ClassNotFoundException: com.lijia.study.InventoryDetail at java.lang.Class.classForName(Native Method) at java.lang.Class.forName(Class.java:309) at android.os.Parcel.readParcelableCreator(Parcel.java:2281) at android.os.Parcel.readParcelable(Parcel.java:2245) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readMapInternal(Parcel.java:2468) at android.os.Parcel.readHashMap(Parcel.java:1678) at android.os.Parcel.readParcelable(Parcel.java:2252) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readArrayMapInternal(Parcel.java:2485) at android.os.BaseBundle.unparcel(BaseBundle.java:221) at android.os.Bundle.getParcelable(Bundle.java:755) at android.content.Intent.getParcelableExtra(Intent.java:5088) ... Caused by: java.lang.ClassNotFoundException: com.lijia.study.InventoryDetail at java.lang.Class.classForName(Native Method) at java.lang.BootClassLoader.findClass(ClassLoader.java:781) at java.lang.BootClassLoader.loadClass(ClassLoader.java:841) at java.lang.ClassLoader.loadClass(ClassLoader.java:469) at java.lang.Class.classForName(Native Method) at java.lang.Class.forName(Class.java:309) at android.os.Parcel.readParcelableCreator(Parcel.java:2281) at android.os.Parcel.readParcelable(Parcel.java:2245) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readMapInternal(Parcel.java:2468) at android.os.Parcel.readHashMap(Parcel.java:1678) at android.os.Parcel.readParcelable(Parcel.java:2252) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readArrayMapInternal(Parcel.java:2485) at android.os.BaseBundle.unparcel(BaseBundle.java:221) at android.os.Bundle.getParcelable(Bundle.java:755) at android.content.Intent.getParcelableExtra(Intent.java:5088) ... Caused by: java.lang.NoClassDefFoundError: Class not found using the boot class loader; no stack available 日志只截取了核心的部分，意思说得很明显了，无法找到类InventoryDetail进行序列化。最后定位错误为使用InventoryDetail类作为HashMap的Value，进行序列化失败。看下使用类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ChooseProductItem implements Parcelable &#123; public SkuBean productSkuBean; public Product product; public double stock = 0D; public HashMap&lt;String, Double&gt; chooseCountMap = new HashMap&lt;&gt;(); public HashMap&lt;String, Double&gt; stockMap = new HashMap&lt;&gt;(); // 重点 public HashMap&lt;String, InventoryDetail&gt; inventoryMap = new HashMap&lt;&gt;(); public HashMap&lt;String, List&lt;CountingTransaction&gt;&gt; countTransMap = new HashMap&lt;&gt;(); public ArrayList&lt;Manifest.ManifestTransaction&gt; transactionList = new ArrayList&lt;&gt;(); private String productNamePinyinFirstWords; public ChooseProductItem(Product product) &#123; this.product = product; &#125; @Override public int describeContents() &#123; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeParcelable(productSkuBean, flags); dest.writeParcelable(this.product, 0); dest.writeDouble(this.stock); dest.writeMap(chooseCountMap); dest.writeMap(stockMap); dest.writeMap(inventoryMap); dest.writeMap(countTransMap); dest.writeList(transactionList); &#125; protected ChooseProductItem(Parcel in) &#123; this.productSkuBean = in.readParcelable(SkuBean.class.getClassLoader()); this.product = in.readParcelable(Product.class.getClassLoader()); this.stock = in.readDouble(); this.chooseCountMap = in.readHashMap(HashMap.class.getClassLoader()); this.stockMap = in.readHashMap(HashMap.class.getClassLoader()); this.inventoryMap = in.readHashMap(HashMap.class.getClassLoader()); this.countTransMap = in.readHashMap(CountingTransaction.class.getClassLoader()); this.transactionList = in.readArrayList(Manifest.ManifestTransaction.class.getClassLoader()); &#125; public static final Creator&lt;ChooseProductItem&gt; CREATOR = new Creator&lt;ChooseProductItem&gt;() &#123; public ChooseProductItem createFromParcel(Parcel source) &#123; return new ChooseProductItem(source); &#125; public ChooseProductItem[] newArray(int size) &#123; return new ChooseProductItem[size]; &#125; &#125;;&#125; 最后错误定位到：1this.inventoryMap = in.readHashMap(HashMap.class.getClassLoader()); 这里在读取 HashMap 的时候找不到类，导致序列化失败。 这里先讲述一下 ClassLoader。Android 中的 ClassLoader 类型分为两种类型，分别是系统 ClassLoader 和自定义 ClassLoader 。其中系统 ClassLoader 包括三种分别是 BootClassLoader、PathClassLoader 和 DexClassLoader。 BootClassLoader：Android 系统启动时会使用 BootClassLoader 来预加载常用类。BootClassLoader 是一个单例类，需要注意的是 BootClassLoader 的访问修饰符是默认的，只有在同一个包中才可以访问，因此我们在应用程序中是无法直接调用的。 PathClassLoader：Android 系统使用 PathClassLoader 来加载系统类和应用程序的类，如果是加载非系统应用程序类，则会加载data/app/目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载哪种文件，最终都是要加载dex文件，在这里为了方便理解，我们将dex文件以及包含dex的apk文件或jar文件统称为dex相关文件。PathClassLoader 不建议开发直接使用。 DexClassLoader：DexClassLoader 可以加载dex文件以及包含dex的apk文件或jar文件，也支持从SD卡进行加载，这也就意味着 DexClassLoader 可以在应用未安装的情况下加载dex相关文件。因此，它是热修复和插件化技术的基础。 现在回过头来看之前的代码：12345public HashMap&lt;String, InventoryDetail&gt; inventoryMap = new HashMap&lt;&gt;();...this.inventoryMap = in.readHashMap(HashMap.class.getClassLoader()); readHashMap传入的参数是ClassLoader，我传入的是HashMap.class.getClassLoader()，HashMap 作为系统自带常用类，是由BootClassLoader进行加载的，而我应用自己编写的类InventoryDetail是由PathClassLoader进行加载的。那么显然，在BootClassLoader中找由PathClassLoader加载的类显然是找不到的，便会报错了。可以看到chooseCountMap、stockMap传入的也是HashMap.class.getClassLoader()，因为其 Value 类型为 Double，也是系统常用类，也是由BootClassLoader进行加载的，所以不会有问题。以后在涉及到 ClassLoader 的时候可要细心点了。这里简单验证一下：12345678910111213ClassLoader classLoader1 = Double.class.getClassLoader();ClassLoader classLoader2 = HashMap.class.getClassLoader();ClassLoader classLoader3 = MyClass.class.getClassLoader();Log.e(\"TAG\", classLoader1.toString());Log.e(\"TAG\", classLoader2.toString());Log.e(\"TAG\", classLoader3.toString());...10-19 20:07:49.659 16333-16333/? E/TAG: java.lang.BootClassLoader@212c4b0d10-19 20:07:49.659 16333-16333/? E/TAG: java.lang.BootClassLoader@212c4b0d10-19 20:07:49.659 16333-16333/? E/TAG: dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.study.lijia.myapplication-2/base.apk\"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]] 很显然了。 另外说下，ArrayList 在序列化的时候可以直接使用：1this.transactionList = in.createTypedArrayList(Manifest.ManifestTransaction.CREATOR); 可以消除Unchecked assignment: &#39;java.util.ArrayList&#39; to &#39;java.util.ArrayList&lt;xxx.Manifest.ManifestTransaction&gt;&#39;的警告，只不过使用createTypedArrayList时 List 需要显示定义成 ArrayList。 Android解析ClassLoader（二）Android中的ClassLoader","tags":[{"name":"code","slug":"code","permalink":"http://lijia92.github.io/tags/code/"}]},{"title":"Android 集成讯飞语音SDK","date":"2017-09-26T08:42:29.000Z","path":"2017/09/26/xunfei/","text":"项目开发需要用到文字转语音的功能，利用 Android 系统自带的Text-to-Speech可以实现英文转语音，但是对于中文就无能为力了。对于中文转语音需要特定引擎的支持，谷歌自带的Pico TTS是不支持的，我的小米手机是度秘语音引擎支持中文，显然我们没法去控制用户用什么手机，所以抛弃原生的TTS，考虑接入讯飞语音SDK。 注册开发者账号进入讯飞开放平台注册账号。 创建应用登录账号，进入控制台，选择创建新应用。 下载SDK点击SDK下载。选择下载服务、平台、应用，然后点击下载。我这里只选择了在线语音合成，免费的。然后得到SDK： 集成SDK首先将对应手机CPU平台的 so 文件导入到工程中，jar 包导入到 libs 中。 在 Application 中初始化讯飞语音：1SpeechUtility.createUtility(this, SpeechConstant.APPID +\"=xxxxxxxx\"); 在调用的地方初始化语音对象：12345678910111213141516171819202122232425private SpeechSynthesizer mTts;private void initMSC() &#123; mTts = SpeechSynthesizer.createSynthesizer(mActivity, new InitListener() &#123; @Override public void onInit(int code) &#123; if (code == ErrorCode.SUCCESS) &#123; // 设置在线合成 mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); // 设置在线合成发音人 mTts.setParameter(SpeechConstant.VOICE_NAME, \"xiaoqi\"); //设置合成语速 mTts.setParameter(SpeechConstant.SPEED, \"50\"); //设置合成音调 mTts.setParameter(SpeechConstant.PITCH, \"50\"); //设置合成音量 mTts.setParameter(SpeechConstant.VOLUME, \"100\"); //设置播放器音频流类型 mTts.setParameter(SpeechConstant.STREAM_TYPE, \"3\"); // 设置播放合成音频打断音乐播放，默认为true mTts.setParameter(SpeechConstant.KEY_REQUEST_FOCUS, \"true\"); &#125; &#125; &#125;);&#125; 然后调用API：1234int code = mTts.startSpeaking(\"Hello 中国\");if (code != ErrorCode.SUCCESS &amp;&amp; code != ErrorCode.ERROR_COMPONENT_NOT_INSTALLED) &#123; ToastUtils.showShort(mActivity, \"语音合成失败,错误码: \" + code);&#125; 过程比较简单，稍微记录一下，更多详情可以参阅官方文档。","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"Android 双屏异显","date":"2017-09-13T10:42:54.000Z","path":"2017/09/13/presentation/","text":"最近在做收银机相关的开发，涉及到双屏异显的一些东西，之前也没有接触过，在查阅一番资料之后，把功能走通了，这里小记一下。 PresentationPresentation 是一种特殊的对话框，主要用于在另外一块屏幕上显示内容。默认为克隆模式，即副屏显示和正屏一样的内容。当需要显示不同内容时，需要自定义 Presentation，并为其指定一个 Display。这里随便定义一个 Presentation：123456789101112public class MyPresentation extends Presentation &#123; public MyPresentation(Context outerContext, Display display) &#123; super(outerContext, display); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.presentation_second_screen); &#125;&#125; 声明权限因为 Presentation 是对话框，所以需要以下权限：12&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/&gt;&lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\" /&gt; 获取 Displays在实例化 Presentation 之前需要先获取 Displays。12345678910private void initDisplays() &#123; if (android.os.Build.VERSION.SDK_INT &lt; android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; return; &#125; DisplayManager mDisplayManager; mDisplayManager = (DisplayManager) this.getSystemService(Context.DISPLAY_SERVICE); mDisplays = new Display[0]; mDisplays = mDisplayManager.getDisplays();&#125; mDisplays 即代表设备所有的屏幕。 实例化 Presentation12345678910111213private void initPresentation() &#123; if (android.os.Build.VERSION.SDK_INT &lt; android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; return; &#125; if (mPresentation == null &amp;&amp; mDisplays != null &amp;&amp; mDisplays.length &gt; 1) &#123; mPresentation = new MyPresentation(this, mDisplays[mDisplays.length - 1]); if (mPresentation.getWindow() != null) &#123; mPresentation.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT); &#125; mPresentation.show(); &#125;&#125; 通过 show() 方法即可展示了。 Tips 双屏需要API &gt;= 17才可使用。 需要兼容只有一块屏幕的设备。所以在展示时，最好加上mDisplays.length &gt; 1的判断，避免在单屏设备上展示了副屏要展示的内容。 直接在 Activity onCreate 中初始化进行展示时，会展示不了，需要延迟一点进行展示。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android 日常开发的一些小知识","date":"2017-08-29T09:06:48.000Z","path":"2017/08/29/small-tips/","text":"前段时间终于下定决心自己实践 RxJava，Retrofit 等当前十分流行的库，利用 Gank.io 的公共 API，做一个自己的 Gank 客户端。项目地址： Gank。只要有闲暇时间便会写写代码，慢慢完善。期间有一些小的知识点，但是却很实用，这里便列一下。关于 RxJava，Retrofit 目前学习还不是很深入，这里便不展开了。 @SerializedName现在与服务端通信通常都是Json，但是服务器返回的Json串的key是服务端自己的命名规则（可能是中文key，或者大写开头），我们直接通过Gson解析就必须一一对应，但是这样的命名在Java里很不友好。那么就可以通过@SerializedName注解给Bean类进行“重命名”，这样在解析的时候便可以直接利用我们自己的命名规则命名变量了。举个栗子：http://gank.io/api/day/2017/08/03返回的数据包含Android，福利等不符合Java规范的key，那么就可以这样：12345678910111213141516public class DataResults &#123; @SerializedName(\"Android\") List&lt;ItemData&gt; androidList; @SerializedName(\"iOS\") List&lt;ItemData&gt; iOSList; @SerializedName(\"休息视频\") List&lt;ItemData&gt; restList; @SerializedName(\"前端\") List&lt;ItemData&gt; jsList; @SerializedName(\"福利\") List&lt;ItemData&gt; welfareList;&#125; 如此便可以直接通过Gson解析，并且变量名是以我们自己的命名规则进行命令的了。 水波纹效果Android 5.0 及以上才有水波纹效果。简单实现:1android:background=\"?attr/selectableItemBackground\" 也可以添加手动添加drawable:1234&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" android:color=\"?android:colorControlHighlight\"&gt;&lt;/ripple&gt; 然后设置给布局的 background， 布局必须可点击。同时为了兼容，最好建立drawable-v21来区分开来。建立低版本的 drawable 去对应 5.0 以下的版本。当然，目前也有很多库可以实现 5.0 以下的水波纹效果，可以参考RippleEffect。 android5.0 水波纹点击效果 Intent传递复杂数据我们知道可以通过 Intent 在多个 Activity、Fragment 之间进行数据传递。基本数据类型不用说，当传递自定义数据类型时，需要实现 Serializable 或 Parcelable 接口。前者通过 Intent 的 getSerializableExtra() 获取数据，后者通过 getParcelableExtra()、getParcelableArrayExtra()、getParcelableArrayListExtra() 获取数据。但是当我们传递的数据是ArrayList&lt;List&lt;Object&gt;&gt;这种嵌套 List 数据呢？当我们是通过 Parcelable 接口进行传递时，会碰到如下的错误：1Error:(46, 88) 错误: 不兼容的类型: ArrayList&lt;Parcelable&gt;无法转换为ArrayList&lt;List&lt;MyObject&gt;&gt; 即类型无法强转。当我们通过 Serializable 接口进行传递时，没有错误，只会有警告：1Unchecked cast: 'java.io.Serializable' to 'java.util.ArrayList&lt;java.util.List&lt;com.study.lijia.gank.data.MyObject&gt;&gt;' 这警告只需添加@SuppressWarnings(&quot;unchecked&quot;)即可消除。看到 ArrayList 的定义:12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 实现了 Serializable，自然是能转换的，但是没有实现 Parcelable，所以无法使用 Parcelable 传递ArrayList&lt;List&lt;Object&gt;&gt;这种嵌套 List 数据。碰到这种需求则只能通过 Serializable 接口来了，或者更换数据传递的方式。 获取资源经常我们会通过mContext.getResources().getColor(R.color.black);来获取我们定义在 color.xml 中的颜色，但是 getColor(@ColorRes int id) 已经被标记为@Deprecated，导致代码里看起来就是一条横线，很不舒服。当然我们可以通过 getColor(@ColorRes int id, @Nullable Theme theme) 来替换它，但是又会有这个问题：1Call requires API level 23 (current min is 15): android.content.res.Resources#getColor 代码强迫症肯定依然受不了。此时我们可以通过 ContextCompat 来获取1ContextCompat.getColor(mContext, R.color.black); 它的实现：12345678public static final int getColor(Context context, @ColorRes int id) &#123; final int version = Build.VERSION.SDK_INT; if (version &gt;= 23) &#123; return ContextCompatApi23.getColor(context, id); &#125; else &#123; return context.getResources().getColor(id); &#125;&#125; 一目了然了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"管理 Github 上的 star","date":"2017-08-04T09:01:29.000Z","path":"2017/08/04/github-star/","text":"Github 逛久了，相信大家都会有很多star，虽然很多star后面再也不会看的。但是只要有那么一丁点的可能回头看，我们还是需要将自己的star整理一下，不然感觉都是无从下手。那么问题便来了：如何管理 Github 上的 star ?答案便是 Astral。这是我偶然发现的一个网站，它可以用来给 Github 上的 star 分类。具体界面是这样子的: 界面很简单，打开就能直接上手用，整理了一个下午，终于将自己的 200 多个 star 全部清理个便，分了几个 TAG，后面再回顾的时候便会方便多了。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"尝试使用 Android SVG","date":"2017-07-26T10:50:34.000Z","path":"2017/07/26/svg/","text":"普遍的 Android 开发可以理解为移动端界面开发，那么界面自然是重中之重。当设计师给到你设计稿时，你便需要将设计稿中的东西用代码做出来。项目开发中便遇到了这样一个设计稿： 这算是一个很基本的对话框了，没什么难度。写这篇文章主要是为了记一下图中关闭按钮的实现。这个关闭按钮算是再简单不过的一个图标了，那么要如何实现呢？当然可以找到设计师要切图。但是这里我想尝试一下 Android 中的 SVG，顺便也是减轻设计师的工作量，经常劳烦别人也不是什么好事。 SVG什么是 SVG ?简单来说：SVG 即 可缩放矢量图形(Scalable Vector Graphics)，是使用XML来描述二维图形和绘图程序的语言，其定义遵循W3C标准。它有哪些特点： SVG 可被非常多的工具读取和修改(比如记事本) SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强 SVG 是可伸缩的，可以保证高清晰度的被放大 SVG 文件是纯粹的 XML 特殊说明一下，SVG 相比 Bitmap，它最大的优点就是放大不会失真。当 Bitmap 需要为不同分辨率适配多套图标时，一套 SVG 即可搞定一切分辨率。 如何使用这里说一下最简单的使用方法： 首先去阿里巴巴矢量图标库(当然也有其他的网站)搜索需要的图标。 下载需要图标的 SVG 图像。 到Android SVG to VectorDrawable将下载的 SVG 图像转成 XML（也可通过 Android Studio 本身的支持进行转换），然后直接用到 Android Studio 中的 drawable 中即可。 举个栗子在网站搜索关闭图标： 选择上图中第三个图标，选择下载： 选择图标颜色，大小，选择SVG 下载。然后将下载的文件拖到上面所说的网站中即可生产 XML： 然后直接用到 drawable 即可： 当然你可以利用 Android Studio 本身的 VectorDrawable 支持： 文中关于 SVG 的使用算是最简单的了，但是 SVG 还有很多其他的用法，它有很多标签，来实现各种效果，有兴趣的同学可以自行谷歌。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"关于 ConcurrentModificationException 异常","date":"2017-07-11T08:24:35.000Z","path":"2017/07/11/java-set/","text":"List、Map等这类数据结构在日常开发中的使用不可谓不多，经常会有遍历的同时进行修改的情况。例如：1234567Integer[] numbers = new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(numbers));for (Integer integer : list) &#123; if (integer % 5 == 0) &#123; list.remove(integer); &#125;&#125; 这段代码在执行的时候便会抛出异常：1234Exception in thread \"main\" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at com.example.MyClass.main(MyClass.java:16) 这个异常出现通常是遍历一个集合的同时，在修改这个集合。看到next方法：123456789101112131415public E next() &#123; this.checkForComodification(); int var1 = this.cursor; if(var1 &gt;= ArrayList.this.size) &#123; throw new NoSuchElementException(); &#125; else &#123; Object[] var2 = ArrayList.this.elementData; if(var1 &gt;= var2.length) &#123; throw new ConcurrentModificationException(); &#125; else &#123; this.cursor = var1 + 1; return var2[this.lastRet = var1]; &#125; &#125;&#125; 然后看到checkForComodification：12345final void checkForComodification() &#123; if(ArrayList.this.modCount != this.expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 即当modCount 与 expectedModCount 不相等时，会抛 ConcurrentModificationException 异常。其实很早之前就会碰到这个问题，使用Iterator进行遍历和操作就不会出现这个问题了，但是一直没有深究其原因。 之前听同事说，for each内部就是使用的Iterator。但是最近项目中就算使用了for each也还是出现了上面的异常。于是决心细究一番。将上面的示例代码转成 class 文件，可以看到：12345678910Integer[] numbers = new Integer[]&#123;Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), Integer.valueOf(5), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8), Integer.valueOf(9), Integer.valueOf(10)&#125;;ArrayList list = new ArrayList(Arrays.asList(numbers));Iterator var4 = list.iterator();while(var4.hasNext()) &#123; Integer integer = (Integer)var4.next(); if(integer.intValue() % 5 == 0) &#123; list.remove(integer); &#125;&#125; 确实看到了Iterator的身影，但是却忽视了真正重要的一点:remove()方法的执行者。将遍历代码改成如下:1234567Iterator iterator = list.iterator();while (iterator.hasNext()) &#123; Integer integer = (Integer) iterator.next(); if (integer % 5 == 0) &#123; iterator.remove(); &#125;&#125; 便可执行通过了。看到 class 文件如下：123456while(iterator.hasNext()) &#123; Integer integer = (Integer)iterator.next(); if(integer.intValue() % 5 == 0) &#123; iterator.remove(); &#125;&#125; 可以看到都是通过Iterator进行遍历，唯独在执行remove操作的时候，报错的示例执行对象是list本身，而正确的示例执行对象是iterator。那么接下来对比下二者的remove方法，便可找到真相了。看到ArrayList自身实现的remove方法：123456789101112131415161718192021222324252627282930public boolean remove(Object var1) &#123; int var2; if(var1 == null) &#123; for(var2 = 0; var2 &lt; this.size; ++var2) &#123; if(this.elementData[var2] == null) &#123; this.fastRemove(var2); return true; &#125; &#125; &#125; else &#123; for(var2 = 0; var2 &lt; this.size; ++var2) &#123; if(var1.equals(this.elementData[var2])) &#123; this.fastRemove(var2); return true; &#125; &#125; &#125; return false;&#125;private void fastRemove(int var1) &#123; ++this.modCount; int var2 = this.size - var1 - 1; if(var2 &gt; 0) &#123; System.arraycopy(this.elementData, var1 + 1, this.elementData, var1, var2); &#125; this.elementData[--this.size] = null;&#125; 看到ArrayList中Iterator实现的remove方法：12345678910111213141516public void remove() &#123; if(this.lastRet &lt; 0) &#123; throw new IllegalStateException(); &#125; else &#123; this.checkForComodification(); try &#123; ArrayList.this.remove(this.lastRet); this.cursor = this.lastRet; this.lastRet = -1; this.expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException var2) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; 如此便一目了然了，ArrayList 本身的 remove 方法执行完之后没有同步 modCount 与 expectedModCount，而 Iterator 有同步。在遍历的时候会 checkForComodification，当使用的非 Iterator 的 remove 方法，会造成 2 个 count 不相等，如此便会抛出异常了。那么细想一下：为什么 Java 集合在遍历的时候要做这样的检查呢？这里引用一下网友的想法，大家自行思考吧～ 设置modCount和expectedModCount的目的是为了检测iterator的有效性，检测是否有其它操作对HashMap的结构进行了修改，由于这些操作不是通过当前iterator进行的，因此有可能破坏iterator的有效性。通过iterator执行remove只能删除当前iterator所在的元素，不会让iterator失效。而通过HashMap.remove()实际上可以删除任意元素，这个元素有可能正是iterator内部的next变量已经引用了的元素，造成iterator失效。 最后说 2 点题外话： Arrays.asList不接受 Java 基本数据类型数组作为参数。原因asList接受的参数为Object，而基本数据类型不是。但是代码List list = Arrays.asList(new int[]{1,2,3})不会报错，因为int[]是Object，此代码会生产一个size = 1的列表。 通过Arrays.asList方法返回的List是不能修改的。 参考：Java遍历HashMap并修改(remove)把Java数组转换为List时的注意事项Java 集合细节（二）：asList 的缺陷","tags":[{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"}]},{"title":"关于 ViewPager 的2点特性","date":"2017-06-30T01:54:26.000Z","path":"2017/06/30/viewpager/","text":"新手引导是每个 App 都具备的。如果新手引导直接用 Activity 来做，可能就会比较繁杂和冗余。所以一般都是 ViewPager 来实现。那么便会有 2 个问题： 不能手动滑动 当前 item 跳转到下一个 item 要平滑滑动 自定义ViewPager可以解决这 2 个问题，下面直接上代码：1234567891011121314151617181920212223242526272829303132333435package android.support.v4.view;import android.content.Context;import android.util.AttributeSet;import android.view.MotionEvent;/** * 1、禁止左右滑动 * 2、setCurrentItem平滑切换 */public class NoScrollViewPager extends ViewPager &#123; public NoScrollViewPager(Context context) &#123; super(context); &#125; public NoScrollViewPager(Context context, AttributeSet attr) &#123; super(context, attr); &#125; void smoothScrollTo(int x, int y, int velocity) &#123; super.smoothScrollTo(x, y, 1); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; return false; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125;&#125; 禁止滑动通过触摸事件返回false，这个很好理解了。setCurrentItem及时添加第二个参数为true也没有平滑滑动的效果，参考stackoverflow。 引申Java 有四种访问权限修饰符： 访问权限 类 包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 通过上面的stackoverflow可以看到，当Android Sdk的某个方法是default时,我们是没有权限调用的，有 2 种方式来解决问题： 反射 建立相同路径的包名，包访问域可以访问到default方法","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"初识 zsh","date":"2017-06-09T02:21:18.000Z","path":"2017/06/09/zsh/","text":"昨天写关于 git 的文章的时候，需要来回切分支，而且 bash 也看不到当前是哪个分支，得不停git branch来看，显得十分麻烦。于是便不得不逼着自己一把，来熟悉一波zsh了。 同事有用zsh的，而且鼎力推荐，因为目前的工作和学习与命令行的交集不是很深，所以一直没有开始用。最近发现bash相比zsh确实是难用许多，便只能硬着头皮来学习了。之所以是硬着头皮，是因为自己对 Linux 系统不是很熟悉，虽然现在是在用，但是对于 Linux 的很多特性都不是很了解，命令行、Shell 脚本算是 Linux 一大特色。 zsh有着强大的功能，但是其配置也是异常复杂，于是 Github 上便有了这样的一个库：oh-my-zsh，oh-my-zsh是为了简化zsh的配置而提供的一个配置模板，可以更好的管理zsh的各项配置。可以看到它有 55k 的 star，可见其火爆程度。现在才来接触，显得挺惭愧的。 关于oh-my-zsh的安装直接照着 github 中的README一步一步来就好了。就提醒一点，安装完之后需要注销掉用户，重启也可以，然后再重新登录，才可以看到zsh。 关于zsh的优势，网上众说纷纭，但是我目前用的不多，体会得不深。现在就我体会到的来说几点。 git支持很直接的一个体现就是进入到有 git 版本控制的目录，会显示出当前所在的分支。 再也不同git branch来看当前是什么分支了。另外，oh-my-zsh也配置了很多 git 命令别名，方便使用。比如gst代表git status，gco代表git checkout，还有许许多多的配置，可以参考Plugin:git。 Tab自动补全比如我想进入到 blog 目录，我敲cd b然后按Tab，zsh变回把所有 b 开头的目录列出来，然后再按Tab，它会帮你选择目录，当选到自己想要的目录时，按回车就可以进入了，是不是非常方便！！！ 大小写忽略大小写切换是很常见的，在上个例子中，即使我敲成cd B也能找到blog目录。 autojump当目录层级很深的时候，想要进入到那个目录得一直cd--ls--cd--ls，就像这样： 看着就觉得头疼，因为实在无法记住那么长的目录。对此，autojump可谓是一大神作。先安装：1sudo apt-get install autojump 然后打开.zshrc，找到plugins，加入autojump：1plugins=(git autojump) 之后便是这种姿势打开目录了： 怎么样，是不是简直爽爆了！？再也不用臃肿的敲着蛋疼的cd了。当在一次终端行为中，有了多个进入的目录，可以直接输入d来看到目录，然后直接输入数字便可以快捷进入到相应的目录中了。 简直就是方便！又多了一个不得不用zsh的理由了！！！ 快速打开当前所在文件夹编辑.zshrc文件，加入：1alias o=\"nautilus .\" 当命令行处于某个文件夹下时，直接键入o即可打开当前文件夹。 这其实只是给zsh配置了一个别名，任何我们常用的操作都可以根据自己喜好配置别名，方便使用。 目前体验的到的可能就这几个我很欣赏的特性了。当然也是才刚刚开始使用，后面有别的再行补充。这里先贴一下网友的配置，后面可能用得到：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# ZSH的环境变量export ZSH=/Users/dawang/.oh-my-zsh# 主题设置# 主题列表在 ~/.oh-my-zsh/themes/# 如果设置为 \"random\", 每次开启都会是不同的主题ZSH_THEME=\"agnoster\"# 如果想要大小写敏感，可以取消注释下面的一行# CASE_SENSITIVE=\"true\"# 如果想要连接符不敏感，可以取消注释下面的一行。_ 和 - 将可以互换# HYPHEN_INSENSITIVE=\"true\"# 如果不想要自动更新，可以取消注释下面的一行# DISABLE_AUTO_UPDATE=\"true\"# 自动更新的时间间隔，单位是天，这里设置 30 天更新一次export UPDATE_ZSH_DAYS=30# 如果不想要 ls 命令输出带颜色，可以取消注释下面的一行# DISABLE_LS_COLORS=\"true\"# 是否禁止更改终端标题,不要禁止,不然所有终端tab只显示zsh了,而不随着目录的改变而改变显示# DISABLE_AUTO_TITLE=\"true\"# 自动纠正命令,不启用,不怎么好用# ENABLE_CORRECTION=\"true\"# 按tab键补全命令的时候,如果没什么可补全的就会出现三个红点,更人性化显示，这里我们启用COMPLETION_WAITING_DOTS=\"true\"# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# 不要在意这些细节，不需要改动# DISABLE_UNTRACKED_FILES_DIRTY=\"true\"# 历史命令日期显示格式# 有三种方式: \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\"，我比较习惯最后那种HIST_STAMPS=\"yyyy-mm-dd\"# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# 插件设置，如果添加太多启动速度会比较慢plugins=(git autojump)[[ -s ~/.autojump/etc/profile.d/autojump.zsh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.zsh# 剩下部分比较不常改动# User configurationexport PATH=\"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/TeX/texbin\"# export MANPATH=\"/usr/local/man:$MANPATH\"source $ZSH/oh-my-zsh.sh# You may need to manually set your language environment# export LANG=en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then# export EDITOR='vim'# else# export EDITOR='mvim'# fi# Compilation flags# export ARCHFLAGS=\"-arch x86_64\"# ssh# export SSH_KEY_PATH=\"~/.ssh/dsa_id\"# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run `alias`.## Example aliases# alias zshconfig=\"mate ~/.zshrc\"# alias ohmyzsh=\"mate ~/.oh-my-zsh\" 题外话Ubuntu用了也有段时间了，但是感觉还是像用Windows一样在用Ubuntu，很多东西还是依赖图形化界面。但是作为一个开发人员，Shell脚本更值得去拥抱。所以决心后面多用多学，真正拥抱Linux。 最后安利一波 Ubuntu 下录制 Gif 的方案：安装 Wine，下载 GifCam.exe，然后直接运行 GifCam.exe。","tags":[{"name":"linux","slug":"linux","permalink":"http://lijia92.github.io/tags/linux/"}]},{"title":"关于 Git 的使用小记","date":"2017-06-07T12:04:42.000Z","path":"2017/06/07/git/","text":"相信选择选择绝大部分开发者都使用的 Git 来进行版本控制，关于 Git 比较基本的东西就不说了，这里主要记录一下我用到的 2 个较为进阶一点的命令。 git revert场景：假定现在有一个分支develop/1.0.0，该分支用于发布1.0.0版本的包，develop/1.0.0依赖一个 module，该 module 的版本与之对应也是1.0.0，就在将要打包的时候， develop 分支新增了一个提交，这个提交依赖 module 的1.0.1版本，可能是由于同事之间的沟通不足导致这种问题，不需要提交的被提交了。在发布1.0.0版本的包时，是不应该包含最新的提交的。那么可以怎么样做呢？revert 意为回退。可以使用git revert指令，回退最新的一次提交。举个例子：初始化一个 git 仓库，添加一个文件git，做一次提交init。然后编辑git文件，做一次提交feature A。准备以当前节点打包时，又多了一次提交feature B，此次提交是不需要包含到此次打包的代码里的。 此时git log可以看到 3 次提交： 执行指令：1git revert 10ffa5 10ffa5为需要回退的 commit id，即上图中feature B那次提交，版本号没必要写全，前几位就可以了，Git会自动去找。填写提交信息： 执行结束后，代码便回退到feature A的提交了,可以安心打包了。 打完包后，可以基于develop/1.0.0分支 new branchdevelop/1.0.1，然后切到develop/1.0.1执行指令：1git revert 13fbb4 之前feature B的提交便回来了，可以继续开发了。 git cherry-pick场景：假定现在有 2 个分支feature/A、feature/B，然后发现了一个 bug，这个 bug 是公共代码造成的，即 2 个分支都存在这样的 bug。选择在feature/A上修复这个 bug，但不能直接 merge feature/A到feature/B上，因为 2 个分支在进行不同特性的开发。那么可以怎么样做呢？cherry-pick 是对已经存在的 commit 进行再次提交。举个例子：我们在feature/A分支修复问题后提交。然后切到feature/B分支，执行指令：1git cherry-pick a89acbe4 因为我的例子中，2 个分支都对同一个文件同一个位置做了修改，所以冲突了。提示： 所以需要先解决冲突，然后执行：1git cherry-pick --continue 好了，再来看看修复bug的提交是否存在feature/B分支中吧。 最后贴一下关于 Git 的一个很好的教程：git-recipes","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"关于混淆的一个小纰漏","date":"2017-05-09T05:37:46.000Z","path":"2017/05/09/confuse/","text":"混淆，相信只要是上线的的应用都会运用到。这里记一下项目中因为混淆而导致的一个较难发现的问题。 问题是这样的：有一个实体类PrintTemplate类，当我调用一个网络接口，会从服务器获取这个类的一个 list，然后我会用 Json 转成字符串存到本地，当要用的时候根据 key 去取对应的模板字符串，然后转成类实体进行使用。当然，混淆规则中没有保持这个类不被混淆。 假设现在的版本是 V1.0，测试打出来的 Release 包是没有问题的。然后版本更新到 V1.1，单独测试也是没问题的。但是，如果是从 V1.0 升到的 V1.1，那么在取对应的模板字符串，然后转成类实体进行使用这一步就会出错了，无法解析到正常的类。如果没有添加异常保护，则会直接崩溃了。 示例代码：1234567891011121314151617181920212223242526272829303132public static PrintTemplate getPrinterTemplate(String bookId, int templateId) &#123; PrintTemplate template = null; String str = getString(KEY_PRINTER_TEMPLATE + \"_\" + bookId + \"_\" + templateId); if (!TextUtils.isEmpty(str)) &#123; try &#123; // 这里没有添加异常捕获，导致直接崩溃 template = JSON.parseObject(str, PrintTemplate.class); &#125; catch (Exception e) &#123; template = null; &#125; &#125; return template;&#125;public static void savePrinterTemplate(List&lt;PrintTemplate&gt; templates, String bookId) &#123; List&lt;TemplateBean&gt; templateTypes = new ArrayList&lt;&gt;(); for (PrintTemplate template : templates) &#123; // 逐一保存每个模板 String str = JSONObject.toJSONString(template); putString(KEY_PRINTER_TEMPLATE + \"_\" + bookId + \"_\" + template.id, str); TemplateBean bean = new TemplateBean(); bean.id = template.id; bean.name = template.typeName; if (!templateTypes.contains(bean)) &#123; templateTypes.add(bean); &#125; &#125; // 保存所有的业务类型 String typeValues = JSONArray.toJSONString(templateTypes); putString(KEY_PRINTER_TEMPLATE_TYPE, typeValues);&#125; 问题的根源很简单，就是类被混淆了嘛。举个栗子，类的属性为 id, name，存入的字符串可能是&quot;{&quot;a&quot;:1,&quot;b&quot;:&quot;2&quot;}&quot;，a 对应 id，b 对应 name，但是当版本升级后，这个类混淆后属性可能就变成了 c 和 d，那么当拿到那个混淆后的字符串进行重新解析的时候肯定就会有问题了。但是只有版本升级的时候才会出现这个问题，平时自己的测试恰好就把这个问题给规避了。这里记录一下，还好尽早改正了，对用户的影响不大。 这里顺便贴一下混淆的一些规则，开发中要保持警惕： 如果使用了Gson之类的工具要使JavaBean类即实体类不被混淆。 如果使用了自定义控件那么要保证它们不参与混淆。 如果使用了枚举要保证枚举不被混淆。 对第三方库中的类不进行混淆。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"针对ListView多Type的优化","date":"2017-05-09T02:46:58.000Z","path":"2017/05/09/multi-type/","text":"在之前写过一篇多 Type 的错误使用使用ListView多Type的错误姿势，下面写一下针对这种使用场景的优化。 可以看到之前的代码很繁杂，根据各种 Type 有各种 position 的判断，在 getView 的时候代码一坨一坨的看着很不舒服，那么有没有什么优化策略呢？可以知道多 Type 的使用原因是界面多种展示风格，本质的原因则是数据类型的不一致，即数据源中有多种数据类型，那么就可以直接 利用泛型来实现数据的区分，整合一个 List mDataList 里面包含所有的数据，在根据 getItem 来获取单个的 item，根据其数据类型来判断属于哪种 Type。 根据策略，将头部的布局抽成String类型，将打印机的布局抽成PrinterInfo类型，后面获取item后根据类型来判断是头布局，还是打印机布局。优化后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268public class PrinterManagerAdapter extends BaseAdapter &#123; private static final int TYPE_HEADER = 0; private static final int TYPE_PRINTER = 1; private static final String TITLE_BLUETOOTH_PRINTER = \"蓝牙打印机\"; private static final String TITLE_NET_PRINTER = \"网络打印机\"; private static final String TITLE_CLOUD_PRINTER = \"云打印机\"; private Context mContext; private LayoutInflater mInflater; private OnItemFunctionClickListener listener; private List&lt;Object&gt; mDataList = new ArrayList&lt;&gt;(); public PrinterManagerAdapter(Context context, ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; mContext = context; mInflater = LayoutInflater.from(context); initDataList(printers); setNotSwipeItems(listView); &#125; private void initDataList(List&lt;PrinterInfo&gt; printerList) &#123; mDataList.clear(); List&lt;PrinterInfo&gt; bluetoothPrinterList = new ArrayList&lt;&gt;(); List&lt;PrinterInfo&gt; netPrinterList = new ArrayList&lt;&gt;(); List&lt;PrinterInfo&gt; cloudPrinterList = new ArrayList&lt;&gt;(); for (PrinterInfo info : printerList) &#123; if (info.printerType == PrinterInfo.TYPE_BLUETOOTH) &#123; bluetoothPrinterList.add(info); &#125; else if (info.printerType == PrinterInfo.TYPE_NETWORK) &#123; netPrinterList.add(info); &#125; else if (info.printerType == PrinterInfo.TYPE_CLOUD) &#123; cloudPrinterList.add(info); &#125; &#125; mDataList.add(TITLE_BLUETOOTH_PRINTER); mDataList.addAll(bluetoothPrinterList); mDataList.add(TITLE_NET_PRINTER); mDataList.addAll(netPrinterList); mDataList.add(TITLE_CLOUD_PRINTER); mDataList.addAll(cloudPrinterList); &#125; private void setNotSwipeItems(SwipePartMenuListView listView) &#123; List&lt;Integer&gt; titleList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mDataList.size(); i++) &#123; if (mDataList.get(i) instanceof String) &#123; titleList.add(i); &#125; &#125; listView.setCannotSwipePositionList(titleList); &#125; public void setPrinters(ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; initDataList(printers); setNotSwipeItems(listView); &#125; public void setListener(OnItemFunctionClickListener listener) &#123; this.listener = listener; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; int viewType = getItemViewType(position); if (viewType == TYPE_HEADER) &#123; return getTitleView(position, convertView, parent); &#125; else &#123; return getPrinterView(position, convertView, parent); &#125; &#125; private View getPrinterView(int position, View convertView, ViewGroup parent) &#123; PrinterViewHolder printerHolder; if (convertView == null) &#123; printerHolder = new PrinterViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_devices, parent, false); printerHolder.connect = (TextView) convertView.findViewById(R.id.printer_connect_tv); printerHolder.divider = convertView.findViewById(R.id.printer_last_divider); printerHolder.setting = (TextView) convertView.findViewById(R.id.printer_setting_tv); printerHolder.title = (TextView) convertView.findViewById(R.id.printer_title_tv); printerHolder.connectIcon = (ImageView) convertView.findViewById(R.id.printer_connect_iv); convertView.setTag(printerHolder); &#125; else &#123; printerHolder = (PrinterViewHolder) convertView.getTag(); &#125; PrinterInfo printer = (PrinterInfo) mDataList.get(position); initPrinter(printerHolder, printer); if (position == getCount() - 1) &#123; printerHolder.divider.setVisibility(View.VISIBLE); &#125; else &#123; printerHolder.divider.setVisibility(View.GONE); &#125; return convertView; &#125; private View getTitleView(int position, View convertView, ViewGroup parent) &#123; HeaderViewHolder headerHolder; if (convertView == null) &#123; headerHolder = new HeaderViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_title, parent, false); headerHolder.headerTitle = (TextView) convertView.findViewById(R.id.printer_category_tv); headerHolder.headerIcon = (ImageView) convertView.findViewById(R.id.printer_icon_iv); headerHolder.headerAdd = (ImageView) convertView.findViewById(R.id.printer_add_device_iv); headerHolder.headerDivider = convertView.findViewById(R.id.printer_title_divider); convertView.setTag(headerHolder); &#125; else &#123; headerHolder = (HeaderViewHolder) convertView.getTag(); &#125; String title = (String) mDataList.get(position); headerHolder.headerTitle.setText(title); headerHolder.headerAdd.setOnTouchListener(new OnTouchEffectedListener()); if (TITLE_BLUETOOTH_PRINTER.equals(title)) &#123; headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_bluetooth); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onRightClick(PrinterInfo.TYPE_BLUETOOTH); &#125; &#125; &#125;); &#125; else if (TITLE_NET_PRINTER.equals(title)) &#123; headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_wifi); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onRightClick(PrinterInfo.TYPE_NETWORK); &#125; &#125; &#125;); &#125; else if (TITLE_CLOUD_PRINTER.equals(title)) &#123; headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_cloud); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_scan); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onRightClick(PrinterInfo.TYPE_CLOUD); &#125; &#125; &#125;); &#125; if (position == getCount() - 1) &#123; headerHolder.headerDivider.setVisibility(View.VISIBLE); &#125; else &#123; headerHolder.headerDivider.setVisibility(View.GONE); &#125; return convertView; &#125; private void initPrinter(PrinterViewHolder holder, final PrinterInfo printerInfo) &#123; if (holder != null) &#123; boolean connected = false; holder.title.setText(printerInfo.name); List&lt;IPrinter&gt; printers = PrinterManager.getInstance().getPrinterList(); for (IPrinter printer : printers) &#123; if (printer.getPrinterId().equals(printerInfo.mac)) &#123; connected = true; holder.connect.setText(\"断开\"); holder.connectIcon.setImageResource(R.drawable.ic_connect); break; &#125; &#125; if (!connected) &#123; holder.connect.setText(\"连接\"); holder.connectIcon.setImageResource(R.drawable.ic_break); &#125; holder.setting.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; PrinterSettingActivity.navigateTo(mContext, printerInfo); &#125; &#125;); final boolean finalConnected = connected; holder.connect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onConnectClick(printerInfo, finalConnected); &#125; &#125; &#125;); &#125; &#125; @Nullable public PrinterInfo getPrinterInfo(int position) &#123; Object o = mDataList.get(position); if (o instanceof PrinterInfo) &#123; return (PrinterInfo) o; &#125; else &#123; return null; &#125; &#125; @Override public int getItemViewType(int position) &#123; Object o = mDataList.get(position); if (o instanceof PrinterInfo) &#123; return TYPE_PRINTER; &#125; else &#123; return TYPE_HEADER; &#125; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public int getCount() &#123; return mDataList.size(); &#125; @Override public Object getItem(int position) &#123; return mDataList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; private class HeaderViewHolder &#123; private TextView headerTitle; private ImageView headerIcon; private ImageView headerAdd; private View headerDivider; &#125; private class PrinterViewHolder &#123; private TextView connect; private TextView title; private View divider; private TextView setting; private ImageView connectIcon; &#125; public interface OnItemFunctionClickListener &#123; void onConnectClick(PrinterInfo printer, boolean connected); /** * 点击标题右侧按钮 * @param printerType 打印机类型。例如 &#123;@link PrinterInfo#TYPE_BLUETOOTH&#125; */ void onRightClick(int printerType); &#125;&#125; 核心代码便在initDataList中，所有的对象都是继承自 Object 的，利用instanceof可以判断放入的是哪种数据类型，一种数据类型对应一种 Type。对比之前的代码，可以看到调整后的代码可读性更高，也更简洁了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"关于 MVP 模式的一点思考","date":"2017-04-25T07:04:41.000Z","path":"2017/04/25/mvp-1/","text":"针对 MVC 的解耦，目前 MVP 模式已经被很多开发者所使用，项目中所使用的便是 MVP 模式。 在我用到 MVP 模式后，我有个疑惑：1个 Presenter 能否对应多个 View？这个问题，在网上已经有很多人展开讨论了：使用 MVP 时，如何让同一个 P 服务多个 V？ 这个issue跟我的情况很类似。我有 A B C 三个页面，我有一个 Presenter，用来处理一个数据类型的增删改查，但是界面上，A界面只需要查询，B界面只需要删除，C界面只需要增和改。基于 Presenter与View 一一对应的情况下，很容易就写出如下的代码：1234567891011121314151617181920public interface IMyPresenter &#123; void query(); void insert(); void update(); void delete();&#125;public interface IMyView &#123; void showList(); void showInsertResult(); void showUpdateResult(); void showDeleteResult();&#125; 在 IMyPresenter 的具体实现中回调 IMyView 的方法，通知界面进行展示。A B C 三个界面都实现 IMyView，然后就会有一个蛋疼的现象：很多do nothing的方法。比如 A 界面会这样：123456789101112131415public void showList()&#123; // show something&#125;public void showInsertResult()&#123; // do nothing&#125;public void showUpdateResult()&#123; // do nothing&#125;public void showDeleteResult()&#123; // do nothing&#125; 因为 A 界面就没用到增删改的接口，所以自然不用实现相应的 View 接口，这看起来就很蛋疼了。 现在假设我们使用多个 Presenter,使一个 Presenter 对应一个 View，也就是写3个 Presenter,一个负责查询对应界面 A，一个负责删除对应界面 B，一个负责增和改对应界面 C。显然是没什么毛病的，但是会多许多的 Presenter，除了写起来很费事繁杂，还有一个缺点：若界面有业务交集（比如 A 界面不仅有查询，还有个删除，那么就会和 B 界面重复），就会导致 Presenter 严重冗余，几个 Presenter 里面的代码大块大块的相似。另外这个 Presenter 本是增删改查一套业务，结果硬生生拆成多个 Presenter，总感觉不合适。 所以在我的实际情况中，上述两种方案我都没有采用。这里便说下我的一些想法：Presenter 仍然独立处理业务，将 View 进行抽离解耦，提供一个顶层的 View 给 Presenter 使用，当要调到具体的 View 方法时，使用 instance of 判断，然后强转进行调用。修改后的代码大致如下：1234567891011121314151617public interface IMyView &#123;&#125;public interface IAView extends IMyView &#123; void showList();&#125;public interface IBView extends IMyView &#123; void showDeleteResult();&#125;public interface IAView extends IMyView &#123; void showUpdateResult(); void showInsertResult();&#125; 然后 IMyPresenter 的实现持有 IMyView 的实例，在调用的地方进行强转。123456public void delete()&#123; // do something if (mView != null &amp;&amp; mView instanceof IBView) &#123; ((IBView) mView).showDeleteResult(); &#125;&#125; 用这种方法，可以一定程度上解决一个 Presenter 对应多个 View 的问题。只能是一定程度上，是因为若 View 对应的业务场景有很复杂的交叉，那么就需要定义非常多的 View 与之对应，并且有很深的继承关系，也是不太合适。若真是碰到这种场景，我可能就会考虑 Google 所说的 MVP Clean 模式了。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://lijia92.github.io/tags/设计模式/"}]},{"title":"博客免密提交、部署到Github","date":"2017-04-19T02:08:07.000Z","path":"2017/04/19/no-password/","text":"每次写完博客，hexo d的时候需要输入一次Github账号密码，git push的时候又需要输入一次，有点烦了。最近转到 Ubuntu 工作，也换了台电脑，之前的配置都忘记了，于是重新查了一下，这里摘录一下，忘记了后面可以回头来看。 hexo d 免密输入在 user 根目录下新建.netrc文件，填写内容：123machine github.comlogin username //username为github账户名 （不是用来登录的邮箱或手机号）password password //password为github账户的密码 保存之后，再执行 hexo d 时即可直接部署，不用输入账号密码了。 git push 免密输入因为是用的 https 方式，进入到 git 控制的根目录，执行：1gedit .git/config 看到：12345678[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote \"origin\"] url = https://github.com/LiJia92/LiJia92.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* 编辑url为：1https://LiJia92:5201314lijia@github.com/LiJia92/LiJia92.github.io.git 即：https://username:password@github.com/username/project.git，username就是你账号名。 参考github https方式免密码提交代码 在git config 中添加用户名密码Hexo免输入密码部署到Github","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"使用ListView多Type的错误姿势","date":"2017-04-18T11:33:01.000Z","path":"2017/04/18/wrong/","text":"项目中，有这样的一个需求： 有三种打印机类型，每种类型可以添加、删除对应类型的打印机。按照以往，我写的Adapter是这样的:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220public class PrinterManagerAdapter extends BaseAdapter &#123; public final static int BLUETOOTH_HEADER = 0; public final static int BLUETOOTH_PRINTER = 1; public final static int NET_HEADER = 2; public final static int NET_PRINTER = 3; public final static int CLOUD_HEADER = 4; public final static int CLOUD_PRINTER = 5; private Context mContext; private LayoutInflater mInflater; private OnItemFunctionClickListener listener; private List&lt;PrinterInfo&gt; mPrinters = new ArrayList&lt;&gt;(); private int blueToothCount = 0; private int netCount = 0; private int cloudCount = 0; public PrinterManagerAdapter(Context context, List&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; mContext = context; mPrinters = printers; mInflater = LayoutInflater.from(context); getNotSwipeItem(listView); &#125; private void getNotSwipeItem(SwipePartMenuListView listView) &#123; blueToothCount = 0; netCount = 0; cloudCount = 0; for (PrinterInfo info : mPrinters) &#123; if (info.printerType == PrinterInfo.TYPE_BLUETOOTH) &#123; blueToothCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_NETWORK) &#123; netCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_CLOUD) &#123; cloudCount++; &#125; &#125; List&lt;Integer&gt; titleList = new LinkedList&lt;&gt;(); titleList.add(0); titleList.add(1 + blueToothCount); titleList.add(2 + blueToothCount + netCount); listView.setCannotSwipePositionList(titleList); &#125; public void setPrinters(List&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; this.mPrinters = printers; getNotSwipeItem(listView); &#125; public void setListener(OnItemFunctionClickListener listener) &#123; this.listener = listener; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; PrinterManagerViewHolder holder; final int viewType = getItemViewType(position); holder = new PrinterManagerViewHolder(); if (viewType == BLUETOOTH_HEADER || viewType == NET_HEADER || viewType == CLOUD_HEADER) &#123; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.item_printer_title, parent, false); holder.headerTitle = (TextView) convertView.findViewById(R.id.printer_category_tv); holder.headerIcon = (ImageView) convertView.findViewById(R.id.printer_icon_iv); holder.headerAdd = (ImageView) convertView.findViewById(R.id.printer_add_device_iv); holder.headerDivider = convertView.findViewById(R.id.printer_title_divider); convertView.setTag(holder); &#125; else &#123; holder = (PrinterManagerViewHolder) convertView.getTag(); &#125; &#125; else &#123; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.item_printer_devices, parent, false); holder.connect = (TextView) convertView.findViewById(R.id.printer_connect_tv); holder.divider = convertView.findViewById(R.id.printer_last_divider); holder.setting = (TextView) convertView.findViewById(R.id.printer_setting_tv); holder.title = (TextView) convertView.findViewById(R.id.printer_title_tv); holder.connectIcon = (ImageView) convertView.findViewById(R.id.printer_connect_iv); convertView.setTag(holder); &#125; else &#123; holder = (PrinterManagerViewHolder) convertView.getTag(); &#125; &#125; switch (viewType) &#123; case BLUETOOTH_HEADER: holder.headerTitle.setText(\"蓝牙打印机\"); holder.headerAdd.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.btn_setting_goods_add)); holder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; BlueToothPrinterActivity.navigateTo(mContext); &#125; &#125;); break; case NET_HEADER: holder.headerTitle.setText(\"网络打印机\"); holder.headerAdd.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.btn_setting_goods_add)); holder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; NetPrinterActivity.navigateTo(mContext); &#125; &#125;); break; case CLOUD_HEADER: holder.headerTitle.setText(\"云打印机\"); holder.headerAdd.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.btn_setting_goods_scan)); if (position == getCount() - 1) &#123; holder.headerDivider.setVisibility(View.VISIBLE); &#125; break; case BLUETOOTH_PRINTER: PrinterInfo printer = mPrinters.get(position - 1); initPrinter(holder, printer); break; case NET_PRINTER: PrinterInfo netPrinter = mPrinters.get(position - 2); initPrinter(holder, netPrinter); break; case CLOUD_PRINTER: if (position == getCount() - 1) &#123; holder.divider.setVisibility(View.VISIBLE); &#125; PrinterInfo cloudPrinter = mPrinters.get(position - 3); initPrinter(holder, cloudPrinter); break; &#125; return convertView; &#125; private void initPrinter(PrinterManagerViewHolder holder, final PrinterInfo printerInfo) &#123; boolean connected = false; holder.title.setText(printerInfo.name); HashMap&lt;String, IPrinter&gt; printers = PrinterManager.getInstance().getPrinterList(); if (printers.keySet().contains(printerInfo.mac)) &#123; connected = true; holder.connect.setText(\"断开\"); holder.connectIcon.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_connect)); &#125; else &#123; holder.connect.setText(\"连接\"); holder.connectIcon.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_break)); &#125; holder.setting.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; PrinterSettingActivity.navigateTo(mContext, printerInfo); &#125; &#125;); final boolean finalConnected = connected; holder.connect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onConnectClicked(printerInfo, finalConnected); &#125; &#125; &#125;); &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return BLUETOOTH_HEADER; &#125; else if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; return BLUETOOTH_PRINTER; &#125; else if (position == blueToothCount + 1) &#123; return NET_HEADER; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; return NET_PRINTER; &#125; else if (position == netCount + blueToothCount + 2) &#123; return CLOUD_HEADER; &#125; else &#123; return CLOUD_PRINTER; &#125; &#125; @Override public int getCount() &#123; if (mPrinters != null) &#123; return mPrinters.size() + 3; &#125; return 0; &#125; @Override public Object getItem(int position) &#123; return null; &#125; @Override public long getItemId(int position) &#123; return position; &#125; private class PrinterManagerViewHolder &#123; // Header private TextView headerTitle; private ImageView headerIcon; private ImageView headerAdd; private View headerDivider; // Printer private TextView connect; private TextView title; private View divider; private TextView setting; private ImageView connectIcon; &#125; public interface OnItemFunctionClickListener &#123; void onConnectClicked(PrinterInfo printer, boolean connected); &#125;&#125; 我将 view 分为了6个 Type ，三种头部 Type 使用一种布局，三种打印机 Type 使用一种布局，然后总共用了一个 ViewHoloder 。然后发现一个问题：当我删除一个打印机之后，刷新界面的时候崩溃了问题其实很简单：就是删除的打印机（BLUETOOTH_PRINTER Type）convertView 进入到缓存里面，然后下个 Item 的 Type 是 NET_HEADER Type，由于重用机制，这个 Item 会重用 convertView，此时这个 convertView 绑定的 ViewHoloder 是 Printer 部分，而自己要使用的是 Header 部分，其 view 都为 null了，导致空指针崩溃。解决办法：添加代码1234@Overridepublic int getViewTypeCount() &#123; return 6;&#125; ListView 的缓存机制是可以针对不同 Type 来进行缓存的，当不复写这个方法的时候，其默认的实现是 返回1 ,所以导致getItemViewType返回的 Type 实际上是没有用的，不管是什么 Type， ListView 填充的 convertView 永远是一样的。所以，当改成 返回6 的时候， ListView 便会填充 6 种 convertView 了，所绑定的 ViewHoloder 具有的属性也会一样，就避免了空指针崩溃了。当和同事讨论这点的时候，同事指出： 有几种布局，就用几种 Type，几种 ViewHoloder，一一对应才是官方推荐的行为。自己想了下，确实是的。当网络打印机这个 Item 要显示的时候，如果缓存中有蓝牙打印机的 convertView，我是用不了的，因为他们的 Type 不一样。这样的一个做法，就是自己把 ListView 的缓存机制整乱了。修改后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253public class PrinterManagerAdapter extends BaseAdapter &#123; private final static int TYPE_HEADER = 0; private final static int TYPE_PRINTER = 1; private Context mContext; private LayoutInflater mInflater; private OnItemFunctionClickListener listener; private ArrayList&lt;PrinterInfo&gt; mPrinters; private int blueToothCount = 0; private int netCount = 0; private int cloudCount = 0; public PrinterManagerAdapter(Context context, ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; mContext = context; mPrinters = printers; mInflater = LayoutInflater.from(context); setNotSwipeItems(listView); &#125; private void setNotSwipeItems(SwipePartMenuListView listView) &#123; blueToothCount = 0; netCount = 0; cloudCount = 0; for (PrinterInfo info : mPrinters) &#123; if (info.printerType == PrinterInfo.TYPE_BLUETOOTH) &#123; blueToothCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_NETWORK) &#123; netCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_CLOUD) &#123; cloudCount++; &#125; &#125; List&lt;Integer&gt; titleList = new ArrayList&lt;&gt;(); titleList.add(0); titleList.add(1 + blueToothCount); titleList.add(2 + blueToothCount + netCount); listView.setCannotSwipePositionList(titleList); &#125; public void setPrinters(ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; this.mPrinters = printers; setNotSwipeItems(listView); &#125; public void setListener(OnItemFunctionClickListener listener) &#123; this.listener = listener; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; HeaderViewHolder headerHolder = null; PrinterViewHolder printerHolder = null; int viewType = getItemViewType(position); if (viewType == TYPE_HEADER) &#123; if (convertView == null) &#123; headerHolder = new HeaderViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_title, parent, false); headerHolder.headerTitle = (TextView) convertView.findViewById(R.id.printer_category_tv); headerHolder.headerIcon = (ImageView) convertView.findViewById(R.id.printer_icon_iv); headerHolder.headerAdd = (ImageView) convertView.findViewById(R.id.printer_add_device_iv); headerHolder.headerDivider = convertView.findViewById(R.id.printer_title_divider); convertView.setTag(headerHolder); &#125; else &#123; headerHolder = (HeaderViewHolder) convertView.getTag(); &#125; &#125; else &#123; if (convertView == null) &#123; printerHolder = new PrinterViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_devices, parent, false); printerHolder.connect = (TextView) convertView.findViewById(R.id.printer_connect_tv); printerHolder.divider = convertView.findViewById(R.id.printer_last_divider); printerHolder.setting = (TextView) convertView.findViewById(R.id.printer_setting_tv); printerHolder.title = (TextView) convertView.findViewById(R.id.printer_title_tv); printerHolder.connectIcon = (ImageView) convertView.findViewById(R.id.printer_connect_iv); convertView.setTag(printerHolder); &#125; else &#123; printerHolder = (PrinterViewHolder) convertView.getTag(); &#125; &#125; switch (viewType) &#123; case TYPE_HEADER: if (headerHolder != null) &#123; if (position == 0) &#123; headerHolder.headerTitle.setText(\"蓝牙打印机\"); headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_bluetooth); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; BlueToothPrinterActivity.navigateTo(mContext, mPrinters); &#125; &#125;); &#125; else if (position == blueToothCount + 1) &#123; headerHolder.headerTitle.setText(\"网络打印机\"); headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_wifi); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;// NetPrinterActivity.navigateTo(mContext); &#125; &#125;); &#125; else if (position == netCount + blueToothCount + 2) &#123; headerHolder.headerTitle.setText(\"云打印机\"); headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_cloud); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_scan); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;// NetPrinterActivity.navigateTo(mContext); &#125; &#125;); if (position == getCount() - 1) &#123; headerHolder.headerDivider.setVisibility(View.VISIBLE); &#125; else &#123; headerHolder.headerDivider.setVisibility(View.GONE); &#125; &#125; &#125; break; case TYPE_PRINTER: if (printerHolder != null) &#123; int index; if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; index = position - 1; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; index = position - 2; &#125; else &#123; index = position - 3; if (position == getCount() - 1) &#123; printerHolder.divider.setVisibility(View.VISIBLE); &#125; else &#123; printerHolder.divider.setVisibility(View.GONE); &#125; &#125; PrinterInfo printer = mPrinters.get(index); initPrinter(printerHolder, printer); &#125; break; default: break; &#125; return convertView; &#125; private void initPrinter(PrinterViewHolder holder, final PrinterInfo printerInfo) &#123; if (holder != null) &#123; boolean connected = false; holder.title.setText(printerInfo.name); HashMap&lt;String, IPrinter&gt; printers = PrinterManager.getInstance().getPrinterList(); if (printers.keySet().contains(printerInfo.mac)) &#123; connected = true; holder.connect.setText(\"断开\"); holder.connectIcon.setImageResource(R.drawable.ic_connect); &#125; else &#123; holder.connect.setText(\"连接\"); holder.connectIcon.setImageResource(R.drawable.ic_break); &#125; holder.setting.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; PrinterSettingActivity.navigateTo(mContext, printerInfo); &#125; &#125;); final boolean finalConnected = connected; holder.connect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onConnectClicked(printerInfo, finalConnected); &#125; &#125; &#125;); &#125; &#125; public PrinterInfo getPrinterInfo(int position) &#123; int index; if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; index = position - 1; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; index = position - 2; &#125; else &#123; index = position - 3; &#125; return mPrinters.get(index); &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return TYPE_HEADER; &#125; else if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; return TYPE_PRINTER; &#125; else if (position == blueToothCount + 1) &#123; return TYPE_HEADER; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; return TYPE_PRINTER; &#125; else if (position == netCount + blueToothCount + 2) &#123; return TYPE_HEADER; &#125; else &#123; return TYPE_PRINTER; &#125; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public int getCount() &#123; if (mPrinters != null) &#123; return mPrinters.size() + 3; &#125; return 3; &#125; &#125; @Override public long getItemId(int position) &#123; return position; &#125; private class HeaderViewHolder &#123; private TextView headerTitle; private ImageView headerIcon; private ImageView headerAdd; private View headerDivider; &#125; private class PrinterViewHolder &#123; private TextView connect; private TextView title; private View divider; private TextView setting; private ImageView connectIcon; &#125; public interface OnItemFunctionClickListener &#123; void onConnectClicked(PrinterInfo printer, boolean connected); &#125;&#125; 这样的话，结构其实会更加清晰，拆分得更具体。另外，注意一点： 代码中的 Type 类型 TYPE_HEADER 是从0开始的。这是因为不从 0 开始当 Adapter notifyDataSetChanged 时就会报错。举个栗子：12private final static int TYPE_HEADER = 5;private final static int TYPE_PRINTER = 6; 报错信息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051FATAL EXCEPTION: mainProcess: com.maimairen.app.jinchuhuo.dev, PID: 15967java.lang.ArrayIndexOutOfBoundsException: length=2; index=5 at android.widget.AbsListView$RecycleBin.addScrapView(AbsListView.java:6726) at android.widget.ListView.layoutChildren(ListView.java:1644) at android.widget.AbsListView.onLayout(AbsListView.java:2148) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) at android.widget.LinearLayout.onLayout(LinearLayout.java:1495) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) at android.widget.FrameLayout.onLayout(FrameLayout.java:273) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) at android.widget.LinearLayout.onLayout(LinearLayout.java:1495) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) at android.widget.FrameLayout.onLayout(FrameLayout.java:273) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) at android.widget.LinearLayout.onLayout(LinearLayout.java:1495) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) at android.widget.FrameLayout.onLayout(FrameLayout.java:273) at com.android.internal.policy.PhoneWindow$DecorView.onLayout(PhoneWindow.java:2678) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.view.ViewRootImpl.performLayout(ViewRootImpl.java:2198) at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:1958) at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1134) at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6050) at android.view.Choreographer$CallbackRecord.run(Choreographer.java:860) at android.view.Choreographer.doCallbacks(Choreographer.java:672) at android.view.Choreographer.doFrame(Choreographer.java:608) at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:846) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5438) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629) 可以看到，ListView 从缓存中去取 view 的时候，是用的 Type 的值来作为 index 的，所以 Type 类型一定是从0开始的。因为自己长期以来一直是之前的那种做法，错了太多次了，却没有及时发现错误，经过这次同事的指正，总算是纠正过来了。写篇博客备忘，忘性太大了～","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"CoordinatorLayout之Behavior认识","date":"2017-03-31T11:09:45.000Z","path":"2017/03/31/coordinatorlayout/","text":"背景项目开发中，我们经常有滑动控件固定某一个部分在顶部的需求，效果类似这样： 在Material Design出来之前，我们可能会有方案一： 给 ListView C 添加一个HeadView（包含A、B），然后另外准备一个外部的B在屏幕顶部，一开始不可见。ListView当前滚动高度超过A的高度时，显示外部的B；滚动高度小于A时隐藏外部的B。 正如我此时的项目中的一样，但是项目中的B是一个搜索框，类似这样： 可以看到 B 的构成是相对复杂的，B 相关的事件操作也会写 2 遍，很显然的会导致整个代码结构非常臃肿，所以需要寻找方案二。 嵌套滚动机制在我早些的一篇文章使用Android新特性：Material Design中有说起一个控件：CoordinatorLayout。它是一个增强型的 FrameLayout。它的作用有两个： 作为一个布局的根布局 最后一个为子视图之间相互协调手势效果的一个协调布局 为子视图协调手势效果主要是基于 Android 的嵌套滚动机制。 所谓嵌套滚动其实就是界面布局中包含一个可滚动的列表和一个不可滚动的View，这样在滚动列表时，首先将不可滚动View移出屏幕或移进屏幕，待不可滚动View固定时，才会继续滚动滚动列表的内容。 关于嵌套滚动机制更详细的一些说明有很多文章都说的不错，稍后会在参考中放出链接。 实例我们知道可以通过Behavior来实现各种嵌套滑动效果。最为典型的就是AppBarLayout中的ScrollingViewBehavior。很经典的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:color/background_light\" android:fitsSystemWindows=\"true\" &gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/main.appbar\" android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" android:fitsSystemWindows=\"true\" &gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/main.collapsing\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginStart=\"48dp\" app:expandedTitleMarginEnd=\"64dp\" &gt; &lt;ImageView android:id=\"@+id/main.backdrop\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scaleType=\"centerCrop\" android:fitsSystemWindows=\"true\" android:src=\"@drawable/material_flat\" app:layout_collapseMode=\"parallax\" /&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/main.toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:layout_collapseMode=\"pin\" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" &gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:lineSpacingExtra=\"8dp\" android:text=\"@string/lorem\" android:padding=\"@dimen/activity_horizontal_margin\" /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_height=\"wrap_content\" android:layout_width=\"wrap_content\" android:layout_margin=\"@dimen/activity_horizontal_margin\" android:src=\"@drawable/ic_comment_24dp\" app:layout_anchor=\"@id/main.appbar\" app:layout_anchorGravity=\"bottom|right|end\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 通过给滑动控件设置app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;来实现控制 ToolBar 隐藏或消失的效果。但是这个 Behavior 是依赖于 AppBarLayout 的，换成其他的控件将会失效。 尝试一基于我的情况，我的Header可能是这样的：1234&lt;LinearLayout&gt; &lt;!-- 展示库存的HeaderA --&gt; &lt;!-- 展示过滤搜索的HeaderB --&gt;&lt;/LinearLayout&gt; 所以我期初的做法是定义 Behavior ,然后通过依赖让 LinearLayout 与 RecyclerView 联动。布局代码如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/activity_behavior\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/colorAccent\" app:layout_behavior=\"com.study.lijia.coordinatorlayoutdemo.RecyclerBehavior\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_behavior=\"com.study.lijia.coordinatorlayoutdemo.HeaderBehavior\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"56dp\" android:background=\"#4400ff00\" android:gravity=\"center\" android:text=\"Header A\" android:textSize=\"18sp\" /&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"48dp\" android:background=\"#4400ffff\" android:gravity=\"center\" android:text=\"Header B\" android:textSize=\"16sp\" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; HeaderBehavior：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class HeaderBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private View childA; // Header A private View childB; // Header B private int childAHeight; private int childBHeight; public HeaderBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; if (child instanceof LinearLayout) &#123; LinearLayout dependent = (LinearLayout) child; if (dependent.getChildCount() == 2) &#123; childA = dependent.getChildAt(0); childB = dependent.getChildAt(1); childAHeight = childA.getHeight(); childBHeight = childB.getHeight(); &#125; &#125; return target instanceof RecyclerView; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0) &#123; //表示向上滚动 float trY = child.getY() - dy &lt;= -childAHeight ? -childAHeight : child.getTranslationY() - dy; child.setY(trY); child.setTag(dy); &#125; else if (dy &lt; 0) &#123; //向下滚动 if (target instanceof RecyclerView) &#123; int scrollY = getScrollY((RecyclerView) target); if (scrollY == 0) &#123; if (target.getTranslationY() &lt; childBHeight) &#123; child.setTag(dy); &#125; else &#123; float trY = child.getY() - dy &gt;= 0 ? 0 : child.getY() - dy; child.setY(trY); child.setTag(dy); &#125; &#125; &#125; &#125; &#125;// @Override// public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY) &#123;// ((NestedScrollView) child).fling((int)velocityY);// return true;// &#125; private int getScrollY(RecyclerView target) &#123; RecyclerView recyclerView = target; LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); int position = layoutManager.findFirstVisibleItemPosition(); View firstVisiableChildView = layoutManager.findViewByPosition(position); int itemHeight = firstVisiableChildView.getHeight(); return (position) * itemHeight - firstVisiableChildView.getTop(); &#125;&#125; RecyclerBehavior：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class RecyclerBehavior extends CoordinatorLayout.Behavior&lt;RecyclerView&gt; &#123; private Context context; private View childA; // Header A private View childB; // Header B private int childAHeight; private int childBHeight; public RecyclerBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, RecyclerView child, View dependency) &#123; if (dependency instanceof LinearLayout) &#123; LinearLayout dependent = (LinearLayout) dependency; if (dependent.getChildCount() == 2) &#123; childA = dependent.getChildAt(0); childB = dependent.getChildAt(1); childAHeight = childA.getHeight(); childBHeight = childB.getHeight(); return true; &#125; &#125; return false; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, RecyclerView child, View dependency) &#123; int y = (int) (dependency.getY() + dependency.getBottom()); Log.e(\"TAG\", \"y:\" + y); int z; if (y &gt; childBHeight) &#123; child.setTranslationY(y); &#125; else &#123; if (dependency.getTag() != null) &#123; int x = (int) child.getTranslationY(); z = x - (int) (dependency.getTag()); if (z &lt; 0) &#123; z = 0; &#125; else if (z &gt; childBHeight + childAHeight) &#123; z = childAHeight + childBHeight; &#125; Log.e(\"TAG\", \"z:\" + z); child.setTranslationY(z); &#125; &#125; return true; &#125;&#125; 最后实现的效果可以说基本满足了。但是当发生Fling滑动时，便会很容易出现问题。因为上面的Header LinearLayout并没有处理Fling的操作。后面我自定义LinearLayoutWithFling利用OverScroller来实现Fling但是结果并不如意。 尝试二自定义实现NestedScrollingParent接口的 LinearLayout ,然后内部来处理 RecyclerView 的滑动。布局代码如下：12345678910111213141516171819202122232425262728&lt;com.study.lijia.coordinatorlayoutdemo.StickyNavLayout android:id=\"@+id/activity_behavior\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"56dp\" android:background=\"#4400ff00\" android:gravity=\"center\" android:text=\"Header A\" android:textSize=\"18sp\" /&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"48dp\" android:background=\"#4400ffff\" android:gravity=\"center\" android:text=\"Header B\" android:textSize=\"16sp\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/colorAccent\" /&gt;&lt;/com.study.lijia.coordinatorlayoutdemo.StickyNavLayout&gt; StickyNavLayout如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class StickyNavLayout extends LinearLayout implements NestedScrollingParent &#123; private NestedScrollingParentHelper parentHelper = new NestedScrollingParentHelper(this); private View mTop; private View mNav; private View thirdView; private int mTopViewHeight; private OverScroller mScroller; private VelocityTracker mVelocityTracker; private int mTouchSlop; private int mMaximumVelocity, mMinimumVelocity; private float mLastY; private boolean mDragging; public StickyNavLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); setOrientation(LinearLayout.VERTICAL); mScroller = new OverScroller(context); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); mMaximumVelocity = ViewConfiguration.get(context).getScaledMaximumFlingVelocity(); mMinimumVelocity = ViewConfiguration.get(context).getScaledMinimumFlingVelocity(); &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); mTop = getChildAt(0); mNav = getChildAt(1); thirdView = getChildAt(2); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mTopViewHeight = mTop.getMeasuredHeight(); //上面测量的结果是viewPager的高度只能占满父控件的剩余空间 //重新设置viewPager的高度 ViewGroup.LayoutParams layoutParams = thirdView.getLayoutParams(); layoutParams.height = getMeasuredHeight() - mNav.getMeasuredHeight(); Log.e(\"TAG\", \"height:\" + layoutParams.height); thirdView.setLayoutParams(layoutParams); &#125; @Override public void scrollTo(int x, int y) &#123; Log.e(\"TAG\", \"y:\" + y); //限制滚动范围 if (y &lt; 0) &#123; y = 0; &#125; if (y &gt; mTopViewHeight) &#123; y = mTopViewHeight; &#125; super.scrollTo(x, y); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(0, mScroller.getCurrY()); invalidate(); &#125; &#125; public void fling(int velocityY) &#123; mScroller.fling(0, getScrollY(), 0, velocityY, 0, 0, 0, mTopViewHeight); invalidate(); &#125;//实现NestedScrollParent接口------------------------------------------------------------------------- @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123; return true; &#125; @Override public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes) &#123; parentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes); &#125; @Override public void onStopNestedScroll(View target) &#123; parentHelper.onStopNestedScroll(target); &#125; @Override public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; &#125; @Override public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; boolean hiddenTop = dy &gt; 0 &amp;&amp; getScrollY() &lt; mTopViewHeight; boolean showTop = dy &lt; 0 &amp;&amp; getScrollY() &gt;= 0 &amp;&amp; !ViewCompat.canScrollVertically(target, -1); if (hiddenTop || showTop) &#123; scrollBy(0, dy); consumed[1] = dy; &#125; &#125; //boolean consumed:子view是否消耗了fling //返回值：自己是否消耗了fling。可见，要消耗只能全部消耗 @Override public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) &#123; Log.e(\"onNestedFling\", \"called\"); return false; &#125; //返回值：自己是否消耗了fling。可见，要消耗只能全部消耗 @Override public boolean onNestedPreFling(View target, float velocityX, float velocityY) &#123; Log.e(\"onNestedPreFling\", \"called\"); if (getScrollY() &lt; mTopViewHeight) &#123; fling((int) velocityY); return true; &#125; else &#123; return false; &#125; &#125; @Override public int getNestedScrollAxes() &#123; return parentHelper.getNestedScrollAxes(); &#125;&#125; 达到的效果姑且不错，但是当我想要加入下拉刷新SwipeRefreshLayout的时候，感觉不是很好加。SwipeRefreshLayout也是基于嵌套滑动机制的一个下拉刷新类，StickyNavLayout与SwipeRefreshLayout要共同处理 RecyclerView 的滑动事件，会冲突。 方案三–回归本质当几经尝试后，感觉还是对原理没摸清，于是回过头来看 AppBarLayout 的 Behavior 。结果我特喵的发现AppBarLayout 就是 LinearLayout，很符合我的项目实情。然后利用layout_scrollFlags来控制Header A的显示、隐藏，并且加入下拉刷新也很方便，最后便采用了原生的方法了。123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/activity_behavior\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@null\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"56dp\" android:background=\"#4400ffff\" android:gravity=\"center\" android:text=\"Header A\" android:textSize=\"18sp\" app:layout_scrollFlags=\"scroll\" /&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"48dp\" android:background=\"#4400ff00\" android:gravity=\"center\" android:text=\"Header B\" android:textSize=\"16sp\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/colorAccent\" /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 下拉刷新加载 RecyclerView 那里实际效果看起来很怪，最后调整将 SwipeRefreshLayout 作为根节点， CoordinatorLayout 作为其子 View ，这个时候下拉刷新会有问题，因为2者都实现了 NestedScrollParent 接口，采取的方法是监听 AppBarLayout 的 offset，根据这个值来是否禁用 SwipeRefreshLayout。12345678910mAppBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() &#123; @Override public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) &#123; if (verticalOffset &gt;= 0) &#123; mRefreshLayout.setEnabled(true); &#125; else &#123; mRefreshLayout.setEnabled(false); &#125; &#125;&#125;); 示例代码 参考demo为了速成，很多代码都是从以下参考文章中直接拿的-。- ListView 两种固定标头的技巧 Android CoordinatorLayout和Behavior (译)掌握 Coordinator Layout CoordinatorLayout高级用法-自定义Behavior NestedScrolling机制(二)——实例 SwipeRefreshLayout 与 CoordinatorLayout 嵌套刷新","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://lijia92.github.io/tags/Material-Design/"}]},{"title":"Gradle 多版本管理","date":"2017-03-16T08:54:10.000Z","path":"2017/03/16/gradle-app/","text":"之前有写过一篇Android Studio使用Gradle进行多渠道打包，多渠道打包算是Gradle最常用的功能了，但是它的强大可不止于此。 简介Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。使用Gradle的优势: 自动处理包相依关系 - 取自 Maven Repos 的概念 自动处理布署问题 - 取自 Ant 的概念 条件判断写法直觉 - 使用 Groovy 语言 更多关于Gradle的学习可以阅读Gradle User Guide 中文版。 多版本其实很多东西在你没有接触的时候，它的一些概念你是很难理解的。我现在重新去理解它，因为我碰到了这样一个情形：由于业务的拓展导致项目越来越复杂，由最初的一个手机基本App版本衍生出很多其他版本，比如pos机，收银机，pad等等，又或者是针对某些具体用户定制的版本。而这些版本的业务是基本一致的，只是在界面或者交互上有一些不一样，这个时候要如何构建自己的项目呢？答案当然是Gradle。 下面举个栗子。创建一个AS项目，在app的build.radle中加入如下代码：1234567891011121314productFlavors &#123; // pad版 pad &#123; &#125; // 手机版 phone &#123; &#125; // 定制版 custom &#123; &#125;&#125; 然后我们看到Build Variant:3个版本对应debug release，6个编译指令。在不同版本的编译指令中，我们可以做不同的事情。比如替换包名：1234567891011121314productFlavors &#123; // pad版 pad &#123; applicationId \"com.study.lijia.gradleapp.pad\" &#125; // 手机版 phone &#123; applicationId \"com.study.lijia.gradleapp.phone\" &#125; // 定制版 custom &#123; applicationId \"com.study.lijia.gradleapp\" &#125;&#125; 这样我们在手机上就可以安装三个不同的版本了。再继续上面的情形，三个版本的绝大部分东西是一样的，只是有个别页面不一样。那么可以这样做： 依然继续上面的栗子。在app src目录下，新建目录，与main目录平行，目录名称与gradle中配置的一致。然后继续创建java、res文件夹，再就是写代码了。注意多个文件夹中的文件名以及路径要一样，代码必须添加java文件夹，资源必须添加res文件夹。公共模块中不能包含与其一样的类，否则当切到相应的版本会导致类重复。 当我们选择一个版本时候，另外不可用的代码就会变成红色J标志。如上图中，我选的custom版本，那么pad与phone目录下的代码都变成红色J了，代表当前版本没有用到此代码。改变Build Variant，然后运行，将3个版本都装到设备上，运行后可以看到每个版本的内容是不一样的。（ubuntu录制gif还没找到很好的方法，就不放图了，可以自己跑代码看。）运行都是各自的代码，main下面的代码则是公共模块。 通过上面的栗子，我们知道可以通过productFlavors做各种版本配置。 依赖当项目变得越来越复杂，就不仅仅是单个项目或者Module能解决的了的。我们通常会有很多个Module，继上面的栗子。 项目拓展后，我们新建了pad，phone，appcore3个module，最顶层的app定义实现各种presenter，pad主要针对pad版的界面，phone主要是针对phone版的界面，appcore则是公共底层，用于数据管理等。那么如果是pad版就有app-&gt;pad-&gt;appcore这样的依赖链。在app的build.gradle中配置:1234567dependencies &#123; padCompile project(path: ':pad', configuration: 'commenDebug') phoneCompile project(path: ':phone', configuration: 'commenDebug') // custom依赖phone的special版 customCompile project(path: ':phone', configuration: 'specialDebug')&#125; 可以结合productFlavors的gradle配置，这里是配置依赖。path是指定module，configuration是指定那个版本。因为我们在pad，phone中也有productFlavors配置。123456789101112131415publishNonDefault trueproductFlavors &#123; commen &#123; &#125; special &#123; &#125;&#125;dependencies &#123; commenCompile project(path: ':appcore') specialCompile project(path: ':appcore')&#125; 注意publishNonDefault true必须加上，否则会提示找不到依赖项。 这句话是设置没有默认发布类型。因为我们在productFlavors中设置了版本，而默认的是debug和release，所以会导致找不到依赖。 It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant. Publishing a variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project. 摘自官网。 这时我们修改app的Build variant，下面相关的依赖则会跟着变化，因为我们做了这样的配置。 多渠道通过productFlavors配置多版本，但是如果此时又要配置多渠道该怎么办呢？最笨的方法，自然是依然通过productFlavors来配置了。但是这里要做1个乘法，如果有3个版本，每个版本又有15个渠道，那么可就得配置45个渠道了，简直要累死。。。 那么有没有不笨的方法呢？方法终归是有的，美团的瓦力便是个不错的方法。它是在生成母包之后，动态替换里面的变量，重新生成渠道包，省去了编译时间，极大的减少了AS gradle编译的时间。瓦力相关信息可参考新一代开源Android渠道包生成工具Walle。 任务Gradle可以配置各种task，接上面的来讲，可以在生成母包之后直接执行瓦力的渠道替换。比如举个栗子，配置pad版的渠道：1234567891011121314151617181920212223242526task releasePAD &lt;&lt; &#123; def flavorMap = [ // 官网版本 \"maimairen\" : \"MHP4PDQFZXZRVNSDXK3G\", // 360平台 \"_360cn\" : \"KB3G2X6SKY379YWWBD56\", // 腾讯应用宝 \"QQyyb\" : \"DCRCMBNQDWMV4GDQCTXW\", ] def sourceApk = \"./build/outputs/apk/app-pad-release.apk\" if (!file(sourceApk).exists()) &#123; throw new RuntimeException(\"找不到原始apk,请先执行 assemblePadRelease!!\"); &#125; flavorMap.each &#123; def flavor = it.key def flurryKey = it.value exec &#123; executable \"bash\" args \"-c\", \"java -jar ./walle-cli-all.jar put -c $flavor -e flurryKey=$flurryKey $sourceApk ./build/outputs/apk/app-$flavor-release.apk\" &#125; &#125;&#125; 示例代码","tags":[{"name":"gradle","slug":"gradle","permalink":"http://lijia92.github.io/tags/gradle/"}]},{"title":"博客主题更新","date":"2017-02-16T06:54:43.000Z","path":"2017/02/16/theme-update/","text":"之前一直用的是next主题，后面看到过yilia主题，感觉也不错，便切换到了yilia主题。但是在用的时候有个问题一直让我很不爽：空行的处理让代码上下空出很多行。就像这样： 到主题的issues#339里面也找到了跟我遇到一样问题的朋友。是yilia主题中的一个bug，作者也回复了已经修改，更新后这个bug便没有了。接下来，我就很尴尬了：我当时为了多电脑在同步博客的同时，也删除了主题的git版本管理，导致此时我无法更新主题了,囧。。。 那么该怎么办呢？感觉只能用死办法重新下一次了-.-。首先直接删除主题目录下的yilia文件夹（删除前备份一下，因为yilia中也有_config.yml），然后执行命令：1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载下来后，更新配置文件，然后再删掉yilia文件夹下得.git版本控制文件夹，这样新更新下来的yilia代码就会处于之前设置的整个git仓库的管理下了，分支是source。后面便和之前的操作保持一致就好了~yilia主题的近期更新： 打赏 搜索 “更好的”标签云 “更好的”分享 一些动画 作者出的搜索直接合并了之前的标签。跟进作者的配置，修改yilia的配置：123456789# slider的设置slider: # 是否默认展开tags板块 showTags: truesmart_menu: innerArchive: '搜索' friends: '友链' aboutme: '关于我' 重新部署后，界面如下： 说明很简单明了了，照着操作一遍后即可。 当执行后仍然如此的话，那就是Node.js的版本与jsonContent不兼容导致，要么升级Node.js版本，要么降低jsonContent版本。 此次更新后，博客整体变得更好看了~ PS：只是以后如果博客主题要更新，就得这样来一次了，着实有点蛋疼&gt;.&lt;。。。","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"Android任意View边沿渐变透明","date":"2017-02-16T02:04:39.000Z","path":"2017/02/16/translucent-view/","text":"之前在做直播产品的时候，有个需求：弹幕列表在滑入滑出的时候要有渐变效果。当时想了几种方案但是都没有做到满意的效果，后面便搁置了。直到我看到了这个库：Android任意View边沿渐变透明，看了下效果，正是我当时需要的。虽然时过境迁，现在没有在意这个需求了，但是从心底里还是想知道它是如何实现的。 将代码clone下来后，发现代码其实就一个类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class EdgeTransparentView extends FrameLayout &#123; private Paint mPaint; private int position; private float drawSize; private int topMask = 0x01; private int bottomMask = topMask &lt;&lt; 1; private int leftMask = topMask &lt;&lt; 2; private int rightMask = topMask &lt;&lt; 3; private int mWidth; private int mHeight; public EdgeTransparentView(Context context) &#123; this(context, null); &#125; public EdgeTransparentView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public EdgeTransparentView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.FILL); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT)); final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.EdgeTransparentView); position = typedArray.getInt(R.styleable.EdgeTransparentView_edge_position, 0); drawSize = typedArray.getDimension(R.styleable.EdgeTransparentView_edge_width, Utils.d2p(getContext(), 20)); typedArray.recycle(); &#125; @Override protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); initShader(); mWidth = getWidth(); mHeight = getHeight(); &#125; //渐变颜色 private int[] mGradientColors = &#123;0xffffffff, 0x00000000&#125;; //渐变位置 private float[] mGradientPosition = new float[]&#123;0, 1&#125;; private void initShader() &#123; mPaint.setShader(new LinearGradient(0, 0, 0, drawSize, mGradientColors, mGradientPosition, Shader.TileMode.CLAMP)); &#125; @Override protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; int layerSave = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); boolean drawChild = super.drawChild(canvas, child, drawingTime); if (position == 0 || (position &amp; topMask) != 0) &#123; canvas.drawRect(0, 0, mWidth, drawSize, mPaint); &#125; if (position == 0 || (position &amp; bottomMask) != 0) &#123; int save = canvas.save(); canvas.rotate(180, mWidth / 2, mHeight / 2); canvas.drawRect(0, 0, mWidth, drawSize, mPaint); canvas.restoreToCount(save); &#125; int offset = (mHeight - mWidth) / 2; if (position == 0 || (position &amp; leftMask) != 0) &#123; int saveCount = canvas.save(); canvas.rotate(90, mWidth / 2, mHeight / 2); canvas.translate(0, offset); canvas.drawRect(0 - offset, 0, mWidth + offset, drawSize, mPaint); canvas.restoreToCount(saveCount); &#125; if (position == 0 || (position &amp; rightMask) != 0) &#123; int saveCount = canvas.save(); canvas.rotate(270, mWidth / 2, mHeight / 2); canvas.translate(0, offset); canvas.drawRect(0 - offset, 0, mWidth + offset, drawSize, mPaint); canvas.restoreToCount(saveCount); &#125; canvas.restoreToCount(layerSave); return drawChild; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125;&#125; 这里开始一点点分析与学习。 自定义属性：12345678910111213&lt;resources&gt; &lt;!--边沿透明View--&gt; &lt;declare-styleable name=\"EdgeTransparentView\"&gt; &lt;attr name=\"edge_position\"&gt; &lt;flag name=\"top\" value=\"0x01\"/&gt; &lt;flag name=\"bottom\" value=\"0x02\"/&gt; &lt;flag name=\"left\" value=\"0x04\"/&gt; &lt;flag name=\"right\" value=\"0x08\"/&gt; &lt;/attr&gt; &lt;attr name=\"edge_width\" format=\"dimension\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 定义了2个属性，一个是要透明的边（上下左右），一个是要透明的宽度。这里利用0x01、0x02十六进制这样的标识，后面再通过“&amp;”操作符来用于标志位的判断真是个不错的idea。 渐变：代码中的渐变是利用给画笔设置shader来实现的。关键代码：1mPaint.setShader(new LinearGradient(0, 0, 0, drawSize, mGradientColors, mGradientPosition, Shader.TileMode.CLAMP)); 看下LinearGradient的构造函数：1234567891011121314151617181920212223242526272829/** Create a shader that draws a linear gradient along a line. @param x0 The x-coordinate for the start of the gradient line @param y0 The y-coordinate for the start of the gradient line @param x1 The x-coordinate for the end of the gradient line @param y1 The y-coordinate for the end of the gradient line @param colors The colors to be distributed along the gradient line @param positions May be null. The relative positions [0..1] of each corresponding color in the colors array. If this is null, the the colors are distributed evenly along the gradient line. @param tile The Shader tiling mode*/public LinearGradient(float x0, float y0, float x1, float y1, int colors[], float positions[], TileMode tile) &#123; if (colors.length &lt; 2) &#123; throw new IllegalArgumentException(\"needs &gt;= 2 number of colors\"); &#125; if (positions != null &amp;&amp; colors.length != positions.length) &#123; throw new IllegalArgumentException(\"color and position arrays must be of equal length\"); &#125; mType = TYPE_COLORS_AND_POSITIONS; mX0 = x0; mY0 = y0; mX1 = x1; mY1 = y1; mColors = colors; mPositions = positions; mTileMode = tile; init(nativeCreate1(x0, y0, x1, y1, colors, positions, tile.nativeInt));&#125; 可以知道前面4个参数都是设置起始、结束坐标。colors是渐变的颜色：0xffffffff–&gt;0x00000000，tile是shader mode。123456789101112131415161718192021public enum TileMode &#123; /** * replicate the edge color if the shader draws outside of its * original bounds */ CLAMP (0), /** * repeat the shader's image horizontally and vertically */ REPEAT (1), /** * repeat the shader's image horizontally and vertically, alternating * mirror images so that adjacent images always seam */ MIRROR (2); TileMode(int nativeInt) &#123; this.nativeInt = nativeInt; &#125; final int nativeInt;&#125; 画：在drawChild中，会优先调用super.drawChild(canvas, child, drawingTime);因为我们的layer要遮罩在子View上，才能有这种效果，所以画layer一定要在其之后执行。根据position的判断，来判断上下左右4条边哪些边需要画layer，通过旋转画布来画不同的边，画完后恢复现场，进行下一个判断。 setXfermode：可能刚开始会没注意到这个方法的调用，但是它的作用不可谓不大。看到核心代码： 1mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT)); 这个便是给画笔设置xfermode，没有这句代码效果可就很不如意咯。这里便要拓展学习一下了，贴一下爱哥的博客。","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"我的2016","date":"2017-01-09T05:55:40.000Z","path":"2017/01/09/summary/","text":"对，已经是1月9号了，早在8天前2016年便成为了过去，总觉得必须要写点什么。恰逢今天来了兴致，便随便叨叨几句。 在新的一年里，我们总会兴冲冲的立下我们的小目标（先挣它一个亿~），但是一年里，有多少是你付出的呢？这个世界从来就不存在免费的午餐。 注意看图中的时间。是的，2015年！2015年立下的几个小目标在2016年过完却是一个都没有实现，这可真是个悲伤的故事。但是我们仍然要相信，美好的事情总会发生。 2016年3月14日7点零2分，我的小外甥出生，为我冠上舅舅之名。同天的11点31分，我的小外甥女也出生了，哥哥叫汪乐涵，妹妹叫王语悠。2个小家伙在家人的悉心照顾下，健康快乐的成长着。一眨眼，2个小家伙都快过周岁了，时间过得可真快呢。 2016年3月28日，我开始跑步锻炼，控制饮食。强度并不大，但也坚持了2个月，直到难以忍受深圳6月份的酷暑便没跑了。经过这段时间的锻炼，体重成功减轻10斤，也算是达到我的预期了。计划着天气变凉一点后，便重新开始跑步的。奈何今年深圳的天气，完全不按套路出牌。直接夏天到“冬天”，冷了几天就重新回到夏天。1月份的天气穿个短袖都嫌热，还特么有蚊子！所以，算是给自己找了个借口，下半年相比上半年就比较懈怠了。期间我的目标就是维持体重不再增加。现在每周六都会跑上4、5公里，倒也不至于一点运动量都没有。 也就是天气变热后直到国庆，我有另外一项运动：游泳。在15年的时候便开始学游泳来着，却一直没有学会，16年基本都是保持着每周一次的频率。我一直都很郁闷，因为我之前学一些东西都是功夫下到了，自然就会了，可这游泳却不同，怎么学都学不会，可能真是天性怕水？真是让我卑微到了尘土里。直到9月10日，那天的我突然就掌握了换气的诀窍，那感觉，就好像被打通了任督二脉一样，直接一跃成为大侠。当然至今我也只会最简单的蛙泳，也说不上好，但好歹能换气，能一次性从水道的一端游到另一端。 2016年6月10日，我们计划着去海滩露营，理想很美好，现实很残酷。我们租了一辆GL8从住所自驾开到杨梅坑，老司机说累了不想开，后面由我接手了，于是惊心动魄的2小时旅程开始了。事后，他们一直说车子左摇右晃，吓得他们赶紧系紧了安全带，当然我这个司机是一点感觉都没有的。在到达目的地后突然发现车胎爆掉了，正直下午6点，打公司到租赁公司派人过来修会很麻烦，附近也没有修车厂，所以我们便照着网上的教程，抄着家伙自己修了起来，最后竟真被我们成功换了个备胎上去。扎好帐篷，天就已经黑了，乌漆墨黑什么都看不到，不一会竟然特么的下起雨来了！没错，下雨了！！！我们一群人真是哔了狗了- -。躲在帐篷里，又热又闷，还特么有蚊子，租的帐篷质量本身又堪忧，整整一晚都是被折磨得死去活来，都不知道我们是怎么过来的。我们一群人肯定是闲疯了才这么自找苦吃，恩，一定是的。 2016年9月17日，我去到了桂林龙脊梯田。从没见过梯田这样的景色，初来乍到之时，便深深地被那景色给吸引住了。话不多说，多放点图自身来感受吧。 2016年9月24日，五月天Just rock it！深圳演唱会，蛮早蛮早之前就已经买好了票，终于是等到这一天，只要能听到一曲现场版的《温柔》，此行无憾矣！虽然我没有经历过一份真正的感情，但是当我听到《温柔》还你自由版时，我的心脏便不由自主的跟着它一起跳动，中间的独白，让我为之疯狂。这是我的温柔，还给你的自由~ 希望你也喜欢这首歌。 2016年10月6日，回到孝感参加同学的婚礼，算是大学同学里的第一对新人。祝福他们。 发现到了年龄，很自然的就变成之前很不想变成的样子，同学吃饭聚会，现在是越来越多的谈论到房子，车子，孩子。哎，终归还是老了，不服是不行的。只是害怕会有一天，我变成了自己最不想变成的那个样子。 过了一年我仍然是条单身汪。但是现在相比过去，我看得更加淡了，不管什么样的人生都是人生，重要的是自己过得快乐，现在一般的狗粮我可是不吃的。这个世界还有很多美好的事情，人生辽阔，不要只活在爱恨里。总而言之一切随缘，生死看淡，不服就干。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"iOS 学习之旅","date":"2016-12-16T02:23:53.000Z","path":"2016/12/16/ios-tips/","text":"接触iOS也有一阵子了，也参与到项目做了有些事情，主要是从改bug入手，边学边做，下面记录一下自己在学习中遇到一些点。 CategoryObjective-C提供了一种与众不同的方式——Category，可以动态的为已经存在的类添加新的行为。这样可以保证类的原始设计规模较小，功能增加时再逐步扩展。使用Category对类进行扩展时，不需要访问其源代码，也不需要创建子类。Category使用简单的方式，实现了类的相关方法的模块化，把不同的类方法分配到不同的分类文件中。1234567891011121314151617181920212223SomeClass.h@interface SomeClass : NSObject&#123;&#125;-(void) print;@end#import \"SomeClass.h\"@interface SomeClass (Hello)-(void)hello;@end#import \"SomeClass+Hello.h\"@implementationSomeClass (Hello)-(void)hello&#123; NSLog (@\"name：%@ \", @\"Jacky\");&#125;@end#import \"SomeClass+Hello.h\"SomeClass * sc =[[SomeClass alloc] init];[sc hello] 这里还有一个约定成俗的习惯，将声明文件和实现文件名称统一采用“原类名+Category”的方式命名。 ProtocolProtocol，简单来说就是一系列不属于任何类的方法列表，其中声明的方法可以被任何类实现。这种模式一般称为代理（delegation）模式。你通过Protocol定义各种行为，在不同的场景采用不同的实现方式。在iOS和OS X开发中，Apple采用了大量的代理模式来实现MVC中View和Controller的解耦。1234567891011@protocol ProcessDataDelegate &lt;NSObject&gt;@required- (void) processSuccessful: (BOOL)success;@optional- (id) submitOrder: (NSNumber *) orderid;@end@interface TestAppDelegate : NSObject&lt;ProcessDataDelegate&gt;;@end @required和@optional，表示如果要实现这个协议，那么processSuccessful方法是必须要实现的，submitOrder则是可选的 如果不注明，那么方法默认是@required的，必须实现。用尖括号（&lt;…&gt;）括起来的ProcessDataDelegate就是创建的Protocol。如果要采用多个Protocol，可以在尖括号内引入多个Protocol名称，并用逗号隔开即可。例如&lt;ProcessDataDelegate,xxxDelegate&gt;。Protocol本身是可以继承的。123456@protocol A -(void)methodA;@end@protocol B &lt;A&gt; -(void)methodB;@end OC中没有方法的重载OC中没有方法的重载！OC中没有方法的重载！OC中没有方法的重载！重要的事情说三遍~遇到个问题一直不能理解，原来就是因为OC没有方法的重载！在Java中，可以根据参数的个数、类型来重载方法，在OC中没有这一说。123-(return_type) instance_method1; // 无参数-(return_type) instance_method2: (int) p1; // 1个参数-(return_type) instance_method3: (int) p1 andPar: (int) p2; // 2个参数 看到2个参数的例子，在参数前面会有andPar，这个结合instance_method3才构成一个方法。调用的时候：123[obj instance_method1];[obj instance_method2:p1];[obj instance_method3:p1 andPar:p2]; 数组 NSArray：不可变数组，NSArray保存的对象可以是不同的对象。但只能保存对象，int ,char,double等基本数据类型不能直接保存，需要通过转换成对象才能加入数组。 [array count] : 数组的长度。 [array objectAtIndex 0]: 传入数组脚标的id 得到数据对象。 [arrayWithObjects; …] :向数组对象初始化赋值。这里可以写任意对象的指针,结尾必须使用nil。 NSMutableArray：可变数组，[NSMutableArray arrayWithCapacity:6] :初始化可变数组对象的长度，如果后面代码继续添加数组超过长度6以后NSMutableArray的长度会自动扩充，6是自己可以设置的颗粒度。 [array addObject:…] : 向可变数组尾部添加数据对象。 [array addObjectsFromArray:..] :向可变数组尾部添加一个数组对象。 blockblock，带有自动变量的匿名函数，回调，用^表示。123456789int b = 0;void (^blo)() = ^&#123; NSLog(@\"Input:b=%d\",b);&#125;;b = 3;blo();/** * Input:b=0 */ 虽然在调用blo之前改变了b的值，但是输出的还是Block编译时候b的值，所以截获瞬间自动变量就是：在Block中会保存变量的值，而不会随变量的值的改变而改变。1234int b = 0;void (^blo)() = ^&#123; b = 3;&#125;; 这段代码编译出错，编译器提示的大概就是不能在Block中改变变量的值。因为在Block中截获了变量的瞬间值以后就不能再改变变量的值，如果想要在Block中改变变量的值，那么只需要在变量声明的时候加上__Block修饰符，像这样：1234__block int b = 0;void (^blo)() = ^&#123; b = 3;&#125;; 然而这样的情况又是允许的：1234NSMutableArray *array = [[NSMutableArray alloc]init];void (^blo)() = ^&#123; [array addObject:@\"Obj\"];&#125;; 为什么呢，因为只是对截获的变量进行了操作，而没有进行赋值，所以对于截获变量，可以进行操作而不可以进行赋值。 self 与 _定义个属性a：1234@interface Test:NSObject @property int a; -(void) changeAValue:(int) newValue; @end 直接用属性名访问：123-(void) changeAValue:(int) newValue &#123; _a = newValue; // 默认生成的属性成员变量前面会自动加上“_”前缀 &#125; 通过self.a的形式访问：123-(void) changeAValue:(int) newValue &#123; self.a = newValue; &#125; 这两种访问方式有区别吗？答案是肯定的。通过第一种方式访问，其实是类似于C++的访问方式，是直接访问的实例变量并赋值。而第二种方式，并不像其表面那么直观，它其实是通过调用编译器自动生成的对于a变量的赋值函数来实现的。即：123-(void) changeAValue:(int) newValue &#123; self.a = newValue; // 此处实际是调用 [self setA:newValue]; &#125; 类的属性仅在本类中可以访问，子类无法通过_a的形式访问。但是可以通过继承父类的存取方法访问。 resignFirstResponder这个方法是取消第一响应者状态的。如果对textfield使用的话，那么调用这个方法，textfield的第一响应者状态就会取消，然后键盘就消失了。 delegate模式类似于Android中的listener。系统提供各种interface，然后调用interface中的方法，至于具体实现，可以由我们自己定义。Android:12345678910111213141516editText.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void afterTextChanged(Editable editable) &#123; &#125;&#125;); iOS：12345@interface YourClass ()&lt;UITextFieldDelegate&gt;UITextField *_mobileTextField;_mobileTextField = [[UITextField alloc]init];_mobileTextField.delegate = self; UITextFieldDelegate就类比于TextWatcher，它内容如下：12345678910111213141516@protocol UITextFieldDelegate &lt;NSObject&gt;@optional- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField; // return NO to disallow editing.- (void)textFieldDidBeginEditing:(UITextField *)textField; // became first responder- (BOOL)textFieldShouldEndEditing:(UITextField *)textField; // return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end- (void)textFieldDidEndEditing:(UITextField *)textField; // may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called- (void)textFieldDidEndEditing:(UITextField *)textField reason:(UITextFieldDidEndEditingReason)reason NS_AVAILABLE_IOS(10_0); // if implemented, called in place of textFieldDidEndEditing:- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string; // return NO to not change text- (BOOL)textFieldShouldClear:(UITextField *)textField; // called when clear button pressed. return NO to ignore (no notifications)- (BOOL)textFieldShouldReturn:(UITextField *)textField; // called when 'return' key pressed. return NO to ignore.@end 通过_mobileTextField.delegate = self就类似于添加了listener，然后实现相应的方法，就可以做自己的事情了。 权限 This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data. 意思就是没有配置权限，需要在 info.plist 文件添加一个 NSPhotoLibraryUsageDescription的 key，然后添加一个描述。1234567891011&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;&lt;string&gt;此 App 需要您的同意才能读取媒体资料库&lt;/string&gt;&lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;cameraDesciption&lt;/string&gt;&lt;key&gt;NSContactsUsageDescription&lt;/key&gt; &lt;string&gt;contactsDesciption&lt;/string&gt;&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;microphoneDesciption&lt;/string&gt; dispatch_async线程相关的语法：1234567dispatch_async(queue, ^&#123; //block具体代码&#125;); //异步执行block，函数立即返回dispatch_sync(queue, ^&#123; //block具体代码&#125;); //同步执行block，函数不返回 实际运用中，一般可以用dispatch这样来写，常见的网络请求数据多线程执行模型：1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //子线程中开始网络请求数据 //更新数据模型 dispatch_sync(dispatch_get_main_queue(), ^&#123; //在主线程中更新UI代码 &#125;);&#125;); dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得程序进程缺省产生的并发队列，可设定优先级来选择高、中、低三个优先级队列。dispatch_get_main_queue(); //获得主线程的dispatch队列。 UITextFiled类似Android中的EditText。可以使用leftView、rightView来实现padding效果，以及编辑状态下添加删除按钮。1234567891011121314151617- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField &#123; _titleTextField.textAlignment = NSTextAlignmentLeft; _titleTextField.width = (self.width -170) / 2 + 170 - 12; UIView *leftEmpty = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 12, 32)]; _titleTextField.leftView = leftEmpty; _titleTextField.leftViewMode = UITextFieldViewModeWhileEditing; UIButton *rightClean = [UIButton buttonWithType:UIButtonTypeCustom]; [rightClean setFrame:CGRectMake(0, 0, 36 , 18)]; [rightClean setImage:[UIImage imageNamed:@\"ct_x\"] forState:UIControlStateNormal]; [rightClean setTitle:@\" \" forState:UIControlStateNormal]; rightClean.titleLabel.font = [UIFont systemFontOfSize:15]; [rightClean addTarget:self action:@selector(cleanText) forControlEvents:UIControlEventTouchUpInside]; _titleTextField.rightView = rightClean; _titleTextField.rightViewMode = UITextFieldViewModeWhileEditing; return YES;&#125; 也可以直接使用layer来实现shader：1234567891011_titleTextField = [[UITextField alloc]initWithFrame:CGRectMake((self.width - 170) / 2, 0, 170, self.height)];_titleTextField.borderStyle = UITextBorderStyleNone;_titleTextField.returnKeyType = UIReturnKeyDone;_titleTextField.backgroundColor = UIColorByHex(0x000000);_titleTextField.layer.cornerRadius = 15;_titleTextField.delegate = self;_titleTextField.textColor = [UIColor whiteColor];_titleTextField.textAlignment = NSTextAlignmentCenter;_titleTextField.placeholder = @\"给直播写个标题吧\";_titleTextField.font = [UIFont systemFontOfSize:16];[_titleTextField setValue:UIColorByHex(0xCCCCCC) forKeyPath:@\"_placeholderLabel.textColor\"]; 拼接字符串12345NSDate * senddate=[NSDate date];NSDateFormatter *dateformatter=[[NSDateFormatter alloc] init];[dateformatter setDateFormat:@\"YYYY.MM.dd HH:mm:ss\"];NSString * morelocationString=[dateformatter stringFromDate:senddate];_titleTextField.text = [NSString stringWithFormat:@\"%@ %@\", [UIDevice currentDevice].name, morelocationString]; 也可以使用NSMutableString。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://lijia92.github.io/tags/iOS/"}]},{"title":"Xcode的基本使用","date":"2016-12-07T06:36:05.000Z","path":"2016/12/07/xcode/","text":"要开发iOS，Xcode是少不了的，这里摘录一下Xcode的基本使用。 基本导航区：导航作用，可以查看项目总体结构。编辑区：用于编写代码的区域。调试区：用于输出和显示调试信息的区域。实用区：用于显示属性和提供xib类库的区域。工具栏：可以选择运行的设备等。 快捷键 全局查找：command + 3（command + shift + F，可以直接输入关键字进行查找） 查看断点：command + 7 查看文件目录：command + 1 查看下一处：command + G 跳转到指定行：command + L 快速定位当前类在文件中的位置：command + shift + J 上下位移代码：command+option + 【（】） 以调试的形式运行程序：command + Y 搜索类：command + shift + O 清空控制台信息：command + K 模拟器回到Home：command + shift + H 模拟器旋转屏幕：command + 左右箭头 删除光标之前的代码：command + delete 注释代码：command + / 到行首（尾）：cmd + 左（右） .m 与.h文件之间切换：command + control + 上/下 清除工程：command + shift + K 调试可以和Android studio一样点击左侧栏，设置断点。右键断点，可以弹出断点设置。F6单步调试、F7跳入，F8继续。在调试时，也可以看下面的调试栏进行操作。可以直接拖拽断点到编辑区就能删除断点了，类似QQ的消息数目提示。 代码块管理利用#pragma注释，管理代码块。如下图，可以很清晰知道代码块内的方法。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://lijia92.github.io/tags/iOS/"}]},{"title":"Objective-C 基本语法","date":"2016-12-07T03:05:24.000Z","path":"2016/12/07/enter-oc/","text":"最近的一段时间都是在学习OC语法，然后看代码，改项目中的bug。OC基本语法是比较固定的，网上的文章都大同小异，这里摘录一下方便后面回顾。 基础Objective-C扩展了ANSI C，是C的超集，也就是说： 任何C源程序，不经修改，即可通过Objective-C编译器成功编译。 Objective-C源程序中可以直接使用任何C语言代码。注意以下几点： OC中头文件后缀为.h，实现文件为.m，类似于c++中的.h于.cpp。 在OC语言中混合使用C或者C++代码，包含有C语言或者C++语言时，文件的后缀使用.mm。同时一般如果是纯粹的C++文件，源代码文件后缀为.cpp，头文件使用.hpp为后缀。 import和include的功能是一样的，都是将引入的文件原封不动拷贝到当前位置。import的优点：会自动防止重复拷贝，同时兼容C语言的引入。 “ ”优先在当前文件路径查找， &lt; &gt;优先在系统环境查找。 字符串相比Java，OC的字符串需要在前面加上“@”符号，否则编译器会理解为c语言中的字符串，导致一些莫名错误。12NSString title = @\"Hello\";if(title == @\"hello\") &#123;&#125; 函数调用不带参数：1[obj method]; 带1个参数：1[counter increase:1]; 带多个参数：12- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue &#123;...&#125; //定义方法[myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; //调用方法 类接口和实现Objective-C的类分为接口定义和实现两个部分。接口定义（Interface）放在头文件中，文件扩展名是.h，实现（implementation）放在实现文件中，文件扩展名是.m。 接口定义也可以写在.m文件中，但最好不要这么干。 需要注意的是，与Objective-C的interface概念最接近的是C和C++里的头文件，它与implementation是成双成对出现的，作用是声明类的成员变量和方法。它与Java的interface概念完全不同： Objective-C里，interface有且只有一个实现，Java的interface可以有0-N个实现。 Objective-C里，interface可以定义成员属性，Java里不可以。 在Objective-C里，和Java的Interface概念相似的是Protocol。定义：123456789@interface MyClass &#123; int memberVar1; id memberVar2;&#125;-(return_type) instance_method1;-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 实现：1234567891011121314@implementation MyClass &#123; int memberVar3;&#125;-(return_type) instance_method1 &#123; ....&#125;-(return_type) instance_method2: (int) p1 &#123; ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ....&#125;@end 接口和实现以@interface、@implementation开头，都以@end结束。“@”符号在Objective-C中是个很神奇的符号。 方法写在.h头文件里的方法都是公开的，Objective-C里没有私有方法的概念。 类方法：类似于Android的静态方法，是属于类的，不需要实例化对象就可以进行调用，用”+”来表示。定义：1234567891011@interface MyClass +(void) sayHello;@end@implementation MyClass+(void) sayHello &#123; NSLog(@\"Hello, World\");&#125;@end 使用：1[MyClass sayHello]; 实例方法：这就跟Android中的费静态方法类似，需要实例化对象才能进行调用，用”-“来表示。定义：1234567891011@interface MyClass : NSObject-(void) sayHello;@end@implementation MyClass-(void) sayHello &#123; NSLog(@\"Hello, World\");&#125;@end 使用：12mycls = [MyClass new];[mycls sayHello]; 属性可以使用@property来声明属性。123456789#import &lt;Foundation/Foundation.h&gt;@interface Car : NSObject@property(nonatomic,strong) NSString *carName;@property(nonatomic,strong) NSString *carType;- (NSString *)carInfo;@end 它会自动生成getter、setter。当然你也可以复写getter、setter，添加一些额外的功能。它也有一些关键字，具有特殊的作用。 原子性： atomic（默认）：atomic意为操作是原子的，意味着只有一个线程访问实例变量。atomic是线程安全的，至少在当前的存取器上是安全的。它是一个默认的特性，但是很少使用，因为比较影响效率，这跟ARM平台和内部锁机制有关。 nonatomic：nonatomic跟atomic刚好相反。表示非原子的，可以被多个线程访问。它的效率比atomic快。但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。 存取器控制： readwrite（默认）：表示该属性同时拥有setter和getter。 readonly：readonly表示只有getter没有setter。有时候为了语意更明确可能需要自定义访问器的名字：1@property (nonatomic, setter = mySetter:,getter = myGetter ) NSString *name; 内存管理： assign（默认）：assign用于值类型，如int、float、double和NSInteger，CGFloat等表示单纯的复制。还包括不存在所有权关系的对象，比如常见的delegate。 retain：在setter方法中，需要对传入的对象进行引用计数加1的操作。简单来说，就是对传入的对象拥有所有权，只要对该对象拥有所有权，该对象就不会被释放。 strong：strong是在iOS引入ARC的时候引入的关键字，是retain的一个可选的替代。表示实例变量对传入的对象要有所有权关系，即强引用。strong跟retain的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。 weak：在setter方法中，需要对传入的对象不进行引用计数加1的操作。简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用weak声明的实例变量指向nil，即实例变量的值为0。 copy：与strong类似，但区别在于实例变量是对传入对象的副本拥有所有权，而非对象本身。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://lijia92.github.io/tags/iOS/"}]},{"title":"Hexo多台电脑同步博客","date":"2016-11-29T11:06:25.000Z","path":"2016/11/29/multi-pc/","text":"前言iMac到了之后，这2天一直在熟悉系统，准备记点东西写到博客里，发现需要解决Hexo多台电脑同步的问题，其实蛮早之前就打算弄的，方便自己在家里也能写写博客，但是考虑要带电脑到公司，而且这也确实是与工作无关的事情，只能周末来弄，但是周末是吧，大家懂的，压根不想来呀233333，所以便拖到今天了。 原理先来想想多台电脑同步博客的原理。假设电脑A已经可以正常写博客发布了，这个时候B电脑也想发布博客该如何做呢？我们知道，发不到Github pages上的东西是静态内容，这些是Hexo生成的，这些东西其实不需要我们管，我们只要在hexo d的时候就会帮我们生成然后上传到github。所以我们需要同步的只是源文件。这里的源文件指的就是md文件、theme相关文件、以及博客配置文件等一切跟Hexo无关的文件。 举个栗子，这里看看Hexo目录。我们需要同步的就是suorce、themes、以及_config.yml了，其他都是Hexo生成的。那么接下来便是同步这些文件了。同步的话我们可以在github.io的仓库下建个分支source（也可以建仓库，原理是一样的），然后将这些源文件同步到source分支，当另一台电脑要写博客时，先从该分支pull最新的数据，然后hexo new，当部署完之后将自己新建的源文件push到该分支。而hexo d的时候，根据我们_config.yml中的配置，会推到master分支，2个分支是互不影响的。1234deploy: type: git repository: https://github.com/LiJia92/LiJia92.github.io.git branch: master 记住一点，每次写博客的时候先pull，完毕的时候push。 A 电脑操作首先，我们要同步themes，就把theme文件夹下面对应的.git删掉，删掉之后便是没有之前的版本控制了，意味着你不能再更新主题了-。-，但是其实一般主题我们再配置后就很少修改它了，所以为了同步主题设置姑且删掉吧。然后在hexo目录下执行下面的命令初始化仓库：1git init 然后配置.gitignore：1234/.deploy_git/node_modules/publicdb.json db.json是每次部署的时候会自动生成，会经常变动，导致冲突，所以我们把它忽略。然后添加远程分支，并push：12345git checkout -b sourcegit add .git commit -m \"first commit\"git remote add origin https://github.com/LiJia92/LiJia92.github.io.gitgit push origin source 执行完毕后再github.io上便能看到source分支了，这个分支里的内容便是源文件了。 B 电脑操作假设新电脑已经装好Git，Node，Hexo这些环境，那么只需要同步下来source分支的内容即可。123git initgit remote add origin https://github.com/LiJia92/LiJia92.github.io.gitgit pull origin source # 从source分支拉取内容 建议先将hexo目录下的source、themes等source分支上有的内容删掉，避免冲突。这样B电脑便具备了和A电脑一样的源文件环境了，接下来便可以进行写博客了。 最后每次在写博客的时候，需要执行一次pull操作：1git pull origin source 写完之后push：123git add . git commit -m \"update new paper\"git push origin source 记得带上分支名称source。 Tip 看到一些博客说是要设置github的默认branch，这个设置只是针对采用git clone方式拷贝代码的，如果通过我文中的方法是不需要设置默认branch的。另外，我在B电脑git push的时候出错了：12error: src refspec source does not match any.error: failed to push some refs to 'https://github.com/LiJia92/LiJia92.github.io.git' 查了一下，是因为我直接本地git init的分支名字叫master，然后要push的分支名为source，不一致导致的。通过下面的指令重命名分支：1git branch -mv master source 再push即可。也可以在init之后就直接checkout branch source。 在我hexo d之后在github看不到我的contributions，Google之，是因为邮箱的问题，切换到iMac之后，邮箱变成了``lijia@lijiadeiMac.local，利用git log可以看到相关的记录。这个时候需要将邮箱改成之前绑定的邮箱，然后重新部署就能看到提交记录了。 1git config --global user.email 你的邮件地址 hexo d提示Deployer not found:git，执行： 1npm install hexo-deployer-git --save 然后重新deploy即可。 参考通过 git 实现多台电脑同步博客Hexo利用Github分支在不同电脑上写博客为什么Github没有记录你的Contributions","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"熟悉OS X系统","date":"2016-11-28T08:01:18.000Z","path":"2016/11/28/OS-X/","text":"等了一个星期，公司配备的iMac总算是到了，今天装上后体验了一下，有很多地方还是很不习惯，后面需要慢慢适应，这里列几点感悟。 FinderFinder便是类似Windows中的文件管理器了吧，只不过OS X不分什么C、D、E、F盘什么的，感觉就是只有简单的几个分类：应用程序、下载、桌面、文稿。同事说有什么东西全部往桌面丢就行了，也不知是真是假。 鼠标打开系统偏好设置，选择鼠标项，会有一些设置，还有一些手势，在你打钩后边能生效，也是类似Mackbook的一些手势，方便做一些操作。 Mission ControlMission Control会提供一个所有已打开的窗口、桌面空间、全屏应用和Split View空间的鸟瞰图，让你能轻松在它们之间进行切换。 触摸角打开系统偏好设置，选择Mission Control项，左下角会有触摸角的设置。当把鼠标移到屏幕的角落的时候可以触发一些操作，4个角可以设置4个操作。 App Store这个就是苹果软件商店了，没什么好说的。需要安装QQ、微信、Xcode等软件直接在里面搜索后购买就行了。购买的时候是需要绑定Apple ID的，这个直接绑定就好了。 终端后续的日常开发肯定离不开终端，例如查看Git版本。按下Command + Space可以出现spotlight搜索，输入terminal回车即可运行终端。 屏幕取词选中单词，按下Command + Control + D即可即时翻译。) 常用快捷键首先了解下符号与按键的对应关系 Command ⌘ Shift ⇧ Option ⌥ Control ⌃ Caps Lock ⇪ Fn 快捷键 描述 Command-X 剪切：删除所选项并将其拷贝到剪贴板。 Command-C 将所选项拷贝到剪贴板。这同样适用于 Finder 中的文件。 Command-V 将剪贴板的内容粘贴到当前文稿或 app 中。这同样适用于 Finder 中的文件。 Command-Z 撤销前一个命令。随后您可以按 Command-Shift-Z 来重做，从而反向执行撤销命令。在某些 app 中，您可以撤销和重做多个命令。 Command-A 全选各项。 Command-F 查找：打开“查找”窗口，或在文稿中查找项目。 Command-G 再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Command-Shift-G。 Command-H 隐藏最前面的 app 的窗口。要查看最前面的 app 但隐藏所有其他 app，请按 Command-Option-H。 Command-M 将最前面的窗口最小化至 Dock。要最小化最前面的 app 的所有窗口，请按 Command-Option-M。 Command-N 新建：打开一个新文稿或窗口。 Command-O 打开所选项，或打开一个对话框以选择要打开的文件。 Command-P 打印当前文稿。 Command-S 存储当前文稿。 Command-W 关闭最前面的窗口。要关闭该 app 的所有窗口，请按 Command-Option-W。 Command-Q 退出 app。 Option-Command-Esc 强制退出：选择要强制退出的 app。或者，按住 Command-Shift-Option-Esc 3 秒钟来仅强制最前面的 app 退出。 Command–空格键 Spotlight：显示或隐藏 Spotlight 搜索栏。要从 Finder 窗口执行 Spotlight 搜索，请按 Command–Option–空格键。如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示 Spotlight。 空格键 快速查看：使用快速查看预览所选项。 Command-Tab 切换 app：在打开的 app 中切换到下一个最近使用的 app。 Shift-Command-波浪号 (~) 切换窗口：切换到最前端应用中下一个最近使用的窗口。 Shift-Command-3 屏幕快照：拍摄整个屏幕的屏幕快照。了解更多屏幕快照快捷键。 Command-逗号 (,) 偏好设置：打开最前面的 app 的偏好设置。 Command-F3 打开桌面 Command-H 隐藏当前 更多快捷键参见官方文档。 最后感觉就是各种手势，各种简单的操作定义复杂的操作，极大的节省时间，而且高逼格，以后我也要走上装逼的道路了！","tags":[{"name":"iOS","slug":"iOS","permalink":"http://lijia92.github.io/tags/iOS/"}]},{"title":"Android 转 iOS","date":"2016-11-21T09:55:53.000Z","path":"2016/11/21/ios/","text":"过完一个周末来上班，今天被技术负责人约着谈了一下，主题是：让我转iOS开发。 其实在刚刚听到这个消息的时候，内心是窃喜的。因为自国庆以来，做的主要工作是预研性质的，诸如网络连接、音视频、图像处理这些非常专业的领域。也不是说自己不能够学习，主要是这些领域都是需要非常专业的人来做这些事情。通过我自学，预研，然后来做相关的开发，说实话，我自己都觉得不靠谱。所以一直以来，我对自己的工作都不是很不满意，虽然通过查资料，看文章，了解了相关东西的一点点皮毛，但是这些皮毛感觉没啥用，如果你不在这些专业的领域继续深挖进去，可以说我之前1、2月的工作都是做的无用功。当然，稍微拓宽了自己的知识层面这是不可否认的。 虽然是以谈的方式来进行的，但是其实我也没得选择了，只能选择同意。难不成不同意然后等着被辞退吗。目前公司是全力进攻iOS端的项目，Android可能要到后续iOS出到稳定的产品了才能慢慢接入进来，但那都是之后的事情了，基于当下的话必须给我找点事干，所以便让我来做iOS，说是同意的话就马上配电脑，前面一段时间可以自己学习，后面才会安排一些事情，其实这样挺好的。于我接触了点新鲜东西，还能体验体验苹果电脑，于公司花成本来培养我，我后面也可以帮忙现在的iOS同事做些事情，缓解他的压力。 就在前不久，苹果发布新的Mackbook Pro了，主要是配备了Touch Bar和Touch Id，但是价格却是异常的贵。15英寸最低配的都得1万8软妹币。。。我的内心是崩溃的，我是打算出了新款花1万左右买台笔记本来体验一下，结果苹果闹了这么一出。纠结了好久，最后还是决定没有买，代价实在太大了。13英寸虽说便宜些，但是我还是喜欢大屏的，1万8的价格我配台外星人打游戏能打得飞起。我最近在玩梦幻西游，每天下班回家就刷刷神器副本啥的，买Mac也是考虑到梦幻有Mac客户端，但是我室友花了1万8买了台15英寸的回来，打梦幻打了一会就直接红屏了，还好我没买。 现在公司能够配电脑让我去学习，我还能体验体验苹果电脑，这也解决了我之前买Mac的心结，最后也是自愿选的转iOS，后面就是要开始学习iOS的入门开发了，不过天下语言一个样，有了Java基础，再来转相信也是挺容易的。况且，大学的入门语言就是C++呢，虽然后面全忘了，但是花点功夫去学学，相信还是能捡起来的。 加油！ 从今天开始打算在自己的博客加入一些生活杂谈方面的笔录，而不再只作为技术博客。毕竟生活不只是工作、技术，也有其他的乐趣所在嘛。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://lijia92.github.io/tags/杂谈/"}]},{"title":"Android直播利用Socket传输实时数据","date":"2016-11-16T01:52:34.000Z","path":"2016/11/16/socket/","text":"前言通过前面一段时间的摸索，iOS的Multipeer Connectivity与Android的Wifi-Direct并不兼容，一些三方可能都是需要连接热点才能实现跨平台传输。热点是需要连接到同一个网络环境下的，那么考虑下Socket是否可行呢？理论上，应该是没问题的。为了验证，我这边便开始Android端的测试，至于跨平台就得等到iOS那边一起合作来验证了。 Socket连接这里分一个Client（采集实时数据），一个server（接收数据进行处理）这样的两个角色。在一个局域网下，他们要互相建立连接首先便是要能互相发现。我的方案是：Server监听一个端口，Client发送一个绑定端口的广播（UDP），广播信息包含Client的ip，Server再收到广播之后，利用收到的ip发送一个单播到Client，单播信息包含Server的ip，Client收到之后便知道Server的ip了，那么便可以建立连接了。 获取ip：12345678910111213141516171819202122232425262728293031private static String getIP(Context application) &#123; WifiManager wifiManager = (WifiManager) application.getSystemService(Context.WIFI_SERVICE); if (!wifiManager.isWifiEnabled()) &#123; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; return inetAddress.getHostAddress(); &#125; &#125; &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); String ip = intToIp(ipAddress); return ip; &#125; return null;&#125;private static String intToIp(int i) &#123; return (i &amp; 0xFF) + \".\" + ((i &gt;&gt; 8) &amp; 0xFF) + \".\" + ((i &gt;&gt; 16) &amp; 0xFF) + \".\" + (i &gt;&gt; 24 &amp; 0xFF);&#125; Server监听端口：1234567891011121314151617181920212223242526272829public void startListening() &#123; stop = false; mHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; byte[] buf = new byte[1024]; DatagramSocket ds = new DatagramSocket(LISTENING_PORT); DatagramPacket dp = new DatagramPacket(buf, buf.length); String ip = getIP(MyApplication.getApplication()); Log.e(\"TAG\", \"startListening:\" + ip); ds.receive(dp); ds.close(); StringBuffer sb = new StringBuffer(); int i; for (i = 0; i &lt; 1024; i++) &#123; if (buf[i] == 0) &#123; break; &#125; sb.append((char) buf[i]); &#125; sendIpBroadcast(sb.toString()); setupServer(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 上面代码会在ds.receive(dp)阻塞，直到收到消息。Client发送广播：12345678910111213141516171819public void sendIpBroadcast() &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; final String message = getIP(MyApplication.getApplication()); try &#123; InetAddress adds = InetAddress.getByName(BROADCAST_IP); DatagramSocket ds = new DatagramSocket(); DatagramPacket dp = new DatagramPacket(message.getBytes(), message.length(), adds, LISTENING_PORT); ds.send(dp); ds.close(); startListening(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; Client将自己的ip通过UDP广播发送出来，同时监听一个端口，用于接收Server发出的广播（带Server ip）。Server的ds.receive(dp)执行，获取到Client ip之后，便是发送自身的ip，以及建立ServerSocket。1234567891011121314151617private void setupServer() &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; mServerSocket = new ServerSocket(SERVER_PORT); while (!stop) &#123; Socket socket = mServerSocket.accept(); socketList.add(socket); new Thread(new MyServerRunnable(socket)).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; mServerSocket.accept()也是个阻塞方法，直到有Client连接进来。Client通过监听收到Server ip，之后便是建立连接了。123456789101112private void connect(final String serverIp) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; socket = new Socket(serverIp, SERVER_PORT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 通过socket = new Socket(serverIp, SERVER_PORT);即可建立连接了（也是阻塞方法）。 时间对齐对于直播这种实时传递音视频数据的需求，在传递数据的时候都是需要打上时间戳的，用于计算超时。但是在不同手机上的时钟表现是不一样的，所以需要选取一个标准，这里我选用Server的时间。那么Client的时间如何与Server的时间对齐呢？我的方案是：Client发送本身时间到Server，Server在收到请求后回复自身的时间到Client，Client记录下发送请求的时间，与收到回复的时间。记发送请求的时间为C1，收到回复的时间为C2，Server回复的时间为S1。我们假定网络是稳定的，那么便能得到如下结论： (C1 + C2) / 2 ==&gt; S1即Client在（C1 + C2）/ 2这个时刻，Server的时间是S1. 记后续发请求的时间为C’，记此时Server的时间为S’，那么便会有如下公式： C’ - (C1 + C2) / 2 = S’ - S1 (Client与Server同时流逝的时间是一致的)==&gt; S’ = C’ - (C1 + C2)/2 + S1 ==&gt; S’ = C’ - C2 + (C2-C1) / 2 + S1 如此在Client每次发送实时音视频数据时，便可依据Client此刻的时间计算出Server端的时间，打上时间戳后传递到Server端，Server端收到后可以与Server此刻的时间对比，来进行超时的计算或其他的一些处理。这里姑且理解delta = (C2-C1) / 2为Client传递数据到Server的时间。这个时间越小，对齐得便越精准。所以需要多发送几次请求，然后取最小的delta。另外发送请求的时候包上时间数据，模拟收发的数据量是一致的。 传递H264数据通过我之前的文章，已经可以采集到H264的数据了，格式是byte数组，那么要如何通过Socket传递到Server呢？我之前是利用BufferedWriter的write(String msg)方法，new String(byte[] data)。服务端在收到后通过String.getBytes()还原byte[]，但是将这种数据传递到MediaCodec进行解码，输出不出正确的视频。所以后面干脆就直接利用DataOutputStream传递byte[]数组了。解码代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void initMediaDecode() &#123; Log.e(\"TAG\", \"initMediaDecode\"); MediaFormat format = MediaFormat.createVideoFormat(\"video/avc\", 1280, 720); try &#123; decoder = MediaCodec.createDecoderByType(\"video/avc\"); // 直接输出到surfaceView decoder.configure(format, surfaceView.getHolder().getSurface(), null, 0); decoder.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; new DecodeThread().start();&#125;private class DecodeThread extends Thread &#123; MediaCodec.BufferInfo mBufferInfo; int mCount = 0; public DecodeThread() &#123; mBufferInfo = new MediaCodec.BufferInfo(); &#125; @Override public void run() &#123; while (true) &#123; try &#123; if (h264data.size() &gt; 0) &#123; byte[] data = h264data.get(0); h264data.remove(0); Log.e(\"Media\", \"save to file data size:\" + data.length); // 保存数据到文件 // Util.save(data, 0, data.length, path, true); ByteBuffer[] inputBuffers = decoder.getInputBuffers(); int inputBufferIndex = decoder.dequeueInputBuffer(100); if (inputBufferIndex &gt;= 0) &#123; ByteBuffer inputBuffer = inputBuffers[inputBufferIndex]; inputBuffer.clear(); inputBuffer.put(data); decoder.queueInputBuffer(inputBufferIndex, 0, data.length, mCount * TIME_INTERNAL, 0); &#125; // Get output buffer index int outputBufferIndex = decoder.dequeueOutputBuffer(mBufferInfo, 100); while (outputBufferIndex &gt;= 0) &#123; Log.e(\"Media\", \"onFrame index:\" + outputBufferIndex); decoder.releaseOutputBuffer(outputBufferIndex, true); outputBufferIndex = decoder.dequeueOutputBuffer(mBufferInfo, 0); &#125; &#125; else &#123; sleep(TIME_INTERNAL); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 通过此种解码，发现解码的视频花屏，但是存入到文件中再打开则是比较清晰流畅的，估计是解码有问题。 Demo代码","tags":[{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"},{"name":"直播","slug":"直播","permalink":"http://lijia92.github.io/tags/直播/"}]},{"title":"Android-iOS 跨平台传输方案调研","date":"2016-10-28T08:21:48.000Z","path":"2016/10/28/cross-platform/","text":"现状 iOS：在iOS7中，引入了一个全新的框架——Multipeer Connectivity（多点连接）。利用Multipeer Connectivity框架，即使在没有连接到WiFi（WLAN）或移动网络（xG）的情况下，距离较近的Apple设备（iMac/iPad/iPhone）之间可基于蓝牙和WiFi（P2P WiFi）技术进行发现和连接实现近场通信。 Android：Wi-Fi peer-to-peer（P2P，对等网络），它允许具备相应硬件的Android 4.0（API level 14）或者更高版本的设备可以直接通过wifi而不需要其它中间中转节点就能直接通信（Android的Wi-Fi P2P框架符合Wi-Fi联盟的Wi-Fi Direct™直连认证标志）。使用这些API，你可以搜索并连接其它同样支持Wi-Fi P2P的设备，然后再通过一个高速的连接进行互相通信，并且这个连接的有效距离要比蓝牙连接的有效距离要长的多。这对于需要在用户之间共享数据的应用程序非常有用，例如多玩家游戏或者照片分享之类应用。 但是iOS的MC框架与Android的Wifi Direct不兼容，通过苹果开发者论坛iOS and Wi-Fi Direct了解：关于不同技术在iOS、Android上的兼容性，如下图： 蓝牙 经典蓝牙阶段：在蓝牙4.0（Bluetooth Low Energy）之前，也就是所谓的经典蓝牙，苹果的蓝牙拒绝接入不信任的设备。也就是说，没得连。 蓝牙4.0阶段：从ios6.0开始，iPhone支持BLe以后，问题得到了改善，因为在蓝牙4.0以后不再存在经典蓝牙的那个限制。ios7.0以后，BLe在 iOS 7 技术性提升里占到的重要位置。但是Android在这方面的脚步就慢很多了。 Android4.3：SDK从4.3以后开始正式在官方层面支持蓝牙4.0，可以使用安卓设备建立主机。注意，这里是说可以建立主机，也就是只能是安卓建立主机，iOS设备连接才可以。安卓无法去连接iOS的主机。 Android L：也就是Android 5.0，从这个版本开始，谷歌正式支持主从机的建立。 Android与IOS之间如何实现蓝牙通信数据传输？ 现有产品 快牙 快牙（ZAPYA），是一款全球首创、实现跨平台文件传输的应用，能帮助智能手机用户之间实现高速海量数据传输。支持安卓（Android）、苹果（iOS）、WP、PC等多种智能终端间的互联互通。通过快牙，可以和任何人分享应用、照片、视频、音乐及其他任意格式文件。目前快牙全球用户数量已超3亿，遍及海内外178个国家和地区，在同类型的传输应用中稳居第一。 茄子快传 茄子快传是北京众联极享科技有限公司推出的一款跨平台、多场景的移动数字互动平台（手机内容传输工具）。通过设备间建立的数据传输通路，茄子快传实现了在没有外部WiFi网络或者数据网络的情况下的数据高速收发，过程中无需消耗数据流量。用户操作简单，没有复杂的配对配置，无需登录账户、添加好友，支持多人互传，让用户摆脱数据线、蓝牙等复杂的分享方式，用一种简单、直观的交互让用户体验到近距离线下社交中与人分享的快乐。 通过以上2款产品，可以实现跨平台数据传输。 我利用2台Android手机测试，都是需要创建热点进行传输。Android与iOS测试，也是需要开启热点的，并且在iOS下需要手动链接到对应的热点。 第三方 AllJoyn AllJoyn，由高通公司主导的高通创新中心（Qualcomm Innovation Center）所开发的开放源代码专案，主要用于近距离无线传输，透过Wifi或蓝牙技术，进行定位与点对点档案传输。 FireChat FireChat，是一个专门用于手机的APP，由开放花园公司开发。它能使智能手机在没有网络存取时，经由无线网状网络的蓝牙、Wi-Fi，或苹果公司的多点连线（Multipeer Connectivity）对等网络架构连线。 Underdark Mobile peer-to-peer mesh networking library.Integrates into iOS and Android apps and works over Wi-Fi and Bluetooth. 目前只是知道这些三方库，至于其内部的实现原理还不了解，但应该是结合Wi-Fi与蓝牙来实现的。 小结通过目前已有的技术（不做多余的工作），应该是做不到跨平台传输的。但是如果自己通过开发Wi-Fi以及蓝牙，应该是可以实现跨平台传输的。至于开发的难点以及技术点，我也不清楚。 其他参考The Sorry State of Peer to Peer iOS to Android connectivityPeer to peer android and iOS with Wifi direct (multipeer connectivity?)Is iOS 7 Multipeer Connectivity compatible with Android Wi-Fi Direct?9 of the best apps for sharing files between devices and friends","tags":[{"name":"直播","slug":"直播","permalink":"http://lijia92.github.io/tags/直播/"}]},{"title":"【Android音视频开发】- 实时采集音频并编码","date":"2016-10-22T01:54:26.000Z","path":"2016/10/22/live-audio/","text":"前言通过我的上一篇文章，利用Camera实时采集视频，并用MediaCodec编码，可以得到YUV、H264文件了。那么接下来便是采集音频并编码了。 基础概念在音频开发中，有一些基础的概念是必须要知道的。 采样率（samplerate）采样就是把模拟信号数字化的过程，不仅仅是音频需要采样，所有的模拟信号都需要通过采样转换为可以用0101来表示的数字信号，示意图如下所示：蓝色代表模拟音频信号，红色的点代表采样得到的量化数值。采样频率越高，红色的间隔就越密集，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音。通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。 量化精度（位宽）上图中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。常见的位宽是：8bit 或者 16bit。 声道数（channels）由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。单声道（Mono）和双声道（Stereo）比较常见，顾名思义，前者的声道数为1，后者为2。 音频帧（frame）音频数据是流式的，本身并没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取 2.5 ms ~ 60 ms为单位的数据量为一帧音频。 这个时间被称之为“采样时间”，其长度没有特别的标准。我们可以计算一下一帧音频帧的大小。假设某通道的音频信号是采样率为 8 kHz，位宽为16 bit，20 ms 一帧，双通道，则一帧音频数据的大小为：1int size = 8000 x 16bit x 0.02s x 2 = 5120 bit = 640 byte 采集 Android SDK 提供了两套音频采集的API，分别是：MediaRecorder 和 AudioRecord，前者是一个更加上层一点的API，它可以直接把手机麦克风录入的音频数据进行编码压缩（如AMR、MP3等）并存成文件，而后者则更接近底层，能够更加自由灵活地控制，可以得到原始的一帧帧PCM音频数据。如果想简单地做一个录音机，录制成音频文件，则推荐使用 MediaRecorder，而如果需要对音频做进一步的算法处理、或者采用第三方的编码库进行压缩、以及网络传输等应用，则建议使用 AudioRecord，其实 MediaRecorder 底层也是调用了 AudioRecord 与 Android Framework 层的 AudioFlinger 进行交互的。 由上可知，在直播中实时采集音频自然是要用AudioRecord了。 编码通过AudioRecord我们可以获取到原始的PCM数据了，接下来就是利用MediaCodec来进行编码成AAC数据了。 示例代码变量声明：123456private static final int DEFAULT_SOURCE = MediaRecorder.AudioSource.MIC; // 麦克风private static final int DEFAULT_SAMPLE_RATE = 44100; // 44.1KHz采样率private static final int DEFAULT_CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_STEREO; // 立体声private static final int DEFAULT_AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT; // 16位宽private static final int DEFAULT_BIT_RATE = 32000; // 比特率private static final String AAC_MIME = \"audio/mp4a-latm\"; // AAC编码 初始化AudioRecord：12345678910111213141516171819202122232425/** * 初始化AudioRecord * * @return */private boolean initAudioRecord() &#123; if (mIsCaptureStarted) &#123; Log.e(TAG, \"Capture already started !\"); return false; &#125; mMinBufferSize = AudioRecord.getMinBufferSize(DEFAULT_SAMPLE_RATE, DEFAULT_CHANNEL_CONFIG, DEFAULT_AUDIO_FORMAT); if (mMinBufferSize == AudioRecord.ERROR_BAD_VALUE) &#123; Log.e(TAG, \"Invalid parameter !\"); return false; &#125; Log.d(TAG, \"getMinBufferSize = \" + mMinBufferSize + \" bytes !\"); mAudioRecord = new AudioRecord(DEFAULT_SOURCE, DEFAULT_SAMPLE_RATE, DEFAULT_CHANNEL_CONFIG, DEFAULT_AUDIO_FORMAT, mMinBufferSize); if (mAudioRecord.getState() == AudioRecord.STATE_UNINITIALIZED) &#123; Log.e(TAG, \"AudioRecord initialize fail !\"); return false; &#125; return true;&#125; 初始化MediaCodec：1234567891011121314151617181920/** * 初始化MediaCodec */private void initMediaCodec() &#123; try &#123; mMediaCodec = MediaCodec.createEncoderByType(AAC_MIME); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; MediaFormat format = new MediaFormat(); format.setString(MediaFormat.KEY_MIME, AAC_MIME); format.setInteger(MediaFormat.KEY_BIT_RATE, DEFAULT_BIT_RATE); format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 2); format.setInteger(MediaFormat.KEY_SAMPLE_RATE, DEFAULT_SAMPLE_RATE); format.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC); format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, mMinBufferSize * 2); mMediaCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mAudioRecord.startRecording(); mMediaCodec.start();&#125; 调用mAudioRecord.startRecording()开始采集，并启动线程从AudioRecord获取数据，最后调用mAudioRecord.stop();停止采集。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private class AudioCaptureRunnable implements Runnable &#123; @Override public void run() &#123; while (!mIsLoopExit) &#123; byte[] buffer = new byte[mMinBufferSize]; int ret = mAudioRecord.read(buffer, 0, mMinBufferSize); if (ret == AudioRecord.ERROR_INVALID_OPERATION) &#123; Log.e(TAG, \"Error ERROR_INVALID_OPERATION\"); &#125; else if (ret == AudioRecord.ERROR_BAD_VALUE) &#123; Log.e(TAG, \"Error ERROR_BAD_VALUE\"); &#125; else &#123; Log.d(TAG, \"OK, Captured \" + ret + \" bytes !\"); Util.save(buffer, 0, buffer.length, pcmPath, true); ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers(); ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers(); int inputBufferIndex = mMediaCodec.dequeueInputBuffer(-1); if (inputBufferIndex &gt;= 0) &#123; ByteBuffer inputBuffer = inputBuffers[inputBufferIndex]; inputBuffer.clear(); inputBuffer.put(buffer); mMediaCodec.queueInputBuffer(inputBufferIndex, 0, buffer.length, System.nanoTime(), 0); &#125; MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); while (outputBufferIndex &gt;= 0) &#123; ByteBuffer outputBuffer = outputBuffers[outputBufferIndex]; outputBuffer.position(bufferInfo.offset); outputBuffer.limit(bufferInfo.offset + bufferInfo.size); byte[] outData = new byte[bufferInfo.size + 7]; addADTStoPacket(outData, bufferInfo.size + 7); outputBuffer.get(outData, 7, bufferInfo.size); outputBuffer.position(bufferInfo.offset); Util.save(outData, 0, outData.length, aacPath, true); mMediaCodec.releaseOutputBuffer(outputBufferIndex, false); outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); &#125; &#125; &#125; &#125;&#125; 核心代码便是这些了，运行程序后最后会生成PCM、AAC文件，将AAC文件用VLC打开也是可以播放的。 工程代码示例 ADTS可以看到上述代码中有addADTStoPacket这个方法：12345678910111213141516171819202122/** * Add ADTS header at the beginning of each and every AAC packet. * This is needed as MediaCodec encoder generates a packet of raw * AAC data. * &lt;p&gt; * Note the packetLen must count in the ADTS header itself. **/private void addADTStoPacket(byte[] packet, int packetLen) &#123; int profile = 2; //AAC LC //39=MediaCodecInfo.CodecProfileLevel.AACObjectELD; int freqIdx = 4; //44.1KHz int chanCfg = 2; //CPE // fill in ADTS data packet[0] = (byte) 0xFF; packet[1] = (byte) 0xF9; packet[2] = (byte) (((profile - 1) &lt;&lt; 6) + (freqIdx &lt;&lt; 2) + (chanCfg &gt;&gt; 2)); packet[3] = (byte) (((chanCfg &amp; 3) &lt;&lt; 6) + (packetLen &gt;&gt; 11)); packet[4] = (byte) ((packetLen &amp; 0x7FF) &gt;&gt; 3); packet[5] = (byte) (((packetLen &amp; 7) &lt;&lt; 5) + 0x1F); packet[6] = (byte) 0xFC;&#125; ADTS头中相对有用的信息 采样率、声道数、帧长度。想想也是，我要是解码器的话，你给我一堆得AAC音频ES流我也解不出来。每一个带ADTS头信息的AAC流会清晰的告送解码器他需要的这些信息。更多信息请参见参考。 参考Android音频开发（1）：基础知识Android音频开发（2）：如何采集一帧音频Android音频开发之AudioRecord录音实现多媒体封装格式详解— AAC ADTS格式分析How to generate the AAC ADTS elementary stream with Android MediaCodec","tags":[{"name":"直播","slug":"直播","permalink":"http://lijia92.github.io/tags/直播/"}]},{"title":"【Android音视频开发】- 实时采集视频并编码","date":"2016-10-20T06:54:45.000Z","path":"2016/10/20/live-code-video/","text":"前言通过我的上一篇文章，实时采集视频的LocalSocket方式在新的Android SDK上是跑不通的，那么便只剩下Camera了。本文将利用Camera来进行实时采集视频，MediaCodec进行硬编码来输出yuv、h264文件。 YUV通过Camera采集到的原始数据是YUV（NV21）格式的，何为YUV？ YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。YUV是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。 YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0。 YUV 4:4:4采样，每一个Y对应一组UV分量。 YUV 4:2:2采样，每两个Y共用一组UV分量。 YUV 4:2:0采样，每四个Y共用一组UV分量。 这里只抛出这样一个概念，详情请参见文末的参考。 H264H264作为当前最火热的编码方式，它有着特殊的分层结构。 H.264 的功能分为两层：视频编码层(VCL, Video Coding Layer)和网络提取层(NAL, Network Abstraction Layer)。VCL 数据即编码处理的输出，它表示被压缩编码后的视频数据 序列。在 VCL 数据传输或存储之前,这些编码的 VCL 数据，先被映射或封装进 NAL 单元中。每个 NAL 单元包括一个原始字节序列负荷(RBSP, Raw Byte Sequence Payload)、一组对应于视频编码的 NAL 头信息。RBSP 的基本结构是：在原始编码数据的后面填加了结尾比特。一个bit“1”若干比特“0”，以便字节对齐。 在H264中，无论是SPS、PPS或者是slice data，都是由一个NAL unit所组成。NALU头结构：NALU类型(5bit)、重要性指示位(2bit)、禁止位(1bit)。 NALU类型：1～12由H.264使用，24～31由H.264以外的应用使用。 重要性指示：标志该NAL单元用于重建时的重要性，值越大，越重要。 禁止位：网络发现NAL单元有比特错误时可设置该比特为1，以便接收方丢掉该单元。 这里依然是抛出这样一个概念，详情请参见文末的参考。（因为我自己也没怎么弄懂，哈哈哈~） 实例下面直接结合Camera与MediaCodec来实现视频采集与编码，并且输出yuv、h264文件。初始化MediaCodec:12345678910111213141516171819202122232425private void initMediaCodec() &#123; int degree = getDegree(); framerate = 15; bitrate = 2 * width * height * framerate / 20; EncoderDebugger debugger = EncoderDebugger.debug(getApplicationContext(), width, height); mConvertor = debugger.getNV21Convertor(); try &#123; mMediaCodec = MediaCodec.createByCodecName(debugger.getEncoderName()); MediaFormat mediaFormat; if (degree == 0) &#123; mediaFormat = MediaFormat.createVideoFormat(\"video/avc\", height, width); &#125; else &#123; mediaFormat = MediaFormat.createVideoFormat(\"video/avc\", width, height); &#125; mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, framerate); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, debugger.getEncoderColorFormat()); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mMediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mMediaCodec.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 获取Camera：12345678910111213141516171819202122232425262728293031private boolean createCamera(SurfaceHolder surfaceHolder) &#123; try &#123; mCamera = Camera.open(mCameraId); Camera.Parameters parameters = mCamera.getParameters(); int[] max = determineMaximumSupportedFrameRate(parameters); Camera.CameraInfo camInfo = new Camera.CameraInfo(); Camera.getCameraInfo(mCameraId, camInfo); int cameraRotationOffset = camInfo.orientation; int rotate = (360 + cameraRotationOffset - getDegree()) % 360; parameters.setRotation(rotate); parameters.setPreviewFormat(ImageFormat.NV21); parameters.setPreviewSize(width, height); parameters.setPreviewFpsRange(max[0], max[1]); mCamera.setParameters(parameters); mCamera.autoFocus(null); int displayRotation; displayRotation = (cameraRotationOffset - getDegree() + 360) % 360; mCamera.setDisplayOrientation(displayRotation); mCamera.setPreviewDisplay(surfaceHolder); return true; &#125; catch (Exception e) &#123; StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); String stack = sw.toString(); Toast.makeText(this, stack, Toast.LENGTH_LONG).show(); destroyCamera(); e.printStackTrace(); return false; &#125;&#125; 采集并编码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Camera.PreviewCallback previewCallback = new Camera.PreviewCallback() &#123; byte[] mPpsSps = new byte[0]; @Override public void onPreviewFrame(byte[] data, Camera camera) &#123; // data即是NV21的数据 if (data == null) &#123; return; &#125; ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers(); ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers(); byte[] dst; Camera.Size previewSize = mCamera.getParameters().getPreviewSize(); if (getDegree() == 0) &#123; dst = Util.rotateNV21Degree90(data, previewSize.width, previewSize.height); &#125; else &#123; dst = data; &#125; Util.save(data, 0, data.length, yuvPath, true); try &#123; int bufferIndex = mMediaCodec.dequeueInputBuffer(5000000); if (bufferIndex &gt;= 0) &#123; inputBuffers[bufferIndex].clear(); mConvertor.convert(dst, inputBuffers[bufferIndex]); mMediaCodec.queueInputBuffer(bufferIndex, 0, inputBuffers[bufferIndex].position(), System.nanoTime() / 1000, 0); MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); while (outputBufferIndex &gt;= 0) &#123; ByteBuffer outputBuffer = outputBuffers[outputBufferIndex]; byte[] outData = new byte[bufferInfo.size]; outputBuffer.get(outData); //记录pps和sps if (outData[0] == 0 &amp;&amp; outData[1] == 0 &amp;&amp; outData[2] == 0 &amp;&amp; outData[3] == 1 &amp;&amp; outData[4] == 103) &#123; mPpsSps = outData; &#125; else if (outData[0] == 0 &amp;&amp; outData[1] == 0 &amp;&amp; outData[2] == 0 &amp;&amp; outData[3] == 1 &amp;&amp; outData[4] == 101) &#123; //在关键帧前面加上pps和sps数据 byte[] frameData = new byte[mPpsSps.length + outData.length]; System.arraycopy(mPpsSps, 0, frameData, 0, mPpsSps.length); System.arraycopy(outData, 0, frameData, mPpsSps.length, outData.length); outData = frameData; &#125; Util.save(outData, 0, outData.length, path, true); mMediaCodec.releaseOutputBuffer(outputBufferIndex, false); outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); &#125; &#125; else &#123; Log.e(\"easypusher\", \"No buffer available !\"); &#125; &#125; catch (Exception e) &#123; StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); String stack = sw.toString(); Log.e(\"save_log\", stack); e.printStackTrace(); &#125; finally &#123; mCamera.addCallbackBuffer(dst); &#125; &#125;&#125;; 获取摄像头支持的分辨率代码：123456789public static void determineClosestSupportedResolution(Camera.Parameters parameters) &#123; String supportedSizesStr = \"Supported resolutions: \"; List&lt;Camera.Size&gt; supportedSizes = parameters.getSupportedPreviewSizes(); for (Iterator&lt;Camera.Size&gt; it = supportedSizes.iterator(); it.hasNext(); ) &#123; Camera.Size size = it.next(); supportedSizesStr += size.width + \"x\" + size.height + (it.hasNext() ? \", \" : \"\"); &#125; Log.e(\"TAG\", supportedSizesStr);&#125; 后面运行，点击开始进行录制，再次点击结束录制，会在sdcard上生成2个文件test_1280x720.yuv、test_1280x720.h264。下载工具后进行查看文件便能看到录制的视频了。YUV工具我是用的雷神改作的一个：修改了一个YUV/RGB播放器。H264工具则是用的VLC。 工程代码示例 Tip：Camera采集默认是横屏，所以竖屏采集输出的图像需要旋转90度，解决方法参见参考即demo中的代码。 参考Camera的简单使用浅析Android Camera原始帧格式转换 —— 获取Camera图像（一）直播必备之YUV使用总结 —— Android常用的几种格式：NV21/NV12/YV12/YUV420P的区别CameraMediaCodecVideo Rendering with 8-Bit YUV FormatsYUV420SP图像的旋转图文详解YUV420数据格式Android 实时视频采集—Cameara预览采集H.264中如何判斷某一段是否為SPS(Sequence Parameter Set)或PPS(Picture Parameter Set)EasyPusher安卓Android手机直播推送之MediaCodec 硬编码H264格式Android屏幕直播方案","tags":[{"name":"直播","slug":"直播","permalink":"http://lijia92.github.io/tags/直播/"}]},{"title":"【Android音视频开发】- 实时采集视频","date":"2016-10-20T02:24:19.000Z","path":"2016/10/20/live-capture-video/","text":"前言通过我的上一篇文章，可以知道直播大致有几个步骤：音视频采集 -&gt; 美颜/滤镜/特效处理 -&gt; 编码 -&gt; 封包 -&gt; 推流 -&gt; 分发 -&gt; 解码/渲染/播放。那么首先便从采集开始，这里我先做的视频采集。那么实时采集视频有哪些方案呢？ 调研通过各种调研，查阅文章，了解到目前Android实时采集视频大致有3种方式： 通过Android Camera拍摄预览中设置setPreviewCallback实现onPreviewFrame接口，实时截取每一帧视频流数据 通过通过Android的MediaRecorder，在SetoutputFile函数中绑定LocalSocket实现 流媒体服务器方式，利用ffmpeg或GetStreamer等获取Camera视频 通过学习，大致了解了1，2两种方式的实现方式，但是对于第3种方式，暂时没有研究。 spydroid当我们在接触一个全新领域的时候，最希望的是能实实在在看到一个demo产品，通过demo产品我们更容易理解其内在的原理。在网上看到了许多的开源项目，最后选择了spydroid，感觉它跟Android结合更紧密。更多的信息可以参考Android视频采集方案总结。 拷贝工程通过github看到的项目是Eclipse结构，这里我把代码拷贝下来后，通过AS打开，配置一些信息后项目结构如下： streaming是作者封装的一套库。 A solution for streaming H.264, H.263, AMR, AAC using RTP on Android 运行项目拷贝到AS后，有部分错误，修复后成功运行在MI 4LTE。它可以通过http，也可以通过rtsp进行推流，打开rtsp推流的开关，首页会多了一个VLC的地址。我在Win 10上使用Chrome接收失败，打开网站后Connect一直连不上。所以采取的VLC方式。打开VLC输入首页提示的地址，即可看到推流成功了。demo跑通后，便有了一个直观的感受，接下来便是看代码了。 代码从SpydroidActivity开始，会看到它连接了一个Service：12345678910111213private ServiceConnection mRtspServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mRtspServer = (CustomRtspServer) ((RtspServer.LocalBinder)service).getService(); mRtspServer.addCallbackListener(mRtspCallbackListener); mRtspServer.start(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123;&#125;&#125;; 看到RtspServer中的start方法：1234567891011public void start() &#123; if (!mEnabled || mRestart) stop(); if (mEnabled &amp;&amp; mListenerThread == null) &#123; try &#123; mListenerThread = new RequestListener(); &#125; catch (Exception e) &#123; mListenerThread = null; &#125; &#125; mRestart = false;&#125; 再看到RequestListener：12345678910111213141516171819202122232425262728293031323334353637383940class RequestListener extends Thread implements Runnable &#123; private final ServerSocket mServer; public RequestListener() throws IOException &#123; try &#123; mServer = new ServerSocket(mPort); start(); &#125; catch (BindException e) &#123; Log.e(TAG,\"Port already in use !\"); postError(e, ERROR_BIND_FAILED); throw e; &#125; &#125; public void run() &#123; Log.i(TAG,\"RTSP server listening on port \"+mServer.getLocalPort()); while (!Thread.interrupted()) &#123; try &#123; new WorkerThread(mServer.accept()).start(); &#125; catch (SocketException e) &#123; break; &#125; catch (IOException e) &#123; Log.e(TAG,e.getMessage()); continue; &#125; &#125; Log.i(TAG,\"RTSP server stopped !\"); &#125; public void kill() &#123; try &#123; mServer.close(); &#125; catch (IOException e) &#123;&#125; try &#123; this.join(); &#125; catch (InterruptedException ignore) &#123;&#125; &#125;&#125; 这是一个进程类，在构造方法中直接调用了Thread.start()，那么便会执行到run()方法。可以看到，初始化了一个ServerSocket，然后当有客户端连接后（通过VLC输入地址开始播放即是连接到这个ServerSocket），便会执行WorkerThread线程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253class WorkerThread extends Thread implements Runnable &#123; private final Socket mClient; private final OutputStream mOutput; private final BufferedReader mInput; // Each client has an associated session private Session mSession; public WorkerThread(final Socket client) throws IOException &#123; mInput = new BufferedReader(new InputStreamReader(client.getInputStream())); mOutput = client.getOutputStream(); mClient = client; mSession = new Session(); &#125; public void run() &#123; Request request; Response response; Log.i(TAG, \"Connection from \"+mClient.getInetAddress().getHostAddress()); while (!Thread.interrupted()) &#123; request = null; response = null; // Parse the request try &#123; request = Request.parseRequest(mInput); &#125; catch (SocketException e) &#123; // Client has left break; &#125; catch (Exception e) &#123; // We don't understand the request :/ response = new Response(); response.status = Response.STATUS_BAD_REQUEST; &#125; // Do something accordingly like starting the streams, sending a session description if (request != null) &#123; try &#123; response = processRequest(request); &#125; catch (Exception e) &#123; // This alerts the main thread that something has gone wrong in this thread postError(e, ERROR_START_FAILED); Log.e(TAG,e.getMessage()!=null?e.getMessage():\"An error occurred\"); e.printStackTrace(); response = new Response(request); &#125; &#125; // We always send a response // The client will receive an \"INTERNAL SERVER ERROR\" if an exception has been thrown at some point try &#123; response.send(mOutput); &#125; catch (IOException e) &#123; Log.e(TAG,\"Response was not sent properly\"); break; &#125; &#125; // Streaming stops when client disconnects boolean streaming = isStreaming(); mSession.syncStop(); if (streaming &amp;&amp; !isStreaming()) &#123; postMessage(MESSAGE_STREAMING_STOPPED); &#125; mSession.release(); try &#123; mClient.close(); &#125; catch (IOException ignore) &#123;&#125; Log.i(TAG, \"Client disconnected\"); &#125; public Response processRequest(Request request) throws IllegalStateException, IOException &#123; Response response = new Response(request); //Ask for authorization unless this is an OPTIONS request if(!isAuthorized(request) &amp;&amp; !request.method.equalsIgnoreCase(\"OPTIONS\")) &#123; response.attributes = \"WWW-Authenticate: Basic realm=\\\"\"+SERVER_NAME+\"\\\"\\r\\n\"; response.status = Response.STATUS_UNAUTHORIZED; &#125; else &#123; /* ********************************************************************************** */ /* ********************************* Method DESCRIBE ******************************** */ /* ********************************************************************************** */ if (request.method.equalsIgnoreCase(\"DESCRIBE\")) &#123; // Parse the requested URI and configure the session mSession = handleRequest(request.uri, mClient); mSessions.put(mSession, null); mSession.syncConfigure(); String requestContent = mSession.getSessionDescription(); String requestAttributes = \"Content-Base: \" + mClient.getLocalAddress().getHostAddress() + \":\" + mClient.getLocalPort() + \"/\\r\\n\" + \"Content-Type: application/sdp\\r\\n\"; response.attributes = requestAttributes; response.content = requestContent; // If no exception has been thrown, we reply with OK response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************* Method OPTIONS ********************************* */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(\"OPTIONS\")) &#123; response.status = Response.STATUS_OK; response.attributes = \"Public: DESCRIBE,SETUP,TEARDOWN,PLAY,PAUSE\\r\\n\"; response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************** Method SETUP ********************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(\"SETUP\")) &#123; Pattern p; Matcher m; int p2, p1, ssrc, trackId, src[]; String destination; p = Pattern.compile(\"trackID=(\\\\w+)\", Pattern.CASE_INSENSITIVE); m = p.matcher(request.uri); if (!m.find()) &#123; response.status = Response.STATUS_BAD_REQUEST; return response; &#125; trackId = Integer.parseInt(m.group(1)); if (!mSession.trackExists(trackId)) &#123; response.status = Response.STATUS_NOT_FOUND; return response; &#125; p = Pattern.compile(\"client_port=(\\\\d+)-(\\\\d+)\", Pattern.CASE_INSENSITIVE); m = p.matcher(request.headers.get(\"transport\")); if (!m.find()) &#123; int[] ports = mSession.getTrack(trackId).getDestinationPorts(); p1 = ports[0]; p2 = ports[1]; &#125; else &#123; p1 = Integer.parseInt(m.group(1)); p2 = Integer.parseInt(m.group(2)); &#125; ssrc = mSession.getTrack(trackId).getSSRC(); src = mSession.getTrack(trackId).getLocalPorts(); destination = mSession.getDestination(); mSession.getTrack(trackId).setDestinationPorts(p1, p2); boolean streaming = isStreaming(); mSession.syncStart(trackId); if (!streaming &amp;&amp; isStreaming()) &#123; postMessage(MESSAGE_STREAMING_STARTED); &#125; response.attributes = \"Transport: RTP/AVP/UDP;\" + (InetAddress.getByName(destination).isMulticastAddress() ? \"multicast\" : \"unicast\") + \";destination=\" + mSession.getDestination() + \";client_port=\" + p1 + \"-\" + p2 + \";server_port=\" + src[0] + \"-\" + src[1] + \";ssrc=\" + Integer.toHexString(ssrc) + \";mode=play\\r\\n\" + \"Session: \" + \"1185d20035702ca\" + \"\\r\\n\" + \"Cache-Control: no-cache\\r\\n\"; response.status = Response.STATUS_OK; // If no exception has been thrown, we reply with OK response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************** Method PLAY *********************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(\"PLAY\")) &#123; String requestAttributes = \"RTP-Info: \"; if (mSession.trackExists(0)) requestAttributes += \"url=rtsp://\" + mClient.getLocalAddress().getHostAddress() + \":\" + mClient.getLocalPort() + \"/trackID=\" + 0 + \";seq=0,\"; if (mSession.trackExists(1)) requestAttributes += \"url=rtsp://\" + mClient.getLocalAddress().getHostAddress() + \":\" + mClient.getLocalPort() + \"/trackID=\" + 1 + \";seq=0,\"; requestAttributes = requestAttributes.substring(0, requestAttributes.length() - 1) + \"\\r\\nSession: 1185d20035702ca\\r\\n\"; response.attributes = requestAttributes; // If no exception has been thrown, we reply with OK response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************** Method PAUSE ********************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(\"PAUSE\")) &#123; response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************* Method TEARDOWN ******************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(\"TEARDOWN\")) &#123; response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************* Unknown method ? ******************************* */ /* ********************************************************************************** */ else &#123; Log.e(TAG, \"Command unknown: \" + request); response.status = Response.STATUS_BAD_REQUEST; &#125; &#125; return response; &#125; /** * Check if the request is authorized * @param request * @return true or false */ private boolean isAuthorized(Request request) &#123; String auth = request.headers.get(\"authorization\"); if(mUsername == null || mPassword == null || mUsername.isEmpty()) return true; if(auth != null &amp;&amp; !auth.isEmpty()) &#123; String received = auth.substring(auth.lastIndexOf(\" \")+1); String local = mUsername+\":\"+mPassword; String localEncoded = Base64.encodeToString(local.getBytes(),Base64.NO_WRAP); if(localEncoded.equals(received)) return true; &#125; return false; &#125;&#125; 这个类比较长，但是我只需关注采集。看到processRequest方法，当有Client连接后，便会有session了，然后打印一些配置之类的信息，最后看到mSession.syncStart(trackId)，可以猜测这个方法便是开始采集、推流了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Starts a stream in a synchronous manner. &lt;br /&gt; * Throws exceptions in addition to calling a callback. * @param id The id of the stream to start **/public void syncStart(int id) throws CameraInUseException, StorageUnavailableException, ConfNotSupportedException, InvalidSurfaceException, UnknownHostException, IOException &#123; Stream stream = id==0 ? mAudioStream : mVideoStream; if (stream!=null &amp;&amp; !stream.isStreaming()) &#123; try &#123; InetAddress destination = InetAddress.getByName(mDestination); stream.setTimeToLive(mTimeToLive); stream.setDestinationAddress(destination); stream.start(); if (getTrack(1-id) == null || getTrack(1-id).isStreaming()) &#123; postSessionStarted(); &#125; if (getTrack(1-id) == null || !getTrack(1-id).isStreaming()) &#123; mHandler.post(mUpdateBitrate); &#125; &#125; catch (UnknownHostException e) &#123; postError(ERROR_UNKNOWN_HOST, id, e); throw e; &#125; catch (CameraInUseException e) &#123; postError(ERROR_CAMERA_ALREADY_IN_USE , id, e); throw e; &#125; catch (StorageUnavailableException e) &#123; postError(ERROR_STORAGE_NOT_READY , id, e); throw e; &#125; catch (ConfNotSupportedException e) &#123; postError(ERROR_CONFIGURATION_NOT_SUPPORTED , id, e); throw e; &#125; catch (InvalidSurfaceException e) &#123; postError(ERROR_INVALID_SURFACE , id, e); throw e; &#125; catch (IOException e) &#123; postError(ERROR_OTHER, id, e); throw e; &#125; catch (RuntimeException e) &#123; postError(ERROR_OTHER, id, e); throw e; &#125; &#125;&#125; 参数id用来标识是音频，还是视频，最后执行到stream.start()，其调用的是最顶层的Stream实现类MediaStream的start方法。123456789101112131415161718/** Starts the stream. */public synchronized void start() throws IllegalStateException, IOException &#123; if (mDestination==null) throw new IllegalStateException(\"No destination ip address set for the stream !\"); if (mRtpPort&lt;=0 || mRtcpPort&lt;=0) throw new IllegalStateException(\"No destination ports set for the stream !\"); mPacketizer.setTimeToLive(mTTL); if (mMode != MODE_MEDIARECORDER_API) &#123; encodeWithMediaCodec(); &#125; else &#123; encodeWithMediaRecorder(); &#125;&#125; 可以看到，根据Mode选择encodeWithMediaCodec或是encodeWithMediaRecorder。然后看到其继承类的实现方法，这里我只关注了VideoStream的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/** * Video encoding is done by a MediaRecorder. */protected void encodeWithMediaRecorder() throws IOException &#123; Log.d(TAG,\"Video encoded using the MediaRecorder API\"); // We need a local socket to forward data output by the camera to the packetizer createSockets(); // Reopens the camera if needed destroyCamera(); createCamera(); // The camera must be unlocked before the MediaRecorder can use it unlockCamera(); try &#123; mMediaRecorder = new MediaRecorder(); mMediaRecorder.setCamera(mCamera); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setVideoEncoder(mVideoEncoder); mMediaRecorder.setPreviewDisplay(mSurfaceView.getHolder().getSurface()); mMediaRecorder.setVideoSize(mRequestedQuality.resX,mRequestedQuality.resY); mMediaRecorder.setVideoFrameRate(mRequestedQuality.framerate); // The bandwidth actually consumed is often above what was requested mMediaRecorder.setVideoEncodingBitRate((int)(mRequestedQuality.bitrate*0.8)); // We write the ouput of the camera in a local socket instead of a file ! // This one little trick makes streaming feasible quiet simply: data from the camera // can then be manipulated at the other end of the socket mMediaRecorder.setOutputFile(mSender.getFileDescriptor()); mMediaRecorder.prepare(); mMediaRecorder.start(); &#125; catch (Exception e) &#123; throw new ConfNotSupportedException(e.getMessage()); &#125; // This will skip the MPEG4 header if this step fails we can't stream anything :( InputStream is = mReceiver.getInputStream(); try &#123; byte buffer[] = new byte[4]; // Skip all atoms preceding mdat atom while (!Thread.interrupted()) &#123; while (is.read() != 'm'); is.read(buffer,0,3); if (buffer[0] == 'd' &amp;&amp; buffer[1] == 'a' &amp;&amp; buffer[2] == 't') break; &#125; &#125; catch (IOException e) &#123; Log.e(TAG,\"Couldn't skip mp4 header :/\"); stop(); throw e; &#125; // The packetizer encapsulates the bit stream in an RTP stream and send it over the network mPacketizer.setDestination(mDestination, mRtpPort, mRtcpPort); mPacketizer.setInputStream(mReceiver.getInputStream()); mPacketizer.start(); mStreaming = true;&#125;/** * Video encoding is done by a MediaCodec. */protected void encodeWithMediaCodec() throws RuntimeException, IOException &#123; if (mMode == MODE_MEDIACODEC_API_2) &#123; // Uses the method MediaCodec.createInputSurface to feed the encoder encodeWithMediaCodecMethod2(); &#125; else &#123; // Uses dequeueInputBuffer to feed the encoder encodeWithMediaCodecMethod1(); &#125;&#125;/** * Video encoding is done by a MediaCodec. */@SuppressLint(\"NewApi\")protected void encodeWithMediaCodecMethod1() throws RuntimeException, IOException &#123; Log.d(TAG,\"Video encoded using the MediaCodec API with a buffer\"); // Updates the parameters of the camera if needed createCamera(); updateCamera(); // Estimates the framerate of the camera measureFramerate(); // Starts the preview if needed if (!mPreviewStarted) &#123; try &#123; mCamera.startPreview(); mPreviewStarted = true; &#125; catch (RuntimeException e) &#123; destroyCamera(); throw e; &#125; &#125; EncoderDebugger debugger = EncoderDebugger.debug(mSettings, mQuality.resX, mQuality.resY); final NV21Convertor convertor = debugger.getNV21Convertor(); mMediaCodec = MediaCodec.createByCodecName(debugger.getEncoderName()); MediaFormat mediaFormat = MediaFormat.createVideoFormat(\"video/avc\", mQuality.resX, mQuality.resY); mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, mQuality.bitrate); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mQuality.framerate); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,debugger.getEncoderColorFormat()); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mMediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mMediaCodec.start(); Camera.PreviewCallback callback = new Camera.PreviewCallback() &#123; long now = System.nanoTime()/1000, oldnow = now, i=0; ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers(); @Override public void onPreviewFrame(byte[] data, Camera camera) &#123; oldnow = now; now = System.nanoTime()/1000; if (i++&gt;3) &#123; i = 0; //Log.d(TAG,\"Measured: \"+1000000L/(now-oldnow)+\" fps.\"); &#125; try &#123; int bufferIndex = mMediaCodec.dequeueInputBuffer(500000); if (bufferIndex&gt;=0) &#123; inputBuffers[bufferIndex].clear(); convertor.convert(data, inputBuffers[bufferIndex]); mMediaCodec.queueInputBuffer(bufferIndex, 0, inputBuffers[bufferIndex].position(), now, 0); &#125; else &#123; Log.e(TAG,\"No buffer available !\"); &#125; &#125; finally &#123; mCamera.addCallbackBuffer(data); &#125; &#125; &#125;; for (int i=0;i&lt;10;i++) mCamera.addCallbackBuffer(new byte[convertor.getBufferSize()]); mCamera.setPreviewCallbackWithBuffer(callback); // The packetizer encapsulates the bit stream in an RTP stream and send it over the network mPacketizer.setDestination(mDestination, mRtpPort, mRtcpPort); mPacketizer.setInputStream(new MediaCodecInputStream(mMediaCodec)); mPacketizer.start(); mStreaming = true;&#125;/** * Video encoding is done by a MediaCodec. * But here we will use the buffer-to-surface methode */@SuppressLint(&#123; \"InlinedApi\", \"NewApi\" &#125;)protected void encodeWithMediaCodecMethod2() throws RuntimeException, IOException &#123; Log.d(TAG,\"Video encoded using the MediaCodec API with a surface\"); // Updates the parameters of the camera if needed createCamera(); updateCamera(); // Estimates the framerate of the camera measureFramerate(); EncoderDebugger debugger = EncoderDebugger.debug(mSettings, mQuality.resX, mQuality.resY); mMediaCodec = MediaCodec.createByCodecName(debugger.getEncoderName()); MediaFormat mediaFormat = MediaFormat.createVideoFormat(\"video/avc\", mQuality.resX, mQuality.resY); mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, mQuality.bitrate); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mQuality.framerate); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mMediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); Surface surface = mMediaCodec.createInputSurface(); ((SurfaceView)mSurfaceView).addMediaCodecSurface(surface); mMediaCodec.start(); // The packetizer encapsulates the bit stream in an RTP stream and send it over the network mPacketizer.setDestination(mDestination, mRtpPort, mRtcpPort); mPacketizer.setInputStream(new MediaCodecInputStream(mMediaCodec)); mPacketizer.start(); mStreaming = true;&#125; 可以看到，整体实现有2个方式： MediaRecorder采集数据，通过绑定LocalSocket来获取数据 利用Camera又分了2种方式：回调onPreviewFrame获取数据进行处理，或者直接输出到Surface 这与之前说到的不谋而合。 问题通过绑定LocalSocket的方式，我在运行（MI 4LTE Android 6.0.1）的时候出现了MediaRecorder: start failed -38的错误。经过Google，后面找到解决方案，setOutputFile时使用ParcelFileDescriptor。作者也在spydroid libstreaming中提到了，并进行了修正。于是我拷贝最新的libstreaming到工程中，运行的依然出错：MediaRecorder: start failed -2147483648，这下我没招了QAQ。后面想到github issues或许也有别人用的时候有这个问题呢，于是我便去看看。但是很不幸，说是在Android 5.0之后不能用MediaRecorder绑定LocalSocket的方式了==&gt;issues#227、issues208、issues#155。毕竟是好几年前的库了，之前Android都没出到5、6呢，后面作者也没有进行维护了，不过我在OPPA A31（Android 4.4.4）的环境下通过此种方式确实可以运行。 参考Android 实时视频采集/编码/传输/解码/播放—方案调研（初）Android 实时视频采集—MediaRecoder录制libstreamingspydroid-ipcameralibstreaming-examples","tags":[{"name":"直播","slug":"直播","permalink":"http://lijia92.github.io/tags/直播/"}]},{"title":"【Android音视频开发】- 直播","date":"2016-10-19T10:05:45.000Z","path":"2016/10/19/live/","text":"前言2015 ~ 1016是直播大火的年代，最近公司也是在着手直播这块，作为Android开发，自然也要懂得一些知识，经过一段时间的调研，学习，作了一下自我总结，写了一个【Android音视频开发】系列，此文便是开篇了！PS：关于这块的文章着实太少，点开10个链接，有7、8个链接的内容是一样的，各种转来转去，也是耗费了很大的功夫才了解到音视频的一点皮毛。而且很多文章都是12年、13年的，拿到现在可能根本就不适用，我通过实例验证，做下此总结。最近一直在看这一块的东西，今天抽空，趁着记忆的知识还比较新鲜记下来，好记性不如烂笔头，也希望能帮助到其他的人。 直播从技术层面上来，直播大致分为：音视频采集、美颜/滤镜/特效处理、编码、封包、推流、分发、解码/渲染/播放。对应到具体的Android层面，便会有如下几个重要环节： 视频实时采集：Camera预览/MediaRecorder绑定LocalSocket 音频实时采集：MediaRecorder/AudioRecord/OpenSL ES 特效处理：视频磨皮美颜，音频降噪去回声等算法 编解码：H264&amp;AAC，MediaCodec(API &gt;= 16)硬解，ffmpeg等三方库软解 流媒体传输：rtmp rtsp hls等 渲染播放：MediaPlayer，ijkplayer等三方库 科普编解码采集到的原始音视频数据是非常大的，不利于传输，所以就需要对这些数据进行压缩，这个过程就是编码。解码则是编码的逆向过程。编码分为硬编码、软编码，解码也是如此。 硬编码：使用非CPU进行编码，如显卡GPU、专用的DSP、FPGA、ASIC芯片等。性能高，低码率下通常质量低于硬编码器，但部分产品在GPU硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。 软编码：使用CPU进行编码。性能高，低码率下通常质量低于硬编码器，但部分产品在GPU硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。 关于音视频压缩编码的基本原理可以参见雷神的这篇文章。 视频编码视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。主要视频编码一览： 名称 推出即构 退出时间 目前使用领域 HEVC(H.265) MPEG/ITU-T 2013 研发中 H.264 MPEG/ITU-T 2003 各个领域 MPEG4 MPEG 2001 不温不火 MPEG2 MPEG 1994 研发中 VP9 Google 2013 研发中 VP8 Google 2008 不普及 VC-1 Microsoft Inc. 2006 微软平台 不难看出，目前主流的视频编码便是H264了，我们项目中选取的也是此编码标准。 音频编码音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。主要音频编码一览： 名称 推出即构 退出时间 目前使用领域 AAC MPEG 1997 各个领域（新） AC-3 Dolby Inc. 1992 电影 MP3 MPEG 1993 各个领域（旧） WMA Microsoft Inc. 1999 微软平台 那么主流的音频编码便是AAC了，项目选取的也是此编码标准。 参考如何搭建一个完整的视频直播系统？android音视频点/直播模块开发视音频编解码技术零基础学习方法移动直播技术秒开优化经验从0到1打造直播 App","tags":[{"name":"直播","slug":"直播","permalink":"http://lijia92.github.io/tags/直播/"}]},{"title":"Android状态栏、虚拟按键小记","date":"2016-09-20T08:05:23.000Z","path":"2016/09/20/system-ui/","text":"之前写过一篇状态栏小记，这里加入虚拟按键重新做一下总结。 前言Android 4.0之后，我们可以通过setSystemUiVisibility(int)方法，结合各种flag来设置系统组件（状态栏、虚拟按键）的显示或隐藏。那么有哪些Flag呢？Android官方文档有以下flag： View.SYSTEM_UI_FLAG_FULLSCREEN View has requested to go into the normal fullscreen mode so that its content can take over the screen while still allowing the user to interact with the application. View.SYSTEM_UI_FLAG_HIDE_NAVIGATION View has requested that the system navigation be temporarily hidden. View.SYSTEM_UI_FLAG_IMMERSIVE View would like to remain interactive when hiding the navigation bar with SYSTEM_UI_FLAG_HIDE_NAVIGATION. View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY View would like to remain interactive when hiding the status bar with SYSTEM_UI_FLAG_FULLSCREEN and/or hiding the navigation bar with SYSTEM_UI_FLAG_HIDE_NAVIGATION. View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN View would like its window to be laid out as if it has requested SYSTEM_UI_FLAG_FULLSCREEN, even if it currently hasn’t. View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION View would like its window to be laid out as if it has requested SYSTEM_UI_FLAG_HIDE_NAVIGATION, even if it currently hasn’t. View.SYSTEM_UI_FLAG_LAYOUT_STABLE When using other layout flags, we would like a stable view of the content insets given to fitSystemWindows(Rect). SYSTEM_UI_FLAG_LIGHT_STATUS_BAR Requests the status bar to draw in a mode that is compatible with light status bar backgrounds. View.SYSTEM_UI_FLAG_LOW_PROFILE View has requested the system UI to enter an unobtrusive “low profile” mode. SYSTEM_UI_FLAG_VISIBLE View has requested the system UI (status bar) to be visible (the default). SYSTEM_UI_LAYOUT_FLAGS Flags that can impact the layout in relation to system UI. 实用代码在做与状态栏、虚拟按键相关的工作时，有些代码亲测比较实用。获取状态栏高度：12345678910111213/** * 获取状态栏高度 * * @return */public int getStatusBarHeight() &#123; int result = 0; int resourceId = getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\"); if (resourceId &gt; 0) &#123; result = getResources().getDimensionPixelSize(resourceId); &#125; return result;&#125; 判断是否有虚拟按键：1234567891011121314151617181920212223242526/** * 是否有虚拟按键 * * @return */public static boolean checkDeviceHasNavigationBar(Context context) &#123; boolean hasNavigationBar = false; Resources rs = context.getResources(); int id = rs.getIdentifier(\"config_showNavigationBar\", \"bool\", \"android\"); if (id &gt; 0) &#123; hasNavigationBar = rs.getBoolean(id); &#125; try &#123; Class systemPropertiesClass = Class.forName(\"android.os.SystemProperties\"); Method m = systemPropertiesClass.getMethod(\"get\", String.class); String navBarOverride = (String) m.invoke(systemPropertiesClass, \"qemu.hw.mainkeys\"); if (\"1\".equals(navBarOverride)) &#123; hasNavigationBar = false; &#125; else if (\"0\".equals(navBarOverride)) &#123; hasNavigationBar = true; &#125; &#125; catch (Exception e) &#123; &#125; return hasNavigationBar;&#125; 获取虚拟按键的高度：12345678910111213/** * 获取虚拟按键的高度 * * @return */public int getNavigationBarHeight() &#123; Resources resources = context.getResources(); int resourceId = resources.getIdentifier(\"navigation_bar_height\", \"dimen\", \"android\"); if (resourceId &gt; 0) &#123; return resources.getDimensionPixelSize(resourceId); &#125; return 0;&#125; 显示状态栏：1234WindowManager.LayoutParams attr = getWindow().getAttributes();attr.flags &amp;= (~WindowManager.LayoutParams.FLAG_FULLSCREEN);getWindow().setAttributes(attr);getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); 隐藏状态栏：1234WindowManager.LayoutParams lp = getWindow().getAttributes(); lp.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN; getWindow().setAttributes(lp); getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); 关于隐藏状态栏以及虚拟按键的显示、隐藏，目前知道的只有通过setSystemUiVisibility方法结合flag来实现。隐藏虚拟按键：1getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION); 下面来做一个示例。 示例前言中11种flag，真正用到的也就几种，下面结合示例来说。新建一个应用，将Activity设置为全屏，并且横屏（模拟直播、播放视频类似的环境）。先贴一下示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity &#123; private boolean isShowing; private TextView hello; private Button dialog; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dialog = (Button) findViewById(R.id.dialog_button); hello = (TextView) findViewById(R.id.hello_world); hello.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (isShowing) &#123; hideOperation(); &#125; else &#123; showOperation(); &#125; &#125; &#125;); dialog.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setMessage(\"Hello World!\"); builder.setTitle(\"Title\"); builder.create().show(); hideOperation(); &#125; &#125;); &#125; private void showOperation() &#123; isShowing = true; WindowManager.LayoutParams attr = getWindow().getAttributes(); attr.flags &amp;= (~WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().setAttributes(attr); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); &#125; private void hideOperation() &#123; isShowing = false; int options = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options |= View.SYSTEM_UI_FLAG_IMMERSIVE; &#125; getWindow().getDecorView().setSystemUiVisibility(options); &#125; @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus);// int options = View.SYSTEM_UI_FLAG_LAYOUT_STABLE// | View.SYSTEM_UI_LAYOUT_FLAGS// | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN// | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION// | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION// | View.SYSTEM_UI_FLAG_FULLSCREEN;// if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;// options |= View.SYSTEM_UI_FLAG_IMMERSIVE;// &#125;// getWindow().getDecorView().setSystemUiVisibility(options); &#125;&#125; 运行效果如下图： 可以看到，在我点击依次”Hello World”之后，button往下移了一点点，同时状态栏也显示了。（初始的时候虚拟按键就已经显示） 再点击一下，进行隐藏操作，状态栏、虚拟按键同时消失。当点击中间的button弹出dialog时，虚拟按键与状态栏会同时出来。然后关掉dialog后要连着点2次，状态栏、虚拟按键才会消失。 针对第一点，是初始的时候，虚拟按键在App布局之外，当执行SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN（根据说明：按全屏模式来表现，尽管当前没有设置全屏模式）之后，App布局占据手机整个显示框，所以会“变高”了些，button会下移。针对第二点，目前也不知道是什么原因导致必须点2次才会执行消失操作。姑且以为是虚拟按键抢占焦点，第一次的点击被它消费了，第二次才是我们App进行消费。另外，当弹出dialog时，我们也可以控制状态栏不显示，将hideOperation改为如下：12345678910111213141516171819private void hideOperation() &#123; isShowing = false; WindowManager.LayoutParams lp = getWindow().getAttributes(); lp.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN; getWindow().setAttributes(lp); getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); int options = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;// | View.SYSTEM_UI_FLAG_FULLSCREEN; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options |= View.SYSTEM_UI_FLAG_IMMERSIVE; &#125; getWindow().getDecorView().setSystemUiVisibility(options);&#125; 如此，当弹出dialog时，状态栏便不会显示了，但是虚拟按键是一定会显示的。可以认为：SYSTEM_UI_FLAG_FULLSCREEN flag的意思就是全屏显示，在此flag下，不会显示状态栏。 至于点击2次才消失的解决方案，便是取消onWindowFocusChanged中的注释，如此，1、2中描述的问题都不会出现了。 通过SYSTEM_UI_FLAG_HIDE_NAVIGATION来隐藏虚拟按键，会导致一个问题：界面有交互时虚拟按键会自动显示。要解决这个问题，便要用到SYSTEM_UI_FLAG_IMMERSIVE了，它的意思是当虚拟按键隐藏时仍然保留交互，可以理解为虚拟按键只是隐藏，但仍然还在，所以发生交互的时候便不会再自动显示了。 总结 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN：按照全屏模式来显示，尽管当前没有设置为全屏模式，设置此flag便会抢占虚拟按键的空间，使应用真正的全屏，虚拟按键若要显示，则只是覆盖在应用的View上了。 SYSTEM_UI_FLAG_FULLSCREEN：全屏显示，此模式下不会显示状态栏。 SYSTEM_UI_FLAG_HIDE_NAVIGATION：隐藏虚拟按键。 SYSTEM_UI_FLAG_IMMERSIVE：当虚拟按键隐藏时，仍然保留交互。解决隐藏后界面发生交互又自动显示的问题。 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION：按照隐藏虚拟按键模式显示，尽管当前没有设置为隐藏虚拟按键模式。针对示例中的第一点，将SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN改为此flag或者SYSTEM_UI_FLAG_HIDE_NAVIGATION都会使App充满显示框，导致button下移。 大致就说这些了，还有一些flag没弄明白，后面继续努力，写得有点乱~ 示例代码","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android Studio发布项目到JCenter","date":"2016-09-12T08:40:48.000Z","path":"2016/09/12/jcenter/","text":"在我的上一篇文章中，尝试将弧形seekbar抽成了一个三方库，这篇文章便以该库为例，将其上传至JCenter。 注册Binatry到Binatry官网注册账号。然后到Your Profile点击Edit，在下面会看到API Key，记录下这个Key备用。 配置gradle我是使用的gradle-bintray-plugin插件来上传项目的，在项目的build.gradle下添加如下配置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108apply plugin: 'com.android.library'apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'//提交到仓库中的版本号version = \"1.0.0\"android &#123; compileSdkVersion 23 buildToolsVersion \"23.0.3\" defaultConfig &#123; minSdkVersion 16 targetSdkVersion 23 versionCode 1 versionName \"1.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.2.1'&#125;def siteUrl = 'https://github.com/LiJia92/CustomArcSeekBar' // 项目的主页def gitUrl = 'https://github.com/LiJia92/CustomArcSeekBar' // Git仓库的urlgroup = \"com.android.lovesixgod.customarcseekbar\" // Maven Group ID for the artifact，一般填你唯一的包名install &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging 'aar' // Add your description here name 'Custom arc seek bar' //项目描述 url siteUrl // Set your license licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; id 'lijia92' //填写的一些基本信息 name 'lastwarmth' email '243244898@qq.com' &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())bintray &#123; user = properties.getProperty(\"bintray.user\") key = properties.getProperty(\"bintray.apikey\") configurations = ['archives'] pkg &#123; repo = \"maven\" name = \"arcseekbar\" //发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [\"Apache-2.0\"] publish = true &#125;&#125;// 解决GBK乱码javadoc &#123; options&#123; encoding \"UTF-8\" charSet 'UTF-8' author true version true links \"http://docs.oracle.com/javase/7/docs/api\" &#125;&#125; 配置name&amp;key在local.propertis里配置binatry的名称与api key：12bintray.user=usernamebintray.apikey=key user即是你注册的名称，key则是第一步中保存的值。 上传首先Sync Gradle File，当build成功后，打开Terminal，执行指令：1gradlew install build成功后在执行指令：1gradlew bintrayUpload 成功后便能在binatry上看到自己上传的项目了。 同步到JCenter点开自己的项目，有一个Add to JCenter，点击后填写描述即可提交申请给binatry了。最后便是等待审核了，审核通过后会收到如下的消息：然后我们进入到项目详情页，会看到Add to JCenter按钮消失了，说明审核已经通过。点到Gradle便能看到gradle依赖的代码：迫不及待的在AS中试了一下，真的可以用了，成就感十足，哈哈。 问题 看Hongyang大神的博客，打算使用bintray-release插件来进行上传的，但是出现了GBK中文编码乱码的问题，除了将代码中的中文全部换成英文之外，没找到其他好的方法，便放弃了这个方法，采用的gradle-bintray-plugin插件可通过配置javadoc的编码来解决这个问题。 包名非常不好看，以后得起个好点的包名。而且不能瞎用“com.android….”，这是google android团队的。 出现如下的错误：12Execution failed for task ':library:bintrayUpload'.&gt; Could not create package 'lijia92/maven/CustomArcSeekBar': HTTP/1.1 404 Not Found [message:Repo 'maven' was not found] 说是maven不存在，于是我在binatry下创建了一个名为maven的仓库，然后重新上传便成功了。（非常坑，找了半天的原因，看的好多博客都没说这个，可能是他们账号下面本身就已经存在maven仓库了）","tags":[{"name":"android studio","slug":"android-studio","permalink":"http://lijia92.github.io/tags/android-studio/"}]},{"title":"Android感悟之造轮子","date":"2016-09-12T03:17:11.000Z","path":"2016/09/12/make-wheel/","text":"最近项目要添加一个点赞的效果，类似这篇文章所说，其实效果是差不多的，便打算直接拿来用了，感谢这位大大制作的轮子~ 而后自己思考了一下，怎么样的轮子别人用起来才方便呢？为了实现方便，其实我们能做的事情有很多，这里说一下自己的感悟。 下面我便拿着我之前写的一个自定义弧形SeekBar来说明，将其抽成一个三方库要做哪些事。 之前的代码结构是这样的：引用的时候是这样的：这显然是非常笨重的引用方式，那么改如何改进呢？ Library第一个最先想到的自然是将代码抽成一个library。然后项目要引用时候，直接gradle添加依赖即可。选择New Module，选择Android Library即可，然后将代码放在src/main/java/包名文件夹下，添加compile project(&#39;:library&#39;)依赖即可。 精简引用方式之前的代码要用，我需要xml中引入三个自定义View，显得很繁杂。站在使用者的角度，若是只用引入一个自定义View，便简单多了。至于球的大小，球的颜色等独立的属性，通过自定义属性来进行设置即可。 下面上一下修改后的代码，ArcSeekBarParent类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class ArcSeekBarParent extends FrameLayout implements SeekBarBallView.OnSmoothScrollListener &#123; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private PointF circleCenter; // 球的坐标 private int top; private int right; private int bottom; private int left; private float currentX; // 当前x坐标，用于控制圆球位置 private final static float LEVEL = 6f; // 设置档次 private int currentLevel = 1; // 当前档次 private OnProgressChangedListener listener; // 档次改变的监听 private Context context; private SeekBarBallView ball; // 球 private SeekBarArcView arc; // 弧 private int ballSize; // 球的大小 private String ballColor; // 球的颜色 private int arcWidth; // 弧的宽度 private String arcColor; // 弧的颜色 public ArcSeekBarParent(Context context) &#123; super(context); init(); &#125; public ArcSeekBarParent(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.ArcSeekBarParent); ballSize = array.getDimensionPixelSize(R.styleable.ArcSeekBarParent_ballSize, 30); arcWidth = array.getDimensionPixelSize(R.styleable.ArcSeekBarParent_arcWidth, 10); ballColor = array.getString(R.styleable.ArcSeekBarParent_ballColor); arcColor = array.getString(R.styleable.ArcSeekBarParent_arcColor); array.recycle(); init(); &#125; private void init() &#123; pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); circleCenter = new PointF(); // 添加弧线View if (arcColor == null) &#123; arcColor = \"#000000\"; // 当没有设置颜色时候，默认使用黑色 &#125; arc = new SeekBarArcView(context, arcColor, arcWidth); arc.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); addView(arc); // 添加球View if (ballColor == null) &#123; ballColor = \"#FFFFFF\"; // 当没有设置颜色时候，默认使用白色 &#125; ball = new SeekBarBallView(context, ballColor, ballSize); ball.setListener(this); addView(ball); &#125; public void setListener(OnProgressChangedListener listener) &#123; this.listener = listener; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); this.left = left; this.top = top; this.right = right; this.bottom = bottom; pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); currentX = (right - left) / LEVEL; changeBallLayout(currentX); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: float downX = event.getX(); float downY = event.getY(); float distance = (downX - circleCenter.x) * (downX - circleCenter.x) + (downY - circleCenter.y) * (downY - circleCenter.y); // 计算到圆球中心的距离，考虑20的误差 return !(distance - (ball.getMeasuredWidth() / 2 + 20) * (ball.getMeasuredWidth() / 2 + 20) &gt; 0); case MotionEvent.ACTION_MOVE: float moveX = event.getX(); currentX = moveX; // 通过x坐标改变圆球的位置 changeBallLayout(currentX); currentLevel = getLevel(moveX); if (listener != null) &#123; listener.OnProgressChanged(currentLevel); &#125; break; default: // 当手指移出或者离开View时，圆球平滑滑到最近的档次 ball.smoothScrollLevel((int) currentX, (int) ((right - left) / LEVEL * currentLevel - currentX)); break; &#125; return super.onTouchEvent(event); &#125; /** * 改变球的位置 * * @param currentX 横坐标 */ private void changeBallLayout(float currentX) &#123; float t = (currentX / (right - left)); float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x; float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y; circleCenter.set(x, y); ball.layout((int) (circleCenter.x - ball.getMeasuredWidth() / 2), (int) (circleCenter.y - ball.getMeasuredWidth() / 2), (int) (circleCenter.x + ball.getMeasuredWidth() / 2), (int) (circleCenter.y + ball.getMeasuredWidth() / 2)); &#125; /** * 计算档次 * * @param x 横坐标 * @return 档次 */ private int getLevel(float x) &#123; float ratio = (x / (right - left)) * LEVEL; // 计算距离哪个档次最近 int result = new BigDecimal(ratio).setScale(0, BigDecimal.ROUND_HALF_UP).intValue(); if (result &lt; 1) &#123; result = 1; &#125; else if (result &gt; (LEVEL - 1)) &#123; result = (int) (LEVEL - 1); &#125; return result; &#125; @Override public void onSmoothScroll(int currentX) &#123; changeBallLayout(currentX); &#125; /** * 滑动接口 */ public interface OnProgressChangedListener &#123; void OnProgressChanged(int level); &#125;&#125; SeekBarArcView类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class SeekBarArcView extends View &#123; private Paint paint; private Path path; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private String arcColor; // 弧的颜色 private int arcWidth; // 弧的宽度 public SeekBarArcView(Context context, String arcColor, int arcWidth) &#123; super(context); this.arcColor = arcColor; this.arcWidth = arcWidth; init(); &#125; private void init() &#123; paint = new Paint(); path = new Path(); pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); // 初始化画笔 paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.parseColor(arcColor)); paint.setStrokeWidth(arcWidth); paint.setStyle(Paint.Style.STROKE); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画2阶贝塞尔曲线 path.moveTo(pointF1.x, pointF1.y); path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y); canvas.drawPath(path, paint); &#125;&#125; SeekBarBallView类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SeekBarBallView extends View &#123; private Paint paint; private Scroller scroller; private int ballSize; private String ballColor; private OnSmoothScrollListener listener; public SeekBarBallView(Context context, String ballColor, int ballSize) &#123; super(context); this.ballColor = ballColor; this.ballSize = ballSize; init(context); &#125; private void init(Context context) &#123; scroller = new Scroller(context); paint = new Paint(); paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.parseColor(ballColor)); paint.setStyle(Paint.Style.FILL); &#125; public void setListener(OnSmoothScrollListener listener) &#123; this.listener = listener; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int spec = MeasureSpec.makeMeasureSpec(ballSize, MeasureSpec.EXACTLY); setMeasuredDimension(spec, spec); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; if (listener != null) &#123; listener.onSmoothScroll(scroller.getCurrX()); postInvalidate(); &#125; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredWidth() / 2, getMeasuredWidth() / 2, paint); &#125; /** * 平滑滑动 * * @param start 起始值 * @param distance 滑动距离 */ public void smoothScrollLevel(int start, int distance) &#123; scroller.startScroll(start, 0, distance, 0, 200); postInvalidate(); &#125; public interface OnSmoothScrollListener &#123; void onSmoothScroll(int currentX); &#125;&#125; 以及自定义属性attr.xml：123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"ArcSeekBarParent\"&gt; &lt;attr name=\"ballColor\" format=\"string\" /&gt; &lt;attr name=\"ballSize\" format=\"dimension\" /&gt; &lt;attr name=\"arcWidth\" format=\"dimension\" /&gt; &lt;attr name=\"arcColor\" format=\"string\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 修改后，在使用的时候只用这样：12345678910&lt;com.android.lovesixgod.library.ArcSeekBarParent android:id=\"@+id/seek_bar\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_marginTop=\"40dp\" android:background=\"@color/colorAccent\" app:arcColor=\"#000000\" app:arcWidth=\"3dp\" app:ballColor=\"#00ffff\" app:ballSize=\"30dp\" /&gt; 相比之前简单了不少。代码中再设置档次改变的监听响应即可直接使用了：1234567ArcSeekBarParent seekBar = (ArcSeekBarParent) findViewById(R.id.seek_bar);seekBar.setListener(new ArcSeekBarParent.OnProgressChangedListener() &#123; @Override public void OnProgressChanged(int level) &#123; textView.setText(String.valueOf(level)); &#125;&#125;); 代码已更新至Github。","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"Android AlarmManager使用小记","date":"2016-08-18T08:20:03.000Z","path":"2016/08/18/alarm/","text":"现在应用大多数都会使用一些三方推送的服务，例如极光、个推等，但是其到达率并不是很高，尤其是Android机型，各大手机厂商定制rom，系统拦截。那么要如何提高消息达到率呢？ Android中提供了AlarmManager可以用来做这个事情。顾名思义，它是一个闹钟管理类，它向系统注册一个事件，时间到了之后，便会触发事件，然后我们便能做一些事情了。 定义接收器首先定义一个BroadcastReceiver，在收到消息后，在onReceive里弹出一个Notification，示例代码如下：12345678910111213141516public class OneShotAlarm extends BroadcastReceiver &#123; private final static int NOTIFICATION_ID = 1001; @Override public void onReceive(Context context, Intent intent) &#123; NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\"title\") .setContentText(\"context\"); NotificationManager mNotifyMgr = (NotificationManager) context.getSystemService(Activity.NOTIFICATION_SERVICE); mNotifyMgr.notify(NOTIFICATION_ID, mBuilder.build()); Toast.makeText(context, \"OneShotAlarm onReceive\", Toast.LENGTH_SHORT).show(); Log.e(\"TAG\", \"OneShotAlarm onReceive\"); &#125;&#125; 记得在AndroidManifest.xml中注册：1234&lt;receiver android:name=\".OneShotAlarm\" android:process=\":remote\" /&gt;&lt;receiver 在此讨论一下process属性，它规定了组件(activity, service, receiver等)所在的进程。通常情况下，没有指定这个属性，一个应用所有的组件都运行在应用的默认进程中，进程的名字和应用的包名一致，比如manifest的package=”com.example.helloalarm”，则默认进程名就是com.example.helloalarm。process属性可以为全部的组件设置一个不同的默认进程，组件可以override这个默认的进程设置，这样你的应用就可以是多进程的。如果你的process属性以一个冒号开头，进程名会在原来的进程名之后附加冒号之后的字符串作为新的进程名。当组件需要时，会自动创建这个进程，这个进程是应用私有的进程。如果process属性以小写字母开头，将会直接以属性中的这个名字作为进程名，这是一个全局进程，这样的进程可以被多个不同应用中的组件共享。 开启闹钟1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MainActivity.this, OneShotAlarm.class); PendingIntent sender = PendingIntent.getBroadcast( MainActivity.this, 0, intent, 0); // We want the alarm to go off 10 seconds from now. Calendar calendar = Calendar.getInstance(); calendar.setTimeInMillis(System.currentTimeMillis()); calendar.add(Calendar.SECOND, 30); AlarmManager am = (AlarmManager) getSystemService(ALARM_SERVICE); am.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), sender); &#125;&#125; 启动Activity之后30秒我们便能看到Toast，以及打出的Log和Notification了。通过这种方式，我们可以定时的发送通知，这样应该能改善推送到达率低的问题。 AlarmManager常用方法有三个： set(int type，long startTime，PendingIntent pi)；该方法用于设置一次性闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟执行时间，第三个参数表示闹钟响应动作。 setRepeating(int type，long startTime，long intervalTime，PendingIntent pi)；该方法用于设置重复闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟首次执行时间，第三个参数表示闹钟两次执行的间隔时间，第三个参数表示闹钟响应动作。 setInexactRepeating（int type，long startTime，long intervalTime，PendingIntent pi）；该方法也用于设置重复闹钟，与第二个方法相似，不过其两个闹钟执行的间隔时间不是固定的而已。 三个方法中都有type、PendingIntent参数，type分为以下几类： AlarmManager.ELAPSED_REALTIME：表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3 AlarmManager.ELAPSED_REALTIME_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2 AlarmManager.RTC：表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1 AlarmManager.RTC_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0 AlarmManager.POWER_OFF_WAKEUP：表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持 PendingIntent为设置接收消息类的参数，一般通过如下代码生成：1PendingIntent sender = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0); 注意第二个参数为requestCode，该参数是闹钟的标识，如果不停设置闹钟，这个参数都一样，那么后设置的闹钟会覆盖之前的闹钟。所以如果需要多个闹钟，则需要将这个参数设为唯一。 若要取消闹钟，则直接调用cancel即可，官方是这样说的： void cancel (PendingIntent operation)Remove any alarms with a matching Intent. Any alarm, of any type, whose Intent matches this one (as defined by filterEquals(Intent)), will be canceled. 只有符合filterEquals的intent才会被取消。12345678910111213public boolean filterEquals(Intent other) &#123; if (other == null) &#123; return false; &#125; if (!Objects.equals(this.mAction, other.mAction)) return false; if (!Objects.equals(this.mData, other.mData)) return false; if (!Objects.equals(this.mType, other.mType)) return false; if (!Objects.equals(this.mPackage, other.mPackage)) return false; if (!Objects.equals(this.mComponent, other.mComponent)) return false; if (!Objects.equals(this.mCategories, other.mCategories)) return false; return true;&#125; 问题对于即时性比较强的应用，比如直播类，闹钟定的时间要与正在直播的推送分开，不然用户就有可能收到2次通知了，所以闹钟就要定提前一点：XXX即将开始直播，类似这样。那么就会有一个问题：用户看到闹钟的这个通知后，进入应用，但是XXX是没有直播的（即将开始直播），所以对于用户当前是没有正确信息来显示的，这种体验可能不太好。如果将闹钟设置退后，XXX已经开始直播，又会显得非常怪异。我的心情：求同学们支招~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android开发事件分发小记","date":"2016-08-05T07:39:32.000Z","path":"2016/08/05/touchevent/","text":"项目开发中，碰到这样一个情形：在点击页面空白处时会弹出状态栏，效果就如我上一篇博客一样。那么何为空白处呢？我的理解是：若是你这个点击事件没有其他View消费，那么便算是点击空白处了。大致画一下页面布局：那么在点击图中画框的其他地方，应该都能算上是空白处了，也就是在点击这些地方的时候，需要执行状态栏弹出的操作。 大致说一下页面布局的层次结构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.miamusic.android.live.ui.RoomActivity\"&gt; &lt;!-- 最底层的摄像画面 --&gt; &lt;SurfaceView android:id=\"@+id/surfaceview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;HorizontalFrameLayout android:id=\"@+id/parent_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!-- 弹幕 --&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/barrage_layout\" android:layout_width=\"match_parent\" android:layout_height=\"140dp\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"40dp\" /&gt; &lt;RelativeLayout android:id=\"@+id/bottom_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\"&gt; &lt;!-- 底部操作栏 --&gt; &lt;/RelativeLayout&gt; &lt;/HorizontalFrameLayout&gt; &lt;RelativeLayout android:id=\"@+id/top_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--顶部主播信息与删除的布局--&gt; &lt;/RelativeLayout&gt;&lt;/FrameLayout&gt; 下面便来逐渐分析事件的分发。 清屏操作与RecyclerView的滑动冲突需求中有向右滑动清屏的操作，向左滑动的时候恢复。我给整个布局parent_layout设置了OnTouchListener，图中弹幕是使用的RecyclerView，RecyclerView本身就会处理滑动，那么就只能滑动RecyclerView之外的地方才能进行清屏。但是这样的体验不好，因为清屏必须要滑动空白地方，因为弹幕的原因可能导致空白地方很小。如何处理好与RecyclerView的滑动冲突呢？项目中，弹幕只具有上下滑动的功能，是不具备左右滑动的，所以事件分发给RecyclerView实际上是没有任何作用的，那么便可以在左右滑动的时候拦截掉事件，从而不分发给RecyclerView，拦截掉之后，若便会执行parent_layout自身的OnTouchListener中的onTouch事件，在这个事件中做清屏的功能。拦截横滑代码：123456789101112131415161718192021@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = ev.getRawX(); downY = ev.getRawY(); break; case MotionEvent.ACTION_MOVE: float moveX = ev.getRawX(); float moveY = ev.getRawY(); /** * 如果是横滑，则拦截，用于清屏 * 如果不是则直接将事件传递 */ if (Math.abs(moveX - downX) &gt; Math.abs(moveY - downY)) &#123; return true; &#125; break; &#125; return super.onInterceptTouchEvent(ev);&#125; 设置的OnTouchListener：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class LiveGestureListener extends GestureDetector.SimpleOnGestureListener implements View.OnTouchListener &#123; Context context; GestureDetector gestureDetector; public LiveGestureListener(Context context) &#123; this(context, null); &#125; public LiveGestureListener(Context context, GestureDetector detector) &#123; if (detector == null) &#123; detector = new GestureDetector(context, this); &#125; this.context = context; this.gestureDetector = detector; &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; if (velocityX &gt;= 0) &#123; hideInteractLayout(); &#125; else if (velocityX &lt; 0) &#123; showInteractLayout(); &#125; return super.onFling(e1, e2, velocityX, velocityY); &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return super.onScroll(e1, e2, distanceX, distanceY); &#125; @Override public boolean onSingleTapConfirmed(MotionEvent e) &#123; return super.onSingleTapConfirmed(e); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; // Within the MyGestureListener class you can now manage the event.getAction() codes. // Note that we are now calling the gesture Detectors onTouchEvent. And given we've set this class as the GestureDetectors listener // the onFling, onSingleTap etc methods will be executed. return gestureDetector.onTouchEvent(event); &#125; public GestureDetector getGestureDetector() &#123; return gestureDetector; &#125;&#125; 结合手势在onFling中做了清屏与恢复的功能。 整个页面的空白处布局层次中可以看到top_layout是单独出来的，并且在FrameLayout的顶层。详细说明一下：1、清屏只清屏parent_layout中的内容，top_layout是不需要隐藏的，所以单独提了出来。2、在顶层是为了提前消费事件，FrameLayout接到事件后会优先分发给顶层的孩子，即top_layout，若top_layout消费了，即点击了关闭或者主播信息等有消费事件的View，那么就不算是点击空白处了，事件便不会分发给parent_layout；若top_layout没消费，即点击了空白处，则会将事件分发给parent_layout，parent_layout便是我们自定义的FrameLayout，重写onTouchEvent，执行弹出状态栏的操作便可实现需求。1234567891011121314151617181920212223242526@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; /** * 若是单纯的点击，并且没有其他View消费事件，则调用onClickEvent（用于显示或隐藏状态栏） */ switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: interceptX = event.getRawX(); interceptY = event.getRawY(); return true; case MotionEvent.ACTION_UP: float moveX = event.getRawX(); float moveY = event.getRawY(); if ((Math.abs(moveX - interceptX) &lt; 20) &amp;&amp; (Math.abs(moveY - interceptY) &lt; 20)) &#123; if (listener != null) &#123; listener.onClickEvent(event); &#125; &#125; break; &#125; return super.onTouchEvent(event);&#125;public interface DealClickEventListener &#123; void onClickEvent(MotionEvent event);&#125; 我们必须在ACTION_DOWN的时候返回true，才会继续收到ACTION_MOVE、ACTION_UP等事件，否则是收不到的。至于为什么，可以参考我之前的一篇博客Android事件分发机制学习小记。我们再ACTION_UP的时候执行我们弹出状态栏的操作即可。1234567891011holder.interactLayout.setListener(new HorizontalFrameLayout.DealClickEventListener() &#123; @Override public void onClickEvent(MotionEvent event) &#123; if (!isShowing) &#123; showOperation(); &#125; else &#123; handler.removeCallbacks(showOrHide); handler.postDelayed(showOrHide, 5000); &#125; &#125;&#125;); 最后上一下HorizontalFrameLayout的完整代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class HorizontalFrameLayout extends FrameLayout &#123; private float downX; private float downY; private float interceptX; private float interceptY; private DealClickEventListener listener; public HorizontalFrameLayout(Context context) &#123; super(context); &#125; public HorizontalFrameLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public HorizontalFrameLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setListener(DealClickEventListener listener) &#123; this.listener = listener; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = ev.getRawX(); downY = ev.getRawY(); break; case MotionEvent.ACTION_MOVE: float moveX = ev.getRawX(); float moveY = ev.getRawY(); /** * 如果是横滑，则拦截，用于清屏 * 如果不是则直接将事件传递 */ if (Math.abs(moveX - downX) &gt; Math.abs(moveY - downY)) &#123; return true; &#125; break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; /** * 若是单纯的点击，并且没有其他View消费事件，则调用onClickEvent（用于显示或隐藏状态栏） */ switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: interceptX = event.getRawX(); interceptY = event.getRawY(); return true; case MotionEvent.ACTION_UP: float moveX = event.getRawX(); float moveY = event.getRawY(); if ((Math.abs(moveX - interceptX) &lt; 20) &amp;&amp; (Math.abs(moveY - interceptY) &lt; 20)) &#123; if (listener != null) &#123; listener.onClickEvent(event); &#125; &#125; break; &#125; return super.onTouchEvent(event); &#125; public interface DealClickEventListener &#123; void onClickEvent(MotionEvent event); &#125;&#125; 题外话在我的另一篇博客一个关于Android滑动“因缺斯厅”的想法中说到一个点，顶部布局采用透明的，那么便会引发一个问题：需要透传关注按钮的点击事件，因为透明布局是在顶部，会拦截掉点击事件，需要透传才能执行关注的响应事件。123456789101112131415161718192021222324252627282930313233343536373839public class CustomRecyclerView extends RecyclerView &#123; private View view; public CustomRecyclerView(Context context) &#123; super(context); &#125; public CustomRecyclerView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public void setView(View view) &#123; this.view = view; &#125; @Override public boolean onTouchEvent(MotionEvent e) &#123; if (view != null) &#123; final float downX = e.getX(); final float downY = e.getY(); int firstVisiblePosition = ((LinearLayoutManager) getLayoutManager()).findFirstVisibleItemPosition(); if (firstVisiblePosition &gt; 0) &#123; return super.onTouchEvent(e); &#125; else &#123; View c = getLayoutManager().findViewByPosition(0); int top = c.getTop(); float scrollY = -top; if (downX &gt;= view.getLeft() &amp;&amp; downX &lt;= view.getRight() &amp;&amp; downY &lt;= view.getBottom() &amp;&amp; downY &gt;= view.getTop() &amp;&amp; scrollY &lt; view.getHeight()) &#123; return false; &#125; else &#123; return super.onTouchEvent(e); &#125; &#125; &#125; return super.onTouchEvent(e); &#125;&#125; 通过调用setView设置需要透传的View，通过判断点击的位置是否在View的范围内，以及RecyclerView滑动的高度是否已经高过关注按钮的高度，通过返回false，便可以将事件透传下去了。","tags":[{"name":"事件分发","slug":"事件分发","permalink":"http://lijia92.github.io/tags/事件分发/"}]},{"title":"Android状态栏小记","date":"2016-08-04T06:29:46.000Z","path":"2016/08/04/statusbar/","text":"最近做了一个需求：在全屏看视频的时候，点击空白处，显示状态栏。距离最后一次点击5秒后，自动收起状态栏。最后做出的效果如下图： 状态栏显示与隐藏首先状态栏的显示与隐藏代码如下：1234567891011121314151617181920212223242526272829303132333435363738private void showOperation() &#123; isShowing = true; handler.removeCallbacks(showOrHide); handler.postDelayed(showOrHide, 5000); // 显示状态栏 WindowManager.LayoutParams attr = getWindow().getAttributes(); attr.flags &amp;= (~WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().setAttributes(attr); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); top.setTranslationY(getStatusBarHeight());&#125;/** * 获取状态栏高度 */public int getStatusBarHeight() &#123; int result = 0; int resourceId = getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\"); if (resourceId &gt; 0) &#123; result = getResources().getDimensionPixelSize(resourceId); &#125; return result;&#125;/** * 隐藏状态栏 */private void hideOperation() &#123; isShowing = false; // 隐藏状态栏 WindowManager.LayoutParams lp = getWindow().getAttributes(); lp.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN; getWindow().setAttributes(lp); getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); top.setTranslationY(0);&#125; 使用handler来进行自动收起，在每次有效操作时，刷新时间重新数5秒。123456789private Runnable showOrHide = new Runnable() &#123; @Override public void run() &#123; hideOperation(); &#125;&#125;;handler.removeCallbacks(showOrHide);handler.postDelayed(showOrHide, 5000); 全屏透明状态栏首先在Application的Theme里，我进行的如下配置：123456789&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/live_gray_bg&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 整个App所有界面都是FullScreen的，colorPrimaryDark是状态栏的颜色，我这里设置的是#4d000000，一个带透明度的黑色,该属性只在android5.0及以上有效。然后在activity的onCreate里，在setContentView()之前，调用如下代码：12345if (Build.VERSION.SDK_INT &gt; 16) &#123; getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);&#125; 针对View的各种FLAG这里列一下说明： View.SYSTEM_UI_FLAG_VISIBLE：显示状态栏，Activity不全屏显示(恢复到有状态的正常情况)； View.INVISIBLE：隐藏状态栏，同时Activity会伸展全屏显示； View.SYSTEM_UI_FLAG_FULLSCREEN：Activity全屏显示，且状态栏被隐藏覆盖掉； View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN：Activity全屏显示，但状态栏不会被隐藏覆盖，状态栏依然可见，Activity顶端布局部分会被状态遮住； View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION：效果同View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN； View.SYSTEM_UI_LAYOUT_FLAGS：效果同View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN； View.SYSTEM_UI_FLAG_HIDE_NAVIGATION：隐藏虚拟按键(导航栏)。有些手机会用虚拟按键来代替物理按键； View.SYSTEM_UI_FLAG_LOW_PROFILE：状态栏显示处于低能显示状态(low profile模式)，状态栏上一些图标显示会被隐藏。 状态栏显示时布局调整通过上面的代码，这样整个状态栏就是按照我设置的颜色来显示了，他会直接覆盖在我们的布局上。那么问题来了，当状态栏显示的时候，他会盖在我们的布局上，那么如果布局顶部有View，那么就会被遮盖住，要如何解决呢？网上查了很多，说是在activity的根布局设置属性android:fitsSystemWindows=&quot;true&quot;，确实，设置后就不会遮盖在布局了，但是它会单独占据空间，设置的半透明的黑色背景也无作用了，另外界面会被压缩，然后屏幕会跳一下。发个图感受一下：可以看到界面会跳，而且视频这种具有一定长宽比的可能会自适应，导致黑边，所以这不是一个解决方案，所以我没有添加这个属性。那么到底要怎么解决呢？其实是一个很笨的方法，上面的代码已经写到了：在状态栏显示的时候，直接将被挡住的View下移。即上面代码中的：12top.setTranslationY(getStatusBarHeight());top.setTranslationY(0); 在这里也可以添加动画，使效果更柔和一点。 疑问在android4.4上达不到半透明这样的效果，设置的colorPrimaryDark是不起作用的，他会是一整个黑条（黑色和rom有关吧），看起来效果就会差一些了，不知道该要怎么解决，望了解的朋友可以指导一下~Tip：找到很多修改颜色的文章，但是都是用到了android:fitsSystemWindows=&quot;true&quot;属性，故不是我的解决方案~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"TextView使用小记","date":"2016-07-26T02:46:16.000Z","path":"2016/07/26/textview/","text":"相信TextView是Android最常见的控件了，在日常使用中也有一些“心得”，这里记录一下。 格式化有些时候需要在一个TextView上显示不同字体格式的内容，比如说一段黑色，一段灰色的内容，又或者字体一大一小的内容，要实现这样的效果有2种方式： 使用SpannableString 123SpannableString spanString = new SpannableString(\"Hello world!\");ForegroundColorSpan span = new ForegroundColorSpan(getResources().getColor(R.color.black));spanString.setSpan(span, 0, 5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); 使用Html format 12String text = \"&lt;font color='black'&gt;Hello:&lt;/font&gt;\" + \"world!\";content.setText(Html.fromHtml(text), TextView.BufferType.SPANNABLE); 两种方式都是可以的，但是第2种方式会导致TextView设置maxLines=&quot;3&quot;、ellipsize=&quot;end&quot;的情况下，文本超过3行的时候不显示...提示符了。所以在有...的需求的时候建议还是使用第一种。 字的行间距如果内容过多是会换行的，要设置行间距可以如下设置： android:lineSpacingExtra设置行间距，如”3dp”。 android:lineSpacingMultiplier设置行间距的倍数，如”1.2”。 占位符有些时候一段字符大部分是固定的，只有一两位是变化的，那么可以在strings.xml中进行如下配置：12&lt;string name=\"barrage_reward\"&gt;%1$s打赏了主播的专辑&lt;/string&gt;&lt;string name=\"living_view_count\"&gt;%1$d人观看&lt;/string&gt; 1%代表第一个占位符，$s代表字符占位，$d代表数字占位。然后在设置的时候，用真实的数据替换掉占位符即可。12textView.setText(getResources().getString(R.string.barrage_reward, \"Jay\"));textView.setText(getResources().getString(R.string.living_view_count, 10)); FontMetricsFontMetrics意为字体测量。123456789101112131415161718192021222324public static class FontMetrics &#123; /** * The maximum distance above the baseline for the tallest glyph in * the font at a given text size. */ public float top; /** * The recommended distance above the baseline for singled spaced text. */ public float ascent; /** * The recommended distance below the baseline for singled spaced text. */ public float descent; /** * The maximum distance below the baseline for the lowest glyph in * the font at a given text size. */ public float bottom; /** * The recommended additional space to add between lines of text. */ public float leading; &#125; 这五个属性分别是什么呢？看如下的图便能一目了然了：","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android高斯模糊","date":"2016-07-21T02:49:43.000Z","path":"2016/07/21/blur/","text":"高斯模糊的工具类，摘录下来，免得以后找不着了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254/** * 高斯模糊 * @param context * @param sentBitmap * @param radius 0 &lt; radius &lt;= 25 * @return */@SuppressLint(\"NewApi\")public static Bitmap fastBlur(Context context, Bitmap sentBitmap, int radius) &#123; if (Build.VERSION.SDK_INT &gt; 16) &#123; Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true); final RenderScript rs = RenderScript.create(context); final Allocation input = Allocation.createFromBitmap(rs, sentBitmap, Allocation.MipmapControl.MIPMAP_NONE, Allocation.USAGE_SCRIPT); final Allocation output = Allocation.createTyped(rs, input.getType()); final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); script.setRadius(radius); script.setInput(input); script.forEach(output); output.copyTo(bitmap); return bitmap; &#125; // Stack Blur v1.0 from // http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html // // Java Author: Mario Klingemann &lt;mario at quasimondo.com&gt; // http://incubator.quasimondo.com // created Feburary 29, 2004 // Android port : Yahel Bouaziz &lt;yahel at kayenko.com&gt; // http://www.kayenko.com // ported april 5th, 2012 // This is a compromise between Gaussian Blur and Box blur // It creates much better looking blurs than Box Blur, but is // 7x faster than my Gaussian Blur implementation. // // I called it Stack Blur because this describes best how this // filter works internally: it creates a kind of moving stack // of colors whilst scanning through the image. Thereby it // just has to add one new block of color to the right side // of the stack and remove the leftmost color. The remaining // colors on the topmost layer of the stack are either added on // or reduced by one, depending on if they are on the right or // on the left side of the stack. // // If you are using this algorithm in your code please add // the following line: // // Stack Blur Algorithm by Mario Klingemann &lt;mario@quasimondo.com&gt; Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true); if (radius &lt; 1) &#123; return (null); &#125; int w = bitmap.getWidth(); int h = bitmap.getHeight(); int[] pix = new int[w * h]; bitmap.getPixels(pix, 0, w, 0, 0, w, h); int wm = w - 1; int hm = h - 1; int wh = w * h; int div = radius + radius + 1; int r[] = new int[wh]; int g[] = new int[wh]; int b[] = new int[wh]; int rsum, gsum, bsum, x, y, i, p, yp, yi, yw; int vmin[] = new int[Math.max(w, h)]; int divsum = (div + 1) &gt;&gt; 1; divsum *= divsum; int dv[] = new int[256 * divsum]; for (i = 0; i &lt; 256 * divsum; i++) &#123; dv[i] = (i / divsum); &#125; yw = yi = 0; int[][] stack = new int[div][3]; int stackpointer; int stackstart; int[] sir; int rbs; int r1 = radius + 1; int routsum, goutsum, boutsum; int rinsum, ginsum, binsum; for (y = 0; y &lt; h; y++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; for (i = -radius; i &lt;= radius; i++) &#123; p = pix[yi + Math.min(wm, Math.max(i, 0))]; sir = stack[i + radius]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rbs = r1 - Math.abs(i); rsum += sir[0] * rbs; gsum += sir[1] * rbs; bsum += sir[2] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; &#125; stackpointer = radius; for (x = 0; x &lt; w; x++) &#123; r[yi] = dv[rsum]; g[yi] = dv[gsum]; b[yi] = dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (y == 0) &#123; vmin[x] = Math.min(x + radius + 1, wm); &#125; p = pix[yw + vmin[x]]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[(stackpointer) % div]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi++; &#125; yw += w; &#125; for (x = 0; x &lt; w; x++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; yp = -radius * w; for (i = -radius; i &lt;= radius; i++) &#123; yi = Math.max(0, yp) + x; sir = stack[i + radius]; sir[0] = r[yi]; sir[1] = g[yi]; sir[2] = b[yi]; rbs = r1 - Math.abs(i); rsum += r[yi] * rbs; gsum += g[yi] * rbs; bsum += b[yi] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; if (i &lt; hm) &#123; yp += w; &#125; &#125; yi = x; stackpointer = radius; for (y = 0; y &lt; h; y++) &#123; // Preserve alpha channel: ( 0xff000000 &amp; pix[yi] ) pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (x == 0) &#123; vmin[y] = Math.min(y + r1, hm) * w; &#125; p = x + vmin[y]; sir[0] = r[p]; sir[1] = g[p]; sir[2] = b[p]; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[stackpointer]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi += w; &#125; &#125; bitmap.setPixels(pix, 0, w, 0, 0, w, h); return (bitmap);&#125;","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Andoird开发中适配小记","date":"2016-07-21T01:59:06.000Z","path":"2016/07/21/android-adapter/","text":"Android也做了一段时间了，做的项目也经历过大大小小的测试，这里把一些适配的实际情形写下来，方便日后查阅，后面会持续更新。主要记录一些适配的实际情形，至于使用.9图、dp单位这类适配就不说了。 适配虚拟按键部分手机会有虚拟按键，会占用屏幕的一定空间，当我们的界面布局存在“硬编码”的时候（固定写死多少dp），就可能导致界面显示出问题。可以通过如下方法来判断是否有虚拟按键：1234567891011121314151617181920212223242526/** * 是否有虚拟按键 * * @return */public static boolean checkDeviceHasNavigationBar(Context context) &#123; boolean hasNavigationBar = false; Resources rs = context.getResources(); int id = rs.getIdentifier(\"config_showNavigationBar\", \"bool\", \"android\"); if (id &gt; 0) &#123; hasNavigationBar = rs.getBoolean(id); &#125; try &#123; Class systemPropertiesClass = Class.forName(\"android.os.SystemProperties\"); Method m = systemPropertiesClass.getMethod(\"get\", String.class); String navBarOverride = (String) m.invoke(systemPropertiesClass, \"qemu.hw.mainkeys\"); if (\"1\".equals(navBarOverride)) &#123; hasNavigationBar = false; &#125; else if (\"0\".equals(navBarOverride)) &#123; hasNavigationBar = true; &#125; &#125; catch (Exception e) &#123; &#125; return hasNavigationBar;&#125; 然后通过如下方法获取虚拟按键的高度：12345678910111213/** * 获取虚拟按键的高度 * * @return */public int getNavigationBarHeight() &#123; Resources resources = context.getResources(); int resourceId = resources.getIdentifier(\"navigation_bar_height\", \"dimen\", \"android\"); if (resourceId &gt; 0) &#123; return resources.getDimensionPixelSize(resourceId); &#125; return 0;&#125; 获得到高度之后，便能代码控制之前的“硬编码”了，依情况减去或者加上虚拟按键的高度便可以解决这类问题的适配的。示例如下：1234567// 如果有虚拟按键，则加上虚拟按键的高度if (checkDeviceHasNavigationBar(context)) &#123; int navigationBarHeight = getNavigationBarHeight(); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) holder.root.getLayoutParams(); params.bottomMargin = (int) (context.getResources().getDimension(R.dimen.minus_living_card_height) - navigationBarHeight); holder.root.setLayoutParams(params);&#125; 当然你也可以简单粗暴的隐藏掉虚拟按键。代码如下：12345678View decorView = getWindow().getDecorView();decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar | View.SYSTEM_UI_FLAG_IMMERSIVE); Android4.4横屏弹出的对话框顶部被状态栏遮盖效果就像这样：初步感觉是Android4.4的一个BUG，可以在Dialog创建的时候，添加如下代码来解决问题：123456789/** * 针对Android 4.4在横屏下顶部被状态栏遮挡的问题 * 暂没有4.4以下的手机进行测试 */if (Build.VERSION.SDK_INT == 19) &#123; mWindow.setFlags( WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);&#125; 联想K3 Note中GridView自带分隔线效果就像这样：在GridViewz中添加horizontalSpacing、verticalSpacing2条属性来解决问题：123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;CustomGridView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:horizontalSpacing=\"0dp\" android:listSelector=\"@color/transparent\" android:numColumns=\"3\" android:scrollbars=\"none\" android:verticalSpacing=\"0dp\" /&gt; VideoView切换横竖屏VideoView在切换横竖屏，如果是Activity跳转，那么就会重新加载，导致切换前后不连贯。所以我的做法是：只有一个Activity，点击全屏按钮将其置为横屏状态，每次切换的时候，显示一套布局，隐藏一套布局。配置activity的android:configChanges=&quot;orientation|screenSize&quot;，这样在切换的时候就不会重新布局，然后在onConfigurationChanged中进行相关操作：12345678910111213@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; /** * 适配部分机型在旋转的时候，视频尺寸没有自适应的问题 */ videoView.getHolder().setFixedSize(videoView.getWidth(), videoView.getHeight()); if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; // 横屏时隐藏竖屏布局 &#125; else &#123; // 竖屏时隐藏横屏布局 &#125; super.onConfigurationChanged(newConfig);&#125; 但是在部分机型会导致切换后视屏尺寸没有自适应，如图：利用如上代码videoView.getHolder().setFixedSize(videoView.getWidth(), videoView.getHeight());即可解决问题。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android屏幕横竖屏切换小记","date":"2016-07-01T09:22:25.000Z","path":"2016/07/01/about-screen/","text":"最后做的项目中，有用到横竖屏切换，碰到个小坑，在这里记录一下。 背景：用户在进入直播页面（姑且称之为RoomActivity），进入页面的时候会传入横竖屏的参数，在RoomActivity中拿到参数通过setRequestedOrientation来进行设置横竖屏。 众所周知，android在横竖屏切换的时候，会销毁当前的页面，然后重建，导致的便是activity的生命周期会执行2次，那么写在其中的方法也会执行2次。在onStart()中我写了进入直播间的方法(enterRoom())，在onStop()中写了离开直播间的方法(exitRoom())，那么在切换屏幕的时候，会调用2次enterRoom，1次exitRoom，因为都是网络请求，不能保证后请求的一定后完成，那么就有可能导致2次enterRoom执行完成之后，exitRoom才执行完成，即用户发了2次进入直播间的请求，1次离开直播间的请求，离开的请求是最后完成，导致的最终结果便是用户不在直播间了，但他依然能看到画面，只不过看不到弹幕相关的一些东西了。 这显然是个问题，需要解决。 方案一：起初，我的想法是在切换的时候保存状态，在新建的时候取出状态，根据状态来判断要不要执行第二次方法，这种想法应该是可行的，但是我找不到保存状态的方法。网上查的是onSaveInstanceState()方法可用来保存，但是它只会在activity意外关闭的时候才会调用，何为意外就不得知了，有点不可控，所以我便放弃了这种做法。 方案二：设置activty参数，避免销毁当前页面重建。在设置configChanges参数后，在切换横竖屏时候便不会重建页面了，那么当前页面或得到的业务数据也自然就还在，只是要强调一点：切换横竖屏后，所有的View需要重新进行初始化。在AndroidManifest.xml中给activity设置如下configChanges参数：123456&lt;activity android:name=\".RoomActivity\" android:screenOrientation=\"portrait\" android:keepScreenOn=\"true\" android:configChanges=\"orientation|screenSize\" android:windowSoftInputMode=\"adjustNothing\"/&gt; 然后在activity的onConfigurationChanged中进行view的初始化。1234567@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; setContentView(R.layout.activity_room); initViewHolder(); initBarrageView(); super.onConfigurationChanged(newConfig);&#125; 之所以会重新调用setContentView(R.layout.activity_room);是因为我的RoomActivity有横、竖两套布局，需要重新设置一下（布局名称名字一样，横屏的布局文件写在land文件下即可）。 如此便解决了横竖屏切换导致的问题了，特此小记一下。 补充：Android横屏切换可能有2种：90度和270度。这两种都是横屏。现在做直播产品，需要设置摄像头的角度，所以不仅仅需要知道横竖屏，也需要知道横屏是90度的那种还是270度的那种。如果仅仅依靠重力感应，部分安卓手机会不支持180度转屏，以致于从90度转到270度或者从270度转到90度时，系统认为界面没有发生变化，所以没有合适的机会来设置摄像头的角度。采用DisplayManager.DisplayListener可以达到目的，但是必须是Android 17以上，这就需要依据项目情况来做些取舍了。1234567891011121314151617181920212223242526272829303132333435363738394041private void initDisplayListener() &#123; /** * 部分安卓手机不支持180度转屏，以致于从90度转到270度或者从270度转到90度时，系统认为界面没有发生变化 * Android 17及以上可以通过DisplayManager.DisplayListener来监听手机旋转，以解决这个问题 */ if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; mDisplayListener = new DisplayManager.DisplayListener() &#123; @Override public void onDisplayAdded(int displayId) &#123; &#125; @Override public void onDisplayChanged(int displayId) &#123; changeRotation(); &#125; @Override public void onDisplayRemoved(int displayId) &#123; &#125; &#125;; DisplayManager displayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE); displayManager.registerDisplayListener(mDisplayListener, null); &#125;&#125;private void changeRotation() &#123; switch (getWindowManager().getDefaultDisplay().getRotation()) &#123; case Surface.ROTATION_0: // 0度 break; case Surface.ROTATION_90: // 90度 break; case Surface.ROTATION_180: // 180度 break; case Surface.ROTATION_270: // 270度 break; &#125;&#125; 参考： Activity 横竖屏切换 Android 横竖屏切换小结","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"从谷歌官方TODO-MVP看MVP模式","date":"2016-06-27T07:47:01.000Z","path":"2016/06/27/mvp/","text":"前言很早之前就听说过android MVP的模式，也看过许许多多的文章，但是众说纷纭，每个人有每个人的理解，如果光看，可能并不能很深刻的理解。但是作为android界的权威，Google出了一个MVP的官方例子。若是从这个例子来看MVP模式，或许会有不一样的感悟呢？多说无益，下面开始。 代码准备Github上打开googlesamples/android-architecture，打开分支，选择todo-mvp（Basic Model-View-Presenter architecture），然后下载zip，解压后导入到AS中。 代码分析首先贴一张官方的MVP示意图：在分析代码之前，我们先简单的运行一下App，大致有一个感觉，App里有哪些功能。ok，下面进入到代码里，先上一下代码结构图：可以看到分包是根据模块进行的分包，通过gif图大概可以知道分为添加（编辑）、统计、详情、主页List。本文只为了分析mvp的使用，所以我选取最简单的AddEditTask来进行分析。 MM主要是位于data包下面的类，Task是基本的bean，涉及到数据的相关操作由接口TasksDataSource体现。1234567891011121314151617181920212223242526272829303132333435363738public interface TasksDataSource &#123; interface LoadTasksCallback &#123; void onTasksLoaded(List&lt;Task&gt; tasks); void onDataNotAvailable(); &#125; interface GetTaskCallback &#123; void onTaskLoaded(Task task); void onDataNotAvailable(); &#125; void getTasks(@NonNull LoadTasksCallback callback); void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback); void saveTask(@NonNull Task task); void completeTask(@NonNull Task task); void completeTask(@NonNull String taskId); void activateTask(@NonNull Task task); void activateTask(@NonNull String taskId); void clearCompletedTasks(); void refreshTasks(); void deleteAllTasks(); void deleteTask(@NonNull String taskId);&#125; V首先是V的基类：12345public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; 然后看到AddEditTaskContract:12345678910111213141516171819202122public interface AddEditTaskContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void showEmptyTaskError(); void showTasksList(); void setTitle(String title); void setDescription(String description); boolean isActive(); &#125; interface Presenter extends BasePresenter &#123; void saveTask(String title, String description); void populateTask(); &#125;&#125; 这个类将V、P整合在了一起，这样做的好处是可以很方便的看到V、P都有哪些方法，方便后面修改。其中的View则是BaseView的下一层接口，它定义了View相关的一些方法。 PP的基类：12345public interface BasePresenter &#123; void start();&#125; 然后在AddEditTaskContract中我们也可以看到P的具体声明。 MVP综合分析MVP大致的代码便是如此了，下面来看具体的实现。在AddEditTaskActivity的onCreate()方法中，我们重点看到这一句代码：1234new AddEditTaskPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment); 可以知道，这句代码便是创建具体的P了。来看下一下AddEditTaskPresenter的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * Listens to user actions from the UI (&#123;@link AddEditTaskFragment&#125;), retrieves the data and updates * the UI as required. */public class AddEditTaskPresenter implements AddEditTaskContract.Presenter, TasksDataSource.GetTaskCallback &#123; @NonNull private final TasksDataSource mTasksRepository; @NonNull private final AddEditTaskContract.View mAddTaskView; @Nullable private String mTaskId; /** * Creates a presenter for the add/edit view. * * @param taskId ID of the task to edit or null for a new task * @param tasksRepository a repository of data for tasks * @param addTaskView the add/edit view */ public AddEditTaskPresenter(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView) &#123; mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository); mAddTaskView = checkNotNull(addTaskView); mAddTaskView.setPresenter(this); &#125; @Override public void start() &#123; if (!isNewTask()) &#123; populateTask(); &#125; &#125; @Override public void saveTask(String title, String description) &#123; if (isNewTask()) &#123; createTask(title, description); &#125; else &#123; updateTask(title, description); &#125; &#125; @Override public void populateTask() &#123; if (isNewTask()) &#123; throw new RuntimeException(\"populateTask() was called but task is new.\"); &#125; mTasksRepository.getTask(mTaskId, this); &#125; @Override public void onTaskLoaded(Task task) &#123; // The view may not be able to handle UI updates anymore if (mAddTaskView.isActive()) &#123; mAddTaskView.setTitle(task.getTitle()); mAddTaskView.setDescription(task.getDescription()); &#125; &#125; @Override public void onDataNotAvailable() &#123; // The view may not be able to handle UI updates anymore if (mAddTaskView.isActive()) &#123; mAddTaskView.showEmptyTaskError(); &#125; &#125; private boolean isNewTask() &#123; return mTaskId == null; &#125; private void createTask(String title, String description) &#123; Task newTask = new Task(title, description); if (newTask.isEmpty()) &#123; mAddTaskView.showEmptyTaskError(); &#125; else &#123; mTasksRepository.saveTask(newTask); mAddTaskView.showTasksList(); &#125; &#125; private void updateTask(String title, String description) &#123; if (isNewTask()) &#123; throw new RuntimeException(\"updateTask() was called but task is new.\"); &#125; mTasksRepository.saveTask(new Task(title, description, mTaskId)); mAddTaskView.showTasksList(); // After an edit, go back to the list. &#125;&#125; 我们通过其构造函数，传入了一个addEditTaskFragment对象，通过其构造函数的方法，我们可以猜测：AddEditTaskFragment便是具体的V了。并且注意mAddTaskView.setPresenter(this);这句代码，即是在P创建的时候，V、P便实现了绑定。看到AddEditTaskFragment代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class AddEditTaskFragment extends Fragment implements AddEditTaskContract.View &#123; public static final String ARGUMENT_EDIT_TASK_ID = \"EDIT_TASK_ID\"; private AddEditTaskContract.Presenter mPresenter; private TextView mTitle; private TextView mDescription; public static AddEditTaskFragment newInstance() &#123; return new AddEditTaskFragment(); &#125; public AddEditTaskFragment() &#123; // Required empty public constructor &#125; @Override public void onResume() &#123; super.onResume(); mPresenter.start(); &#125; @Override public void setPresenter(@NonNull AddEditTaskContract.Presenter presenter) &#123; mPresenter = checkNotNull(presenter); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); FloatingActionButton fab = (FloatingActionButton) getActivity().findViewById(R.id.fab_edit_task_done); fab.setImageResource(R.drawable.ic_done); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mPresenter.saveTask(mTitle.getText().toString(), mDescription.getText().toString()); &#125; &#125;); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View root = inflater.inflate(R.layout.addtask_frag, container, false); mTitle = (TextView) root.findViewById(R.id.add_task_title); mDescription = (TextView) root.findViewById(R.id.add_task_description); setHasOptionsMenu(true); setRetainInstance(true); return root; &#125; @Override public void showEmptyTaskError() &#123; Snackbar.make(mTitle, getString(R.string.empty_task_message), Snackbar.LENGTH_LONG).show(); &#125; @Override public void showTasksList() &#123; getActivity().setResult(Activity.RESULT_OK); getActivity().finish(); &#125; @Override public void setTitle(String title) &#123; mTitle.setText(title); &#125; @Override public void setDescription(String description) &#123; mDescription.setText(description); &#125; @Override public boolean isActive() &#123; return isAdded(); &#125;&#125; 通过前面的gif图，可以猜测P中必定是有一个保存Task的方法，即saveTask方法，在我们点击悬浮按钮的时候会触发。即我们的操作（业务逻辑相关）会由P来执行。看到P中saveTask的具体实现，他会判断当前是否是一个新任务，若是则调用createTask创建新的Task，若标题与内容都为空，则会回调V的showEmptyTaskError方法来显示相关的UI，若不为空，则执行M的操作：mTasksRepository.saveTask(newTask);保存相应的数据，然后回调V的showTasksList方法来显示相关UI。若不是一个新的Task（编辑），则调用updateTask，执行M操作mTasksRepository.saveTask来操作数据。至此，一个完整的业务操作（新建或编辑一个新的Task）分析完毕。可以看到在V中，我们只调用P的相关的接口，然后实现上层V的接口就可以了。由P来调用M中的方法，来操作数据，然后通过回调来使V展示相应的界面。V与M完全分离，整套业务都由P来执行。最后上一张分析图： MVP的优缺点优点： 解耦。实现了Model和View真正的完全分离，再也不是Activity中一大坨代码了。 清晰。模块职责划分明显，层次清晰。 测试。在使用MVP的项目中Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过模拟一个View对象，这个对象只需要实现了View的接口即可。然后注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。 组件化。在MVP当中，View不依赖Model，这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知，它只需要提供一系列接口提供给上层操作，这样就可以做到高度可复用的View组件。 缺点： 新增很多接口类，额外的代码复杂度及学习成本。 Presenter中除了业务逻辑以外，可能还有大量的与业务无关的数据操作逻辑，会导致Presenter比较臃肿。 测试在代码中，Google已经写好了测试代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class AddEditTaskPresenterTest &#123; @Mock private TasksRepository mTasksRepository; @Mock private AddEditTaskContract.View mAddEditTaskView; /** * &#123;@link ArgumentCaptor&#125; is a powerful Mockito API to capture argument values and use them to * perform further actions or assertions on them. */ @Captor private ArgumentCaptor&lt;TasksDataSource.GetTaskCallback&gt; mGetTaskCallbackCaptor; private AddEditTaskPresenter mAddEditTaskPresenter; @Before public void setupMocksAndView() &#123; // Mockito has a very convenient way to inject mocks by using the @Mock annotation. To // inject the mocks in the test the initMocks method needs to be called. MockitoAnnotations.initMocks(this); // The presenter wont't update the view unless it's active. when(mAddEditTaskView.isActive()).thenReturn(true); &#125; @Test public void saveNewTaskToRepository_showsSuccessMessageUi() &#123; // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(\"1\", mTasksRepository, mAddEditTaskView); // When the presenter is asked to save a task mAddEditTaskPresenter.saveTask(\"New Task Title\", \"Some Task Description\"); // Then a task is saved in the repository and the view updated verify(mTasksRepository).saveTask(any(Task.class)); // saved to the model verify(mAddEditTaskView).showTasksList(); // shown in the UI &#125; @Test public void saveTask_emptyTaskShowsErrorUi() &#123; // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(null, mTasksRepository, mAddEditTaskView); // When the presenter is asked to save an empty task mAddEditTaskPresenter.saveTask(\"\", \"\"); // Then an empty not error is shown in the UI verify(mAddEditTaskView).showEmptyTaskError(); &#125; @Test public void saveExistingTaskToRepository_showsSuccessMessageUi() &#123; // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(\"1\", mTasksRepository, mAddEditTaskView); // When the presenter is asked to save an existing task mAddEditTaskPresenter.saveTask(\"New Task Title\", \"Some Task Description\"); // Then a task is saved in the repository and the view updated verify(mTasksRepository).saveTask(any(Task.class)); // saved to the model verify(mAddEditTaskView).showTasksList(); // shown in the UI &#125; @Test public void populateTask_callsRepoAndUpdatesView() &#123; Task testTask = new Task(\"TITLE\", \"DESCRIPTION\"); // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(testTask.getId(), mTasksRepository, mAddEditTaskView); // When the presenter is asked to populate an existing task mAddEditTaskPresenter.populateTask(); // Then the task repository is queried and the view updated verify(mTasksRepository).getTask(eq(testTask.getId()), mGetTaskCallbackCaptor.capture()); // Simulate callback mGetTaskCallbackCaptor.getValue().onTaskLoaded(testTask); verify(mAddEditTaskView).setTitle(testTask.getTitle()); verify(mAddEditTaskView).setDescription(testTask.getDescription()); &#125;&#125; 来执行一下吧：可以看到测试成功。那么假设我们采用传统的开发模式，代码全在Activity里，要怎么样测试呢？噢，想想就觉得头大了，是吗？ 总结通过此次Google官方例子的学习分析，让我对MVP模式有了更清晰的认识，并且我认为MVP模式的实用性很高。虽然它增加了额外的代码，但是它带来的好处是不言而喻的。在今后的开发中，我想我会尝试着使用它。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://lijia92.github.io/tags/设计模式/"}]},{"title":"Retrofit初识","date":"2016-06-23T07:33:45.000Z","path":"2016/06/23/retrofit/","text":"前言在这个技术日新月累的今天，各种新的轮子层出不穷。网络这块，从HttpClient到android-async-http，再到Volley。当下比较火的网络框架Retrofit也是受到了很多开发者的热爱。虽然项目中并没有使用到Retrofit，但抱着学习的态度，我还是打算接触一下，算是有个了解。说不定后面的开发中会用到呢？ Retrofit概述Retrofit是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是Retrofit来完成的。Retrofit 2.0开始内置OkHttp，前者专注于接口的封装，后者专注于网络请求的高效，二者分工协作。我们的应用程序通过Retrofit请求网络，实际上是使用Retrofit接口层封装请求参数、Header、Url等信息，之后由OkHttp完成后续的请求操作，在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，后者根据用户的需求对结果进行解析的过程。所谓Retrofit，其实就是Retrofitting OkHttp了。 Hello Retrofit废话不多说，直接撸代码。 新建项目，添加依赖：12compile 'com.squareup.retrofit2:retrofit:2.1.0' //Retrofit2所需要的包compile 'com.squareup.retrofit2:converter-scalars:2.1.0' //ConverterFactory的String依赖包 我找了一个天气API，用作示例中的网络请求。1http://weatherapi.market.xiaomi.com/wtr-v2/temp/realtime?cityId=101010100 101010100代表的是北京市，这个接口会返回北京的实时天气。 OK，下面开始写请求的API了。 定义如下接口：1234public interface RequestService &#123; @GET(\"realtime\") Call&lt;String&gt; getString(@Query(\"cityId\") String cityId);&#125; 然后在Activity中添加代码：1234567891011121314151617181920212223button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://weatherapi.market.xiaomi.com/wtr-v2/temp/\") .addConverterFactory(ScalarsConverterFactory.create()) .build(); RequestService requestService = retrofit.create(RequestService.class); Call&lt;String&gt; call = requestService.getString(\"101010100\"); call.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; Log.e(\"TAG\", \"成功：\" + response.body().toString()); &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; Log.e(\"TAG\", \"失败\"); &#125; &#125;); &#125;&#125;); 运行代码，点击按钮。会发现Log中有如下的Log： 可见，网络请求成功。 相关说明 Retrofit支持的协议包括GET/POST/PUT/DELETE/HEAD/PATCH，当然你也可以直接用HTTP来自定义请求,这些协议均以注解的形式进行配置。 使用ScalarsConverterFactory可使返回值转化成String。 Retrofit使用@Query来添加请求参数，示例中发送的请求实际就是http://weatherapi.market.xiaomi.com/wtr-v2/temp/realtime?cityId=101010100，通过@Query添加了cityId参数。 Retrofit还有@path注解，直接与baseUrl整合成一个完整的请求。举个例子，采用相对路径：12path = \"apath\"，baseUrl = \"http://host:port/a/b/\"那么最后发送的请求 url = \"http://host:port/a/b/apath\" 当然，Retrofit还有很多功能以及用法，以及背后它为什么如此受宠的原因，都有待慢慢学习。It’s just the beginning！","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"android PopupWindow在控件上方显示","date":"2016-06-02T08:26:54.000Z","path":"2016/06/02/popupwindow/","text":"项目中有这样一个需求： 用户点击送礼物，会弹出一个礼物选择对话框，然后在选择一个礼物之后，可以选择礼物数量，按照图中的意思，选择数量很自然的想到了用PopupWindow来做了。但是这里有一个问题就是：弹出来的数量选择框是需要在数量显示栏的上方的。 如果是在下方，那很简单，直接popupWindow.showAsDropDown(v);即可。但若是在上方，则需要自己计算坐标了，然后通过showAtLocation()方法来显示。 首先贴一下大致的布局：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;com.miamusic.android.live.ui.widget.CertainScaleImageView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/gift_background\" android:visibility=\"visible\" app:radio=\"0.667\" /&gt; &lt;com.miamusic.android.live.ui.widget.WrapContentViewPager android:id=\"@+id/gift_view_pager\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:id=\"@+id/gift_recharge_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#000000\" android:gravity=\"center\" android:orientation=\"horizontal\" android:paddingBottom=\"24dp\" android:paddingLeft=\"16dp\" android:paddingRight=\"16dp\" android:paddingTop=\"24dp\"&gt; &lt;TextView android:id=\"@+id/gift_remain_coin\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:drawablePadding=\"2dp\" android:drawableRight=\"@drawable/m_coin_small\" android:minWidth=\"24dp\" android:textColor=\"#C4AF94\" android:textSize=\"15sp\" /&gt; &lt;TextView android:id=\"@+id/gift_recharge\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:paddingBottom=\"4dp\" android:paddingLeft=\"8dp\" android:paddingTop=\"4dp\" android:text=\"充值 &gt;\" android:textColor=\"@color/white\" android:textSize=\"14sp\" /&gt; &lt;android.support.v4.widget.Space android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" /&gt; &lt;LinearLayout android:id=\"@+id/choose_gift_count\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/follow_button_background\" android:gravity=\"center\" android:paddingBottom=\"8dp\" android:paddingLeft=\"12dp\" android:paddingRight=\"12dp\" android:paddingTop=\"8dp\" android:visibility=\"visible\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"数量\" android:textColor=\"@color/white\" android:textSize=\"14sp\" /&gt; &lt;TextView android:id=\"@+id/send_gift_count\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"4dp\" android:gravity=\"left\" android:text=\"1\" android:textColor=\"@color/white\" android:textSize=\"14sp\" /&gt; &lt;ImageView android:layout_width=\"16dp\" android:layout_height=\"16dp\" android:src=\"@drawable/btn_up_white\" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/gift_send\" android:layout_width=\"80dp\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_marginLeft=\"16dp\" android:background=\"@drawable/reward_album\" android:gravity=\"center\" android:paddingBottom=\"8dp\" android:paddingTop=\"8dp\" android:text=\"送礼物\" android:textColor=\"@color/black\" android:textSize=\"14sp\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 对应界面的预览如下图： 这里贴一下Android中的坐标体系：根据这个图，再来计算坐标值。 这里我在图中做了一下标注：popupwindow的y坐标应该是1的高度 + 2的高度 - popupwindow的高度。 1的高度即是gift_recharge_layout对应view.getTop()，2的高度即是choose_gift_count对应view.getTop()。 popupwindow的高度，我们通过调用一次measure()方法然后通过getMeasuredHeight()获取。 那么最终popupwindow的y坐标便计算出来了，横坐标的计算比较简单，就不多说了。x、y计算完之后通过showAtLocation进行设置即可。 下面给下示例的片段代码：1234567891011121314151617181920212223242526272829303132popupParent = (LinearLayout) findViewById(R.id.gift_recharge_layout);chooseCount.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; final View convertView = LayoutInflater.from(mContext).inflate(R.layout.choose_count_popup_window, null); ListView listView = (ListView) convertView.findViewById(R.id.count_list); listView.setAdapter(new CountAdapter()); // 弹出PopupWindow final PopupWindow popupWindow = new PopupWindow(convertView, LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT, true); popupWindow.setTouchable(true); popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable( android.R.color.transparent)); // 执行measure操作，以便后面获取高宽 convertView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED); int x = v.getLeft(); // 对应2的高度 int y1 = v.getTop(); // 对应1的高度 int y2 = popupParent.getTop(); // 设置PopupWindow显示的位置， popupWindow.showAsDropDown(v); popupWindow.showAtLocation(v, Gravity.NO_GRAVITY, x + v.getMeasuredWidth() / 2 - convertView.getMeasuredWidth() / 2, (y1 + y2 - 10) - convertView.getMeasuredHeight()); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; popupWindow.dismiss(); sendCount.setText(counts[position]); &#125; &#125;); &#125;&#125;);","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android实现任务队列：一个入口一个出口、一个入口两个出口","date":"2016-05-27T07:11:25.000Z","path":"2016/05/27/task-queue/","text":"前言在我的Android实现简易轻量下载器：单线程任务队列文章中，有提到过任务队列。当时是需要下载，实现一个简单的单线程任务队列即可。最近项目中也需要用到任务队列，并且有2种需求： 动态礼物动画：在用户送完动态礼物之后，会在界面上展现一个动画。界面上一次最多能执行1个动画，动画按顺序执行。即：一个入口一个出口。 静态礼物动画：在用户送完静态礼物之后，会在界面上展现一个动画。界面上一次最多能并列执行2个动画，动画按顺序执行。即：一个入口两个出口。同样都是任务队列，只不过一个是只有一个出口，另一个有两个出口。 动态礼物动画参照着之前那篇文章，很快就写出来了。动态礼物单体类DynamicGiftModel：123456789101112131415161718192021222324252627282930313233343536373839404142public class DynamicGiftModel implements GiftModel &#123; private GifImageView gifImageView; private GifDrawable gifDrawable; private DynamicGiftListener listener; public DynamicGiftModel(GifDrawable gifDrawable, GifImageView gifImageView, DynamicGiftListener listener) &#123; this.gifDrawable = gifDrawable; this.gifImageView = gifImageView; this.listener = listener; &#125; @Override public void startAnimation(final GiftAnimationEndListener nextListener) &#123; if (listener != null) &#123; listener.beforeDynamicAnimation(); &#125; gifImageView.setImageDrawable(gifDrawable); gifDrawable.addAnimationListener(new AnimationListener() &#123; @Override public void onAnimationCompleted(int loopNumber) &#123; if (loopNumber == (gifDrawable.getLoopCount() - 1)) &#123; if (listener != null) &#123; listener.afterDynamicAnimation(); &#125; gifDrawable.recycle(); if (nextListener != null) &#123; nextListener.onGiftAnimationEnd(); &#125; &#125; &#125; &#125;); &#125; public interface DynamicGiftListener &#123; void beforeDynamicAnimation(); void afterDynamicAnimation(); &#125;&#125; 动态礼物队列类DynamicGift:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DynamicGift &#123; private static DynamicGift instance = new DynamicGift(); private DynamicGiftExecutor executor; public static DynamicGift getInstance() &#123; if (instance == null) &#123; instance = new DynamicGift(); &#125; return instance; &#125; private DynamicGift() &#123; executor = new DynamicGiftExecutor(); &#125; /** * 动画队列，顺序执行 */ class DynamicGiftExecutor implements GiftAnimationEndListener &#123; final ArrayDeque&lt;DynamicGiftModel&gt; mTasks = new ArrayDeque&lt;&gt;(); DynamicGiftModel mActive; public void execute(final DynamicGiftModel model) &#123; mTasks.offer(model); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; mActive.startAnimation(this); &#125; &#125; @Override public void onGiftAnimationEnd() &#123; scheduleNext(); &#125; &#125; /** * 往队列中添加动画对象 * * @param gifImageView imageView * @param gifDrawable gif图 * @param listener 监听 */ public void addGifAnimation(GifImageView gifImageView, GifDrawable gifDrawable, DynamicGiftModel.DynamicGiftListener listener) &#123; executor.execute(new DynamicGiftModel(gifDrawable, gifImageView, listener)); &#125;&#125; 说明一下：GifImageView就是用来播放gif的ImageView，GifDrawable就是gif对应的drawable，DynamicGiftListener就是动画执行前后的回调。可以看到，我们通过execute()将一个DynamicGiftModel任务放入到队列中，DynamicGiftModel调用startAnimation()便能开始动画了。DynamicGiftExecutor与那篇博客中的类似。只不过我这里做了一些修改：下载中使用的Runnable，他是同步的，在执行完之后会自动去取一下。但是在这里，动画执行是异步的，我在调用完startAnimation()之后就会立即返回，所以需要一个监听（GiftAnimationEndListener）在动画执行完毕之后才去执行scheduleNext()操作，即取下一个任务。GiftAnimationEndListener代码很简单：123public interface GiftAnimationEndListener &#123; void onGiftAnimationEnd();&#125; 调用如下代码将任务添加到队列便能顺序播放动画了。1DynamicGift.getInstance().addGifAnimation(gifImageView, gifDrawable, listener); 静态礼物动画静态礼物因为有两个出口，之前没思考过，所以花了一些时间。静态礼物单体类DynamicGiftModel:123456789101112131415161718192021222324252627282930public class StaticGiftModel implements GiftModel &#123; private StaticGiftListener listener; private PushGift gift; private boolean over; public StaticGiftModel(PushGift gift, StaticGiftListener listener) &#123; this.gift = gift; this.listener = listener; &#125; public boolean isOver() &#123; return over; &#125; public void setOver(boolean over) &#123; this.over = over; &#125; @Override public void startAnimation(final GiftAnimationEndListener nextListener) &#123; if (listener != null) &#123; listener.startStaticAnimation(this, gift, nextListener); &#125; &#125; public interface StaticGiftListener &#123; void startStaticAnimation(StaticGiftModel giftModel, PushGift gift, GiftAnimationEndListener nextListener); &#125;&#125; 静态礼物队列类StaticGift：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class StaticGift &#123; private static StaticGift instance = new StaticGift(); private StaticGiftExecutor executor; public static StaticGift getInstance() &#123; if (instance == null) &#123; instance = new StaticGift(); &#125; return instance; &#125; private StaticGift() &#123; executor = new StaticGiftExecutor(); &#125; /** * 动画队列，2个出口，顺序执行 */ class StaticGiftExecutor implements GiftAnimationEndListener &#123; final ArrayDeque&lt;StaticGiftModel&gt; mTasks = new ArrayDeque&lt;&gt;(); StaticGiftModel mActive1; StaticGiftModel mActive2; public void execute(final StaticGiftModel model) &#123; mTasks.offer(model); if (mActive1 == null) &#123; mActive1 = mTasks.poll(); if (mActive1 != null) &#123; mActive1.startAnimation(this); &#125; &#125; else if (mActive2 == null) &#123; mActive2 = mTasks.poll(); if (mActive2 != null) &#123; mActive2.startAnimation(this); &#125; &#125; &#125; @Override public void onGiftAnimationEnd() &#123; if (mActive1 != null &amp;&amp; mActive1.isOver()) &#123; mActive1 = mTasks.poll(); if (mActive1 != null) &#123; mActive1.startAnimation(this); &#125; &#125; if (mActive2 != null &amp;&amp; mActive2.isOver()) &#123; mActive2 = mTasks.poll(); if (mActive2 != null) &#123; mActive2.startAnimation(this); &#125; &#125; &#125; &#125; /** * 添加任务 * * @param gift 推送的Gift内容 * @param listener 回调 */ public void addNumAnimation(PushGift gift, StaticGiftModel.StaticGiftListener listener) &#123; executor.execute(new StaticGiftModel(gift, listener)); &#125;&#125; 可以看到，我在StaticGiftExecutor中定义了2个变量mActive1、mActive2，他们即代表两个出口。在execute中先判断mActive1是否为空，是则取出元素给它，让它执行动画。否则判断mActive2是否为空，是则取出元素给它，让它执行动画。因为有两个出口，队列并不知道我的下一个任务要在哪个出口执行，所以具体的播放逻辑不能写在其中，所以我将具体的播放逻辑设计在StaticGiftListener.startStaticAnimation()的中，由调用的用户自行实现，并且在动画结束时，我需要回调队列的接口，来通知队列某某出口的动画执行完毕了。实现片段代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 执行静态礼物动画 * * @param gift * @param nextListener */ @Override public void startStaticAnimation(final StaticGiftModel giftModel, PushGift gift, final GiftAnimationEndListener nextListener) &#123; if (holder.staticLayout1.getVisibility() == View.GONE) &#123; holder.staticLayout1.setVisibility(View.VISIBLE); holder.staticGiftUserNick1.setText(gift.getUserNick()); holder.staticGiftDesc1.setText(gift.getDescription()); showIcon(gift.getUserIcon(), holder.staticGiftUserIcon1); // 获取对应礼物的本地下载路径 String fileName = CommonUtils.MD5(gift.getGiftIcon()); File savePath = new File(GiftManager.getInstance().getDownloadDir(), fileName); String path = \"file://\" + savePath.getAbsolutePath(); ImageLoader.getInstance().displayImage(path, holder.staticGiftIcon1); holder.staticGiftView1.setListener(new StaticGiftView.StaticGiftAnimationListener() &#123; @Override public void onAnimationEnd() &#123; holder.staticLayout1.setVisibility(View.GONE); giftModel.setOver(true); nextListener.onGiftAnimationEnd(); &#125; &#125;); holder.staticGiftView1.setNum(Integer.valueOf(gift.getNum())); &#125; else if (holder.staticLayout2.getVisibility() == View.GONE) &#123; holder.staticLayout2.setVisibility(View.VISIBLE); holder.staticGiftUserNick2.setText(gift.getUserNick()); holder.staticGiftDesc2.setText(gift.getDescription()); showIcon(gift.getUserIcon(), holder.staticGiftUserIcon2); // 获取对应礼物的本地下载路径 String fileName = CommonUtils.MD5(gift.getGiftIcon()); File savePath = new File(GiftManager.getInstance().getDownloadDir(), fileName); String path = \"file://\" + savePath.getAbsolutePath(); ImageLoader.getInstance().displayImage(path, holder.staticGiftIcon2); holder.staticGiftView2.setListener(new StaticGiftView.StaticGiftAnimationListener() &#123; @Override public void onAnimationEnd() &#123; holder.staticLayout2.setVisibility(View.GONE); giftModel.setOver(true); nextListener.onGiftAnimationEnd(); &#125; &#125;); holder.staticGiftView2.setNum(Integer.valueOf(gift.getNum())); &#125; &#125; 静态礼物动画实现类StaticGiftView：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StaticGiftView extends TextView &#123; private int current = 1; private int num; private StaticGiftAnimationListener listener; private Animation scaleAnimation = AnimationUtils.loadAnimation(getContext(), R.anim.gift_scale); public StaticGiftView(Context context) &#123; super(context); &#125; public StaticGiftView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public StaticGiftView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setListener(StaticGiftAnimationListener listener) &#123; this.listener = listener; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125; public void setNum(int num) &#123; this.num = num; startAnimation(scaleAnimation); &#125; @Override protected void onAnimationEnd() &#123; super.onAnimationEnd(); current++; if (current &lt;= num) &#123; setText(\"X \" + current); startAnimation(scaleAnimation); &#125; else &#123; current = 1; if (listener != null) &#123; listener.onAnimationEnd(); &#125; &#125; &#125; public interface StaticGiftAnimationListener &#123; void onAnimationEnd(); &#125;&#125; 静态礼物是通过StaticGiftView的setNum()方法来显示动画的，就是显示一个数量递增，同时伴随着缩放的动画。页面布局中有staticLayout1和staticLayout2，分别代表两个执行动画的布局，通过判断getVisibility()是否为GONE来决定是否将动画分发给这个布局。在动画开始时，将布局设置成VISIBLE，在动画结束后，再将布局设置成GONE。我通过setOver(true)来告知队列某某出口的动画执行完毕，然后队列回调到onGiftAnimationEnd()中，继续取出任务分配给有空的出口。 调用如下代码将任务添加到队列便能顺序播放动画了。1StaticGift.getInstance().addNumAnimation(pushGift, listener); 待优化 代码之间的依赖很重，任务队列直接依赖到了前端的UI组件，需要解耦。 若是增加至三个、四个或是更多个出口，代码就得一直添加mActive了，不利于拓展。","tags":[{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"}]},{"title":"Android接入支付宝移动支付","date":"2016-05-18T07:01:25.000Z","path":"2016/05/18/alipay/","text":"项目组支付宝商户审核通过，要准备接入支付宝移动支付的能力，本文主要讲述一下android接入支付宝移动支付SDK的步骤。 前期准备 支付宝商户网站注册支付宝商户账号。 签约移动支付产品，等到审核通过。 秘钥的生成与上传。注册和签约没什么好说的，由公司相关部门或人员进行操作就好了。这里重点讲一下密钥。 秘钥的生成：下载SDK资源压缩包，解压后，里面会有openssl的文件夹，里面有个openssl.exe，双击运行。输入如下指令生成私钥:1genrsa -out rsa_private_key.pem 1024 java开发者（否则跳过此步骤）需要转换成PKCS8格式，再输入如下指令进行转换：1pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt 可以看到下面的界面：右键点击openssl窗口上边边缘，选择“编辑→标记”，选中要复制的文字，将PKCS8格式私钥复制下来，保存到一个文本中，后面会用到。继续执行指令：1rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 会得到公钥文本。 秘钥的上传：登录支付宝商户账户，进入到我的商家服务。点击查询PID、KEY，输入支付密码，进入到下面的页面：记录下PID。点击RSA加密后面的添加密码，这里我已经添加过，所以显示的查看秘钥。将生成步骤中生成的公钥文本粘贴进编辑框，点击保存，若显示上传成功则代表成功。 接入SDK 将alipaySDK-20160223.jarjar包添加至项目中。 修改AndroidManifest.xml：1234567891011121314151617181920&lt;!-- 权限 --&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;!-- 当用户手机没有安装支付宝App时，会调用H5的页面进行支付，若不进行声明，则直接返回支付失败 --&gt;&lt;activity android:name=\"com.alipay.sdk.app.H5PayActivity\" android:configChanges=\"orientation|keyboardHidden|navigation\" android:exported=\"false\" android:screenOrientation=\"behind\" &gt;&lt;/activity&gt;&lt;activity android:name=\"com.alipay.sdk.auth.AuthActivity\" android:configChanges=\"orientation|keyboardHidden|navigation\" android:exported=\"false\" android:screenOrientation=\"behind\" &gt; &lt;/activity&gt; 至此，SDK接入已完成。 调用支付在支付宝Demo中，已经有了很详细的说明了。我们只需要填入3个字段：PARTNER、SELLER、RSA_PRIVATE。PARTNER就是上面步骤记录的PID，SELLER即是支付宝账号，RSA_PRIVATE就是记录的PKCS8格式私钥。这里贴一下Demo代码吧：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228public class PayDemoActivity extends FragmentActivity &#123; // 商户PID public static final String PARTNER = \"\"; // 商户收款账号 public static final String SELLER = \"\"; // 商户私钥，pkcs8格式 public static final String RSA_PRIVATE = \"\"; // 支付宝公钥 public static final String RSA_PUBLIC = \"\"; private static final int SDK_PAY_FLAG = 1; @SuppressLint(\"HandlerLeak\") private Handler mHandler = new Handler() &#123; @SuppressWarnings(\"unused\") public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SDK_PAY_FLAG: &#123; PayResult payResult = new PayResult((String) msg.obj); /** * 同步返回的结果必须放置到服务端进行验证（验证的规则请看https://doc.open.alipay.com/doc2/ * detail.htm?spm=0.0.0.0.xdvAU6&amp;treeId=59&amp;articleId=103665&amp; * docType=1) 建议商户依赖异步通知 */ String resultInfo = payResult.getResult();// 同步返回需要验证的信息 String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档 if (TextUtils.equals(resultStatus, \"9000\")) &#123; Toast.makeText(PayDemoActivity.this, \"支付成功\", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 判断resultStatus 为非\"9000\"则代表可能支付失败 // \"8000\"代表支付结果因为支付渠道原因或者系统原因还在等待支付结果确认，最终交易是否成功以服务端异步通知为准（小概率状态） if (TextUtils.equals(resultStatus, \"8000\")) &#123; Toast.makeText(PayDemoActivity.this, \"支付结果确认中\", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 其他值就可以判断为支付失败，包括用户主动取消支付，或者系统返回的错误 Toast.makeText(PayDemoActivity.this, \"支付失败\", Toast.LENGTH_SHORT).show(); &#125; &#125; break; &#125; default: break; &#125; &#125; ; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.pay_main); &#125; /** * call alipay sdk pay. 调用SDK支付 */ public void pay(View v) &#123; if (TextUtils.isEmpty(PARTNER) || TextUtils.isEmpty(RSA_PRIVATE) || TextUtils.isEmpty(SELLER)) &#123; new AlertDialog.Builder(this).setTitle(\"警告\").setMessage(\"需要配置PARTNER | RSA_PRIVATE| SELLER\") .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialoginterface, int i) &#123; // finish(); &#125; &#125;).show(); return; &#125; String orderInfo = getOrderInfo(\"测试的商品\", \"该测试商品的详细描述\", \"0.01\"); /** * 特别注意，这里的签名逻辑需要放在服务端，切勿将私钥泄露在代码中！ */ String sign = sign(orderInfo); try &#123; /** * 仅需对sign 做URL编码 */ sign = URLEncoder.encode(sign, \"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; /** * 完整的符合支付宝参数规范的订单信息 */ final String payInfo = orderInfo + \"&amp;sign=\\\"\" + sign + \"\\\"&amp;\" + getSignType(); Runnable payRunnable = new Runnable() &#123; @Override public void run() &#123; // 构造PayTask 对象 PayTask alipay = new PayTask(PayDemoActivity.this); // 调用支付接口，获取支付结果 String result = alipay.pay(payInfo, true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); &#125; &#125;; // 必须异步调用 Thread payThread = new Thread(payRunnable); payThread.start(); &#125; /** * get the sdk version. 获取SDK版本号 */ public void getSDKVersion() &#123; PayTask payTask = new PayTask(this); String version = payTask.getVersion(); Toast.makeText(this, version, Toast.LENGTH_SHORT).show(); &#125; /** * 原生的H5（手机网页版支付切natvie支付） 【对应页面网页支付按钮】 * * @param v */ public void h5Pay(View v) &#123; Intent intent = new Intent(this, H5PayDemoActivity.class); Bundle extras = new Bundle(); /** * url是测试的网站，在app内部打开页面是基于webview打开的，demo中的webview是H5PayDemoActivity， * demo中拦截url进行支付的逻辑是在H5PayDemoActivity中shouldOverrideUrlLoading方法实现， * 商户可以根据自己的需求来实现 */ String url = \"http://m.meituan.com\"; // url可以是一号店或者美团等第三方的购物wap站点，在该网站的支付过程中，支付宝sdk完成拦截支付 extras.putString(\"url\", url); intent.putExtras(extras); startActivity(intent); &#125; /** * create the order info. 创建订单信息 */ private String getOrderInfo(String subject, String body, String price) &#123; // 签约合作者身份ID String orderInfo = \"partner=\" + \"\\\"\" + PARTNER + \"\\\"\"; // 签约卖家支付宝账号 orderInfo += \"&amp;seller_id=\" + \"\\\"\" + SELLER + \"\\\"\"; // 商户网站唯一订单号 orderInfo += \"&amp;out_trade_no=\" + \"\\\"\" + getOutTradeNo() + \"\\\"\"; // 商品名称 orderInfo += \"&amp;subject=\" + \"\\\"\" + subject + \"\\\"\"; // 商品详情 orderInfo += \"&amp;body=\" + \"\\\"\" + body + \"\\\"\"; // 商品金额 orderInfo += \"&amp;total_fee=\" + \"\\\"\" + price + \"\\\"\"; // 服务器异步通知页面路径 orderInfo += \"&amp;notify_url=\" + \"\\\"\" + \"http://notify.msp.hk/notify.htm\" + \"\\\"\"; // 服务接口名称， 固定值 orderInfo += \"&amp;service=\\\"mobile.securitypay.pay\\\"\"; // 支付类型， 固定值 orderInfo += \"&amp;payment_type=\\\"1\\\"\"; // 参数编码， 固定值 orderInfo += \"&amp;_input_charset=\\\"utf-8\\\"\"; // 设置未付款交易的超时时间 // 默认30分钟，一旦超时，该笔交易就会自动被关闭。 // 取值范围：1m～15d。 // m-分钟，h-小时，d-天，1c-当天（无论交易何时创建，都在0点关闭）。 // 该参数数值不接受小数点，如1.5h，可转换为90m。 orderInfo += \"&amp;it_b_pay=\\\"30m\\\"\"; // extern_token为经过快登授权获取到的alipay_open_id,带上此参数用户将使用授权的账户进行支付 // orderInfo += \"&amp;extern_token=\" + \"\\\"\" + extern_token + \"\\\"\"; // 支付宝处理完请求后，当前页面跳转到商户指定页面的路径，可空 orderInfo += \"&amp;return_url=\\\"m.alipay.com\\\"\"; // 调用银行卡支付，需配置此参数，参与签名， 固定值 （需要签约《无线银行卡快捷支付》才能使用） // orderInfo += \"&amp;paymethod=\\\"expressGateway\\\"\"; return orderInfo; &#125; /** * get the out_trade_no for an order. 生成商户订单号，该值在商户端应保持唯一（可自定义格式规范） */ private String getOutTradeNo() &#123; SimpleDateFormat format = new SimpleDateFormat(\"MMddHHmmss\", Locale.getDefault()); Date date = new Date(); String key = format.format(date); Random r = new Random(); key = key + r.nextInt(); key = key.substring(0, 15); return key; &#125; /** * sign the order info. 对订单信息进行签名 * * @param content 待签名订单信息 */ private String sign(String content) &#123; return SignUtils.sign(content, RSA_PRIVATE); &#125; /** * get the sign type we use. 获取签名方式 */ private String getSignType() &#123; return \"sign_type=\\\"RSA\\\"\"; &#125;&#125; 代码中有个注释需要特别注意：特别注意，这里的签名逻辑需要放在服务端，切勿将私钥泄露在代码中！ 至此，整个集成就已经结束了，不得不说，支付宝的官方文档比微信好多了，哈哈~ 补充正式项目中需要将签名逻辑放在服务端，在我与服务端进行联调时，出现了很多问题，这里说几点： 服务端若是使用的是java，则使用PKCS8格式的秘钥，否则使用非PKCS8格式的秘钥。 请求参数可以无序，但是必须保证请求的参数与待签名参数的顺序一致。（非常坑，花了半天时间跟服务端联调才找到这个问题）","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"Android自定义View实现仪表盘效果","date":"2016-05-16T06:41:26.000Z","path":"2016/05/16/dashboard/","text":"本篇博客主要介绍如何实现一个仪表盘动态显示的效果，此效果来源于买卖人这个应用，3个室友有2个做安卓，而且都在买卖人，所以我也跟着实现了一波。效果如下： 实现思路涉及到动画效果，首先将其拆分成变化的部分，和不变的部分。变化的部分有：颜色渐变的进度条、以及数字。不变的部分：指针刻度、灰色圆弧背景。拆分开来后，再来单独实现就非常简单了。 渐变的进度条：通过shader，设置起点和终点的颜色，便能达到颜色渐变的一个效果了。 1mShader = new RadialGradient(0, 0, (1080 - 300) / 2, 0xffde5669, 0xffe79950, Shader.TileMode.MIRROR); 数字：直接调用drawText即可。 指针刻度：先选取最好画的一个刻度，然后通过旋转画布重新绘制，就能画出所有的刻度了。（记得在画完之后要把画布归位） 灰色圆弧背景：设置好参数，调用drawArc即可。 动画效果：通过handler发送消息，改变变量值然后重绘就能实现了。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class DashboardView extends View &#123; private Paint mPaint; private RectF rectF; private Shader mShader; private int targetDegree; // 目标角度 private int currentDegree; // 当前角度 private int currentNum; // 当前数值 private int targetNum; // 目标数值 public DashboardView(Context context) &#123; super(context); init(); &#125; public DashboardView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public DashboardView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint = new Paint(); rectF = new RectF(); // 颜色渐变的shader mShader = new RadialGradient(0, 0, (1080 - 300) / 2, 0xffde5669, 0xffe79950, Shader.TileMode.MIRROR); &#125; /** * 通过Handler发送消息，改变变量，重绘View */ private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; currentDegree += 5; currentNum += currentDegree / 1000f * 259; if (currentDegree &lt; targetDegree) &#123; handler.sendEmptyMessageDelayed(0, 5); &#125; else &#123; currentDegree = targetDegree; currentNum = targetNum; &#125; invalidate(); &#125; &#125;; public void setNum(int num) &#123; targetNum = num; targetDegree = (int) (targetNum / 1000f * 259); handler.sendEmptyMessageDelayed(0, 400); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画大圆弧灰色背景 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.GRAY); mPaint.setStrokeWidth(40); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeCap(Paint.Cap.ROUND); rectF.top = getMeasuredHeight() / 2 - getMeasuredWidth() / 4; rectF.left = getMeasuredWidth() / 4; rectF.right = getWidth() / 4 * 3; rectF.bottom = getMeasuredHeight() / 2 + getMeasuredWidth() / 4; canvas.drawArc(rectF, 140, 260, false, mPaint); // 通过旋转画布画指针刻度 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.GRAY); mPaint.setStrokeWidth(3); canvas.drawLine(getMeasuredWidth() / 2, rectF.top + 40, getMeasuredWidth() / 2, rectF.top + 60, mPaint); for (int i = 0; i &lt; 26; i++) &#123; int degrees = (int) (10 * (i + 1) * Math.pow(-1, i)); canvas.rotate(degrees, getWidth() / 2, getHeight() / 2); canvas.drawLine(getMeasuredWidth() / 2, rectF.top + 40, getMeasuredWidth() / 2, rectF.top + 60, mPaint); &#125; canvas.rotate(130, getWidth() / 2, getHeight() / 2); // 画中间的小圆 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.DKGRAY); canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, 80, mPaint); // 画带颜色的进度条 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setShader(mShader); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(40); mPaint.setStrokeCap(Paint.Cap.ROUND); canvas.drawArc(rectF, 140, currentDegree, false, mPaint); // 画Text mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.parseColor(\"#ffde5669\")); mPaint.setTextSize(70); canvas.drawText(String.valueOf(currentNum), getMeasuredWidth() / 2 - 55, getMeasuredHeight() / 2 + 25, mPaint); &#125;&#125; 画笔相关Style有三种。STROKE：FILL：FILL_AND_STROKE：StrokeCap也有三种。BUTT：SQUARE:ROUND： 最后代码比较简单，在实现带动画的View时，最好先进行拆分，找出变化的部分和不变的部分，然后各自实现，将大问题拆分成若干个小问题，逐个击破。","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"Android自定义属性","date":"2016-05-10T07:42:43.000Z","path":"2016/05/10/custom-attr/","text":"前言项目中对于图片的长宽比有很严格的需求，如果比例不一致，那么在App上显示会影响体验，于是要求长宽比一致。但是比例并不是固定的，有的图需要1:1比例，有的图需要14:9比例，有的图又需要9:16的比例。 起初我的想法是，自定义View在onMeasure里利用比例，将计算后的宽高设置给View就好了。但是这么一想，比例不一致啊。现在需要3种比例，我要自定义3个View，那如果后面有其他的一些比例呢？我不是又得写啦~ 抱着偷懒的态度，我设想用自定义属性来解决这个问题，自己设置比例，这样只用自定义一个View，然后根据传入的比例再行计算即可。 自定义属性添加属性在res/value文件夹下定义一个attr.xml文件，添加如下代码：123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;declare-styleable name=\"CertainScaleImageView\"&gt; &lt;attr name=\"radio\" format=\"float\" /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; radio即是代表比例，这里是高比宽。我是先获取宽，然后根据比例计算高。 设置属性在xml顶层布局中添加xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;，然后利用app:radio设置属性，示例代码如下：1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"8dp\" android:background=\"#ffffff\" android:focusable=\"true\" android:focusableInTouchMode=\"true\"&gt; &lt;com.miamusic.android.live.ui.widget.CertainScaleImageView android:id=\"@+id/anchor_profile_background\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:transitionName=\"cover\" app:radio=\"1.779\" /&gt;... 这里我设置的1.779，即高是宽的1.779倍，显示一个瘦窄的长方形。 获取属性在自定义View中通过如下代码获取radio属性：123456public CertainScaleImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CertainScaleImageView); radio = typedArray.getFloat(R.styleable.CertainScaleImageView_radio, 1f); typedArray.recycle();&#125; radio自定义View的一个属性，通过TypedArray获取相应的值并保存起来，TypedArray用完需要调用recycle()。 计算宽高获取属性之后，我们需要通过这个比例来计算宽高，代码如下：1234567@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = MeasureSpec.getSize(widthMeasureSpec); int widthSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); int heightSpec = MeasureSpec.makeMeasureSpec((int) (width * radio), MeasureSpec.EXACTLY); setMeasuredDimension(widthSpec, heightSpec);&#125; 获得宽度值，然后根据radio计算高度，然后调用setMeasuredDimension即可。 总结通过onMeasure，我们可以自行控制View要显示的区域。在调用setMeasuredDimension时，我们不仅需要计算它确切的高宽，还要给他设置一个MODE。MODE有三类： MeasureSpec.EXACTLY：精确尺寸，当我们将控件的layout_width或layout_height指定为具体数值时如andorid:layout_width=”50dp”，或者为match_parent是，都是控件大小已经确定的情况，都是精确尺寸。 MeasureSpec.AT_MOST：最大尺寸，当控件的layout_width或layout_height指定为wrap_content时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。因此，此时的mode是AT_MOST，size给出了父控件允许的最大尺寸。 MeasureSpec.UNSPECIFIED：未指定尺寸，这种情况不多，一般都是父控件是AdapterView，通过measure方法传入的模式。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android自定义View实现弧形SeekBar（续）","date":"2016-04-28T08:13:36.000Z","path":"2016/04/28/new-seekbar/","text":"问题在我的上一篇文章中，写了自定义弧形SeekBar，效果达到了自己的预期，于是高高兴兴回家了。但是后面手贱，在家里自己随意玩了玩，发现SeekBar滑动几下之后再滑动就会变得特别卡。然后查看代码，短时间内没什么头绪。 没错，这个时候又要祭出我的室友了。室友之前是做rom相关的，对于android系统工具用得很熟。然后他拿着我的手机打开开发者选项中的GPU呈现模式分析，运行了一下程序，滑了一会之后就这样了： 我们可以看到一条绿线，这条绿线代表的是60帧，超过这条线就代表不足60帧，那么人眼看起来就会感觉卡顿，可以看到超出了好多了，难怪会很卡~。 那么问题可以大致定位到绘制View的方法不够科学。 那么怎样才能科学呢？其实我也没答案。但是大致有了一个思路：绘制好弧线和圆球之后，在滑动的时候不再重绘弧线和圆球，仅仅改变圆球的位置，这样就会少了很多的绘制操作。如此实现的话或许便能解决问题了。但也只是假设，下面开始实战。 解决方案我将代码拆分成3个类：继承自FrameLayout的ArcSeekBarParent，SeekBarArcView以及SeekBarBallView。ArcSeekBarParent代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class ArcSeekBarParent extends FrameLayout implements SeekBarBallView.OnSmoothScrollListener &#123; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private PointF circleCenter; // 球的坐标 private int top; private int right; private int bottom; private int left; private float currentX; // 当前x坐标，用于控制圆球位置 private final static float LEVEL = 6f; // 设置档次 private int currentLevel = 1; // 当前档次 private OnProgressChangedListener listener; private SeekBarBallView ball; public ArcSeekBarParent(Context context) &#123; super(context); init(); &#125; public ArcSeekBarParent(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ArcSeekBarParent(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); circleCenter = new PointF(); &#125; public void setListener(OnProgressChangedListener listener) &#123; this.listener = listener; &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); ball = (SeekBarBallView) getChildAt(1); ball.setListener(this); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); this.left = left; this.top = top; this.right = right; this.bottom = bottom; pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); currentX = (right - left) / LEVEL; changeBallLayout(currentX); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: float downX = event.getX(); float downY = event.getY(); float distance = (downX - circleCenter.x) * (downX - circleCenter.x) + (downY - circleCenter.y) * (downY - circleCenter.y); // 计算到圆球中心的距离，考虑20的误差 return !(distance - (ball.getMeasuredWidth() / 2 + 20) * (ball.getMeasuredWidth() / 2 + 20) &gt; 0); case MotionEvent.ACTION_MOVE: float moveX = event.getX(); currentX = moveX; // 通过x坐标改变圆球的位置 changeBallLayout(currentX); currentLevel = getLevel(moveX); if (listener != null) &#123; listener.OnProgressChanged(currentLevel); &#125; break; default: // 当手指移出或者离开View时，圆球平滑滑到最近的档次 ball.smoothScrollLevel((int) currentX, (int) ((right - left) / LEVEL * currentLevel - currentX)); break; &#125; return super.onTouchEvent(event); &#125; /** * 改变球的位置 * * @param currentX 横坐标 */ private void changeBallLayout(float currentX) &#123; float t = (currentX / (right - left)); float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x; float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y; circleCenter.set(x, y); ball.layout((int) (circleCenter.x - ball.getMeasuredWidth() / 2), (int) (circleCenter.y - ball.getMeasuredWidth() / 2), (int) (circleCenter.x + ball.getMeasuredWidth() / 2), (int) (circleCenter.y + ball.getMeasuredWidth() / 2)); &#125; /** * 计算档次 * * @param x 横坐标 * @return 档次 */ private int getLevel(float x) &#123; float ratio = (x / (right - left)) * LEVEL; // 计算距离哪个档次最近 int result = new BigDecimal(ratio).setScale(0, BigDecimal.ROUND_HALF_UP).intValue(); if (result &lt; 1) &#123; result = 1; &#125; else if (result &gt; (LEVEL - 1)) &#123; result = (int) (LEVEL - 1); &#125; return result; &#125; @Override public void onSmoothScroll(int currentX) &#123; changeBallLayout(currentX); &#125; /** * 滑动接口 */ public interface OnProgressChangedListener &#123; void OnProgressChanged(int level); &#125;&#125; SeekBarArcView代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class SeekBarArcView extends View &#123; private Paint paint; private Path path; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 public SeekBarArcView(Context context) &#123; super(context); init(); &#125; public SeekBarArcView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public SeekBarArcView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; paint = new Paint(); path = new Path(); pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画2阶贝塞尔曲线 paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.GRAY); paint.setStrokeWidth(10); paint.setStyle(Paint.Style.STROKE); path.moveTo(pointF1.x, pointF1.y); path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y); canvas.drawPath(path, paint); &#125;&#125; SeekBarBallView代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class SeekBarBallView extends View &#123; private Paint paint; private Scroller scroller; private OnSmoothScrollListener listener; public SeekBarBallView(Context context) &#123; super(context); init(context); &#125; public SeekBarBallView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public SeekBarBallView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; paint = new Paint(); scroller = new Scroller(context); &#125; public void setListener(OnSmoothScrollListener listener) &#123; this.listener = listener; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(widthMeasureSpec, widthMeasureSpec); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; if (listener != null) &#123; listener.onSmoothScroll(scroller.getCurrX()); postInvalidate(); &#125; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); paint.reset(); paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.WHITE); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredWidth() / 2, getMeasuredWidth() / 2, paint); &#125; /** * 平滑滑动 * * @param start 起始值 * @param distance 滑动距离 */ public void smoothScrollLevel(int start, int distance) &#123; scroller.startScroll(start, 0, distance, 0, 200); postInvalidate(); &#125; public interface OnSmoothScrollListener &#123; void onSmoothScroll(int currentX); &#125;&#125; 可以看到代码基本都是差不多的，只不过我将之前的View拆分成一个ViewGroup，绘制弧线的SeekBarArcView和绘制圆球的SeekBarBallView。在ACTION_MOVE的时候，我只是使用ball.layout()方法，即只改变圆球的layout，而没有重绘整个SeekBar。 添加xml引用：12345678910111213141516&lt;com.android.lovesixgod.customarcseekbar.seekbar.ArcSeekBarParent android:id=\"@+id/seek_bar\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_marginTop=\"40dp\" android:background=\"@color/colorAccent\"&gt; &lt;com.android.lovesixgod.customarcseekbar.seekbar.SeekBarArcView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;com.android.lovesixgod.customarcseekbar.seekbar.SeekBarBallView android:layout_width=\"20dp\" android:layout_height=\"100dp\" /&gt;&lt;/com.android.lovesixgod.customarcseekbar.seekbar.ArcSeekBarParent&gt; 然后运行，进行滑动。可以看到GPU分析显示的线条基本不会超过绿线，滑起来也没有明显的卡顿，问题应该算是解决了~ 代码已更新至Github。 小结 自定义View的时候尽量避免不变View的重绘。因为弧形线这个View是没有任何改变的，但是还不停地重绘，可能就会导致这样的性能问题了。 Scroller的使用是针对View的，对于ViewGroup好像是无效的，所以我将Scroller写在了SeekBarBallView中。另外Scroller要能正常使用，在startScroll()以及computeScroll()需要invalidate()或者postInvalidate。 多使用相关工具，来观察代码的性能。","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"Android自定义View实现弧形SeekBar","date":"2016-04-27T05:53:19.000Z","path":"2016/04/27/seekbar/","text":"前言项目开发中有这样一个需求：通过滑动SeekBar来控制打赏金额，金额设置5个档次。 看到设计稿的时候，除了自定义View想不到什么更好的方法了。自定义View一直是我的短板，内心总会有点抗拒，总感觉自己做不出来。最近一段时间，也是有意无意的练习自定义View。最后决定还是用自定义View来实现这次的需求。 根据设计图，我分为3个步骤： 画弧线。 画圆球。 触摸事件的处理，并提供对外接口。 画弧线圆弧起初的想法是根据自定义View的宽高，创建一个正方形，然后画一个内切圆，截取其中的一段圆弧。大致就是这样的：假设这样的圆存在，那么对于View的宽高有一个要求:假定宽为a，高为b，x为半径。取一个直角三角形，勾股定理能得出这样的公式：1(a/2)*(a/2) + (x-b)*(x-b) = x*x; 化简得到:1x = b/2 + (a*a) / (8*b) 假设若成立，那么x-b&gt;0,得到1a &gt; 2b 即对View的宽高有一个这样的硬性要求，才能符合预期。 另外，后续还需要画圆球，圆球的圆心肯定是需要在弧线上的，那么我每次画圆球时，圆心的坐标都需要通过三角函数来获得，会显得比较麻烦。考虑再三便放弃这种做法了。 抛物线晚上下班回家，跟室友讨论了一波这个问题，我室友当场来了个：抛物线。后面一想：卧槽？确实可以啊。直接确定3个点，就能确定抛物线的公式了，这样对于后续画圆球，求圆心的坐标也非常简单。于是打算第二天来做一波。 第二天。 网上一查，没查到android关于画抛物线的方法。我的内心：于是便也放弃了这种做法。 贝塞尔网上查阅资料的时候，关于弧线说的最多的就是利用贝塞尔曲线。关于贝塞尔曲线的更多介绍可以参考这篇文章。 二阶贝塞尔曲线符合我的情况，于是选取的二阶贝塞尔曲线。贝塞尔曲线的关键代码如下：123path.moveTo(pointF1.x, pointF1.y);path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y);canvas.drawPath(path, paint); pointF1是起始点，pointF2是控制点，pointF3是终止点。采用贝塞尔曲线实现的效果还不错，只是控制点是不在曲线上的，曲线无法与View的顶部相切，但也无伤大雅了。 画圆球画圆球就比较简单了，计算出圆心坐标直接画圆即可。12345678910// 二阶贝塞尔曲线公式计算坐标float t = (currentX / (right - left));float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x;float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y;circleCenter.set(x, y);paint.reset();paint.setFlags(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.WHITE);paint.setStyle(Paint.Style.FILL);canvas.drawCircle(x, y, RADIUS, paint); 二阶贝塞尔曲线的公式是这样的：我们把当前的横坐标currentX对于View宽度的比例作为t。 触摸事件处理&amp;对外接口触摸事件无非就是重写onTouchEvent，这里我只对横坐标做了处理，只要横着滑，就能滑动圆球了，并没有处理纵坐标。 ACTION_DOWN：判断点下的坐标是否在圆球返回内（我设置了20的误差），若不在圆球内，则直接返回false，那么后续就不会接收ACTION_MOVE等其他事件了。若在则返回true，接收后续的ACTION_MOVE等事件。 ACTION_MOVE：获取x坐标，然后设置currentX，重绘。对外的接口也是在这里调用。 default：当手指移出或者离开View时，利用Scroller使圆球平滑滑到距离最近的档次。 下面上完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public class CustomArcSeekBar extends View &#123; private Scroller scroller; private Paint paint; private Path path; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private PointF circleCenter; // 圆心的坐标 private int top; private int right; private int bottom; private int left; private float currentX; // 当前x坐标，用于控制圆球位置 private int currentLevel; // 当前档次 private OnProgressChangedListener listener; private final static float RADIUS = 30f; // 圆球半径 private final static float LEVEL = 6f; // 设置档次 public CustomArcSeekBar(Context context) &#123; super(context); init(context); &#125; public CustomArcSeekBar(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public CustomArcSeekBar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; paint = new Paint(); path = new Path(); pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); circleCenter = new PointF(); scroller = new Scroller(context); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; currentX = scroller.getCurrX(); postInvalidate(); &#125; &#125; public void setListener(OnProgressChangedListener listener) &#123; this.listener = listener; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); this.left = left; this.top = top; this.right = right; this.bottom = bottom; pointF1.set(0, bottom - top); pointF2.set((right - left) / 2, -(bottom - top) / 2); pointF3.set(right, bottom - top); currentX = (right - left) / LEVEL; currentLevel = 1; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画2阶贝塞尔曲线 paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.GRAY); paint.setStrokeWidth(10); paint.setStyle(Paint.Style.STROKE); path.moveTo(pointF1.x, pointF1.y); path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y); canvas.drawPath(path, paint); // 通过x坐标，计算圆心的坐标，画圆 float t = (currentX / (right - left)); float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x; float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y; circleCenter.set(x, y); paint.reset(); paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.WHITE); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(x, y, RADIUS, paint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: float downX = event.getX(); float downY = event.getY(); float distance = (downX - circleCenter.x) * (downX - circleCenter.x) + (downY - circleCenter.y) * (downY - circleCenter.y); // 计算到圆球中心的距离，考虑20的误差 return !(distance - (RADIUS + 20) * (RADIUS + 20) &gt; 0); case MotionEvent.ACTION_MOVE: float moveX = event.getX(); currentX = moveX; // 通过x坐标重绘圆球 invalidate(); currentLevel = getLevel(moveX); if (listener != null) &#123; listener.OnProgressChanged(currentLevel); &#125; break; default: // 当手指移出或者离开View时，圆球平滑滑到最近的档次 scroller.startScroll((int) currentX, 0, (int) ((right - left) / LEVEL * currentLevel - currentX), 0, 200); postInvalidate(); break; &#125; return super.onTouchEvent(event); &#125; /** * 计算档次 * * @param x 横坐标 * @return 档次 */ private int getLevel(float x) &#123; float ratio = (x / (right - left)) * LEVEL; // 计算距离哪个档次最近 int result = new BigDecimal(ratio).setScale(0, BigDecimal.ROUND_HALF_UP).intValue(); if (result &lt; 1) &#123; result = 1; &#125; else if (result &gt; (LEVEL - 1)) &#123; result = (int) (LEVEL - 1); &#125; return result; &#125; /** * 滑动接口 */ public interface OnProgressChangedListener &#123; void OnProgressChanged(int level); &#125;&#125; 使用在代码中使用，非常简单，在布局文件中引用：1234567891011121314&lt;com.lastwarmth.viewstudy.CustomArcSeekBar android:id=\"@+id/seek_bar\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_marginTop=\"40dp\" android:background=\"@color/colorAccent\" /&gt;&lt;TextView android:id=\"@+id/seek_bar_progress\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:text=\"1\" android:textSize=\"30sp\" /&gt; 代码中：12345678final TextView textView = (TextView) findViewById(R.id.seek_bar_progress);CustomArcSeekBar seekBar = (CustomArcSeekBar) findViewById(R.id.seek_bar);seekBar.setListener(new CustomArcSeekBar.OnProgressChangedListener() &#123; @Override public void OnProgressChanged(int level) &#123; textView.setText(String.valueOf(level)); &#125;&#125;); 最终效果：算是达到我的预期。 源码链接 小结 自定义View在绘制矩形、圆等图形时，使用的坐标是要相对于View本身的，而不是相对于屏幕的坐标。 使用贝塞尔曲线能获得不错的曲线效果。 Paint在画完1个东西之后记得reset，然后重新设置值，不然画笔的属性一样，得到的效果就不对。","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"一个关于Android滑动“因缺斯厅”的想法","date":"2016-04-22T06:07:10.000Z","path":"2016/04/22/android-scroll/","text":"前言在项目实际开发过程中，需要实现一个这样的需求：在屏幕上进行上滑时，顶端大图背景不动，下面的正在直播、数字专辑等模块进行滑动，并且大图背景慢慢模糊。 起初想着是自定义View，重写onTouchEvent来进行滑动事件的处理，如果是手指滑一点，界面跟着滑一点还好。如果还要计算加速度、阻尼效果等这些因素，就会显得非常复杂了。于是跟基友讨论了一下，有个因缺斯厅的idea，先上一下最后实现的一个效果图。 擦，好端端的妹子录Gif被录得完全看不清… 方案通过FrameLayout叠加2个布局，第1个布局就是大图背景，第2个布局就是原生ScrollView，ScrollView顶部使用一个透明的View，与第2个布局完全重叠，因为是透明的，所以尽管是叠加上去的，大图背景依然能正常显示，底部的正在直播、数字专辑等模块也能正常显示。FrameLayout的特性是后面的View叠加在前面的View之上。所以ScrollView处于界面的顶端，能够全屏接收触摸事件，然后进行滑动即可。并且ScrollView是android原生用来滑动的View，滑动起来会比较流畅。特意整了一个示意图： 实现布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"480dp\" android:layout_marginBottom=\"8dp\" android:background=\"#ffffff\" android:focusable=\"true\" android:focusableInTouchMode=\"true\"&gt; &lt;!-- 大图背景布局 --&gt; &lt;!-- 大图背景中的关注按钮 --&gt; &lt;TextView android:id=\"@+id/follow_text\" android:layout_width=\"80dp\" android:layout_height=\"64dp\" android:layout_gravity=\"right|bottom\" android:gravity=\"center\" android:text=\"关注\" android:textColor=\"@color/white\" android:textSize=\"20sp\" /&gt; &lt;/FrameLayout&gt; &lt;com.example.CustomScrollView android:id=\"@+id/scroll_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scrollbars=\"none\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;!-- 这个FrameLayout与大图背景的属性要完全一致，才能完全覆盖，并且设置alpha为0，使其透明 --&gt; &lt;FrameLayout android:id=\"@+id/shade\" android:layout_width=\"match_parent\" android:layout_height=\"480dp\" android:alpha=\"0\" android:background=\"#000000\"&gt; &lt;!-- 用于覆盖大图背景中的点击事件，相对位置、大小也必须一致 --&gt; &lt;TextView android:id=\"@+id/follow\" android:layout_width=\"80dp\" android:layout_height=\"64dp\" android:layout_gravity=\"right|bottom\" android:gravity=\"center\" android:text=\"\" android:textColor=\"@color/white\" android:textSize=\"20sp\" /&gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#000000\" android:orientation=\"vertical\"&gt; &lt;!-- 布局代码 --&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/com.example.CustomScrollView&gt;&lt;/FrameLayout&gt; 这里重点说明一点，因为是覆盖上去的，所以长宽的属性必须要一致，才能完全覆盖。另外，大图背景中的点击事件，可以在ScrollView顶部布局使用相对位置一致的View来进行响应，注意相对位置，长宽也最好一致。 监听ScrollView滑动上面的布局大致已经能实现滑动的功能了。接下来就是要监听ScrollView滑动，来慢慢模糊大图背景。Android SDK并没有提供能够直接监听滑动的方法，但是提供了一个protected void onScrollChanged(int x, int y, int oldx, int oldy)方法，是protectd的，所以不能被外界调用。因此写一个接口，然后把它暴露出去。12345678910111213141516171819202122232425262728293031323334public class CustomScrollView extends ScrollView &#123; private OnScrollListener listener; public CustomScrollView(Context context) &#123; super(context); &#125; public CustomScrollView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public CustomScrollView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public interface OnScrollListener &#123; void onScrollChanged(CustomScrollView scrollView, int x, int y, int oldx, int oldy); &#125; public void setListener(OnScrollListener listener) &#123; this.listener = listener; &#125; @Override protected void onScrollChanged(int x, int y, int oldx, int oldy) &#123; super.onScrollChanged(x, y, oldx, oldy); if (listener != null) &#123; listener.onScrollChanged(this, x, y, oldx, oldy); &#125; &#125;&#125; 然后定义自己的Listener即可。12345678910111213141516171819202122232425262728293031scrollView.setListener(new CustomScrollView.OnScrollListener() &#123; @Override public void onScrollChanged(CustomScrollView scrollView, int x, int y, int oldx, int oldy) &#123; int scrollY = scrollView.getScrollY(); if (scrollY == 0) &#123; followToggle.setClickable(true); &#125; else &#123; followToggle.setClickable(false); &#125; if (scrollY &gt; 0) &#123; if (scrollY &gt; background.getHeight()) &#123; scrollY = background.getHeight(); &#125; if (bitmap != null) &#123; int radius = (int) (scrollY * 25f / background.getHeight() * 1.5f); if (radius &lt;= 0) &#123; radius = 1; &#125; else if (radius &gt; 25) &#123; radius = 25; &#125; if (lastRadius != radius) &#123; lastRadius = radius; Bitmap blurBitmap = AndroidUtils.fastBlur(MainActivity.this, bitmap, radius); background.setImageBitmap(blurBitmap); &#125; float alpha = (float) scrollY / background.getHeight() / 1.5f; shade.setAlpha(alpha); &#125; &#125; &#125;&#125;); 在Listener中通过getScrollY()来获得滑动距离，来设置响应的模糊radius，以及alpha值，即可实现想要的效果了。 小结虽然并不一定是最好的实现方法，但是这个方法我个人觉得是比较取巧，比较因缺斯厅的方法。其实之前就想到了这样的方法，只不过当时脑袋短路，一直纠结自定义View，导致想不清楚，后面再仔细想一想就没什么大问题了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android仿美团下拉刷新","date":"2016-04-18T08:07:15.000Z","path":"2016/04/18/refresh-listview/","text":"在之前看过一篇文章Android自定义控件之仿美团下拉刷新，就是实现仿美团下拉刷新。一直对ListView等控件的下拉刷新的了解程度，可能也就停留在用HeaderView来实现，然后重写onTouchEvent，但是具体应该是怎样的呢？一直没有实际动手自己写过，于是抽空自己照着这篇博客自己写了一遍，以加深自己的理解。我对原博客进行摘录，重点写出一些对自己帮助大的内容。 刷新状态一般下拉刷新应该都是会有三种状态：下拉刷新、松开刷新、正在刷新。 下拉刷新实现思路：自定义View，通过设置进度值进行缩放。用SeekBar来模仿一下下拉距离的进度。 自定义View代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class RefreshFirstView extends View &#123; private Bitmap firstBitmap; private Bitmap endBitmap; private float mCurrentProgress; private int measuredWidth; private int measuredHeight; private Bitmap scaledBitmap; public RefreshFirstView(Context context) &#123; super(context); init(context); &#125; public RefreshFirstView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public RefreshFirstView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; firstBitmap = Bitmap.createBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.pull_image)); endBitmap = Bitmap.createBitmap(BitmapFactory.decodeResource(getResources(), R.drawable.pull_end_image_frame_05)); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureWidth(widthMeasureSpec), measureWidth(widthMeasureSpec) * endBitmap.getHeight() / endBitmap.getWidth()); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); measuredWidth = getMeasuredWidth(); measuredHeight = getMeasuredHeight(); //根据第二阶段娃娃宽高 给椭圆形图片进行等比例的缩放 scaledBitmap = Bitmap.createScaledBitmap(firstBitmap, measuredWidth, measuredWidth * firstBitmap.getHeight() / firstBitmap.getWidth(), true); &#125; private int measureWidth(int widMeasureSpec) &#123; int result; int size = MeasureSpec.getSize(widMeasureSpec); int mode = MeasureSpec.getMode(widMeasureSpec); if (mode == MeasureSpec.EXACTLY) &#123; result = size; &#125; else &#123; result = endBitmap.getWidth(); if (mode == MeasureSpec.AT_MOST) &#123; result = Math.min(result, size); &#125; &#125; return result; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 通过画布缩放，控制View缩放 canvas.scale(mCurrentProgress, mCurrentProgress, measuredWidth / 2, measuredHeight / 2); canvas.drawBitmap(scaledBitmap, 0, measuredHeight / 4, null); &#125; public void setCurrentProgress(float currentProgress) &#123; this.mCurrentProgress = currentProgress; &#125;&#125; 松开刷新这里主要是一个帧动画。12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"true\"&gt; &lt;item android:drawable=\"@drawable/pull_end_image_frame_01\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/pull_end_image_frame_02\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/pull_end_image_frame_03\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/pull_end_image_frame_04\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/pull_end_image_frame_05\" android:duration=\"100\" /&gt;&lt;/animation-list&gt; 正在刷新与松开刷新一样，也是一个帧动画，这里便不做赘述。 三种状态通过自定义View，重写onMeasure来确保三个状态的View的宽高保持一致。 下拉刷新的实现先贴一下原博客的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318public class MeiTuanListView extends ListView implements AbsListView.OnScrollListener&#123; private static final int DONE = 0; private static final int PULL_TO_REFRESH = 1; private static final int RELEASE_TO_REFRESH = 2; private static final int REFRESHING = 3; private static final int RATIO = 3; private LinearLayout headerView; private int headerViewHeight; private float startY; private float offsetY; private TextView tv_pull_to_refresh; private OnMeiTuanRefreshListener mOnRefreshListener; private int state; private int mFirstVisibleItem; private boolean isRecord; private boolean isEnd; private boolean isRefreable; private FrameLayout mAnimContainer; private Animation animation; private SimpleDateFormat format; private MeiTuanRefreshFirstStepView mFirstView; private MeiTuanRefreshSecondStepView mSecondView; private AnimationDrawable secondAnim; private MeiTuanRefreshThirdStepView mThirdView; private AnimationDrawable thirdAnim; public MeiTuanListView(Context context) &#123; super(context); init(context); &#125; public MeiTuanListView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public MeiTuanListView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; public interface OnMeiTuanRefreshListener&#123; void onRefresh(); &#125; /** * 回调接口，想实现下拉刷新的listview实现此接口 * @param onRefreshListener */ public void setOnMeiTuanRefreshListener(OnMeiTuanRefreshListener onRefreshListener)&#123; mOnRefreshListener = onRefreshListener; isRefreable = true; &#125; /** * 刷新完毕，从主线程发送过来，并且改变headerView的状态和文字动画信息 */ public void setOnRefreshComplete()&#123; //一定要将isEnd设置为true，以便于下次的下拉刷新 isEnd = true; state = DONE; changeHeaderByState(state); &#125; private void init(Context context) &#123; setOverScrollMode(View.OVER_SCROLL_NEVER); setOnScrollListener(this); headerView = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.meituan_item, null, false); mFirstView = (MeiTuanRefreshFirstStepView) headerView.findViewById(R.id.first_view); tv_pull_to_refresh = (TextView) headerView.findViewById(R.id.tv_pull_to_refresh); mSecondView = (MeiTuanRefreshSecondStepView) headerView.findViewById(R.id.second_view); mSecondView.setBackgroundResource(R.drawable.pull_to_refresh_second_anim); secondAnim = (AnimationDrawable) mSecondView.getBackground(); mThirdView = (MeiTuanRefreshThirdStepView) headerView.findViewById(R.id.third_view); mThirdView.setBackgroundResource(R.drawable.pull_to_refresh_third_anim); thirdAnim = (AnimationDrawable) mThirdView.getBackground(); measureView(headerView); addHeaderView(headerView); headerViewHeight = headerView.getMeasuredHeight(); headerView.setPadding(0, -headerViewHeight, 0, 0); Log.i(\"zhangqi\",\"headerViewHeight=\"+headerViewHeight); state = DONE; isEnd = true; isRefreable = false; &#125; @Override public void onScrollStateChanged(AbsListView absListView, int i) &#123; &#125; @Override public void onScroll(AbsListView absListView, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; mFirstVisibleItem = firstVisibleItem; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isEnd) &#123;//如果现在时结束的状态，即刷新完毕了，可以再次刷新了，在onRefreshComplete中设置 if (isRefreable) &#123;//如果现在是可刷新状态 在setOnMeiTuanListener中设置为true switch (ev.getAction())&#123; //用户按下 case MotionEvent.ACTION_DOWN: //如果当前是在listview顶部并且没有记录y坐标 if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; //将isRecord置为true，说明现在已记录y坐标 isRecord = true; //将当前y坐标赋值给startY起始y坐标 startY = ev.getY(); &#125; break; //用户滑动 case MotionEvent.ACTION_MOVE: //再次得到y坐标，用来和startY相减来计算offsetY位移值 float tempY = ev.getY(); //再起判断一下是否为listview顶部并且没有记录y坐标 if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; isRecord = true; startY = tempY; &#125; //如果当前状态不是正在刷新的状态，并且已经记录了y坐标 if (state!=REFRESHING &amp;&amp; isRecord ) &#123; //计算y的偏移量 offsetY = tempY - startY; //计算当前滑动的高度 float currentHeight = (-headerViewHeight+offsetY/3); //用当前滑动的高度和头部headerView的总高度进行比 计算出当前滑动的百分比 0到1 float currentProgress = 1+currentHeight/headerViewHeight; //如果当前百分比大于1了，将其设置为1，目的是让第一个状态的椭圆不再继续变大 if (currentProgress&gt;=1) &#123; currentProgress = 1; &#125; //如果当前的状态是放开刷新，并且已经记录y坐标 if (state == RELEASE_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果当前滑动的距离小于headerView的总高度 if (-headerViewHeight+offsetY/RATIO&lt;0) &#123; //将状态置为下拉刷新状态 state = PULL_TO_REFRESH; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125;else if (offsetY&lt;=0) &#123; //将状态变为done state = DONE; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); &#125; &#125; //如果当前状态为下拉刷新并且已经记录y坐标 if (state == PULL_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果下拉距离大于等于headerView的总高度 if (-headerViewHeight+offsetY/RATIO&gt;=0) &#123; //将状态变为放开刷新 state = RELEASE_TO_REFRESH; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125;else if (offsetY&lt;=0) &#123; //将状态变为done state = DONE; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); &#125; &#125; //如果当前状态为done并且已经记录y坐标 if (state == DONE &amp;&amp; isRecord) &#123; //如果位移值大于0 if (offsetY&gt;=0) &#123; //将状态改为下拉刷新状态 state = PULL_TO_REFRESH; &#125; &#125; //如果为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //则改变headerView的padding来实现下拉的效果 headerView.setPadding(0,(int)(-headerViewHeight+offsetY/RATIO) ,0,0); //给第一个状态的View设置当前进度值 mFirstView.setCurrentProgress(currentProgress); //重画 mFirstView.postInvalidate(); &#125; //如果为放开刷新状态 if (state == RELEASE_TO_REFRESH) &#123; //改变headerView的padding值 headerView.setPadding(0,(int)(-headerViewHeight+offsetY/RATIO) ,0, 0); //给第一个状态的View设置当前进度值 mFirstView.setCurrentProgress(currentProgress); //重画 mFirstView.postInvalidate(); &#125; &#125; break; //当用户手指抬起时 case MotionEvent.ACTION_UP: //如果当前状态为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //平滑的隐藏headerView this.smoothScrollBy((int)(-headerViewHeight+offsetY/RATIO)+headerViewHeight, 500); //根据状态改变headerView changeHeaderByState(state); &#125; //如果当前状态为放开刷新 if (state == RELEASE_TO_REFRESH) &#123; //平滑的滑到正好显示headerView this.smoothScrollBy((int)(-headerViewHeight+offsetY/RATIO), 500); //将当前状态设置为正在刷新 state = REFRESHING; //回调接口的onRefresh方法 mOnRefreshListener.onRefresh(); //根据状态改变headerView changeHeaderByState(state); &#125; //这一套手势执行完，一定别忘了将记录y坐标的isRecord改为false，以便于下一次手势的执行 isRecord = false; break; &#125; &#125; &#125; return super.onTouchEvent(ev); &#125; /** * 根据状态改变headerView的动画和文字显示 * @param state */ private void changeHeaderByState(int state)&#123; switch (state) &#123; case DONE://如果的隐藏的状态 //设置headerView的padding为隐藏 headerView.setPadding(0, -headerViewHeight, 0, 0); //第一状态的view显示出来 mFirstView.setVisibility(View.VISIBLE); //第二状态的view隐藏起来 mSecondView.setVisibility(View.GONE); //停止第二状态的动画 secondAnim.stop(); //第三状态的view隐藏起来 mThirdView.setVisibility(View.GONE); //停止第三状态的动画 thirdAnim.stop(); break; case RELEASE_TO_REFRESH://当前状态为放开刷新 //文字显示为放开刷新 tv_pull_to_refresh.setText(\"放开刷新\"); //第一状态view隐藏起来 mFirstView.setVisibility(View.GONE); //第二状态view显示出来 mSecondView.setVisibility(View.VISIBLE); //播放第二状态的动画 secondAnim.start(); //第三状态view隐藏起来 mThirdView.setVisibility(View.GONE); //停止第三状态的动画 thirdAnim.stop(); break; case PULL_TO_REFRESH://当前状态为下拉刷新 //设置文字为下拉刷新 tv_pull_to_refresh.setText(\"下拉刷新\"); //第一状态view显示出来 mFirstView.setVisibility(View.VISIBLE); //第二状态view隐藏起来 mSecondView.setVisibility(View.GONE); //第二状态动画停止 secondAnim.stop(); //第三状态view隐藏起来 mThirdView.setVisibility(View.GONE); //第三状态动画停止 thirdAnim.stop(); break; case REFRESHING://当前状态为正在刷新 //文字设置为正在刷新 tv_pull_to_refresh.setText(\"正在刷新\"); //第一状态view隐藏起来 mFirstView.setVisibility(View.GONE); //第三状态view显示出来 mThirdView.setVisibility(View.VISIBLE); //第二状态view隐藏起来 mSecondView.setVisibility(View.GONE); //停止第二状态动画 secondAnim.stop(); //启动第三状态view thirdAnim.start(); break; default: break; &#125; &#125; private void measureView(View child) &#123; ViewGroup.LayoutParams p = child.getLayoutParams(); if (p == null) &#123; p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125;&#125; 代码中已经有了很详细的注释了，看起来应该会比较轻松。 改进写完之后运行，发现有2个地方可以改进。 下拉白块在下拉刷新的时候，若下拉的高度很高，那么松开刷新后，再次下拉，会出现很大的一个空白块，影响视觉。导致该问题的原因是在RELEASE_TO_REFRESH状态下ACTION_UP时，只是利用smoothScrollBy滑动到headerView的显示位置。但是此时，headerView的paddingTop属性依然是ACTION_MOVE中设置的headerView.setPadding(0,(int)(-headerViewHeight+offsetY/RATIO) ,0, 0);，其值跟offsetY有关，offsetY越大，那么paddingTop值就会越大，导致再次下拉会出现很大的空白块。 改进办法：利用Scroller滑动辅助类替换smoothScrollBy，在滑动的过程中不停设置headerView的paddingTop值。当滑动结束时，headerView的paddingTop正好等于0，即刚刚好显示。 刷新结束后立刻消失刷新结束后，会直接设置headerView的paddingTop为-headerViewHeight，导致headerView立刻不可见，会显得比较突兀。 改进办法：依然是利用Scroller类滑动辅助类，通过滑动动画使headerView不可见。改进后，我的代码是这样的:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310public class RefreshListView extends ListView implements ListView.OnScrollListener &#123; /** * 刷新四种状态 */ public final static int DONE = 0; // 刷新完成 public final static int PULL_TO_REFRESH = 1; // 下拉刷新 public final static int RELEASE_TO_REFRESH = 2; // 松开刷新 public final static int REFRESHING = 3; // 正在刷新 private static final int RATIO = 3; // 滑动的比例值 private int state; // 当前的状态 private boolean isRefreshable; // 是否可刷新 private boolean isRecord; // 是否开始准备下拉刷新 private boolean refreshEnd; // 是否刷新结束 private int mFirstVisibleItem; // 当前第一个可见Item private LinearLayout headerView; // 头布局 private TextView refreshText; // 刷新文字说明 private RefreshFirstView firstView; // 下拉刷新 private RefreshSecondView secondView; // 松开刷新 private RefreshThirdView thirdView; // 正在刷新 private AnimationDrawable secondAnim; // secondView对应的动画 private AnimationDrawable thirdAnim; // thirdView对应的动画 private int headerViewHeight; // 头布局的高度 private float startY; // 起始Y坐标 private float offsetY; // Y坐标上的偏移量 private OnRefreshListener refreshListener; // 回调接口 // 滑动类 private Scroller mScroller = null; public RefreshListView(Context context) &#123; super(context); init(context); &#125; public RefreshListView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public RefreshListView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; public void setRefreshListener(OnRefreshListener refreshListener) &#123; this.refreshListener = refreshListener; isRefreshable = true; &#125; /** * 初始化 * * @param context */ private void init(Context context) &#123; setOverScrollMode(View.OVER_SCROLL_NEVER); setOnScrollListener(this); mScroller = new Scroller(context); headerView = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.list_header, this, false); refreshText = (TextView) headerView.findViewById(R.id.pull_to_refresh); firstView = (RefreshFirstView) headerView.findViewById(R.id.first_view); secondView = (RefreshSecondView) headerView.findViewById(R.id.second_view); thirdView = (RefreshThirdView) headerView.findViewById(R.id.third_view); secondAnim = (AnimationDrawable) secondView.getBackground(); thirdAnim = (AnimationDrawable) thirdView.getBackground(); measureView(headerView); addHeaderView(headerView); headerViewHeight = headerView.getMeasuredHeight(); headerView.setPadding(0, -headerViewHeight, 0, 0); // 全局通过设置headerView的paddingTop来控制内部View的显示 state = DONE; isRefreshable = false; isRecord = false; &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; setPaddingTop(mScroller.getCurrY()); &#125; &#125; private void setPaddingTop(int paddingTop) &#123; headerView.setPadding(0, paddingTop, 0, 0); headerView.postInvalidate(); &#125; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; mFirstVisibleItem = firstVisibleItem; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isRefreshable) &#123;//如果现在是可刷新状态 在setOnMeiTuanListener中设置为true switch (ev.getAction()) &#123; //用户按下 case MotionEvent.ACTION_DOWN: if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; //将isRecord置为true，说明现在已记录y坐标 isRecord = true; startY = ev.getY(); &#125; break; //用户滑动 case MotionEvent.ACTION_MOVE: //再次得到y坐标，用来和startY相减来计算offsetY位移值 float tempY = ev.getY(); //再判断一次 if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; isRecord = true; startY = tempY; &#125; //如果当前状态不是正在刷新的状态，并且已经记录了y坐标 if (state != REFRESHING &amp;&amp; isRecord) &#123; //计算y的偏移量 offsetY = tempY - startY; //计算当前滑动的高度 float currentHeight = (-headerViewHeight + offsetY / 3); //用当前滑动的高度和头部headerView的总高度进行比 计算出当前滑动的百分比 0到1 float currentProgress = 1 + currentHeight / headerViewHeight; //如果当前百分比大于1了，将其设置为1，目的是让第一个状态的椭圆不再继续变大 if (currentProgress &gt;= 1) &#123; currentProgress = 1; &#125; //如果当前的状态是放开刷新，并且已经记录y坐标 if (state == RELEASE_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果当前滑动的距离小于headerView的总高度 if (-headerViewHeight + offsetY / RATIO &lt; 0) &#123; //将状态置为下拉刷新状态 state = PULL_TO_REFRESH; changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125; else if (offsetY &lt;= 0) &#123; //将状态变为done state = DONE; changeHeaderByState(state); &#125; &#125; //如果当前状态为下拉刷新并且已经记录y坐标 if (state == PULL_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果下拉距离大于等于headerView的总高度 if (-headerViewHeight + offsetY / RATIO &gt;= 0) &#123; //将状态变为放开刷新 state = RELEASE_TO_REFRESH; changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125; else if (offsetY &lt;= 0) &#123; //将状态变为done state = DONE; changeHeaderByState(state); &#125; &#125; //如果当前状态为done并且已经记录y坐标 if (state == DONE &amp;&amp; isRecord) &#123; //如果位移值大于0 if (offsetY &gt;= 0) &#123; //将状态改为下拉刷新状态 state = PULL_TO_REFRESH; &#125; &#125; //如果为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //则改变headerView的padding来实现下拉的效果 headerView.setPadding(0, (int) (-headerViewHeight + offsetY / RATIO), 0, 0); //给第一个状态的View设置当前进度值 firstView.setCurrentProgress(currentProgress); //重画 firstView.postInvalidate(); &#125; //如果为放开刷新状态 if (state == RELEASE_TO_REFRESH) &#123; //改变headerView的padding值 headerView.setPadding(0, (int) (-headerViewHeight + offsetY / RATIO), 0, 0); //给第一个状态的View设置当前进度值 firstView.setCurrentProgress(currentProgress); //重画 firstView.postInvalidate(); &#125; &#125; break; default: //如果当前状态为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //平滑的隐藏headerView this.smoothScrollBy((int) (-headerViewHeight + offsetY / RATIO) + headerViewHeight, 500); changeHeaderByState(state); &#125; //如果当前状态为放开刷新 if (state == RELEASE_TO_REFRESH) &#123; //平滑的滑到正好显示headerView// this.smoothScrollBy((int) (-headerViewHeight + offsetY / RATIO), 500); mScroller.startScroll(0, (int) (-headerViewHeight + offsetY / RATIO), 0, (int) (headerViewHeight - offsetY / RATIO), 500); //将当前状态设置为正在刷新 state = REFRESHING; //回调接口的onRefresh方法 changeHeaderByState(state); if (refreshListener != null) &#123; refreshListener.onRefresh(); &#125; &#125; //一套操作执行完，重置状态 isRecord = false; break; &#125; &#125; return super.onTouchEvent(ev); &#125; /** * 根据state改变HeaderView * * @param state */ private void changeHeaderByState(int state) &#123; switch (state) &#123; case DONE: if (refreshEnd) &#123; // 如果是刷新结束，则慢慢滚动消失 mScroller.startScroll(0, 0, 0, -headerViewHeight, 500); refreshEnd = false; &#125; else &#123; headerView.setPadding(0, -headerViewHeight, 0, 0); &#125; firstView.setVisibility(VISIBLE); secondView.setVisibility(GONE); secondAnim.stop(); thirdView.setVisibility(GONE); thirdAnim.stop(); break; case PULL_TO_REFRESH: refreshText.setText(\"下拉刷新\"); firstView.setVisibility(View.VISIBLE); secondView.setVisibility(View.GONE); secondAnim.stop(); thirdView.setVisibility(View.GONE); thirdAnim.stop(); break; case RELEASE_TO_REFRESH: refreshText.setText(\"放开刷新\"); firstView.setVisibility(View.GONE); secondView.setVisibility(View.VISIBLE); secondAnim.start(); thirdView.setVisibility(View.GONE); thirdAnim.stop(); break; case REFRESHING: refreshText.setText(\"正在刷新\"); firstView.setVisibility(View.GONE); thirdView.setVisibility(View.VISIBLE); secondView.setVisibility(View.GONE); secondAnim.stop(); thirdAnim.start(); break; default: break; &#125; &#125; /** * 在init时View尚未绘制，为了获取HeaderView的高度，需要此方法提前绘制 * * @param child */ private void measureView(View child) &#123; ViewGroup.LayoutParams p = child.getLayoutParams(); if (p == null) &#123; p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125; /** * 刷新结束后的回调，重置状态 */ public void setOnRefreshComplete() &#123; state = DONE; refreshEnd = true; changeHeaderByState(state); &#125; /** * 刷新回调接口 */ public interface OnRefreshListener &#123; void onRefresh(); &#125;&#125; 讨论在原博客中有这样的讨论：setOnRefreshComplete没必要暴露，隐藏在ListView里面更好。 个人觉得也确实是这样，我们使用下拉刷新只会关心onRefresh，对于setOnRefreshComplete是不关心的。但是setOnRefreshComplete是必须要在onRefresh执行完之后才会执行，对于ListView它是不知道onRefresh在何时结束的，所以如果非要隐藏setOnRefreshComplete，我暂时没想到好的实现方案。 后面我找了一下下拉刷新相关的库，都有类似setOnRefreshComplete的方法。XListView：SwipeRefreshLayout:希望有想法的大神不吝赐教~ 感受 对于自己记忆中模棱两可的知识一定要自己动手做一遍，以加深印象。 可以通过缩放canvas，来实现自定义view的缩放。 通过设置paddingTop值来控制headerView的显示。 在查看XListView相关源码的时候，发现它是这样在View还没显示的时候获取高度的： 12345678mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener( new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; mHeaderViewHeight = mHeaderViewContent.getHeight(); getViewTreeObserver().removeGlobalOnLayoutListener(this); &#125;&#125;); onTouchEvent里的事件处理是非常繁杂的，当时自己写滑动删除的ListView时也重写过onTouchEvent，一定要细心。 我的代码代码已上传至我的Github。 参考文章Android自定义控件之仿美团下拉刷新","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"博客添加域名映射","date":"2016-04-07T06:05:45.000Z","path":"2016/04/07/domain/","text":"利用Github搭建博客有一阵子了，每次访问都必须带上github.io，其实我的内心是拒绝的，于是今天打算买个自己的域名，然后映射到博客。 购买域名首先第一步自然是买域名了。许多人都说是用GoDaddy，但是我去搜了一下，随便一个就是15刀，吓死宝宝了~刚开始嘛，弄个便宜的尝尝鲜才是我的目的，于是我上阿里云买了lastwarmth.site这个域名，首年才只收费4块钱哟~ 域名解析登录阿里云，进入到管理控制台，点击域名。可以看到自己购买的域名，点击后面的解析。跳过新手设置引导，直接点击进入高级设置。然后点击添加解析。可以看到记录的几种类型，因为映射到的github.io博客也是Github的域名，所以我选择的CNAME，主机记录配置www，解析线路默认，记录值填写自己的博客地址，我填的是lijia92.github.io。填写完之后，再添加一条@主机记录配置。 Github关联在自己Github的github.io的仓库根目录下创建CNAME文件，编辑，填入你的域名。 最后wait。 稍后便能通过域名访问博客啦。 小问题在更新博客deploy的时候，添加的CNAME文件会被刷掉，导致映射不过去。所以需要将CNAME添加到hexo/source下面，然后重新部署。","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"Android接入JPush（极光推送）","date":"2016-04-05T06:14:58.000Z","path":"2016/04/05/jpush/","text":"项目中需要有推送功能，技术负责人最后决定使用极光推送，活被分配给我了，于是我便接了一波，在此小记一下~ 在极光推送的官方文档中，已经有了较详细的说明了，这里只做一下简单的摘录。 三分钟快速Demo在极光推送的官方文档中，有三分钟快速Demo，我也是从demo入手。 创建开发者账号接过sdk的同学应该都知道，再使用第三方的服务的时候，总会需要先注册一个开发者账号。要创建极光推送开发者帐号，请访问极光推送官方网站。 创建应用使用注册账号登录，进入极光控制台后，点击创建应用。创建帐号进入极光推送后，首先显示的是创建应用的界面。填上你的应用程序的名称，以及 Android包名这二顶就可以了。 下载应用Example点击下载Android Example。 启动项目下载后得到一个Zip，可直接解压导入到Android Studio中，然后编译运行项目，安装到手机运行即可。gradle配置可能需要依据你当前开发极其做些修改。 推送消息填写要推送的内容，选择推送对象，点击发送即可推送消息了。这时手机便能接受到推送的消息了。 接入JPush到实际项目导入sdk在官网上下载sdk，然后导入到项目中： 解压缩 jpush-sdk_v2.x.y.zip 集成压缩包 复制libs/jpush-sdk-release2.x.y.jar到工程 libs/ 目录下 复制libs/armeabi/libjpush2xy.so到工程 libs/armeabi 目录下 复制libs/armeabi-v7a/libjpush.so到工程 libs/armeabi-v7a 目录下 复制res/drawable-hdpi中的资源文件到工程的 res/drawable-hdpi/ 目录下 复制res/layout中的布局文件到工程的 res/layout/ 目录下 其中5和6，其实是可以忽略的，我导入的时候看了下，这是极光推送默认的布局，在集成的时候，项目肯定会有自己的布局，需要自己去自定义，本身的默认布局是用不到的。 配置AndroidManifest.xml参考官网的示例xml中进行配置AndroidManifest.xml，这里贴一下官网的示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"您应用的包名\" android:versionCode=\"205\" android:versionName=\"2.0.5\" &gt; &lt;uses-sdk android:minSdkVersion=\"11\" android:targetSdkVersion=\"17\" /&gt; &lt;!-- Required 自定义用来收发消息的相关权限 --&gt; &lt;permission android:name=\"$&#123;applicationId&#125;.permission.JPUSH_MESSAGE\" android:protectionLevel=\"signature\" /&gt; &lt;!-- Required 一些系统要求的权限，如访问网络等--&gt; &lt;uses-permission android:name=\"$&#123;applicationId&#125;.permission.JPUSH_MESSAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.RECEIVE_USER_PRESENT\" /&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_SETTINGS\" /&gt; &lt;uses-permission android:name=\"android.permission.VIBRATE\" /&gt; &lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;!-- Optional for location --&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_LOCATION_EXTRA_COMMANDS\" /&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_NETWORK_STATE\" /&gt; &lt;application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\"&gt; &lt;!-- Required SDK核心功能--&gt; &lt;activity android:name=\"cn.jpush.android.ui.PushActivity\" android:configChanges=\"orientation|keyboardHidden\" android:theme=\"@android:style/Theme.NoTitleBar\" android:exported=\"false\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"cn.jpush.android.ui.PushActivity\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"$&#123;applicationId&#125;\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- Required SDK核心功能--&gt; &lt;service android:name=\"cn.jpush.android.service.DownloadService\" android:enabled=\"true\" android:exported=\"false\" &gt; &lt;/service&gt; &lt;!-- Required SDK 核心功能--&gt; &lt;!-- option since 2.0.5 可配置PushService的android:process参数 将JPush服务配置为一个独立进程 --&gt; &lt;!-- 如：android:process=\":remote\" --&gt; &lt;service android:name=\"cn.jpush.android.service.PushService\" android:enabled=\"true\" android:exported=\"false\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"cn.jpush.android.intent.REGISTER\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.REPORT\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.PushService\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.PUSH_TIME\" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;!-- Required SDK 核心功能 since 1.8.0 --&gt; &lt;service android:name=\"cn.jpush.android.service.DaemonService\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter &gt; &lt;action android:name=\"cn.jpush.android.intent.DaemonService\" /&gt; &lt;category android:name=\"$&#123;applicationId&#125;\"/&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;!-- Required SDK核心功能--&gt; &lt;receiver android:name=\"cn.jpush.android.service.PushReceiver\" android:enabled=\"true\" android:exported=\"false\"&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"cn.jpush.android.intent.NOTIFICATION_RECEIVED_PROXY\" /&gt; &lt;!--Required 显示通知栏 --&gt; &lt;category android:name=\"$&#123;applicationId&#125;\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.USER_PRESENT\" /&gt; &lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt; &lt;/intent-filter&gt; &lt;!-- Optional --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.PACKAGE_ADDED\" /&gt; &lt;action android:name=\"android.intent.action.PACKAGE_REMOVED\" /&gt; &lt;data android:scheme=\"package\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Required SDK核心功能--&gt; &lt;receiver android:name=\"cn.jpush.android.service.AlarmReceiver\" /&gt; &lt;!-- User defined. 用户自定义的广播接收器--&gt; &lt;receiver android:name=\"您自己定义的Receiver\" android:enabled=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"cn.jpush.android.intent.REGISTRATION\" /&gt; &lt;!--Required 用户注册SDK的intent--&gt; &lt;action android:name=\"cn.jpush.android.intent.MESSAGE_RECEIVED\" /&gt; &lt;!--Required 用户接收SDK消息的intent--&gt; &lt;action android:name=\"cn.jpush.android.intent.NOTIFICATION_RECEIVED\" /&gt; &lt;!--Required 用户接收SDK通知栏信息的intent--&gt; &lt;action android:name=\"cn.jpush.android.intent.NOTIFICATION_OPENED\" /&gt; &lt;!--Required 用户打开自定义通知栏的intent--&gt; &lt;action android:name=\"cn.jpush.android.intent.ACTION_RICHPUSH_CALLBACK\" /&gt; &lt;!--Optional 用户接受Rich Push Javascript 回调函数的intent--&gt; &lt;action android:name=\"cn.jpush.android.intent.CONNECTION\" /&gt;&lt;!-- 接收网络变化 连接/断开 since 1.6.3 --&gt; &lt;category android:name=\"$&#123;applicationId&#125;\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Required . Enable it you can get statistics data with channel --&gt; &lt;meta-data android:name=\"JPUSH_CHANNEL\" android:value=\"developer-default\"/&gt; &lt;meta-data android:name=\"JPUSH_APPKEY\" android:value=\"您应用applicationId对应的appKey\" /&gt; &lt;!-- &lt;/&gt;值来自开发者平台取得的AppKey--&gt; &lt;/application&gt;&lt;/manifest&gt; 其中注意： 标注Required为必须的 包名 AppKey 初始化在Application中初始化JPush。12345678public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); JPushInterface.setDebugMode(true); JPushInterface.init(this); &#125;&#125; 至此，JPush便已全部集成完毕。至于自定义通知布局，以及Notification的点击响应，后面再说了。 问题 我是小米的测试机，在接收推送消息的时候，必须要启动应用的时候才会收到推送的消息。后面才知道，是有些手机需要允许应用自启动。修改之后便可在没启动应用的时候也能收到推送消息了。点这里传送常见问题。 所感作为一款比较大众的产品，肯定是不会有很多坑的（不然也没那么多人会用它了），在其官方文档的说明上，一般都会有相应的说明。在看文档的时候，一定要仔细，仔细，仔细，重要的事情说三遍~","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"Android使用VideoView进行视频播放","date":"2016-04-01T07:07:19.000Z","path":"2016/04/01/video-view/","text":"最近在做一个主播类的App，里面涉及到视频播放，之前没有接触过，在探索一阵后能够播放基本视频了。特此写下小记，方便日后查看。 首先，确定使用VideoView进行视频播放。 步骤： 在界面布局文件中定义VideoView组件，或在程序中创建VideoView组件。 调用VideoView的如下两个方法来加载指定的视频: setVidePath(String path)：加载path文件代表的视频 setVideoURI(Uri uri)：加载uri所对应的视频 调用VideoView的start()、stop()、psuse()等方法来控制视频的播放。 若要显示进度条，可结合MediaController一起使用。 下面代码进行说明。 布局文件：1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;VideoView android:id=\"@+id/video_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; Activity：1234567891011121314151617181920public class VideoPlayActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_video_play); VideoView videoView = (VideoView) this.findViewById(R.id.video_view); videoView.setMediaController(new MediaController(this)); // 添加MediaController videoView.setVideoPath(\"你的视频路径\"); // 设置路径 videoView.requestFocus(); // 获取焦点 videoView.start(); // 播放 videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; finish(); // 播放结束回调 &#125; &#125;); &#125;&#125; 因为视频播放一般是全屏，直接使用系统的FullScreen会提示需要使用AppCompat主题，所以我给Activity设置了一个style。123456&lt;style name=\"NoTitleFullscreen\" parent=\"AppTheme\"&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowContentOverlay\"&gt;@null&lt;/item&gt;&lt;/style&gt; 12345&lt;activity android:name=\".ui.VideoPlayActivity\" android:screenOrientation=\"portrait\" android:theme=\"@style/NoTitleFullscreen\"&gt;&lt;/activity&gt; 实际效果： 因为是虚拟机，效果看起来可能不太满意，但是至少视频是能播放了。后续可能还有屏幕视频适配的问题，现在就不多说了，后面解决了再来更新。 问题：VideoView加载资源需要一定的耗时, 会造成短暂的黑屏现象。如何避免播放前的黑屏现象呢？可以给videoview设置加载的监听，在加载前给一个遮罩，等资源加载完成后隐藏遮罩。123456789101112131415161718&lt;FrameLayout android:id=\"@+id/frameLayout1\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:layout_gravity=\"center\" android:layout_marginTop=\"50dip\" &gt; &lt;VideoView android:id=\"@+id/geoloc_anim\" android:layout_width=\"fill_parent\" android:layout_height=\"172dip\" android:layout_gravity=\"top|center\" android:visibility=\"visible\"/&gt; &lt;FrameLayout android:id=\"@+id/placeholder\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:background=\"@drawable/fondvert_anim\"&gt; &lt;/FrameLayout&gt;&lt;/FrameLayout&gt; 设置监听：123456789videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mediaPlayer) &#123; //Called when the video is ready to play View placeholder = findViewById(R.id.placeholder); placeholder.setVisibility(View.GONE); &#125; &#125;); 今天是愚人节，节日快乐哦~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"博客搬家","date":"2016-03-25T01:39:01.000Z","path":"2016/03/25/blog-move/","text":"在2015年10月24日，正好是程序猿节，我开始写博客。 在半年前找工作的时候，看到许多许多公司的招聘上，都会有个加分项：拥有维护半年以上的个人博客。 其实也是一直想写博客来着，因为我学习安卓都是从许多大牛的博客中学习的，我也想朝着他们的方向努力。分享自己的知识，帮助他人。 刚开始写博客的时候，还不太熟练，借用的CSDN平台，比较方便快捷的写起了博客。 最近使用Hexo+Github搭建完自己的博客之后，便打算把所有的博客迁移过来，并做了些许调整。 有几篇转载的，写得非常好的文章因为没有md格式的文件，暂时迁移不过来，后面再说了。 文章列表： Android Studio使用Gradle进行多渠道打包 Android实现渐变title栏 Android实现简易轻量下载器：单线程任务队列 Android实现照片墙背景 使用Android新特性：Material Design React Native For Android初探-问题小结 React Native For Android初探 Android Hybrid开发实战之图片的交互 Android Notification使用小记 Android Hybrid开发入门：原生Android与JS的交互 Android仿QQ空间浏览图片 Android Studio中使用.9（Nine Patch）图 Android仿QQ实现ListView滑动删除 Android事件分发机制学习小记 Android Studio使用Genymotion小记 Java反射实现接口 百度定位SDK无法定位 Android DDMS无法输出logcat 现在，我作为一个入门不久的安卓开发工程师，大牛自然是称不上的。但是在学习安卓的路上，各种各样的钉子是肯定会碰到的，我会把这些钉子分享出来，方便他人能够少走一些弯路，也记录我自己在学习之路上的点点滴滴，以及生活中的所想所感。","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"android接入微信支付SDK","date":"2016-03-18T07:04:30.000Z","path":"2016/03/18/wechat-sdk/","text":"本文主要讲述一下android接入微信支付SDK的步骤以及需要注意的一些Tips。 前期准备接入微信支付SDK前期需要许多前期准备。 微信开放平台 注册微信开放平台账号。 登录账号，进入管理中心，创建你的App应用，创建应用的包名与签名要与你实际的应用一致。 进入应用详情，获取AppID，以及申请开通微信支付能力。 等待审核通过。 微信商户平台 注册微信商户平台账号。 登录账号，在基本信息中获得微信支付商户号。 安装操作证书，然后进入API安全设置秘钥，最好使用UUID自动生成的，记住这个秘钥。OK，前期准备做完，下面进行代码接入。 工程接入SDK新建应用工程以AS为例，新建工程，注意包名与使用的签名要与微信开放平台申请应用时填写的一致。 引入libs将libammsdk.jar放到libs文件夹下。 配置debug、release的签名文件123456789101112131415signingConfigs &#123; debug &#123; storeFile file(\"你的keystore路径\") storePassword \"xxx\" keyAlias \"xxx\" keyPassword \"xxx\" &#125; release &#123; storeFile file(\"你的keystore路径\") storePassword \"xxx\" keyAlias \"xxx\" keyPassword \"xxx\" &#125; &#125; 这里debug、realse我采用的是一样的签名。不论是debug，还是release都能对应上。 AndroidManifest.xml中配置12345678910111213&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"你的AppID\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 也别忘记加入网络权限。 获取prepay_id在支付之前，都需要调用微信的接口https://api.mch.weixin.qq.com/pay/unifiedorder来获得prepay_id。 支付获取到prepay_id之后，调用IWXAPI的sendReq方法即可完成支付。 添加支付成功回调Activity添加wxapi的包名，在这个包名下必须要有WXPayEntryActivity这个Activity，支付成功后会显示此界面。 另外，声明此 Activity 需要添加如下属性：1234&lt;activity android:name=\".wxapi.WXPayEntryActivity\" android:exported=\"true\" android:launchMode=\"singleTop\" /&gt; 调用接口相关参数以及返回值参考开发者手册。 Tips下面说一下接入过程中需要注意的点。 官网下的demo，第一次支付时，能成功。之后就会一直支付失败。原因是：支付的时候商户唯一订单ID是唯一的，测试的时候请不断的更换订单ID参数支付。若要继续使用demo支付，可以微信清除数据、或者退出登录重新登录。 微信支付返回-1，一般是签名错误。这个签名有2种意思：1、Apk签名文件，debug与release最好使用同样的keystore；2、参数MD5签名生成的sign。要仔细检查是否正确。 签名、包名必须跟微信开放平台申请的一致. 获取prepay_id最好是在服务器完成，由服务器去跟微信服务器交互，客户端不需要参与，以免泄露重要信息。 与微信接口交互时，参数都需要签名。签名方法如下图：这里重点说一下。 参数名ASCII码从小到大排序（字典序） 参数名区分大小写，包括sign。 需要添加商户key值，这个key即是在前期准备中，我所说的微信商户的那个秘钥。 若接入过程中注意到这些Tips，一步一步来，那么应该是能支付成功了。","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"Hexo-Tools","date":"2016-03-17T10:14:16.000Z","path":"2016/03/17/hexo-tools/","text":"本文主要讲述一下使用Hexo搭建博客的过程中，使用的一些比较实用的工具。 七牛介绍在博客中若要插入图片，我们可以直接将图片放在本地。但是这样的话，在deploy的时候，图片也会上传至Github。但是Github上的空间只有300Mb，很有可能导致以后不够用，所以最好找一个图床。之前听说过七牛，便打算试一试。它： 注册之后实名制便有10G的免费空间，一段时间内是肯定够用的； 比较稳定； 有很多实用的工具，你可以使用； 更多的就待以后慢慢发现了~ 注册 去到七牛官网注册账户。 上传图片 创建空间。 长传图片。选择空间后，点击内容管理。点击上传文件。在长传文件时，建议加入路径前缀，方便后面进行查找。 使用图片 在七牛中预览图片，点击复制外链。 在Markdown中引用1![这里输入图片描述](图片外链地址) Atom介绍在代码编辑器、文本编辑器领域，有着不少的「神器」级的产品，如历史悠久的 VIM、Emacs 以及如今当红的 SublimeText。另外还有 EditPlus、NotePad++、UltraEdit 等一大堆流行的利器，可谓百家争鸣。 然而，作为目前全球范围内影响力最大的代码仓库/开源社区，GitHub 的程序员们并不满足于此。他们使用目前最先进流行的技术重新打造了一款称为“属于21世纪”的代码编辑器——Atom， 它开源免费跨平台，并且整合 GIT 并提供类似 SublimeText 的包管理功能，支持插件扩展，可配置性非常高…… ATOM - 由 GitHub 打造更为先进的编辑器 安装去到 Atom 官网，进行下载安装。 使用点击File–&gt;Open Folder…打开自己的工程。然后便可以随心所欲的编辑了~ Markdown编辑与预览 打开任意.md文件(Markdown源文件); windows下使用快捷键 ctrl + shift + p，打开命令输入框； 输入Markdown Preview Toggle(可以偷懒只输入mdpt，支持模糊匹配)。也可以通过菜单栏Packages-&gt;Markdown Preview-&gt;Toggle Treview。按enter键即可看到预览，左边编辑，右边实时预览。也可以直接使用快捷键Ctrl + Shift + M。 如此便能非常方便的编辑、预览我们的博客了。","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"Hexo-Tips","date":"2016-03-17T04:23:14.000Z","path":"2016/03/17/hexo-tips/","text":"本文主要讲述一下使用Hexo搭建博客的一些Tips。 hexo基本指令 hexo clean 清除 hexo new page “menu name” 新建菜单 hexo g == hexo generate 生成 hexo d == hexo deploy 部署 hexo s == hexo server 启动本地 hexo n == hexo new 新建 首页文章显示在md文件中添加&lt;!--more--&gt;，那么首页就只会显示这个标签之上的内容了，并显示一个阅读全文的按钮。 部署到Github保证README.md不被渲染 在Hexo目录下的source根目录下创建README.md文件,并编辑保存。 编辑Hexo目录的_config.yml文件中的“skip_render”参数。 1skip_render: README.md 部署到Github，然后看仓库是否有README.md。 博客基本配置打开hexo目录下的_config.yml文件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 听雪楼 #站点名，站点左上角subtitle: 那是一座悲欢离合聚集的楼。 #副标题，站点左上角description: #对站点的描述author: 最后的温存 #作者language: zh-Hans #语言timezone: #时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://lijia92.github.io/ #站点Urlroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next #主题插件# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署相关信息 type: git repository: https://github.com/LiJia92/LiJia92.github.io.git branch: master 分类与标签1.若已存在分类或标签，则直接修改。打开hexo/source/tags/index.md。修改为如下。123title: tagsdate: 2016-03-16 15:33:44type: \"tags\" 时间可随意修改，必须设置type字段为”tags”。分类也如此：123title: categoriesdate: 2016-03-16 15:33:56type: \"categories\" 2.若不存在，则直接新建，修改为1中所示即可。12$ hexo new page \"tags\"$ hexo new page \"categories\" index.md中不需要再额外写什么东西，它会根据你日志的分类、标签自动匹配。123456title: Windows使用Hexo + Github Pages搭建自己的博客date: 2016-03-17 11:30:45tags: - blog - hexocategories: hexo 主题hexo有许多主题可以选择，可以参考知乎回答选择自己喜欢的主题。我这里选择的是next主题。 下载主题使用Git Bash进入到hexo目录。输入指令下载主题：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 使用主题回到上面的_config.yml配置文件中，找到theme字段，修改成next主题：1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next Next主题相关语言hexo/_config.yml的配置中，language字段若要使用中文，需使用zh-Hans。 菜单hexo/themes/hexo-theme-next/_config.yml的配置中。menu是设置菜单，menu_icons是设置菜单对应的图标。这里对应的key都必须是一样的，大小写也有区分。1234567891011121314151617181920212223242526272829# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( \"/archives\" -&gt; \"archives\" )menu: home: / categories: /categories archives: /archives tags: /tags # about: /about commonweal: /404.html# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置个人信息hexo/themes/hexo-theme-next/_config.yml的配置中。将图像avatar.png放在hexo/themes/hexo-theme-next/source/images目录下。avatar–&gt;个人头像，author–&gt;昵称，description–&gt;描述12345avatar: /images/avatar.pngauthor: lastwarmthdescription: 如果要飞得高，就该把地平线忘掉 社交信息hexo/themes/hexo-theme-next/_config.yml的配置中。设置社交信息与icon，与菜单一样，key值需要完全对应，区分大小写。123456789101112# Social linkssocial: GitHub: https://github.com/LiJia92 Weibo: http://weibo.com/2950244271# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo Schemeshexo/themes/hexo-theme-next/_config.yml的配置中。Next主题有三种Scheme，可随意切换。123#scheme: Muse#scheme: Mistscheme: Pisces 网站图标与设置个人图像类似。12# Place your favicon.ico to /source directory.favicon: /images/avatar.png 集成多说hexo/themes/hexo-theme-next/_config.yml的配置中。设置duoshuo_shortname字段。12# Duoshuo ShortNameduoshuo_shortname: lastwarmth 这个ShortName怎么来？进入多说红色方框填写的即是ShortName 代码高亮hexo/_config.yml的配置中。修改auto_detect字段为true12345highlight: enable: true line_number: true auto_detect: true tab_replace: hexo/themes/hexo-theme-next/_config.yml的配置中。修改highlight_theme: normal字段。NexT使用Tomorrow Theme作为代码高亮，共有5款主题供你选择，可选的值有 normal，night， night blue， night bright， night eighties。12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 问题 本地预览没问题，deploy后主页显示大面积空白 点此 更多更多请查看 Next 官网","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"Windows使用Hexo + Github Pages搭建自己的博客","date":"2016-03-17T03:30:45.000Z","path":"2016/03/17/hexo-blog/","text":"本文主要讲述一下Windows环境使用Hexo + Github Pages搭建自己博客的一些主要步骤。 介绍Hexohexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在Github上。 A fast, simple &amp; powerful blog framework 超快的速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署：只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 丰富的插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Github PagesGitHub Pages本用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 Websites for you and your projects. Github Pages 有300M免费空间，资料自己管理，保存可靠； Github作为最大的同性交流社区，已经得到了人们的肯定； Github上有很多大牛，学着用 Github ，享受 GitHub 的便利，眼界会开阔很多。 前期准备安装Git去 Git 官网下载相应版本，进行安装即可。 安装Node.js去 NodeJs 官网下载相应版本，进行安装即可。 注册Github账号去 Github 官网进行注册即可。注册完之后记得添加 SSH Key。 搭建博客安装Hexo在本地新建一个blog文件夹，右键，选择Git Bash。输入指令安装Hexo： 1npm install -g hexo 等到完成之后，输入指令初始化Hexo： 1hexo init Hexo 完成之后，便能在blog文件夹下看到hexo文件夹了。 进入到hexo目录，输入指令npm install，安装依赖文件 12$ cd hexo$ npm install 安装完成之后，输入指令部署： 12$ hexo generate$ hexo server 此时打开浏览器，输入http://localhost:4000/便可看到最原始的博客了。 此时，Hexo已搭建完毕。 GitHub创建仓库登录Github，点击New respository。 输入仓库名：你的Github名称.github.io。然后点击Create repository。图中因为我已经创建，故给出提示，不用管。 托管到Github打开hexo配置文件_config.yml。 编辑deploy属性：repository属性改成你的git地址即可。 然后Git Bash进入到hexo文件夹，输入指令即可完成部署： 123$ hexo clean$ hexo generate$ hexo deploy 最后，打开你的github.io页面看下效果吧~","tags":[{"name":"blog","slug":"blog","permalink":"http://lijia92.github.io/tags/blog/"}]},{"title":"Android Studio 使用 Gradle 进行多渠道打包","date":"2016-03-09T06:39:58.000Z","path":"2016/03/09/gradle-pack/","text":"使用Android Studio也有一段时间了，最近项目开发完成，内部测试也已经通过。下一步就是渠道打包，然后上线了。 在出渠道包的时候，若是出一个包，便手动修改一次渠道号，很显然是很费时费力的。庆幸的是，Android Studio采用的Gradle可以很方便的实现我们的多渠道出包。 下面结合代码进行说明。 项目中使用的是友盟，在AndroidManifest.xml中有这样的代码：1&lt;meta-data android:name=\"UMENG_CHANNEL\" android:value=\"$&#123;UMENG_CHANNEL_VALUE&#125;\" /&gt; 其中${UMENG_CHANNEL_VALUE}中的值就是在gradle中自定义配置的值。 然后在项目的build.gradle中利用productFlavors进行多渠道的配置，在android节点下添加如下代码：1234567891011121314151617181920productFlavors &#123; official &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"official\"] &#125; baidu &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"baidu\"] &#125; _360 &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"_360\"] &#125; samsung &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"samsung\"] &#125; huawei &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"huawei\"] &#125; lenovo &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"lenovo\"] &#125; &#125; 项目实际情况，便是上线百度、360、三星、华为、联想这5个市场。 至此，所有的配置已经完成。下面开始编译出包了。 在Android Studio中打开Terminal：输入指令gradlew assembleRelease便可以生成所有的渠道包了。但是此次命令中使用的gradle版本无法控制，很有可能会去下其他的gradle版本，gradle的下载需要翻墙，若是没翻则会一直下载，耽误时间。这里我们直接ctrl+c，再输入y，终止操作。使用下面的方法。 先找到gralde的根目录，在系统变量里添加两个环境变量： 变量名为GRADLE_HOME，变量值就为gradle的根目录。在我的环境里，使用的gradle 2.2.1的版本，目录是C:\\Users***.gradle\\wrapper\\dists\\gradle-2.2.1-all\\c64ydeuardnfqctvr1gm30w53\\gradle-2.2.1。 然后在系统变量path里面添加gradle的bin目录%GRADLE_HOME%\\bin。 这里配置完成了，接着在Terminal中敲下gradle assembleRelease就可以一次性生成所有的渠道包了。build成功后，便可生成所有渠道的渠道包了。若是想单独生成某一个渠道包，先打开Android Studio右侧的Gradle栏：点到相应项目的build task中。要生成什么渠道包，双击相应的栏目即可。 改进：将productFlavors改成如下，更加简洁些：123456789101112productFlavors &#123; \"official\" &#123;&#125; \"baidu\" &#123;&#125; \"_360\" &#123;&#125; \"samsung\" &#123;&#125; \"huawei\" &#123;&#125; \"lenovo\" &#123;&#125; &#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125;","tags":[{"name":"gradle","slug":"gradle","permalink":"http://lijia92.github.io/tags/gradle/"}]},{"title":"Android实现渐变title栏","date":"2016-03-02T02:03:48.000Z","path":"2016/03/02/change-title/","text":"最近用美团外卖点餐看到这样一个效果： 顶部的title栏伴随着滑动有这样的一个效果，看起来很不错。 正好项目中可能需要用到，于是打算自己实现一波。 后面在百度、谷歌之后，发现ToolBar+CoordinatorLayout可以很轻易的实现这种效果。 但是在项目中，并没有采用Android新特性的一些东西，所以就得基于目前状况想办法了。 先上一下最终的效果图： 项目中并没有使用ToolBar这种控件，而是全部自己写的xml文件当做title，整个页面又是由ListView构成。顶部的遮罩背景是添加的一个HeaderView。 贴一下这个页面的布局：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#ffffff\" android:orientation=\"vertical\"&gt; &lt;ListView android:id=\"@+id/share_list\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:divider=\"@null\" android:scrollbars=\"none\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;FrameLayout android:id=\"@+id/profile_header\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/activity_head_normal_height\" android:background=\"#00ffffff\"&gt; &lt;ImageView android:id=\"@+id/profile_play_entry\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" android:layout_gravity=\"center_vertical|right\" android:scaleType=\"center\" android:src=\"@drawable/play_entry\" /&gt; &lt;TextView android:id=\"@+id/profile_page\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"我的\" android:textColor=\"#ffffff\" android:textSize=\"16sp\" /&gt; &lt;/FrameLayout&gt; &lt;View android:id=\"@+id/divider\" android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"@color/dark_gray\" /&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; 使用了一个布局固定在顶部，利用FrameLayout进行遮盖。那么要怎么样实现图中的效果呢？ 起初，我是想着自定义View，然后重写onTouchEvent事件，但是后面考虑到滑动距离，上滑、下滑等等很多可能性之后，可能需要各种各样的逻辑判断，会显得非常复杂，所以便放弃了这种思路。 后面考虑到，其实我只需要获得到ListView顶端滑出屏幕的纵向距离，然后计算alpha值，赋给title的父布局应该就可以实现了。 若是使用ScrollView，则会有个方法getScrollY可以直接获得到滑出的Y值，但是ListView我试了一下，获得的Y值总是0，所以得另想办法了。 在网上找到这样的一个方法：123456789public int getScrollY() &#123; View c = mListView.getChildAt(0); if (c == null) &#123; return 0; &#125; int firstVisiblePosition = mListView.getFirstVisiblePosition(); int top = c.getTop(); return -top + firstVisiblePosition * c.getHeight() ;&#125; 就是通过item高度，以及第一个child的top值来计算出滑出的距离。 结合这个思路，写出如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private AbsListView.OnScrollListener mScrollListener = new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE &amp;&amp; !nothingToLoad) &#123; // 如果到达最后一行 if (shareList.getLastVisiblePosition() == shareList.getAdapter().getCount() - 1) &#123; loadMore(); // 加载更多 &#125; &#125; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; float scrollY = getScrollY(); float alpha = getAlpha(scrollY); profilePage.setAlpha(alpha); if (alpha &gt; 0.5) &#123; // alpha &gt; 0.5设置黑色图标 if (isWhite) &#123; entryPlay.setImageResource(R.drawable.play_entry1); profilePage.setTextColor(Color.BLACK); ObjectAnimator animator = ObjectAnimator.ofFloat(entryPlay, \"alpha\", 0.5f, 1); animator.setDuration(1000); animator.start(); &#125; isWhite = false; &#125; else &#123; // 否则设置白色 if (!isWhite) &#123; entryPlay.setImageResource(R.drawable.play_entry); profilePage.setTextColor(Color.WHITE); ObjectAnimator animator = ObjectAnimator.ofFloat(entryPlay, \"alpha\", 0.5f, 1); animator.setDuration(1000); animator.start(); &#125; isWhite = true; &#125; if (Math.abs(alpha - 1) &lt; 0.03) &#123; divider.setVisibility(View.VISIBLE); &#125; else &#123; divider.setVisibility(View.GONE); &#125; header.setBackgroundColor(Color.argb((int) (alpha * 255), 255, 255, 255)); &#125; &#125;; /** * 计算ListView顶部滑动Y值 * * @return */ public float getScrollY() &#123; float scrollY; View c = shareList.getChildAt(0); if (c == null) &#123; return 0; &#125; int firstVisiblePosition = shareList.getFirstVisiblePosition(); int top = c.getTop(); if (firstVisiblePosition &gt; 0) &#123; scrollY = mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height); // 当HeaderView完全滑出时，alpha值为1，直接设置其高度值 &#125; else &#123; scrollY = -top; &#125; if (scrollY &gt; mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height)) &#123; scrollY = mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height); &#125; return scrollY; &#125; /** * 根据滑动Y值计算alpha值 * * @param scrollY * @return */ public float getAlpha(float scrollY) &#123; if (mHeaderView.getHeight() != 0) &#123; return scrollY / (mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height)); &#125; return 0; &#125; activity_head_normal_height就是title栏的高度，所以能够滑动的最高距离是ListView的HeaderView的高度减去title的高度，当滑出高度大于这个高度，alpha直接就等于1了。 通过上述代码，即可实现之前的效果了。 疑问： 当HeaderView完全滑出的时候，c.getHeight() != mHeaderView.getHeight()，按理说c应该是跟mHeaderView是一致的； 在滑动过程中，白色变黑色如何能够让它更自然的过渡呢（图标、文字）？目前是alpha = 0.5这个阈值，直接由白变黑，由黑变白，显得不太自然。 欢迎网友们一起探讨~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android实现简易轻量下载器：单线程任务队列","date":"2016-02-23T03:40:10.000Z","path":"2016/02/23/single-thread-queue/","text":"最近的项目是一个与音乐相关的App，其中有一个功能：收藏喜欢的歌曲，在wifi的环境下自动下载。 考虑到音乐歌曲都是3、4Mb的小文件，断点下载的功能便不需要了。因此只需要实现一个特别轻量、简单的下载管理类，进行管理即可。 最初的思路便是任务队列，单线程顺序执行，一个文件接着一个文件进行下载。 之前看过AsyncTask的部分源码，其设计与我的想法类似，于是便借鉴着AsyncTask的源码，实现了一个特别简单、轻量的下载管理类。 源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class MyDownloadManager &#123; private static final String TAG = \"MyDownloadManager\"; private File downloadDir; // 文件保存路径 private static MyDownloadManager instance; // 单例 // 单线程任务队列 public static Executor executor; private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"MyDownloadManager #\" + mCount.getAndIncrement()); &#125; &#125;; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;&gt;(128); public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(1, 1, 1, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); private MyDownloadManager() &#123; // 初始化下载路径 downloadDir = new File(AndroidCacheUtils.getCacheDirFile(MiaApplication.getInstance()), \"download\"); if (!downloadDir.exists()) &#123; downloadDir.mkdirs(); &#125; executor = new SerialExecutor(); &#125; /** * 顺序执行下载任务 */ private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; /** * 获取单例对象 * * @return */ public static MyDownloadManager getInstance() &#123; if (instance == null) &#123; instance = new MyDownloadManager(); &#125; return instance; &#125; /** * 添加下载任务 * * @param path */ public void addDownloadTask(final String path) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; download(path); &#125; &#125;); &#125; /** * 下载文件 * * @param path */ private void download(String path) &#123; String fileName = AndroidMD5.MD5(path); File savePath = new File(downloadDir, fileName); // 下载文件路径 File finallyPath = new File(downloadDir, fileName + \".mp3\"); // 下载完成后加入.mp3后缀 if (finallyPath.exists()) &#123; // 文件存在则已下载 Log.i(TAG, \"file is existed\"); return; &#125; if (AndroidNetWorkUtils.isWifiDataEnable(MiaApplication.getInstance())) &#123; // 如果是Wifi则开始下载 if (savePath.exists() &amp;&amp; savePath.delete()) &#123; // 如果之前存在文件，证明没有下载完成，删掉重新创建 savePath = new File(downloadDir, fileName); &#125; Log.i(TAG, \"download start\"); try &#123; byte[] bs = new byte[1024]; int len; URL url = new URL(path); InputStream is = url.openStream(); OutputStream os = new FileOutputStream(savePath); while ((len = is.read(bs)) != -1) &#123; os.write(bs, 0, len); &#125; os.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (savePath.renameTo(finallyPath)) &#123; // 下载完成后重命名为.mp3文件 Log.i(TAG, \"download end\"); EventBus.getDefault().post(new DownloadDoneEvent(path)); &#125; &#125; else &#123; // 不是wifi则不下载 Log.i(TAG, \"not wifi net, stop download\"); &#125; &#125; /** * 添加删除任务 * * @param path */ public void addDeleteTask(final String path) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; delete(path); &#125; &#125;); &#125; /** * 删除本地文件 * * @param path */ private void delete(String path) &#123; String fileName = AndroidMD5.MD5(path); File savePath = new File(downloadDir, fileName + \".mp3\"); Log.i(TAG, savePath.getPath()); if (savePath.exists()) &#123; if (savePath.delete()) &#123; Log.i(TAG, \"file is deleted\"); &#125; &#125; &#125; /** * 返回下载路径 * * @return */ public File getDownloadDir() &#123; return downloadDir; &#125;&#125; 我们看到public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(1, 1, 1,TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);，这句代码便是创建一个线程池。其方法源码及参数说明：12345678910111213141516171819202122232425262728293031323334/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default rejected execution handler. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; 这里我前三个参数传的都是1，既是最多只有1个线程。sPoolWorkQueue参数则是一个容量为128的任务队列，既最多能存放128个任务。 下面我们看到SerialExecutor的代码，它有一个Runnable队列mTasks ，不断的接受Runnable对象，并通过poll操作，每次取出顶部的Runnable进行执行。结合创建的单一线程池，便实现了我需要的简易、轻量的下载器。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"},{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"}]},{"title":"Android实现照片墙背景","date":"2016-02-17T09:34:49.000Z","path":"2016/02/17/photo-wall/","text":"项目开发中，有一个这样的需求：在个人主页里会有12张图片的背景墙。这12张图片由服务器返回，会不定时刷新。 第一种方案起初，自己的实现思路是：xml直接定义12个ImageView，然后在接收到图片路径后，再进行异步加载。 显然，这种方法是肯定可以的，但是却显得不“优雅”。而且后续可能会对这整个背景墙有个缩放的动画之类的，那么再实现起来便会比较复杂了。 第二种方案之后，我想到了GridView，显然也是可以的，在得到图片路径后传入到Adapter中即可。比起方案一稍微“优雅”些，但是也是很难将这个背景墙当成一个整体，进行将来可能会添加的动画特效需求。 第三种方案最后，我想到，既然要当成一整个整体，那么自定义View或许是个不错的办法。 思路思路是这样的： 首先ImageView展示初始图片； 下载图片； 所有图片下载完成后刷新View，显示下载的图片墙。 下面上代码。 代码自定义ImageView：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class JointImageView extends ImageView &#123; private Paint mPaint;// 画笔 private List&lt;Bitmap&gt; bitmaps;// 位图 private List&lt;Rect&gt; rectList; // 正方形画bitmap private int width; // 边长 private static int pictureInRow = 4; // 每一行显示4张图片 public JointImageView(Context context) &#123; super(context); &#125; public JointImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); &#125; /** * 设置Bitmap数据 * * @param bitmaps */ public void setBitmaps(List&lt;Bitmap&gt; bitmaps) &#123; this.bitmaps = bitmaps; width = getMeasuredWidth() / pictureInRow; createRect(); postInvalidate(); // 在设置Bitmaps之后重绘 &#125; private void createRect() &#123; // 计算12个矩形的坐标 rectList = new ArrayList&lt;&gt;(AppConfigs.PROFILE_PICTURE_NUM); for (int i = 0; i &lt; AppConfigs.PROFILE_PICTURE_NUM; i++) &#123; Rect rect = new Rect((i % pictureInRow) * width, (i / pictureInRow) * width, (i % pictureInRow + 1) * width, (i / pictureInRow + 1) * width); rectList.add(rect); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; if (bitmaps == null) &#123; super.onDraw(canvas); &#125; else &#123; for (int i = 0; i &lt; bitmaps.size(); i++) &#123; if (bitmaps.get(i) != null) &#123; canvas.drawBitmap(bitmaps.get(i), null, rectList.get(i), mPaint); // 画图 &#125; &#125; &#125; &#125;&#125; 布局文件中使用：123456&lt;com.android.widget.JointImageView android:id=\"@+id/my_profile_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scaleType=\"centerCrop\" android:src=\"@drawable/background\" /&gt; 项目中使用的Universal-Image-Loader三方库进行图片的加载。 下载图片的异步任务代码：1234567891011121314151617181920212223242526272829303132private class BitmapLoaderTask extends AsyncTask&lt;String[], Integer, List&lt;Bitmap&gt;&gt; &#123; private List&lt;Bitmap&gt; bitmaps; public BitmapLoaderTask() &#123; bitmaps = new ArrayList&lt;&gt;(AppConfigs.PROFILE_PICTURE_NUM); &#125; @Override protected List&lt;Bitmap&gt; doInBackground(String[]... params) &#123; ImageSize imageSize = new ImageSize(80, 80); // 图片压缩到80*80的大小 for (int i = 0; i &lt; params[0].length &amp;&amp; i &lt; AppConfigs.PROFILE_PICTURE_NUM; i++) &#123; // 使用UIL同步下载图片的方法下载图片，存到bitmap数组 Bitmap bitmap = ImageLoader.getInstance().loadImageSync(params[0][i], imageSize); bitmaps.add(bitmap); &#125; return bitmaps; &#125; @Override protected void onPostExecute(List&lt;Bitmap&gt; bitmaps) &#123; // 全部下载完毕，通知View进行重绘 if (bitmaps != null &amp;&amp; bitmaps.size() == AppConfigs.PROFILE_PICTURE_NUM) &#123; profileBackground.setBitmaps(bitmaps); &#125; &#125; @Override protected void onCancelled() &#123; super.onCancelled(); &#125;&#125; 通过方案三，在实现当下需求的同时，也可以作为一个单独的View，在将来拓展可能的缩放等特效动画。 但是也有一个缺点：必须所有的图片下载完毕才进行刷新。 当然，也可以将刷新策略调整成下载一张刷新一次，这个就得看具体的需求了。 题外话对于图片中的阴影效果，我们可以采用alpha背景来实现。也可以通过色彩矩阵在绘制的时候进行调整。 通过alpha背景实现很简单，在FrameLayout上遮罩一个View，alpha设置成相应的值即可。12345&lt;View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:alpha=\"0.7\" android:background=\"#000000\" /&gt; 通过色彩矩阵就得不停的调整了。12345678// 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); // 画笔设置色彩矩阵，这样再绘制的时候就会有效果了","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"使用Android新特性：Material Design","date":"2016-02-17T08:34:11.000Z","path":"2016/02/17/material-design/","text":"前言大年初十，相信许多人都已经过完年，在上班的路上或者已经上班了。在这里跟大家说一声：新年好~ 新年新气象，今天打算写一篇关于Android新特性：Material Design的文章。Material Design作为android 5.0的重头戏，说是新特性，但是其实已经算不上“新”了，毕竟android 6.0都出来了呢。 情人节刚过，我便以“秀恩爱”为主题，做一个新特性的使用例子。废话少说，下面开撸。 添加依赖使用新特性需要添加依赖：123compile 'com.android.support:design:23.0.1'compile 'com.android.support:cardview-v7:23.1.0'compile 'com.android.support:recyclerview-v7:23.1.0' 新组件介绍AppBarlayoutAppBarLayout是继承LinearLayout实现的一个ViewGroup容器组件，它是为了Material Design设计的App Bar,支持手势滑动操作。默认的AppBarLayout是垂直方向的，它的作用是把AppBarLayout包裹的内容都作为AppBar。 常用效果：将Toolbar 和Tablayout的组合部分共同构成 AppBar的效果。 CoordinatorLayoutCoordinatorLayout是一个增强型的FrameLayout。它的作用有两个： 作为一个布局的根布局 最后一个为子视图之间相互协调手势效果的一个协调布局 我们可以用过上滑将顶部的ToolBar移出屏幕，下滑时再显示。 NavigationView用于侧滑菜单中的menu布局。 FloatingActionButton悬浮按钮，给人一种Z轴的空间感。 SnackBar当Snackbar在显示的时候，往往出现在屏幕的底部。为了给Snackbar留出空间，浮动操作按钮需要向上移动。 CardViewCardView继承自FrameLayout类，可以在一个卡片布局中一致性的显示内容，卡片可以包含圆角和阴影。CardView是一个Layout，可以布局其他View。 RecyclerViewRecyclerView用于展示数据集，与ListView、GridView类似，但是它更灵活。 SwipeRefreshLayoutGoogle官方推出的下拉刷新控件，使用非常简便。 布局文件首先是activity_main布局文件：12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/content_main\" /&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/navigation\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"left\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 看到content_main.xml：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\" app:title=\"\" /&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tab_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabGravity=\"fill\" app:tabIndicatorColor=\"#ffffff\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/view_pager\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/floating_button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; ViewPager对应的fragment布局：123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/swipe_refresh\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; RecyclerView对应的Adapter布局：1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" app:cardCornerRadius=\"4dp\" app:cardElevation=\"5dp\" app:cardMaxElevation=\"10dp\" app:cardPreventCornerOverlap=\"true\" app:cardUseCompatPadding=\"true\"&gt; &lt;TextView android:id=\"@+id/card_text\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:layout_gravity=\"center\" android:gravity=\"center\" android:text=\"1111\" android:textColor=\"@android:color/black\" android:textSize=\"30sp\" /&gt;&lt;/android.support.v7.widget.CardView&gt; 抽屉对应的HeaderView布局：123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"220dp\" android:background=\"@drawable/ic_user_background\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/id_header_face\" android:layout_width=\"120dp\" android:layout_height=\"120dp\" android:scaleType=\"fitXY\" android:src=\"@drawable/user\" /&gt; &lt;TextView android:id=\"@+id/id_header_authorname\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_name\" android:textColor=\"@android:color/black\" android:textSize=\"16sp\" /&gt; &lt;TextView android:id=\"@+id/id_header_url\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_url\" android:textColor=\"@android:color/black\" android:textSize=\"18sp\" /&gt;&lt;/LinearLayout&gt; 相关说明 使用NavigationView时，通过layout_gravity=&quot;left&quot;属性控制抽屉从左边打开。抽屉内容填充对应于xml属性app:headerLayout与app:menu。 12345678// 跳转到Menu的ToggleActionBarDrawerToggle mActionBarDrawerToggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.drawer_open, R.string.drawer_open);mActionBarDrawerToggle.syncState();drawerLayout.setDrawerListener(mActionBarDrawerToggle);// 抽屉菜单填充内容navigationView.inflateHeaderView(R.layout.header_navigation);navigationView.inflateMenu(R.menu.menu_navigation); TabLayout与ViewPager关联。 123tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);tabLayout.setupWithViewPager(viewPager);tabLayout.setTabsFromPagerAdapter(myViewPagerAdapter); SwipeRefreshLayout刷新设置颜色及刷新事件。 123swipeRefreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.swipe_refresh);swipeRefreshLayout.setColorSchemeResources(R.color.colorPrimary);swipeRefreshLayout.setOnRefreshListener(this); RecyclerView设置布局及Adapter。 12345RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);adapter = new MyRecyclerViewAdapter(getActivity());RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false);recyclerView.setAdapter(adapter);recyclerView.setLayoutManager(layoutManager); CoordinatorLayout可滑动的条件。 CoordinatorLayout必须作为整个布局的父布局容器。 给需要滑动的组件设置 app:layout_scrollFlags=”scroll|enterAlways” 属性。 (ToolBar) 给你的可滑动的组件，也就是RecyclerView、ViewPager或者 NestedScrollView 设置属性：app:layout_behavior=@string/appbar_scrolling_view_behavior 设置的layout_scrollFlags有如下几种选项： scroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。 enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 滚动退出屏幕，最后折叠在顶端。 在我的布局中给Toolbar设置了app:layout_scrollFlags属性，因此，Toolbar是可以滚动出屏幕，且向下滚动有可以出现。 最后最终效果：源码地址：https://github.com/LiJia92/showlove Tips：本文只对这些新的特性做了最基本的说明及非常简单的使用，至于更加复杂的使用及效果，则需要在使用过程中慢慢发现、慢慢学习了。","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://lijia92.github.io/tags/Material-Design/"}]},{"title":"React Native For Android初探-问题小结","date":"2016-01-19T03:38:48.000Z","path":"2016/01/19/react-native-tips/","text":"在上一篇文章中，我介绍了React Native For Android的基本使用。这篇文章重点介绍一下使用过程中碰到的问题以及解决办法。 真机运行白屏在执行react-native run-android指令编译安装apk到真机之后，运行程序，发现程序白屏，感觉像ANR一样。解决方法：手机设置中打开应用管理，选择我们安装的应用。然后点击权限管理，将显示悬浮框设置为允许。白屏问题便能解决了。 真机运行提示Unable to download JS bundle在我们解决完白屏问题之后，重新运行程序，发现程序能运行了，但是报错了：点击Reload JS后，提示Unable to download JS bundle：解决方法：摇晃设备或按Menu键，可以打开调试菜单，点击DevSettings，选Debug server host for device，输入你的正在运行packager的那台电脑的局域网IP加:8081（同时要保证手机和电脑在同一网段，且没有防火墙阻拦），再按back键返回，再次打开Menu键，在调试菜单中选择Reload JS，就可以看到运行的结果了。 Chrome调试JS 安装拓展程序React Developer Tools。 在模拟器或真机菜单中选择Debug JS，打开调试开关。 Chrome打开：http://localhost:8081/debugger-ui，按F12打开开发者工具便能进行调试。","tags":[{"name":"hybrid开发","slug":"hybrid开发","permalink":"http://lijia92.github.io/tags/hybrid开发/"}]},{"title":"React Native For Android初探","date":"2016-01-15T09:20:02.000Z","path":"2016/01/15/react-native/","text":"介绍Facebook 在 React.js Conf 2015 大会上推出了基于 JavaScript 的开源框架 React Native。React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。 React Native enables you to build world-class application experiences on native platforms using a consistent developer experience based on JavaScript and React. The focus of React Native is on developer efficiency across all the platforms you care about — learn once, write anywhere. Facebook uses React Native in multiple production apps and will continue investing in React Native. React Native 使你能够使用基于 JavaScript 和 React 一致的开发体验在本地平台上构建世界一流的应用程序体验。React Native 把重点放在所有开发人员关心的平台的开发效率上——开发者只需学习一种语言就能轻易为任何平台高效地编写代码。Facebook 在多个应用程序产品中使用了 React Native，并将继续为 React Native 投资。 对于不太了解React Native是什么以及Facebook为什么要创建React Native，可以先看看这篇博客。 Facebook 于 2015 年 9 月 15 日发布了 React Native for Android， 把 Web 和原生平台的 JavaScript 开发技术扩展到了 Google 的流行移动平台–Android。 最近项目技术负责人说可能以后我们也会使用这套框架进行App开发，所以便预先学习一下，顺便做下笔记，分享给大家。 实践安装Node.jsreact native依赖Node.js，第一步便是下载Node.js。去官网下载，对应电脑系统版本。我是Win 10，下载的64位。下载完成后，直接安装。 可以随意创建一个一个test.js，来测试Node.js是否安装成功。123456789var http = require(\"http\");http.createServer(function(req, res) &#123; res.writeHead( 200 , &#123;\"Content-Type\":\"text/html\"&#125;); res.write(\"&lt;h1&gt;Node.js&lt;/h1&gt;\"); res.write(\"&lt;p&gt;Hello World&lt;/p&gt;\"); res.end(\"\");&#125;).listen(8080);console.log(\"HTTP server is listening at port 8080.\"); 然后进入到响应的目录，执行cmd，键入命令：node test.js，然后浏览器打开”localhost:8080”，显示如下则是安装成功。 安装native环境使用npm指令安装react-native-cli。打开命令行，执行指令：1npm install -g react-native-cli react-native-cli是用来开发React Native的命令行工具。你需要使用npm来安装它。上面这行代码将会帮助你在terminal中安装react-native命令。这行cmd命令只需要执行一次，后面便可持续使用。 下面便可以开始创建我们的React Native项目了。 创建项目创建好自己的文件夹之后，cmd命令进入文件夹，执行命令：1react-native init HelloWorld HelloWorld便是项目名，可自己随意取。执行完毕之后便会生成HelloWorld文件夹。目录结构是这样的：可以看到生成的项目既包含IOS，也包含Android。因为我是Android开发，所以就暂时不管IOS了。 运行项目在命令行执行完毕之后，我们会看到To run your app on Android的提示。进入到HelloWorld文件夹，执行命令：1react-native run-android 图上所示便是在进行编译，准备安装了。编译成功后，安装运行，界面如下：提示不能下载JS bundle。这里我们注意一下编译时的黄色提示：Starting the packager in a new window is not supported on Windows yet.Please start it manually using &#39;react-native start&#39;.就是说不支持在Windows上自动开启packager，需要我们自己先启动。 照着提示来，执行命令：1react-native start 可以看到React packager ready. OK，再来运行我们的程序。此时界面变显示正常了：同时React packager会打印一些信息：很多东西都还不懂，暂时就先不管了，后面再慢慢了解，至少现在看起来没出什么错。 js代码初探下面便来研究一下显示到界面上的内容到底是怎么来的。 看到HelloWolrd文件夹下有index.android.js文件，编辑器打开，看到的代码是这样的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Sample React Native App * https://github.com/facebook/react-native */'use strict';import React, &#123; AppRegistry, Component, StyleSheet, Text, View&#125; from 'react-native';class HelloWorld extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Shake or press menu button for dev menu &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld); 此时，对着代码与界面，我们便可以大胆的猜测界面上显示的文字就是HelloWorld class中对应的3个Text标签了。下面尝试一下： HelloWorld class代码改成如下：1234567891011class HelloWorld extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Hello World! &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 我们把之前3个Text标签去掉，写一个显示Hello World的Text标签。那么改好之后如何看到效果呢？？？请注意，这便是React Native框架非常厉害的地方，你不需要重新编译安装apk，更新包等操作，直接虚拟机点出Menu，点击Roload JS即可实现更新：可以看到，界面确实是变成了我们预想的样子。 下面我从官网复制了一份index.android.js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * Sample React Native App * https://github.com/facebook/react-native */'use strict';var React = require('react-native');var &#123; AppRegistry, Image, ListView, StyleSheet, Text, View,&#125; = React;var API_KEY = '7waqfqbprs7pajbz28mqf6vz';var API_URL = 'http://api.rottentomatoes.com/api/public/v1.0/lists/movies/in_theaters.json';var PAGE_SIZE = 25;var PARAMS = '?apikey=' + API_KEY + '&amp;page_limit=' + PAGE_SIZE;var REQUEST_URL = API_URL + PARAMS;var AwesomeProject = React.createClass(&#123; getInitialState: function() &#123; return &#123; dataSource: new ListView.DataSource(&#123; rowHasChanged: (row1, row2) =&gt; row1 !== row2, &#125;), loaded: false, &#125;; &#125;, componentDidMount: function() &#123; this.fetchData(); &#125;, fetchData: function() &#123; fetch(REQUEST_URL) .then((response) =&gt; response.json()) .then((responseData) =&gt; &#123; this.setState(&#123; dataSource: this.state.dataSource.cloneWithRows(responseData.movies), loaded: true, &#125;); &#125;) .done(); &#125;, render: function() &#123; if (!this.state.loaded) &#123; return this.renderLoadingView(); &#125; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderMovie&#125; style=&#123;styles.listView&#125; /&gt; ); &#125;, renderLoadingView: function() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt; Loading movies... &lt;/Text&gt; &lt;/View&gt; ); &#125;, renderMovie: function(movie) &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Image source=&#123;&#123;uri: movie.posters.thumbnail&#125;&#125; style=&#123;styles.thumbnail&#125; /&gt; &lt;View style=&#123;styles.rightContainer&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;,&#125;);var styles = StyleSheet.create(&#123; container: &#123; flex: 1, flexDirection: 'row', justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, rightContainer: &#123; flex: 1, &#125;, title: &#123; fontSize: 20, marginBottom: 8, textAlign: 'center', &#125;, year: &#123; textAlign: 'center', &#125;, thumbnail: &#123; width: 53, height: 81, &#125;, listView: &#123; paddingTop: 20, backgroundColor: '#F5FCFF', &#125;,&#125;);AppRegistry.registerComponent('AwesomeProject', () =&gt; AwesomeProject); 然后Reload JS，界面如下：呀，出错了。我们看到是在registerComponent的时候出错了。想起来我们的项目名称是HelloWorld，将最后一句代码改掉。1AppRegistry.registerComponent('HelloWorld', () =&gt; AwesomeProject); Reload JS。加载完毕后的显示界面：但是将代码改成：1AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld); 执行又出错了：看来东西不能乱改呀，至于是什么原因，就放在以后慢慢去发现去解决了。另外这种JS代码的写法也是需要在实践中慢慢积累，学习，才能逐步掌握。 今天就到这里了，代码都是自动生成的，便不上传了。Have a nice weekend~","tags":[{"name":"hybrid开发","slug":"hybrid开发","permalink":"http://lijia92.github.io/tags/hybrid开发/"}]},{"title":"Android Hybrid开发实战之图片的交互","date":"2016-01-14T06:32:59.000Z","path":"2016/01/14/hybrid-practice/","text":"前言最近一直在学习Hybrid开发，如何在H5页面调用Android原生接口，并返回值，以及回调。学习了一段时间，总算是有点收获，效果也做出来了。于是写下这篇博客，记录一下。 本文中我以2个接口示例，来进行讲解。第1个示例很简单，就是调用接口，返回登录Token；第2个示例是H5调用接口，弹出Android原生界面进行图片选择，选择完之后返回选择图片的Base64格式的字符串。然后H5页面接收返回的字符串，回调进行图片显示。 Base64首先，讲解一下Base64。图片也是一个文件，可以通过Base64返回这个文件的Base64字符串，这个字符串可以直接放到H5的img标签进行显示。 下面做个示例，方便大家了解。新建一个Html文件，编写代码如下：1234567&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAAwCAMAAAChd4FcAAAAA3NCSVQICAjb4U/gAAACRlBMVEUAAADi6OSMjIxSUlIrXja5trg8rFEDRhErokJ8w4pJrVxmZmYERRIinTn++P07nk/X0Naww7Stra0pdTj37/dlunUXWiS53L+ZmZmOy5pahGJKdVIQEBAsXzdni24VmC7MzMw1kEYzMzPZ4Nul1K6Wr5tWs2jp8eseaC0ufz5mZmaEoorI1cszpUkXTSJErFix2bi1tbVKSkp7e3skWC9wvn5zlHq6yL3S3dSXzqJBcEspKSnY6dxCQkLI486mvKulpaVAbUkTSx8ICAgjcDIhISHh7eM6Ojonnz1QsGP///+Dxo9Re1paWlqNqZOZzJmasJ6s1rMZGRk4pkx5wYYcYyodmzViuHPFxcVEtFl5mH/V3def0qlhh2rZ7d7F2MiEhIQ4Z0Lv8+/F4csvo0QbUidAp1OEoIoqfDozZjOx27kOSho6mkw2j0iftaMyi0S2xroSUiBrvHuFx5J0v4Lm7+eNqJOc0KVBq1TU59gpoEBskXRzc3Pg2N6tubDe5d99nYRNr1+ZmZkbWyg9pFHN18779/patWuZzJkzZT6Sq5e0xbfAz8OtvbUhazC12ryJpY6+3sXD0MbE4MmJyJUgVCtSsmXQ5tWjuKd5wobd8OEfYy0ZUCS9vb3v7+8LRxgtgD0xZzw1j0cnWjJiimp2mX2An4aUtZye1qkYmjDm5ube3t7W1tbk9+fM5NA4lEombjRWfl9Ke1K2270xhUGbs6BrjnI7akSY1aSrvq+5yr1Kc0q8zL/19fVrvXMxYjt5mX+1vbVNR7MSAAAACXBIWXMAAAsSAAALEgHS3X78AAAAFnRFWHRDcmVhdGlvbiBUaW1lADAzLzI0LzEzWoVZMQAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNXG14zYAAAt9SURBVFiFzZn/U9NoHsfDl3KFXgOWAQtUL0Kh7EiF0sUFSqG0UsoDdYQgxBM9zUbOubIo2C7feoeM8HRWdjiqq7jnJuyt685d2ivrCHg4ZvRPuydJW5ICCj/s6WeYJn1Kklfen29PnmDCJ27YAeMQwv8rx4G2DyAEyNAWR5uPT7kHEICs16vbL1pbW/vmzr+xfHTGDEAgHLuSe2biXu25c+dqSycmTpxcFj4uogoQwPFXgdKbG4vT9aJNL27cLHV3dkDwsegENSB4UBGo3ZhW21dPAxV1H5FwFxDC1TOlG0i3TDtV+kO12s0ofZJpLn4kE16K1nTuox1pHMeTBzy4i3Ju/As5AY8Q2WlAXPh5vXh0L55oxetzyqoDLl+4DHie4CC9FIccH4+JJA8uzEOhqAh9hzzPxWIwViTAeYJHv4HmC6Fvy1+/xuuqqurGq3DLkyfcUQFx4UXg1qV98ZBtrl/ZJcSX+t51NrMG1sCxlIaIGSlXHIJjfavlNMsaiJgGUAQaImw2NqYhDDyE3/ad7Vu+fvrV7dM7z/vOtoa2V8tPHjZqUoDwSuCnA/mmL90KbKe9AubGwdd3qTjQsC6KdRUhIArHb3f++fa8AXCGOCsCLgEDh3M2G+GiADi5A0LL5eDC6urO2WXQd7luZ67isD5OAoLT6wfrJ2t4PnXPYHsL3P8FASK9+FhMBEKAVcvVr/6mAZytSFJwCSLAmIHi4/MQnOwAdePboPr86s4fl0H5t+Vbq334kQDBa/fN9/KhODzzIEmIP+h811fFulgNbWBZKi4ruNx6/0WzRmMjOBflWqIIQBk0bNxA2JCL37Q+f9FxBdxfPd1x9hh48UXF+Z9bD8knA0L61cX34yG7lz4naN6qAhoiTkO6qEiQkgJh112oAnRRDEI+znM8SoJ4PJ0kS1shrhnOz1dlXeaFJaF5/PISfRRA8HVgbP/8VdhGoDrlZBxAyMbEb4rkTpcZCFMlKF1m0G9y3RE3QOryR1EQWt7+mslXv7cgrlynD4hs/ICAOmhcZpa3H2pTIiDY2iPg2KlTGxlF8VKh+4l8Mohn2FobLii/p06+ZtlFxdX/AClKPlmMSvKqTa1gRUYEbpa6f/jBXfrZ6KhisPDH3/0sHQfXyloUVhYNkWQDaJhsStpkr6w03q+/k2JtKFMdASHn8UiEoBsj0BYSOpVlKwFB86NNZQovPj1z5djS0u25G/cK0yKeWnE/Kl+SLxz8g17PMD69Xj9rZfRDBUIZw7QUMLOzswxJarU+0ivJBKb0+UBWrJ1h9LumJdsAsGOVUtA6MI3Y+5yY2mJAATg+UahK19w3ssx1128syg4XJzVfVyWFhwmkQkFe71TLSNAamWqJ4ng/OVlQcDyRKGMi7e0Pr+IJc39/f0OQGW5AW/NxPMrUNKTspbmAvFqUnW3qMoqOrUQKShun/do1u2jhHLvdBZUKzpUqXVn8aClJD+ZzV+rrF29dDDzbfiPsxoWoSY8VqQAakEZAjD/vWl6JpTcYIQuCwWAbXYB09Pms9ST69DHMTLt2cK1lKmntEfI/3ZJMYUQ0gPnt9mzYjRlAVpakS46JUMcg3lerSIcxd7plCOCJe7N44kzFVlZmWbAskAkE1u8bRFFmaQiBNnKyxUeS09Mk6Wuh6/Mm8wfzI+Tj/MHBwXrrlwnt4OQQigCrVqsdGhwm/2HThXWYqSvt0bgTM8QwTzbiM2BSVCqTpLNYAfjjs6x0FkL6n+tv39XBPVUL0hIgEAFx/PhQjdeLAGeD0Zcvo8HZKbp+2osuNSLHYIRpb9c2WRKJtYjVPJNIeGvIGQnET4TDYRPmD4clBecHMMwZAw4sR3k5TIBZb28qAFeUbRx/0GHZW1MhLSrYDmnc7BtEX4R8fWRtdLLFKp/BKgKKhadFny/eqwwIQ6FQCXOcDtF0DzmD4/yAKQ52Y7AbcwE+B8MGcjBPPBMwVwl4UdXG95lZQstkT03N9DT6qFnIK6ipebyGf1/TjgCZyPfIIsx+gIO9Pqs1DwUAST6MiAo6sW5KbCwOjAVStXEhzGwTcrdRpYgIeEIJeE41EdqnJ+FtpNWKxBI/UcxZrUwUNTLRxdpJ88iIeVJycUhyca8ozrAIGGxoCgYX8iZLSu601ZBXgV+MPL8aELVAHRp1ZQAK9CtlDG5+XrX7D/Qv1fN7RbyamDk+Onp8Zq0NMbUlZiC80/SlddA8axXLo9VnRklSZjabm5jhfrTpYVCSTIqok0xb/gKN95BXRRCHCQsDoFQQhj1YpoRiFlesKAALJ97tZvH937s/L+/gMxghBAkruhAulRmUBlfJAjOTL5jLRhbyyu40CJZpxieXGb1UZhIJbZMX5U/EOpI/G2yryfsTNqDDdJRJDaipxLBGtkutoVgHt0uVdfrmmdtJHlD3qLjwx3vu3JPHODUj+G62BM1LkmUGf6ltGvGVge8WvMP1d6ZHcLxhMD8/v3eYfNyLtoMt8CETjAwhVCuqNPrHEbKNitlQsvJSJ0kC2oxiZYQg1oV5OKgC3FJ3kpUb49LqB9j5/OIomtWIfeTt2Te0olJ767UtIlkSMN/X0uuLtmsLvJH6MpKJyv1NikF5N6oNRlPduOyllCQuBCiaA6PkLGaNpkYpoXmnTl2owdKNW6qJy6/uivvLy9V97pXF5PhG8cTE9bt1KRcLJUy9F6YAYaiA7F+oj/b4/g5qSG+vbzh5G8ksRntRbQmdNu8CKjMSIEFRRBdmJCgC78bscRsRp5ARyHhlqxOE1hX1zOqn2glkF28px06dmwgkeww9yTBm8dK4WR9E5WRKX4JcHhn67stgPekNTfse4knA79OApNKsEqDOtTs3MGZMFrrSTpbmg+fdKh8jWxwbW8wYurQRuC8B4u0+ckRGaPg30ggfWWjvIRP//Rc+OMTUWMBfSrzyrGfqD0kFBUvwcY3C8mkoNhKqMmXdhMHRpTS/0sUCPv+s+AOPTKIVn0gJH02kLtyfZIkmQNFf8VA0ahFsfCqfQmZvSgf11Bo1SYE3EtKDgGR7FvrUE1YB3A0UfvCZZCywuvtMsruCKB0v9Sw56LMqWXQ1+QfF3FjahfIOeixxNR72sUR+qgudWPmggE+/SccFoIxGNKMEcSOSQQC0wajBQaUubrQJkGN5geU1Rkr+wZicebLzrJEVJ2Yao4sDsW6TgTvco3vyubgjsPkBJ38WOJa+ZV1l2D+QDYwOe9ikA4QjJ1xZyTUONOaYnMI8ZhM8jpxGTxhQA357jkmcMAucqQsN6YDF2Wj3OyjKYQrzRwFEk9bAxvsIL321/jy9smDEUG9BH36PgWcNkm95O++sBIDFCB4BYnYAwibIGiFHIFAREG3ANQ/QdcV4vtEE7I7Drm8lAaFQMTH2nrWZDfeL9CMw0DmQ+7JQB8ju7qrMpj2od4oxiMorIQN6DGhiMgB5ndOpM9nFpTrOg1qt0QQrHf7GRr8OhB1HXTwCodaJgzX8yl1BpxMRlTCUgNkYb88WhYw7nQD1J9bpTwOKjf+aCXQ7IOA9dsDxCNAoTqaAbgDdi/EaUvKICoqEFYHNfZYvpfhb7+MUdwzDXf4chw24Bhp1Th1eVenUVepgt1+l4LUBYOzy+3O6/CC7i5MAjSaBa3SgQw3A5emOHW75aHeFFQhzgdrCfUQcexp4rn5rAmIGlkZ+5VhDXHQvhTYwHkOhtsRxRZxQhB7Y+bj8b3wRjBGCEOelIQiKDCy6FCRsh1zCVKxRQ7BzIlBcmKHiWHHgm+VMf8BkYd2tg8l1DiD/QXkXSkvF0upGakisnXI5PBxfxiq/5Zdngdpbu32vcLM2kLvKHfZkv4Wp35NAkFVdccNdWlt8E1lt6cSjigv8J/SeRBARYfPWXF/n29zczr658cvwE3vTJJrUQHmeP9Iy3m9mB7zthJ/M287/AdxppEv2qVN4AAAAAElFTkSuQmCC\" /&gt;&lt;/body&gt;&lt;/html&gt; 可以看到img标签的src属性跟一串字符。”data:image/jpg;base64“表示数据的类型，之后的一大长串就是Base64串。直接浏览器打开，显示如下：可以看到图片正常显示了。 有了这个基础之后，后面的思路就很清楚了：Android层选择好图片后，返回图片的Base64格式的String对象到H5，H5回调拿来显示即可。 实践本次例子采用三方库safe-java-js-webview-bridge进行Android、JS互调，PhotoPicker进行图片选择。 AS新建项目，添加gradle依赖。PhotoPicker不支持gradle依赖，直接将代码下载下来后导入library Module。添加asserts目录，将H5页面，js、css文件添加进去。这里我直接将项目中的联调页面扔进去了，以求简便。 根据safe-java-js-webview-bridge三方库的使用说明，新建MyBridge类。这个类就是定义Android、JS互调接口的类。1234567891011121314151617181920212223242526272829303132public class MyBridge &#123; private static WebViewActivity activity; public static void init(WebViewActivity activity) &#123; MyBridge.activity = activity; &#125; public static void send(WebView webView, JSONObject jsonObject, JsCallback jsCallback) &#123; try &#123; String method = jsonObject.getString(\"cmd\"); switch (method) &#123; case \"getToken\": String token = activity.getToken(); if (jsCallback != null) &#123; jsCallback.apply(token); &#125; break; case \"getPictures\": activity.getPictures(jsCallback); break; default: break; &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; catch (JsCallback.JsCallbackException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这个类需要根据H5页面那边调用接口的格式来进行编写，示例中的接口调用是这样子的。12345678910111213141516171819202122232425262728293031323334353637function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge); &#125; else &#123; document.addEventListener('WebViewJavascriptBridgeReady', function() &#123; callback(WebViewJavascriptBridge) &#125;, false); &#125;&#125;;$(document).ready(function() &#123; connectWebViewJavascriptBridge(function(bridge) &#123; $(\"#getTokenBtn\").click(function() &#123; bridge.send(&#123; \"cmd\": \"getToken\", \"data\":&#123;&#125; &#125;, function responseCallback(responseData) &#123; $(\"#logger\")[0].innerHTML += responseData + \"&lt;br&gt;\"; &#125;); &#125;); $(\"#addPicBtn\").click(function() &#123; bridge.send(&#123; \"cmd\": \"getPictures\", \"data\": &#123; \"count\": 9 &#125; &#125;, function responseCallback(responseData) &#123; var imgs = JSON.parse(responseData).data.imgs; for (var i = 0; i &lt; imgs.length; i++) &#123; $('#picList').append('&lt;li&gt;&lt;img src=\"data:image/jpeg;base64,' + imgs[i] + '\" alt=\"image\" width=\"50\" height=\"50\"&gt;&lt;/li&gt;'); &#125; &#125;); &#125;); &#125;);&#125;); 所以我的MyBridge类只定义了一个send方法，在其内部接收Json数据，根据cmd参数判断到底要执行哪个方法。我把方法写在引用WebView的Activity中了，所以添加了一个init方法，进行初始化，保持WebViewActivity对象，以便调用。 下面编写WebViewActivity类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class WebViewActivity extends Activity &#123; private WebView webView; public static JsCallback onceCallback; // 单次回调 private static final int PICK_PHOTO_REQUEST = 1; // 选择图片请求码 private static final int MAX_PHOTO_NUM = 9; // 最大选择数量 private static boolean showCamera = true; // 是否打开相机 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyBridge.init(this); webView = new WebView(this); // 切换到内容视图 setContentView(webView); // 获取WebView配置 WebSettings ws = webView.getSettings(); // 启用JavaScript ws.setJavaScriptEnabled(true); webView.setWebChromeClient(new InjectedChromeClient(\"WebViewJavascriptBridge\", MyBridge.class)); // 载入assets目录下的一个页面 webView.loadUrl(\"file:///android_asset/native-api.html\"); &#125; public String getToken() &#123; return \"hello world\"; &#125; public void getPictures(JsCallback jsCallback) &#123; onceCallback = jsCallback; Intent intent = new Intent(this, PhotoPickerActivity.class); intent.putExtra(PhotoPickerActivity.EXTRA_SHOW_CAMERA, showCamera); intent.putExtra(PhotoPickerActivity.EXTRA_SELECT_MODE, PhotoPickerActivity.MODE_MULTI); intent.putExtra(PhotoPickerActivity.EXTRA_MAX_MUN, MAX_PHOTO_NUM); startActivityForResult(intent, PICK_PHOTO_REQUEST); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == PICK_PHOTO_REQUEST) &#123; if (resultCode == RESULT_OK) &#123; // 拼接返回Json ArrayList&lt;String&gt; result = data.getStringArrayListExtra(PhotoPickerActivity.KEY_RESULT); JSONObject dataJson = new JSONObject(); JSONObject images = new JSONObject(); JSONArray jsonArray = new JSONArray(); for (int i = 0; i &lt; result.size(); i++) &#123; File file = new File(result.get(i)); try &#123; FileInputStream fis = new FileInputStream(file); byte[] dataInByte = steamToByte(fis); String msg = Base64.encodeToString(dataInByte, Base64.DEFAULT); // 通过Base64方式返回的String会包含许多\\n，需去除掉 msg = msg.replaceAll(\"\\n\", \"\"); jsonArray.put(msg); fis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; images.put(\"imgs\", jsonArray); dataJson.put(\"data\", images); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; // 回调 try &#123; if (onceCallback != null) &#123; onceCallback.apply(dataJson.toString()); &#125; &#125; catch (JsCallback.JsCallbackException e) &#123; e.printStackTrace(); &#125; &#125; &#125; super.onActivityResult(requestCode, resultCode, data); &#125; public static byte[] steamToByte(InputStream input) throws IOException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); int len; byte[] b = new byte[1024]; while ((len = input.read(b, 0, b.length)) != -1) &#123; baos.write(b, 0, len); &#125; byte[] buffer = baos.toByteArray(); return buffer; &#125;&#125; 可以看到MyBridge中的send方法最终会调用到WebViewActivity中的getToken方法与getPictures方法。getToken方法很简单，仅仅是返回一个”Hello world“。getPictures方法则是打开PhotoPicker三方库中的Activity。在选完图片之后，利用onActivityResult接收返回的图片路径。然后利用Base64进行处理，得到我们需要的String对象，返回给JsCallback进行回调。 在JS中处理回调参数的代码是var imgs = JSON.parse(responseData).data.imgs;，所以我们返回的String对象也需要时JSON格式，并且包含data、imgs属性。类似这样：{“data”:{“imgs”:[“string1”, “string2”]}}。所以我在onActivityResult中进行了拼接处理。 最后运行程序，得到的效果大致是这样的。可以看到，在我们的H5页面确实显示了图片。 题外话话题1在引入PhotoPicker的时候，若在选择图片碰到很长的图片，例如微博长图，400*8000px这样的图，会导致在时容易出现OOM。在原来库中进行压缩的inSampleSize是这样计算的：123456789101112private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // 源图片的宽度 int width = options.outWidth; int height = options.outHeight; int inSampleSize = 1; int min = Math.min(width, height); int maxReq = Math.max(reqWidth, reqHeight); if(min &gt; maxReq) &#123; inSampleSize = Math.round((float) min / (float) maxReq); &#125; return inSampleSize;&#125; 使用这种方式，计算得到的inSampleSize值，在压缩这种长图后得到的Bitmap仍然会很大，导致OOM。改成如下则不会OOM了，但是图片会变得模糊一些（不可避免的，总要舍弃一些东西，微信也是这样）。12345678910111213private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // 源图片的宽度 int width = options.outWidth; int height = options.outHeight; int inSampleSize = 1; if (width &gt; reqWidth || height &gt; reqHeight) &#123; int widthRadio = Math.round(width * 1.0f / reqWidth); int heightRadio = Math.round(height * 1.0f / reqHeight); inSampleSize = Math.max(widthRadio, heightRadio); &#125; return inSampleSize;&#125; 这个问题我已经跟作者反应，并且已经改正了。 话题2拼接好String字符串，准备返回给JsCallback进行回调时会出错。Log信息：1Log：I/chromium: [INFO:CONSOLE(1)] \"Uncaught SyntaxError: Unexpected identifier\", source: (1) 后面我看到JsCallback里的apply函数：123456789101112131415161718192021222324public void apply (Object... args) throws JsCallbackException &#123; if (mWebViewRef.get() == null) &#123; throw new JsCallbackException(\"the WebView related to the JsCallback has been recycled\"); &#125; if (!mCouldGoOn) &#123; throw new JsCallbackException(\"the JsCallback isn't permanent,cannot be called more than once\"); &#125; StringBuilder sb = new StringBuilder(); for (Object arg : args)&#123; sb.append(\",\"); boolean isStrArg = arg instanceof String; if (isStrArg) &#123; sb.append(\"\\\"\"); &#125; sb.append(String.valueOf(arg)); if (isStrArg) &#123; sb.append(\"\\\"\"); &#125; &#125; String execJs = String.format(CALLBACK_JS_FORMAT, mInjectedName, mIndex, mIsPermanent, sb.toString()); Log.d(\"JsCallBack\", execJs); mWebViewRef.get().loadUrl(execJs); mCouldGoOn = mIsPermanent &gt; 0;&#125; 他会在参数的前后加上双引号。因为返回的String对象是类似Json格式，里面也会包含双引号，这就会导致传递出错。这个问题我也已经提了issue给作者，但目前还没有什么回应。 碰到问题需要解决，在作者回应之前只能自己改咯。将代码下载下来，丢到工程中，不采用gradle依赖的方式了。也就三个类：InjectedChromeClient、JsCallback、JsCallJava。手动将apply中的代码改成如下：123456789101112131415161718192021222324public void apply (Object... args) throws JsCallbackException &#123; if (mWebViewRef.get() == null) &#123; throw new JsCallbackException(\"the WebView related to the JsCallback has been recycled\"); &#125; if (!mCouldGoOn) &#123; throw new JsCallbackException(\"the JsCallback isn't permanent,cannot be called more than once\"); &#125; StringBuilder sb = new StringBuilder(); for (Object arg : args)&#123; sb.append(\",\"); boolean isStrArg = arg instanceof String; if (isStrArg) &#123; sb.append(\"'\"); &#125; sb.append(String.valueOf(arg)); if (isStrArg) &#123; sb.append(\"'\"); &#125; &#125; String execJs = String.format(CALLBACK_JS_FORMAT, mInjectedName, mIndex, mIsPermanent, sb.toString()); Log.d(\"JsCallBack\", execJs); mWebViewRef.get().loadUrl(execJs); mCouldGoOn = mIsPermanent &gt; 0;&#125; 双引号改成单引号就行了。 但是只有又会引发新的问题：返回的String不能包含单引号。这确实比较蛋疼了，只能根据需求来吧，能解决当前问题的就行。延伸到既包含双引号又包含单引号的String对象又该如何传递呢？这里抛个疑问，大家可以共同探讨。 补充一点：通过Base64返回的String串来显示图片只适合小图片，太大的图片需要压缩后再返回，不然也会OOM。 最后源码下载","tags":[{"name":"hybrid开发","slug":"hybrid开发","permalink":"http://lijia92.github.io/tags/hybrid开发/"}]},{"title":"Android Notification使用小记","date":"2016-01-11T12:46:50.000Z","path":"2016/01/11/notification/","text":"介绍最近的项目中，需要用到Notification。上一下效果图： 首先，学习一下关于Notification的基本知识。 状态通知栏主要涉及到2个类： Notification 和 NotificationManager 。Notification为通知信息类，它里面对应了通知栏的各个属性。NotificationManager ： 是状态栏通知的管理类，负责发通知、清除通知等操作。注意：NotificationManager 是一个系统Service，必须通过 getSystemService(NOTIFICATION_SERVICE)方法来获取：1mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 自定义Notification大致分为以下几步： 自定义布局； 使用NotificationCompat.Builder创建Notification。使用RemoteViews填充自定义布局，然后通过setContent()添加到Builder中； 使用广播，添加按钮点击事件； NotificationManager.notify()将Notification显示到手机状态栏。 下面结合代码进行说明。 代码第一步，对应于Notification的布局文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/music_cover\" android:layout_width=\"64dp\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/mia\" /&gt; &lt;LinearLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/music_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:ellipsize=\"end\" android:singleLine=\"true\" android:text=\"无与伦比的美丽\" /&gt; &lt;TextView android:id=\"@+id/singer_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:ellipsize=\"end\" android:singleLine=\"true\" android:text=\"苏打绿\" /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=\"@+id/pause\" android:layout_width=\"48dp\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/button_pause\" /&gt; &lt;ImageView android:id=\"@+id/play\" android:layout_width=\"48dp\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/button_play\" android:visibility=\"gone\" /&gt; &lt;ImageView android:id=\"@+id/next\" android:layout_width=\"48dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"8dp\" android:scaleType=\"centerCrop\" android:src=\"@drawable/btn_next\" /&gt; &lt;ImageView android:id=\"@+id/delete\" android:layout_width=\"48dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"8dp\" android:layout_marginRight=\"8dp\" android:scaleType=\"centerCrop\" android:src=\"@drawable/search_delete\" /&gt;&lt;/LinearLayout&gt; 布局文件很简单，不做过多叙述。 再来看到Notification的创建。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class PlayerService extends Service &#123; // 广播Action private final static String NOTIFICATION_PLAY_ACTION = \"com.notifications.intent.action.PlayClick\"; private final static String NOTIFICATION_PAUSE_ACTION = \"com.notifications.intent.action.PauseClick\"; private final static String NOTIFICATION_NEXT_ACTION = \"com.notifications.intent.action.NextClick\"; private final static String NOTIFICATION_DELETE_ACTION = \"com.notifications.intent.action.DeleteClick\"; // 自定义Notification private NotificationManager mNotificationManager = null; private PendingIntent contentIntent; private NotificationCompat.Builder builder; private Notification notification; private RemoteViews contentView; // 自定义Notification，接收布局 private PlayerService service = this; private BroadcastReceiver onClickReceiver; // 注册广播接收点击事件 @Override public void onCreate() &#123; mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, MusicPlayActivity.class), 0); contentView = new RemoteViews(getPackageName(), R.layout.custom_notification); builder = new NotificationCompat.Builder(this); notification = builder .setContentIntent(contentIntent) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.drawable.mia) .setContent(contentView) .build(); notification.flags = Notification.FLAG_NO_CLEAR; // 注意Flag，会影响是否能cancel // 播放 Intent playIntent = new Intent(NOTIFICATION_PLAY_ACTION); PendingIntent play = PendingIntent.getBroadcast(this, 0, playIntent, 0); contentView.setOnClickPendingIntent(R.id.play, play); // 暂停 Intent pauseIntent = new Intent(NOTIFICATION_PAUSE_ACTION); PendingIntent pause = PendingIntent.getBroadcast(this, 0, pauseIntent, 0); contentView.setOnClickPendingIntent(R.id.pause, pause); // 下一首 Intent nextIntent = new Intent(NOTIFICATION_NEXT_ACTION); PendingIntent next = PendingIntent.getBroadcast(this, 0, nextIntent, 0); contentView.setOnClickPendingIntent(R.id.next, next); // 关闭 Intent deleteIntent = new Intent(NOTIFICATION_DELETE_ACTION); final PendingIntent delete = PendingIntent.getBroadcast(this, 0, deleteIntent, 0); contentView.setOnClickPendingIntent(R.id.delete, delete); // Notification中按钮点击事件需注册广播 onClickReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); switch (action) &#123; case NOTIFICATION_PLAY_ACTION: contentView.setViewVisibility(R.id.play, View.GONE); contentView.setViewVisibility(R.id.pause, View.VISIBLE); if (!service.isPlaying()) &#123; service.resume(); // 继续播放 &#125; mNotificationManager.notify(PLAYING_NOTIFY_ID, notification); break; case NOTIFICATION_PAUSE_ACTION: contentView.setViewVisibility(R.id.pause, View.GONE); contentView.setViewVisibility(R.id.play, View.VISIBLE); if (service.isPlaying()) &#123; service.pause(); // 暂停 &#125; mNotificationManager.notify(PLAYING_NOTIFY_ID, notification); break; case NOTIFICATION_NEXT_ACTION: service.next(); // 下一首 break; case NOTIFICATION_DELETE_ACTION: service.stop(); break; default: break; &#125; &#125; &#125;; IntentFilter filter = new IntentFilter(); filter.addAction(NOTIFICATION_PLAY_ACTION); filter.addAction(NOTIFICATION_PAUSE_ACTION); filter.addAction(NOTIFICATION_NEXT_ACTION); filter.addAction(NOTIFICATION_DELETE_ACTION); registerReceiver(onClickReceiver, filter); &#125; 播放音乐使用的自然是Service了。于是我定义了PlayerService继承自Service，声明相应的变量，然后在onCreate()中进行初始化。 我们可以看到，代码中使用RemoteViews填充了布局，并将其设置到Notification创建的Builder中。 RemoteViews不同于View，它不能通过findViewById()来获取View控件。它里面的控件的点击事件必须通过setOnClickPendingIntent()来进行设置。它有2个参数，1个是控件ID，另外1个是进行处理的PendingIntent。PendingIntent的创建必须通过广播的方式来实现。重复下上面的代码：123Intent playIntent = new Intent(NOTIFICATION_PLAY_ACTION);PendingIntent play = PendingIntent.getBroadcast(this, 0, playIntent, 0);contentView.setOnClickPendingIntent(R.id.play, play); 然后在广播的onReceive()方法中，判断是哪个控件被点击。然后执行相应的逻辑。 记得广播一定要先注册才能使用。 最后，便是将Notification显示到手机了。12345678910final Track track = getCurrentEntry().getTrack();ImageLoader.getInstance().loadImage(track.getUrl(), new SimpleImageLoadingListener() &#123; @Override public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123; contentView.setImageViewBitmap(R.id.music_cover, loadedImage); contentView.setTextViewText(R.id.music_name, track.getName()); contentView.setTextViewText(R.id.singer_name, track.getSinger()); mNotificationManager.notify(PLAYING_NOTIFY_ID, notification); &#125; &#125;); Track是我进行音乐播放的一个Model类。包含一些播放音乐的基本信息。这里我是通过的Universal-Image-Loader进行图片加载。在其加载成功后的回调中，通过setTextViewText()等类似方法给控件设值。也是有2个参数，第1个是控件Id，第二个便是要设置的值。最后通过mNotificationManager.notify(PLAYING_NOTIFY_ID, notification)将Notification显示到手机。 经过上述几个步骤，自定义Notification便能显示到手机了，并且具备点击事件。 Tips 自定义布局仅支持FrameLayout、LinearLayout、RelativeLayout三种布局控件和AnalogClock、Chronometer、Button、ImageButton、ImageView、ProgressBar、TextView、ViewFlipper、ListView、GridView、StackView和AdapterViewFlipper这些显示控件，不支持这些类的子类或Android提供的其他控件，否则会引起ClassNotFoundException异常。之前播放的按钮打算用ToggleButton，使用之后发现显示不了，后面才找到原因。 Notification属于系统级别的组件，使用了RemoteViews的setViewVisibility()、setTextViewText()等方法后，必须通知系统重绘才能更新UI，最简单的方式就是重新notify一下。只要传入的Id一样，就会覆盖掉之前的通知。在播放、暂停按钮切换的时候，就碰到这个问题，一直不能显示，加上notify语句后就能正常执行了。 关于Notification的取消。使用mNotificationManager.cancel(PLAYING_NOTIFY_ID)即可。但是一定要注意Notification的flag。这里补充下Notification的标识符。提醒标志符成员：Notification.FLAG_SHOW_LIGHTS //三色灯提醒，在使用三色灯提醒时候必须加该标志符Notification.FLAG_ONGOING_EVENT //发起正在运行事件（活动中）Notification.FLAG_INSISTENT //让声音、振动无限循环，直到用户响应 （取消或者打开）Notification.FLAG_ONLY_ALERT_ONCE //发起Notification后，铃声和震动均只执行一次Notification.FLAG_AUTO_CANCEL //用户单击通知后自动消失Notification.FLAG_NO_CLEAR //只有全部清除时，Notification才会清除 ，不清楚该通知(QQ的通知无法清除，就是用的这个)Notification.FLAG_FOREGROUND_SERVICE //表示正在运行的服务我当时使用的FLAG_FOREGROUND_SERVICE，导致cancel一直关闭不了Notification，更换flag后就能关闭了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android Hybrid开发入门：原生Android与JS的交互","date":"2015-12-25T07:03:16.000Z","path":"2015/12/25/hybrid-introduction/","text":"介绍我们知道，现在App大致分为3类：Hybrid App、Web App、Native App。Hybrid App兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”，市面上现在也有许多Hybrid App。 最近做的项目，也会使用到Hybrid开发，之前没做过的。所以今天初步学习了一下，记录一下学习心得。 代码首先，新建一个新的AS module，然后新建assets目录，至于src/main文件夹下。如下图：我们再assets目录下，新建一个hello.html，编辑内容如下：1234567891011121314&lt;html&gt;&lt;head&gt; &lt;script&gt; function hello() &#123; document.getElementById(\"demo\").innerHTML = \"Hello Hybrid!\"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a href=\"#\" id=\"demo\" onclick=\"window.demo.clickOnAndroid()\"&gt;Click Me&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一个很简单的html页面。 然后新建一个WebViewActivity。1234567891011121314151617181920212223242526272829303132333435public class WebViewActivity extends Activity &#123; private WebView webView; private Context mContext; private Handler mHandler = new Handler(); @SuppressLint(\"JavascriptInterface\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mContext = this; // 创建WebView对象 webView = new WebView(this); // 切换到内容视图 setContentView(webView); // 获取WebView配置 WebSettings ws = webView.getSettings(); // 启用JavaScript ws.setJavaScriptEnabled(true); // 载入assets目录下的一个页面 webView.loadUrl(\"file:///android_asset/hello.html\"); // 添加交互接口 webView.addJavascriptInterface(new Object() &#123; @JavascriptInterface public void clickOnAndroid() &#123; Toast.makeText(mContext, \"Hello Hybrid.\", Toast.LENGTH_SHORT).show(); mHandler.post(new Runnable() &#123; public void run() &#123; webView.loadUrl(\"javascript:hello()\"); &#125; &#125;); &#125; &#125;, \"demo\"); &#125;&#125; 通过WebView的loadUrl，填入我们hello.html的路径，便能在App中加载这个页面了。（别忘记在AndroidManifest.xml中声明Activity）loadUrl填入JS方法，则可调JS方法。注意使用的handler发送消息来更新。如是直接webView.loadUrl(“javascript:hello()”);可能会导致如下错误： java.lang.Throwable: A WebView method was called on thread ‘JavaBridge’. All WebView methods must be called on the same thread. (Expected Looper Looper (main, tid 1) {425f48a8} called on Looper (JavaBridge, tid 92104) {426508d0}, FYI main Looper is Looper (main, tid 1) {425f48a8}) 即是需要在同一个进程中进行更新，所以需要使用handler发送消息更新。 回到AS帮我们自动建好的MainActivity。修改FloatingActionButton点击事件：12345678FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(MainActivity.this, WebViewActivity.class); startActivity(intent); &#125; &#125;); 启动应用，看下效果：可以看到，点击“click me”的时候，弹出了Toast，并且button的text改变了，这即是android与js的交互。当然，这个交互十分简单，后面还有很多的坑要踩~ Tips注意到代码中的clickOnAndroid方法上方的注解@JavascriptInterface，这个注解很关键。若没有这个注解，会在4.2以上版本的android上出现：Uncaught TypeError: Object [object Object] has no method xxx的错误。 对于4.2之前的版本，采用这种方式可能会被恶意JS攻击，诸如平台型App需要访问三方Html的则不建议采用这种方式实现交互。 更多前面示例js调用android是通过addJavascriptInterface来进行交互的，下面再介绍2种方式。 重写WebViewClient.shouldOverrideUrlLoading：1234567webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; Toast.makeText(mContext, url, Toast.LENGTH_SHORT).show(); return super.shouldOverrideUrlLoading(view, url); &#125; &#125;); 当页面内的URL发生变化时，如点击链接、执行JavaScript（如location.href=”xxxxxxx”）等均会触发WebViewClient.shouldOverrideUrlLoading，通过将Web调用Native的数据封装在URL，再由Native解析数据并执行响应Native方法。 例如：将前面示例中的hello.html改成如下：1234567891011121314&lt;html&gt;&lt;head&gt; &lt;script&gt; function hello() &#123; document.getElementById(\"demo\").innerHTML = \"Hello Hybrid!\"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a href=\"hybrid.html\" id=\"demo\" onclick=\"window.demo.clickOnAndroid()\"&gt;Click Me&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在点击“Click Me”之后，页面会跳转到hybrid.html，此时便会进入native执行shouldOverrideUrlLoading方法，再来解析Url，并执行相应的native方法。 重写WebChromeClient.onJsPrompt，或onJsConfirm，或onJsAlert：1234567webView.setWebChromeClient(new WebChromeClient() &#123; public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; Toast.makeText(mContext, url, Toast.LENGTH_SHORT).show(); result.confirm(\"\"); return true; &#125; &#125;); 当执行“window.prompt（“{}”）”这样的JavaScript代码时，将会触发WebChromeClient.onJsPrompt。onJsConfirm、onJsAlert也是如此。 例如：将前面示例中的hello.html改成如下：1234567891011121314&lt;html&gt;&lt;head&gt; &lt;script&gt; function hello() &#123; document.getElementById(\"demo\").innerHTML = \"Hello Hybrid!\"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a href=\"#\" id=\"demo\" onclick=\"window.prompt('Hello')\"&gt;Click Me&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当点击“Click Me”时，会进入native执行onJsPrompt方法，再来解析url，message，并执行相应的native方法。 最后Github上找到一个开源库：safe-java-js-webview-bridge，便是采用的这种方式进行交互，并做了更好的封装，是个不错的选择。","tags":[{"name":"hybrid开发","slug":"hybrid开发","permalink":"http://lijia92.github.io/tags/hybrid开发/"}]},{"title":"Android仿QQ空间浏览图片","date":"2015-12-08T09:09:39.000Z","path":"2015/12/08/picture-view/","text":"前言最近的项目中需要用到类似QQ空间那样的图片浏览功能，于是Google了一波，发现使用ViewPager与PhotoView即可实现。有了思路便开撸了。 代码首先，我们定义一个用于展示原图的Activity。12345678910111213141516171819202122232425public class ImageBrowseActivity extends Activity &#123; // ViewPager对象 private ViewPager mViewPager; // 原图url路径List private List&lt;String&gt; imagePath; // 当前显示的位置 private int position; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_images_view); // 获取参数 this.position = getIntent().getIntExtra(\"position\", 0); this.imagePath = getIntent().getStringArrayListExtra(\"imagePath\"); mViewPager = (ViewPager) findViewById(R.id.images_view); // 设置左右两列缓存的数目 mViewPager.setOffscreenPageLimit(2); // 添加Adapter PagerAdapter adapter = new ImageBrowseAdapter(this, imagePath); mViewPager.setAdapter(adapter); mViewPager.setCurrentItem(position); &#125;&#125; 布局如下：1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#000000\" android:orientation=\"vertical\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/images_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" /&gt;&lt;/FrameLayout&gt; Activity比较简单，不做过多赘述。下面看看ImageBrowseAdapter怎么实现的。ImageBrowseAdapter代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class ImageBrowseAdapter extends PagerAdapter &#123; PhotoViewAttacher mAttacher; private Context context; private List&lt;String&gt; imagePath; public ImageBrowseAdapter(Context context, List&lt;String&gt; urls) &#123; this.context = context; this.imagePath = urls; &#125; @Override public int getCount() &#123; return imagePath.size(); &#125; @Override public boolean isViewFromObject(View view, Object o) &#123; return view == o; &#125; @Override public void destroyItem(ViewGroup view, int position, Object object) &#123; view.removeView((View) object); &#125; @Override public Object instantiateItem(ViewGroup view, int position) &#123; ImageView imageView = new ImageView(context); new DownloadImageTask(context, imageView).execute(imagePath.get(position)); view.addView(imageView); return imageView; &#125; private class DownloadImageTask extends BaseAsyncTask&lt;String, Void, Bitmap&gt; &#123; ImageView bmImage; public DownloadImageTask(Context context, ImageView bmImage) &#123; super(context); this.bmImage = bmImage; &#125; @Override protected void onPreExecute() &#123; &#125; protected Bitmap doInBackground(String... urls) &#123; String path = urls[0]; Bitmap result = null; try &#123; BitmapFactory.Options options = new BitmapFactory.Options(); //先设置为true，获取bitmap宽度、高度 options.inJustDecodeBounds = true; InputStream in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options); in.close(); resetOptions(options); //后设置为false，加载进内存显示 options.inJustDecodeBounds = false; // InputStream在读取完之后就到结尾了，需要再次打开才能重新读取，否则下面的result将返回null in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; protected void onPostExecute(Bitmap result) &#123; if (result != null) &#123; bmImage.setImageBitmap(result); // PhotoViewAttacher绑定ImageView mAttacher = new PhotoViewAttacher(bmImage); &#125; &#125; &#125; /** * 设置inSampleSize参数 * * @param options * @return */ public void resetOptions(BitmapFactory.Options options) &#123; DisplayMetrics dm = context.getResources().getDisplayMetrics(); int width = dm.widthPixels / 2; int height = dm.heightPixels / 2; options.inSampleSize = (options.outWidth / width &gt; options.outHeight / height) ? options.outWidth / width : options.outHeight / height; &#125;&#125; 在Adapter中，我为了求简便，直接在instantiateItem()中新建ImageView实例，然后传入到DownloadImageTask异步任务中进行下载，下载完成后更新，然后将PhotoViewAttacher与ImageView实例绑定。示例中没有使用PhoteView这个类，主要是用到了PhotoViewAttacher这个类。 我们会有一个显示缩略图的列表，给列表的Item设置如下点击事件：1234567@Overridepublic void ImageClicked(ArrayList&lt;String&gt; imagePath, int position) &#123; Intent intent = new Intent(getActivity(), ImageBrowseActivity.class); intent.putExtra(\"position\", position); intent.putStringArrayListExtra(\"imagePath\", imagePath); startActivity(intent);&#125; imagePath是原图的路径数组，position代表当前显示第几张。点击事件设置好之后，便能实现网络图片浏览功能了。下面上效果图： 小结 使用ViewPager来实现大图左右滑动。 使用PhotoView开源库实现图片的缩放，移动等特性，点击传送PhotoView开源库。 问题 在使用PhotoView与ViewPager结合进行滑动显示的时候，会打出ImageView no longer exists. You should not use this PhotoViewAttacher any more.的Log，算不上错误，是个Warning，网上查找的解决办法是修改cleapUp方法。 自己手贱，传了一些手机拍摄的“高清大图”，没滑2张就OOM了。也算是个契机让自己了解下Bitmap的内存优化。故在示例中会有resetOptions()方法以及这样的代码片段：12345678910111213141516...BitmapFactory.Options options = new BitmapFactory.Options(); //先设置为true，获取bitmap宽度、高度 options.inJustDecodeBounds = true; InputStream in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options); in.close(); resetOptions(options); //后设置为false，加载进内存显示 options.inJustDecodeBounds = false; // InputStream在读取完之后就到结尾了，需要再次打开才能重新读取，否则下面的result将返回null in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options);... Bitmap是OOM的一大凶器，所以碰到大图我们需要压缩。压缩可以通过设置BitmapFactory.Options，来生成压缩后的图片，主要是inSampleSize参数的设置。resetOptions()方法便是进行设置inSampleSize参数的，方法内部的具体逻辑则需要根据项目业务的需求来制定了。 另外，在第二次BitmapFactory.decodeStream()时，若不进行其他处理，会返回null，后面查询原因，是InputStream流在访问后，内部指针会指到尾部，相当于是传入的in是空的。所以需要添加一句in = new java.net.URL(path).openStream();，重新打开in，然后再使用decodeStream方法，返回bitmap。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]},{"title":"Android Studio中使用.9（Nine Patch）图","date":"2015-11-23T02:09:38.000Z","path":"2015/11/23/nine-patch/","text":"本文主要结合Android Studio讲述一下.9图片的原理与使用。 原理在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以任意调整大小的一种图片格式“.9.png”。这种图片是用于Android开发的一种特殊的图片格式，它的好处在于可以用简单的方式把一张图片中哪些区域可以拉伸，哪些区域不可以拉伸设定好，同时可以把显示内容区域的位置标示清楚。 .9图片相比普通图片，在四条边会多出1px的空隙，我们在这1px的空隙中画上黑线，即可控制图片怎么拉伸，内容区域的位置。讲解一下四条边的作用： Top，图中1所示，是控制图片可横向拉伸的区域。 Left，图中2所示，是控制图片可纵向拉伸的区域。 Right&amp;Botton，图中的3与4，结合起来控制内容显示的区域。 使用我们在Android Studio中新建一个项目，选择一张普通图片，置于drawable目录下。 下面我们将它改为.9图片。在Android Studio中使用.9图很简单：直接将图片名称以”.9.png”结束。使用.9图必须注意一点：文件的后缀名必须是.9.png，不能是.png或者是.9.png.png，这样的命名都会导致编译失败。 将名称改好之后，重新打开图片，可以看到图片下面会有2个Tab，切换到9-Patch即可配置.9图片了。 下面做如下配置： 在右边的效果图中，纵向只拉伸了Left所画黑线对应的区域，横向只拉伸了Top所画黑线对应的区域。至于Right与Bottom，我们可以通过勾选下方的Show content让其显示内容区域。 可以看到，这里上下左右四条黑边的作用确实如原理中所说。图中效果很难看，改成这样：看起来效果还不错，这样我们可以尽情的配置图片该如何拉伸，针对不同分辨率，以达到一个更好的效果。 解惑起初对Right与Bottom这2条边限定的内容区域不太了解，便做了个小测试。将2条边改成如下：然后布局文件里引入一个TextView，将background设置为此.9图片。123456&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:background=\"@drawable/ninepatch\" android:text=\"Hello World!\" /&gt; 运行后的效果：可以看到“Hello World！”显示在了图片的右下方。Right与Bottom这2条边限定的内容区域所起的作用便一目了然了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"},{"name":"android studio","slug":"android-studio","permalink":"http://lijia92.github.io/tags/android-studio/"}]},{"title":"Android仿QQ实现ListView滑动删除","date":"2015-11-13T18:09:38.000Z","path":"2015/11/14/swipe-listview/","text":"前言手机QQ应该是很普及的App了，看到QQ消息栏对话框列表的每个子项左滑的时候会弹出删除、置顶图标。like this：于是突发奇想：想要自己实现一个这样的效果。很显然的，这样的效果实现要依赖Android的事件分发机制，于是我先从Android事件分发入手。对于事件分发还不太熟悉的朋友可以参考Android事件分发机制学习。下面开工！ List Item首先，针对ListView的每个Item自定义一个MyItemLayout。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MyItemLayout extends LinearLayout &#123; // content View private LinearLayout contentView; // menu View private LinearLayout menuView; // content View的布局参数对象 private LayoutParams contentLayout; // 菜单是否打开 private boolean isMenuOpen; // contentView最小的leftMargin private int minLeftMargin; // contentView最大的leftMargin private int maxLeftMargin = 0; // 滑动类 private Scroller mScroller = null; public MyItemLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); contentLayout = new LayoutParams(getScreenWidth(), LayoutParams.WRAP_CONTENT); mScroller = new Scroller(context); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; setLeftMargin(mScroller.getCurrX()); postInvalidate(); &#125; &#125; /** * Scroller平滑打开Menu */ public void smoothOpenMenu() &#123; isMenuOpen = true; mScroller.startScroll(contentLayout.leftMargin, 0, minLeftMargin - contentLayout.leftMargin, 0, 350); postInvalidate(); &#125; /** * Scroller平滑关闭Menu */ public void smoothCloseMenu() &#123; isMenuOpen = false; mScroller.startScroll(contentLayout.leftMargin, 0, maxLeftMargin - contentLayout.leftMargin, 0, 350); postInvalidate(); &#125; /** * 在布局inflate完成后调用 */ @Override protected void onFinishInflate() &#123; super.onFinishInflate(); // 第一个孩子是contentView contentView = (LinearLayout) getChildAt(0); // 第二个孩子是MenuView menuView = (LinearLayout) getChildAt(1); // 最小的leftMargin为负的menuView宽度 ViewGroup.LayoutParams lp = menuView.getLayoutParams(); minLeftMargin = -lp.width; &#125; /** * 获取屏幕宽度 * @return */ private int getScreenWidth() &#123; DisplayMetrics dm = getResources().getDisplayMetrics(); return dm.widthPixels; &#125; /** * 给contentView设置leftMargin * @param leftMargin */ public void setLeftMargin(int leftMargin) &#123; // 控制leftMargin不越界 if (leftMargin &gt; maxLeftMargin) &#123; leftMargin = maxLeftMargin; &#125; if (leftMargin &lt; minLeftMargin) &#123; leftMargin = minLeftMargin; &#125; contentLayout.leftMargin = leftMargin; // 通过设置leftMargin，达到menu显示的效果 contentView.setLayoutParams(contentLayout); &#125; /** * 获取menuView宽度 * @return */ public int getMenuWidth() &#123; return -minLeftMargin; &#125; /** * Menu是否打开 * @return */ public boolean isMenuOpen() &#123; return isMenuOpen; &#125;&#125; 每个Item有2个直接子节点，第一个是contentView，第二个是menuView。通过设置contentView的leftMargin，达到显示Menu的效果。初始时，leftMargin为0，Menu完全隐藏。当滑动时，leftMargin逐渐缩小（因为是负数），当leftMargin等于minLeftMargin时，Menu完全显示。本来有种想法（参考郭霖大神的博客）是采用线程Sleep的方式来达到滑动效果的。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546private class ScrollTask extends AsyncTask&lt;Integer, Integer, Integer&gt; &#123; @Override protected Integer doInBackground(Integer... speed) &#123; int leftMargin = contentLayout.leftMargin; while (true) &#123; leftMargin = leftMargin - speed[0]; if (leftMargin &gt; maxLeftMargin) &#123; leftMargin = maxLeftMargin; break; &#125; if (leftMargin &lt; minLeftMargin) &#123; leftMargin = minLeftMargin; break; &#125; publishProgress(leftMargin); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; isMenuOpen = speed[0] &gt; 0; return leftMargin; &#125; @Override protected void onProgressUpdate(Integer... leftMargin) &#123; contentLayout.leftMargin = leftMargin[0]; contentView.setLayoutParams(contentLayout); &#125; @Override protected void onPostExecute(Integer leftMargin) &#123; contentLayout.leftMargin = leftMargin; contentView.setLayoutParams(contentLayout); &#125; &#125;public void toOpenMenu() &#123; new ScrollTask().execute(30); &#125; public void toCloseMenu() &#123; new ScrollTask().execute(-30); &#125; 但是后面产生的实际效果不太好，滑动的时候总是有点卡顿的感觉，于是便弃用了，后面还是采用的Scroller类。 下面贴上每个Item的布局：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;com.lastwarmth.mylistview.MyItemLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;LinearLayout android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:paddingBottom=\"4dp\" android:paddingLeft=\"8dp\" android:paddingTop=\"4dp\"&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=\"@+id/profile_image\" android:layout_width=\"56dp\" android:layout_height=\"56dp\" app:civ_border_color=\"#FF000000\" app:civ_border_width=\"1dp\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"16dp\" android:layout_marginTop=\"4dp\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/group_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"群名称\" /&gt; &lt;TextView android:id=\"@+id/qq_content\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:singleLine=\"true\" android:text=\"聊天内容\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/menu\" android:layout_width=\"240dp\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;TextView android:id=\"@+id/to_top\" style=\"@style/menu_text_style\" android:layout_width=\"80dp\" android:layout_height=\"match_parent\" android:background=\"@android:color/darker_gray\" android:gravity=\"center\" android:text=\"置顶\" /&gt; &lt;TextView android:id=\"@+id/had_read\" style=\"@style/menu_text_style\" android:layout_width=\"80dp\" android:layout_height=\"match_parent\" android:background=\"@android:color/holo_orange_light\" android:gravity=\"center\" android:text=\"标为已读\" /&gt; &lt;TextView android:id=\"@+id/delete\" style=\"@style/menu_text_style\" android:layout_width=\"80dp\" android:layout_height=\"match_parent\" android:background=\"@android:color/holo_red_light\" android:gravity=\"center\" android:text=\"删除\" /&gt; &lt;/LinearLayout&gt;&lt;/com.lastwarmth.mylistview.MyItemLayout&gt; content id即是第一个子节点，menu id为第二个子节点。 Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MyAdapter extends BaseAdapter &#123; private List&lt;MyModel&gt; data; private Context mContext; public MyAdapter(List&lt;MyModel&gt; data, Context mContext) &#123; this.data = data; this.mContext = mContext; &#125; @Override public int getCount() &#123; if (data != null) &#123; return data.size(); &#125; return 0; &#125; @Override public Object getItem(int position) &#123; if (data != null) &#123; return data.get(position); &#125; return null; &#125; @Override public long getItemId(int position) &#123; return 0; &#125; @Override public View getView(final int position, View contentView, ViewGroup parent) &#123; ViewHolder holder; if (contentView == null) &#123; holder = new ViewHolder(); contentView = LayoutInflater.from(mContext).inflate(R.layout.list_item, parent, false); holder.imageView = (CircleImageView) contentView.findViewById(R.id.profile_image); holder.groupName = (TextView) contentView.findViewById(R.id.group_name); holder.content = (TextView) contentView.findViewById(R.id.qq_content); holder.toTop = (TextView) contentView.findViewById(R.id.to_top); holder.hadRead = (TextView) contentView.findViewById(R.id.had_read); holder.delete = (TextView) contentView.findViewById(R.id.delete); contentView.setTag(holder); &#125; else &#123; holder = (ViewHolder) contentView.getTag(); &#125; MyModel myModel = (MyModel) getItem(position); holder.groupName.setText(myModel.getGroupName()); holder.content.setText(myModel.getContent()); Picasso.with(mContext) .load(myModel.getImageUrl()) .placeholder(R.mipmap.lb_zjtx) .into(holder.imageView); final MyItemLayout finalContentView = (MyItemLayout) contentView; holder.toTop.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(mContext, \"已置顶\", Toast.LENGTH_SHORT).show(); finalContentView.smoothCloseMenu(); &#125; &#125;); holder.hadRead.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(mContext, \"已阅读\", Toast.LENGTH_SHORT).show(); finalContentView.smoothCloseMenu(); &#125; &#125;); holder.delete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; data.remove(position); finalContentView.smoothCloseMenu(); notifyDataSetChanged(); Toast.makeText(mContext, \"已删除\", Toast.LENGTH_SHORT).show(); &#125; &#125;); return contentView; &#125; private static class ViewHolder &#123; CircleImageView imageView; TextView groupName; TextView content; TextView toTop; TextView hadRead; TextView delete; &#125;&#125; Adapter类比较简单，这里不做过多的赘述。 Model类MyModel类主要是为了模仿QQ会话写的一个类。12345678910111213141516171819202122232425public class MyModel &#123; String imageUrl; // 头像Url String groupName; // 群名称 String content; // 聊天内容 public MyModel(String imageUrl, String groupName, String content) &#123; this.imageUrl = imageUrl; this.groupName = groupName; this.content = content; &#125; public String getImageUrl() &#123; return imageUrl; &#125; public String getGroupName() &#123; return groupName; &#125; public String getContent() &#123; return content; &#125;&#125; 自定义ListView下面便是最关键的一个：自定义ListView，覆写onTouchEvent方法，实现滑动删除。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class MyListView extends ListView &#123; // 滑动速度追踪类 private VelocityTracker mVelocityTracker; // ACTION_DOWN的坐标 private float xDown; private float yDown; // 判断横滑、竖滑的最小值 private int MAX_Y = 5; private int MAX_X = 3; // 当前点击的position private int mTouchPosition; // 当前点击的item View private MyItemLayout mTouchView; // 当前触摸状态 private int mTouchState = TOUCH_STATE_NONE; private static final int TOUCH_STATE_NONE = 0; //ACTION_DOWN时设置的状态 private static final int TOUCH_STATE_X = 1; //横滑 private static final int TOUCH_STATE_Y = 2; //竖滑 public MyListView(Context context, AttributeSet attrs) &#123; super(context, attrs); MAX_X = dp2px(MAX_X); MAX_Y = dp2px(MAX_Y); &#125; /** * 创建VelocityTracker对象，并将触摸事件加入到VelocityTracker当中 * * @param event */ private void createVelocityTracker(MotionEvent event) &#123; if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(event); &#125; /** * 获取手指在滑动的速度 * * @return 滑动速度，以每秒钟移动了多少像素值为单位 */ private int getScrollVelocity() &#123; mVelocityTracker.computeCurrentVelocity(1000); int velocity = (int) mVelocityTracker.getXVelocity(); return Math.abs(velocity); &#125; /** * 回收VelocityTracker对象 */ private void recycleVelocityTracker() &#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return super.onInterceptTouchEvent(ev); &#125; /** * 触摸事件的控制 * * @param ev * @return */ @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (ev.getAction() != MotionEvent.ACTION_DOWN &amp;&amp; mTouchView == null) &#123; return super.onTouchEvent(ev); &#125; // 加入触摸跟踪类 createVelocityTracker(ev); float moveX; float moveY; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN: int prevPosition = mTouchPosition; xDown = ev.getX(); yDown = ev.getY(); mTouchState = TOUCH_STATE_NONE; mTouchPosition = pointToPosition((int) xDown, (int) yDown); // 当前点击的Item正好是已经显示Menu的Item if (prevPosition == mTouchPosition &amp;&amp; mTouchView != null &amp;&amp; mTouchView.isMenuOpen()) &#123; mTouchState = TOUCH_STATE_X; return true; // 返回true表示接受了ACTION_DOWN，那么后面的事件依然会分发给MyListView &#125; View view = getChildAt(mTouchPosition - getFirstVisiblePosition()); // 点击的Item不是正在显示Menu的Item，则直接关闭Menu if (mTouchView != null &amp;&amp; mTouchView.isMenuOpen()) &#123; mTouchView.smoothCloseMenu(); mTouchView = null; return false; // 返回false，那么后面的事件全部会接收不到 &#125; if (view instanceof MyItemLayout) &#123; mTouchView = (MyItemLayout) view; &#125; break; case MotionEvent.ACTION_MOVE: moveX = ev.getX() - xDown; moveY = ev.getY() - yDown; if (mTouchState == TOUCH_STATE_X) &#123; // 如果是横滑，则设置leftMargin if (!mTouchView.isMenuOpen()) &#123; mTouchView.setLeftMargin((int) moveX); &#125; else &#123; mTouchView.setLeftMargin((int) (moveX - mTouchView.getMenuWidth())); &#125; return true; &#125; else if (mTouchState == TOUCH_STATE_NONE) &#123; // 设置横滑还是竖滑 if (Math.abs(moveY) &gt; MAX_Y) &#123; mTouchState = TOUCH_STATE_Y; &#125; else if (Math.abs(moveX) &gt; MAX_X) &#123; mTouchState = TOUCH_STATE_X; &#125; &#125; break; case MotionEvent.ACTION_UP: moveX = ev.getX() - xDown; if (mTouchState == TOUCH_STATE_X) &#123; // 若滑动的距离是Menu宽度的一半，或者左滑速度大于200, if (-moveX &gt; mTouchView.getMenuWidth() / 2 || (moveX &lt; 0 &amp;&amp; getScrollVelocity() &gt; 200)) &#123; // 若Menu是关闭的 if (!mTouchView.isMenuOpen()) &#123; // 滑动打开Menu mTouchView.smoothOpenMenu(); &#125; &#125; else &#123; // 滑动关闭Menu mTouchView.smoothCloseMenu(); mTouchView = null; mTouchPosition = -1; &#125; recycleVelocityTracker(); return true; &#125; break; &#125; return super.onTouchEvent(ev); &#125; private int dp2px(int dp) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, getContext().getResources().getDisplayMetrics()); &#125;&#125; 在这个项目中，触摸事件分以下几种情况： 当前没有Menu正在显示 ACTION_DOWN记录相关信息，准备接收ACTION_MOVE、ACTION_UP事件。 ACTION_MOVE中，判断是横滑还是竖滑。若是横滑，则调用setLeftMargin()，这个时候若一直滑动，Menu会慢慢地显示出来。后面会返回true，主要是为了拦截最后的super.onTouchEvent(ev)不执行。若是竖滑，则直接调用super.onTouchEvent(ev)，这个时候若一直滑动，则是ListView的上下滑动了。 ACTION_UP中，我们只需要判断是否要显示，若显示则调用smoothOpenMenu()，并返回true（这里返回true或者false都没有实际的意义）。若是不需要，则直接super.onTouchEvent(ev)。 当前有Menu正在显示 ACTION_DOWN，若当前点击的Item不是Menu正在显示的Item，那么直接smoothCloseMenu()，并且返回false。返回false后MOVE、UP等事件会统统不接收。 若是正在点击的Item，那么首先设置为横滑，并且返回true，等待后续的触摸事件。 ACTION_MOVE因为在DOWN的时候设置了mTouchState = TOUCH_STATE_X;那么会执行到if内部，因为Menu正在显示，所以不会调用setLeftMargin()，并且直接返回true，即后面的super.onTouchEvent(ev)也不会调用。 ACTION_UP中判断Menu是否要关闭，若关闭则调用smoothCloseMenu()，并且返回true。若是不需要，则直接返回super.onTouchEvent(ev)。 这里是复杂的地方，需要对各种情况进行判断，然后执行相应的逻辑。我写了好多次，改过好多次QAQ… Tips 在ACTION_DOWN的分支中，返回false会直接截断后面MOVE、UP等事件的接收。 在ACTION_MOVE与ACTION_UP的返回值，为true为false，并没有特别实际的效果，仅仅是为了返回，以此来截断super.onTouchEvent(ev)的执行。 最后下面上效果图：看起来效果也还不错，是吧？ 源码下载","tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://lijia92.github.io/tags/自定义View/"}]},{"title":"Android事件分发机制学习小记","date":"2015-11-13T17:15:22.000Z","path":"2015/11/14/touch-event/","text":"Android事件分发机制有三类：Activity、View、ViewGroup，其调用顺序是Activity-&gt;ViewGroup-&gt;View，考虑到实际开发中Activity的事件分发很少用到，这里便不作赘述。想要了解的可自行百度、谷歌。下面，我从View的事件分发开始。 View的事件分发我们知道，任何触摸事件都是从dispatchTouchEvent函数开始。在View的dispatchTouchEvent函数中，会看到这样的代码块：123456789101112131415...if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125;... 说明View若要进行事件分发，那么会优先分发给onTouch()，若onTouch()返回true，则直接返回true，不会进入到onTouchEvent()中。否则，进入到onTouchEvent()。 onTouch()与onTouchEvent()都是View中用户处理触摸事件的方法。onTouch是OnTouchListener接口中的函数，OnTouchListener接口是暴露给用户，让用户自己处理触摸事件。onTouchEvent()是View自带的接口，Android系统提供了默认的实现，当然，也可以重载该方法。 在onTouchEvent()函数中，会看到这样的代码块：12345678910...if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; ... return true; ...&#125;return false;... 即若View可点击，则返回true；若不可点击，则返回false。 在if内部，若是ACTION_UP事件，条件符合的情况下会执行performClick()方法，该方法会执行mOnClickListener.onClick()，即View的onClick事件，是在onTouchEvent()方法的ACTION_UP分支中进行调用的。 下面我做了一个测试： 分别定义一个Button与TextView，设置OnTouchListener。123456789101112131415button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(\"TAG\", \"onTouch execute, action \" + event.getAction()); return false; &#125; &#125;);textView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(\"TAG\", \"onTouch execute, action \" + event.getAction()); return false; &#125; &#125;); 点击Button，log如下：点击ImageView，log如下：可以看到Button的所有事件都执行了，而TextView只执行了ACTION_DOWN事件。针对ACTION_DOWN事件，Button的dispatchTouchEvent()返回的是true（onTouch返回false后会继续执行onTouchEvent，由于可点击，所以返回true），而TextView返回false。 修改textView的onTouch如下：123456789101112131415@Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: return true; case MotionEvent.ACTION_MOVE: return false; case MotionEvent.ACTION_UP: return false; default: break; &#125; Log.d(\"TAG\", \"onTouch execute, action \" + event.getAction()); return false; &#125; 会发现ACTION_DOWN、ACTION_MOVE（手指点击不精确，会造成移动）、ACTION_UP都会执行。后面我对这三个事件的返回值进行组合，后面发现只有在ACTION_DOWN事件触发，dispatchTouchEvent返回true时，后面的ACTION_MOVE、ACTION_UP才会执行。暂时还不知道原因，姑且理解为：ACTION_DOWN是触摸事件的起点，连消费开头的能力都不具备，那么后面的事件就免谈了？这里暂时留一个疑问。 下面我们来看看ViewGroup。 ViewGroup的事件分发ViewGroup继承于View，它中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理： ViewGroup重载了dispatchTouchEvent()方法。 ViewGroup新增了onInterceptTouchEvent()方法。 onInterceptTouchEvent()是用来判断ViewGroup是否拦截事件。默认返回false，即不拦截。在dispatchTouchEvent()中，会通过onInterceptTouchEvent()判断ViewGroup是否拦截事件，若返回true，则没有后续。若返回false，则ViewGroup会尝试分发事件给自己的子View。在分发时，会有这么一个判断：1234567if (!canceled &amp;&amp; !intercepted) &#123; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; ... &#125; 即只有在ACTION_DOWN的时候，ViewGroup才会尝试着将事件分发给子View，这便是疑问的答案。在ACTION_DOWN之后，传递ACTION_MOVE或ACTION_UP时，ViewGroup不会再执行上面的if，而是直接遍历子View链表，查找之前接受ACTION_DOWN的子View，并将触摸事件分配给这些子View。 小结 View事件分发，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 onTouchEvent()的返回值与View是否可点击有关。 ViewGroup中的dispatchTouchEvent()会将触摸事件进行递归遍历传递。ViewGroup会遍历它的所有孩子，对每个孩子都递归的调用dispatchTouchEvent()来分发触摸事件。 若ViewGroup的某个孩子没有接受(消费或者拦截)ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子。 ViewGroup的onInterceptTouchEvent()默认返回false。 下面贴一张总结图： 注：文中源码的if判断都是以一般情况为前提，提取我们比较关注的点进行判断来得出的结论。 参考文章http://blog.csdn.net/guolin_blog/article/details/9097463http://blog.csdn.net/guolin_blog/article/details/9153747http://wangkuiwu.github.io/2015/01/03/TouchEvent-View/http://wangkuiwu.github.io/2015/01/04/TouchEvent-ViewGroup/","tags":[{"name":"事件分发","slug":"事件分发","permalink":"http://lijia92.github.io/tags/事件分发/"}]},{"title":"Android Studio使用Genymotion小记","date":"2015-11-05T02:46:29.000Z","path":"2015/11/05/genymotion/","text":"在学习Android Studio的过程中，看到网上很多人都推荐使用Genymotion插件，在某些无法使用真机的情况下，这个模拟器插件能大大加快模拟器的运行速度。而且由于没有Android 5.0以上的真机，使用Genymotion可以运行Android 5.0以上的模拟器，看看Meterial Design的设计，所谓一举两得，于是便开始了一波Genymotion的学习。 安装Genymotion安装Genymotion。进入到官网，下载Genymotion，没有安装Virtual Box的，选择带有Virtual Box的安装文件进行下载。下载成功后，安装，基本都是下一步，下一步。 Android Studio使用Genymotion插件 Android Studio安装Genymotion插件。安装过程很简单，网上一搜一大把，就不赘述了。 将Genymotion路径配置到Android Studio中。 启动Genymotion插件，选择要配置的机型，系统，点击Next，等待下载，安装，部署结束之后，启动模拟器即可进行使用了。 问题 在选择好机型后，点击Next时，一直在Downloading files界面，最后弹出”Connection timeout occurred”，提示创建虚拟机失败。出现这种情况，主要是下载的ova文件无法正常下载下来。打开日志文件（路径：C:\\Users\\Administrator\\AppData\\Local\\Genymobile\\genymotion.log），可以看到类似的log：拷贝出.ova的那个地址，下载好这个ova文件后，替换到C:\\Users\\Administrator\\AppData\\Local\\Genymobile\\Genymotion\\ova文件夹中即可。在我的情形中，是由于公司网速太慢导致QAQ…后面在寝室一下就好了~ 创建好虚拟机后，启动失败。网上查了许多解决方法，诸如修改Ip的一些等等，但是并不适用于我的情况。后面找到了解决方法：减少虚拟机内存！打开Virtual Box，找到相应的虚拟机，打开设置-&gt;系统，将内存大小从2048改成1024后，虚拟机启动成功！ 但是当我创建安卓5.0以上的虚拟机时，虚拟机虽然启动成功了，却一直停留在下面这个画面：本以为进度到了74之后就会结束，进入系统的，结果是我太天真…进度到了74之后，黑屏，显示一个“Android”字样，然后又重复开始从1到74，就这样不停重复不停重复，根本无法使用虚拟机。于是又在网上搜罗相关的解决办法，最后算是找到了：安装HAXM。 首先进入BIOS开启intel虚拟加速。不同的品牌电脑设置界面不同，这个自行百度。 需要在SDK Manager里面下载Intel x86 Emulator Accelator。 下载完成之后，找到相关安装文件进行安装。 进入cmd，输入命令【sc query intelhaxm】查看intelhaxm状态。没有开启的话，输入【sc start intelhaxm】即可进行开启。通过以上步骤，我的安卓5.1虚拟机，总算是成功跑起来了！！！ 后面回到家里，也通过上述一些操作，但是却仍然启动失败！！！后面打开VirtualBox，从VirtualBox启动虚拟机，报如下的错误：后面网上找到该错误的原因，是因为系统破解，system32文件夹下的uxtheme.dll文件出问题。在网上下载电脑相应64位或32位的未破解的uxtheme.dll文件，替换到system32里去，然后重新启动虚拟机，成功！也可以下载下面的破解还原工具，还原破解。破解还原工具 使用Genymotion安装APK出现错误INSTALL_FAILED_CPU_ABI_INCOMPATIBLE，解决办法如下：下载这个Zip，不要解压，直接拖到虚拟机窗口中。对，你没有看错，就是直接拖进去。然后重启虚拟机就可以了。","tags":[{"name":"android studio","slug":"android-studio","permalink":"http://lijia92.github.io/tags/android-studio/"}]},{"title":"Java反射实现接口","date":"2015-10-28T04:00:03.000Z","path":"2015/10/28/reflect-interface/","text":"之前做过一个插件，综合了移动MM，移动和游戏，沃商店等一些计费SDK。将这些计费SDK提供的接口全部整合，最后由插件提供一套接口。通过后台配置，来让游戏使用某种计费SDK。游戏开发商接入计费的时候，只需要调用插件提供的一套接口即可。因为不可能保证游戏会包含所有的计费SDK的代码，所以插件内部只能利用反射来实现。通过反射来获取类，获取方法进行调用是比较简单的。 但是有个问题困扰了我很久：计费SDK都有提供回调接口，使游戏开发商在计费成功或失败进行回调，那么如何通过反射来实现这些回调接口，进行调用呢？通过一段时间的摸索，知道了一种解决方法：使用Proxy类与InvocationHandler接口。 下面通过一个例子进行讲解。 首先以计费SDK为例子写一个library工程，提供一个方法和一个回调接口： 12345678910111213package com.lastwarmth.library;public class MyLibrary &#123; public interface Callback &#123; void doCallback(); &#125; public void mainMethod(Callback callback) &#123; System.out.println(\"doing main...\"); callback.doCallback(); &#125;&#125; 新建MyTest工程，编写类实现InvocationHandler： 1234567891011121314package com.lastwarmth.demo;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyHandler implements InvocationHandler&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"doing callback...\"); return null; &#125;&#125; MyTest工程测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.lastwarmth.demo;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class MyTest &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; mClass = Class.forName(\"com.lastwarmth.library.MyLibrary\"); Class&lt;?&gt; mCallback = Class.forName(\"com.lastwarmth.library.MyLibrary$Callback\"); MyHandler mHandler = new MyHandler(); Object mObj = Proxy.newProxyInstance(MyTest.class.getClassLoader(), new Class[] &#123; mCallback &#125;, mHandler); Method mMethod = mClass.getDeclaredMethod(\"mainMethod\", new Class[] &#123; mCallback &#125;); mMethod.invoke(mClass.newInstance(), new Object[] &#123; mObj &#125;); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SecurityException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 将MyLibrary打成jar包，引入到MyTest的build path中，或者直接将java代码考到MyTest工程下（若不这样做，运行会抛出异常，但不会致使程序崩溃）。然后运行，控制台输出结果： 12doing main...doing callback... 说明MyTest类通过反射获取到了MyLibrary类中的Callback接口，并实现调用。代码比较简单，就不作过多讲述了。 总结： java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。 static InvocationHandler getInvocationHandler(Object proxy)：该方法用于获取指定代理对象所关联的调用处理器 static Class getProxyClass(ClassLoader loader, Class[] interfaces) ：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 static boolean isProxyClass(Class cl)：该方法用于判断指定类对象是否是一个动态代理类 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例文中采用第4个方法，获取到了实现接口Callback的实例。 java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。 Object invoke(Object proxy, Method method, Object[] args)：该方法负责集中处理动态代理类上的所有方法调用。第一个参数是代理类实例，第二个参数是被调用的方法对象。第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行。 在本文中，并没有代理类。直接在invoke方法中写入我们继承Callback接口需要实现的方法内容即可。通过Proxy类与InvocationHandler接口，即可完成反射实现接口的功能了。","tags":[{"name":"java","slug":"java","permalink":"http://lijia92.github.io/tags/java/"}]},{"title":"百度定位SDK无法定位","date":"2015-10-24T09:14:50.000Z","path":"2015/10/24/baidu-loc/","text":"最近的项目中，有使用到百度定位SDK，在自己的debug环境安装apk，手机可以进行定位。但是发布release版本后安装，手机却无法定位。后面找到问题是百度配置的秘钥不对。 百度地图SDK在申请秘钥时，需要SHA1值。此值在Eclipse中在Eclipse中，可直接看到：若是使用Android Studio，直接在setting中好像看不到该值。此时需要通过命令行来获取，具体操作可参考百度开发指南。 通过上述方式获取到的SHA1值为debug版本的，若是在Android Studio中，采用自己的keystore生成的apk对应的SHA1值会与debug版本的值不一致，这就导致了在百度开放平台上申请到的key值不对（key值需要SHA1值与app包名）。 此时需要获得release版本对应的SHA1值。步骤如下： 将自己的keystore拷贝一份到C:\\Users\\Administrator.android目录下； 命令行进入到.android文件夹，执行命令：1keytool -list -keystore keystorefile keystorefile为刚刚拷贝的keystore文件。会提示输入秘钥库口令，输入之后回车即可获取SHA1值。使用该SHA1值去开放平台申请秘钥，然后替换AndroidManifest.xml中的key值。之后采用自己那个keystore进行release打包出来的apk即可正常使用百度SDK了。","tags":[{"name":"sdk","slug":"sdk","permalink":"http://lijia92.github.io/tags/sdk/"}]},{"title":"Android DDMS无法输出logcat","date":"2015-10-24T08:00:11.000Z","path":"2015/10/24/ddms-logcat/","text":"问题在Android开发中，我们经常需要真机测试，查看log。有好几次碰到如下的情况：1Unable to open log device‘/dev/log/main’: No such file or directory 导致连上真机却看不到log。 网上有很多解决方法，比如各种重启，重启手机，电脑，eclipse，adb，重新安装eclipse，拨号等。又或者stackoverflow上说的与手机内核有关。但是对我的手机都不奏效，我的手机是华为3C，刷的MIUI的rom。 原因后面折腾了老半天，终于找到了原因： ./system/etc/init.d目录下的脚本删掉了日志设备 知道问题出在哪了，那么解决起来就很方便了。 解决方法找到删掉日志设备的脚本123adb shellsucd /system/etc/init.d &amp;&amp; grep -r \"rm /dev/log/main\" 找到该文件：03MTKTweakElse文件。 修改脚本利用pull指令将该文件拷贝到电脑上。1abd pull /system/ect/init.d/03MTKTweakElse L:\\ 利用文本编辑工具（editplus、notepad++等）打开03MTKTweakElse文件，找到rm /dev/log/main，然后注释掉该行。 将文件替换到之前的路径中1adb push L:\\03MTKTweakElse /system/etc/init.d 重启手机 经过以上几个步骤，应该就可以输出logcat了。 Tips 手机需要root。 adb pull、push指令可能会失败，建议可以使用R.E资源管理器。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/日常开发/"}]}]