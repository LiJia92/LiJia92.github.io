[{"title":"CodeBuddy IDE 初体验","date":"2025-07-28T03:43:50.000Z","path":"2025/07/28/codebuddy/","text":"在上周五的时候，观看了一些公众号讲解关于 CodeBuddy IDE 的文章，让让我对这款腾讯云最新推出的AI编程工具产生了浓厚兴趣。作为国内首个实现”产品-设计-研发部署”全流程AI一体化的开发工作台，CodeBuddy IDE的出现正在重塑软件开发的范式。 产品定位：AI驱动的全栈开发新时代CodeBuddy IDE不仅仅是一个代码编辑器，它定位为开发者的AI搭档，能够理解设计意图、生成代码、重构应用，甚至处理部署流程。它的目标是将开发者从繁琐的编码工作中解放出来，专注于创意和架构设计等更高层次的工作。腾讯云开发者产品总经理刘毅表示，未来AI编程将分化成两种范式：简单应用开发需求，非技术背景的个人开发者通过氛围编程即可实现；复杂系统需要专业化的团队协作，则需要基于共同规范的规约编程。 核心功能概览CodeBuddy IDE集成了多项革命性功能，彻底改变了传统开发流程： AI设计生成：将手绘概念和创意转化为高保真交互原型，缩短设计周期，快速验证创意。用户可以上传手绘草图、线框图，甚至是参考图片，AI都能智能解析并转化为可交互的产品原型。 AI代码补全：基于先进AI技术的智能实时代码预测与自动补全，提高编码效率，减少语法错误。 设计到代码转换：将Figma设计以99.9%的精确度转换为生产就绪代码，消除设计与开发之间的鸿沟，加速产品迭代。 多模型支持：国际版整合了Claude、GPT、Gemini等顶尖AI模型，国内版支持腾讯混元、DeepSeek等模型，满足不同开发者的需求。 全流程开发支持：从需求分析到PRD生成，再到设计、开发和部署，CodeBuddy IDE提供了一站式解决方案。用户只需用自然语言描述产品构想，AI即可辅助进行深度需求分析，生成结构化的需求文档（PRD）。 革命性的开发体验传统软件开发需要产品、设计、研发多个团队接力协作，涉及产品规划、设计、研发和部署多个环节。而CodeBuddy IDE允许用户一个人担任”产品经理、设计师和前后端工程师”，实现从创意到产品的全流程开发。 例如，开发一个”二手书交易平台”，用户只需输入需求，CodeBuddy就能处理从需求分析、界面设计到后端逻辑、数据库配置的全流程。通过内置BaaS服务和强大的AI编程助手，极大简化了动态网站的开发过程。 适用人群与未来展望CodeBuddy IDE不仅适合专业开发者提升效率，更降低了软件开发的门槛，让非技术背景的从业者也能快速实现创意。腾讯云开发者产品总经理刘毅认为，这将催生更多独立开发者，形成一个增量市场。 随着AI技术的不断发展，CodeBuddy IDE有望在以下方面持续进化：更精准的代码生成能力、更自然的交互方式、更深度的行业解决方案定制，以及更广泛的生态系统整合。对于开发者而言，拥抱这类AI辅助工具将成为提升竞争力的关键。 总体而言，CodeBuddy IDE代表了软件开发的未来趋势，通过AI驱动的全流程整合，它不仅提高了开发效率，更重新定义了软件开发的可能性，让创意转化为产品的过程变得前所未有的简单。","tags":[{"name":"AI","slug":"AI","permalink":"http://lijia92.github.io/tags/AI/"}]},{"title":"爬楼运动实践","date":"2025-07-25T09:43:00.000Z","path":"2025/07/25/climb/","text":"5 月份入手了一块华为手表 GT5，银色的表盘在手腕上闪闪发光，主要是为了满足运动时记录心率和听歌的需求。说起来也巧，6 月 10 日那个平凡的晚上，我看着手表上显示的各种运动模式，找了许久终于找到”爬楼梯”模式。早些时候就是爬楼梯来锻炼，这次准备带着手表试试，没想到这一试就是一个半月。从 6 月 10 日到今天，中途偶尔因为某些原因休息一两天，体重从 77.5kg 稳步降到了现在的 70.5kg，成功减重 7kg。每次站在体重秤上看到数字的变化，都有种不敢置信的感觉。这个成果让我自己都有些意外，连家人都说我明显瘦了一圈，以前有些紧的衣服现在穿起来也宽松了不少。 我的运动场地是住宅楼的楼梯间，这个看似普通的空间成了我的专属健身房。每天从 4 楼开始，一步一步向上攀登，直到 34 楼，一趟 30 层楼梯。刚开始的时候，爬到 20 层就气喘吁吁，腿部肌肉酸痛不已。但随着体能的提升，现在稳定在一天爬 4 趟，总共 120 层楼梯，相当于爬升了 300 多米的高度。 爬楼过程中，手表显示的心率数据稳定在 150 上下，这正好是最佳的燃脂心率区间。整个过程总耗时 45 分钟左右，包括中间的短暂休息。前段时间武汉梅雨季节连绵不断，外面雨水淅淅沥沥，但楼梯间这个室内空间完全不受天气影响，每天都能正常运动。这也让我深刻体会到选择爬楼梯的一个巨大优势——不用担心刮风下雨，不用办健身卡，随时随地都能锻炼。 减重效果这么明显，很大程度上是因为严格的饮食控制。每天午饭之后就彻底断食，只喝白开水，说实话一大半是饿瘦的。刚开始的几天特别难熬，下午时分肚子咕咕叫，晚上躺在床上还能感受到胃部的空虚感。但人的适应能力真的很强，大概一周后就习惯了这种节奏。看着体重秤上的数字一天天下降，那种成就感足以抵消饥饿带来的不适。等体重到达理想目标后，我准备调整策略，每天晚上少量进食一些蛋白质和蔬菜，既保持营养平衡，又不至于反弹。 在运动过程中，我逐渐摸索出了一套科学的方法。每次运动前，我都会在 4 楼做 5 分钟的热身运动，活动膝关节、踝关节，让身体进入运动状态。考虑到爬楼梯对膝盖的冲击较大，我特意买了一副护膝，虽然看起来有些专业，但确实能有效保护关节。爬楼梯时的姿势也很重要，我保持身体重心尽量不变化，上半身微微前倾，用前脚掌着地，这样能减少对膝盖的冲击。在楼梯连接处，我会特意走外圈转大弯，避免急转弯对踝骨造成扭伤。这些看似细微的技巧，在长期运动中显得格外重要。 装备方面我追求简单实用，随身携带一条吸汗性好的毛巾，夏天爬楼出汗量惊人，没有毛巾真的很难受。我把一个 350ml 的咖啡水杯固定放在 4 楼的窗台上，每爬完一趟下来都会喝几口温水，既补充水分又不会给肠胃造成负担。华为手表 GT5 在整个过程中发挥了核心作用，彩色屏幕上实时显示的心率、卡路里消耗、运动时长等数据，让我对每次运动都有清晰的掌控。更重要的是，通过手表蓝牙连接无线耳机播放音乐，摆脱厚重的手机，节奏感强的歌曲能让枯燥的爬楼过程变得有趣许多。 坚持一个半月下来，收获远超预期。除了体重从 77.5kg 降到 70.5kg 这个显著变化外，整个人的精神状态也焕然一新。以前下午总是昏昏欲睡，现在精力充沛，工作效率明显提升。晚上的睡眠质量也改善了不少，基本上沾枕头就能入睡，再也不用为失眠而烦恼。最让我感到意外的是，这种看似单调的运动竟然成了我每天最期待的时光。当音乐在耳边响起，脚步有节奏地踏在楼梯上，汗水顺着脸颊滑落，那种身心合一的感觉让人上瘾。有时候工作压力大，爬完楼梯后所有的烦恼都随着汗水一起挥发了。 回想起来，这一个半月的坚持改变的不仅仅是体重数字，更是一种生活态度。爬楼梯作为一种简单易行的运动方式，不需要额外的场地费用，不需要复杂的装备，不受天气限制，只要有楼梯就能开始。对于忙碌的都市人来说，这或许是最容易坚持的运动方式之一。当然，任何运动都需要循序渐进，量力而行。如果你也想尝试爬楼梯运动，建议从少量开始，逐步增加强度，同时注意保护关节，做好热身和拉伸。最重要的是，找到适合自己的节奏，享受运动带来的快乐，这样才能长久坚持下去。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Android Launcher 升级 Rom - 续","date":"2025-07-11T08:07:30.000Z","path":"2025/07/11/rom-update1/","text":"上篇文章记录了通过 Rom 自带的固件升级功能，结合无障碍服务进行自动点击，来实现了 Rom 的自动升级。OTA 包下载完成后，若要更新，需要重启一次设备。无障碍自动点击，也会出现弹窗一闪而过的异象。另外放置在存储卡根目录的 update.zip 不太好管理，比如有多个版本的 Rom 升级等等。于是研究了 Rom 的相关源码，终于有所收获，记录一下优化方案。 在上文中，我抓到升级弹窗的包名为android.rockchip.update.service，于是搜索对应包名下面的类，结果令我大跌眼镜：没有任何结果。继续搜索android.rockchip.update.service/android.rockchip.update.service.NotifyDeleteActivity，也是没有任何结果。这就非常奇怪了，我已经下载了刷机用的 Android 系统源码了，为什么搜不到相关类呢？后面看到源码工程里，还有许多的 jar 包文件，可能就在这些 jar 包中了吧？工程实在是太大了，50G 的空间都不够，给我电脑磁盘都干满了，申请了更换更大空间的电脑，才能继续研究。这也算是第一次完整接触一个 Android 系统源码，研究起来还是挺费劲的。还好我的目的很清晰：找到系统 OTA 升级的代码。弹窗入口无法查找，就只能找可能的相关类了。于是搜索RecoverySystem.installPackage，此方法虽然在上文中使用失败，但是仍然可以作为一个入口进行尝试。果然找到一个类：NonAbUpdateInstaller。代码如下： 123456789101112131415161718192021222324252627282930313233343536package com.android.server.devicepolicy;import android.app.admin.DevicePolicyManager.InstallSystemUpdateCallback;import android.app.admin.StartInstallingUpdateCallback;import android.content.Context;import android.os.ParcelFileDescriptor;import android.os.RecoverySystem;import android.util.Log;import java.io.IOException;/** * Used for installing an update for &lt;a href=&quot;https://source.android.com/devices/tech/ota/nonab&quot;&gt;non * AB&lt;/a&gt; devices. */class NonAbUpdateInstaller extends UpdateInstaller &#123; NonAbUpdateInstaller(Context context, ParcelFileDescriptor updateFileDescriptor, StartInstallingUpdateCallback callback, DevicePolicyManagerService.Injector injector, DevicePolicyConstants constants) &#123; super(context, updateFileDescriptor, callback, injector, constants); &#125; @Override public void installUpdateInThread() &#123; try &#123; RecoverySystem.installPackage(mContext, mCopiedUpdateFile); notifyCallbackOnSuccess(); &#125; catch (IOException e) &#123; Log.w(TAG, &quot;IO error while trying to install non AB update.&quot;, e); notifyCallbackOnError( InstallSystemUpdateCallback.UPDATE_ERROR_UNKNOWN, Log.getStackTraceString(e)); &#125; &#125;&#125; 继承自UpdateInstaller，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.android.server.devicepolicy;import android.annotation.Nullable;import android.app.admin.DevicePolicyEventLogger;import android.app.admin.DevicePolicyManager.InstallSystemUpdateCallback;import android.app.admin.StartInstallingUpdateCallback;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.BatteryManager;import android.os.Environment;import android.os.FileUtils;import android.os.ParcelFileDescriptor;import android.os.PowerManager;import android.os.Process;import android.os.RemoteException;import android.stats.devicepolicy.DevicePolicyEnums;import android.util.Log;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;abstract class UpdateInstaller &#123; private StartInstallingUpdateCallback mCallback; private ParcelFileDescriptor mUpdateFileDescriptor; private DevicePolicyConstants mConstants; protected Context mContext; @Nullable protected File mCopiedUpdateFile; static final String TAG = &quot;UpdateInstaller&quot;; private DevicePolicyManagerService.Injector mInjector; protected UpdateInstaller(Context context, ParcelFileDescriptor updateFileDescriptor, StartInstallingUpdateCallback callback, DevicePolicyManagerService.Injector injector, DevicePolicyConstants constants) &#123; mContext = context; mCallback = callback; mUpdateFileDescriptor = updateFileDescriptor; mInjector = injector; mConstants = constants; &#125; public abstract void installUpdateInThread(); public void startInstallUpdate() &#123; mCopiedUpdateFile = null; if (!isBatteryLevelSufficient()) &#123; notifyCallbackOnError( InstallSystemUpdateCallback.UPDATE_ERROR_BATTERY_LOW, &quot;The battery level must be above &quot; + mConstants.BATTERY_THRESHOLD_NOT_CHARGING + &quot; while not charging or &quot; + &quot;above &quot; + mConstants.BATTERY_THRESHOLD_CHARGING + &quot; while charging&quot;); return; &#125; Thread thread = new Thread(() -&gt; &#123; mCopiedUpdateFile = copyUpdateFileToDataOtaPackageDir(); if (mCopiedUpdateFile == null) &#123; notifyCallbackOnError( InstallSystemUpdateCallback.UPDATE_ERROR_UNKNOWN, &quot;Error while copying file.&quot;); return; &#125; installUpdateInThread(); &#125;); thread.setPriority(Process.THREAD_PRIORITY_BACKGROUND); thread.start(); &#125; private boolean isBatteryLevelSufficient() &#123; Intent batteryStatus = mContext.registerReceiver( /* receiver= */ null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); float batteryPercentage = calculateBatteryPercentage(batteryStatus); boolean isBatteryPluggedIn = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, /* defaultValue= */ -1) &gt; 0; return isBatteryPluggedIn ? batteryPercentage &gt;= mConstants.BATTERY_THRESHOLD_CHARGING : batteryPercentage &gt;= mConstants.BATTERY_THRESHOLD_NOT_CHARGING; &#125; private float calculateBatteryPercentage(Intent batteryStatus) &#123; int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, /* defaultValue= */ -1); int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, /* defaultValue= */ -1); return 100 * level / (float) scale; &#125; private File copyUpdateFileToDataOtaPackageDir() &#123; try &#123; File destination = createNewFileWithPermissions(); copyToFile(destination); return destination; &#125; catch (IOException e) &#123; Log.w(TAG, &quot;Failed to copy update file to OTA directory&quot;, e); notifyCallbackOnError( InstallSystemUpdateCallback.UPDATE_ERROR_UNKNOWN, Log.getStackTraceString(e)); return null; &#125; &#125; private File createNewFileWithPermissions() throws IOException &#123; File destination = File.createTempFile( &quot;update&quot;, &quot;.zip&quot;, new File(Environment.getDataDirectory() + &quot;/ota_package&quot;)); FileUtils.setPermissions( /* path= */ destination, /* mode= */ FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IROTH, /* uid= */ -1, /* gid= */ -1); return destination; &#125; private void copyToFile(File destination) throws IOException &#123; try (OutputStream out = new FileOutputStream(destination); InputStream in = new ParcelFileDescriptor.AutoCloseInputStream( mUpdateFileDescriptor)) &#123; FileUtils.copy(in, out); &#125; &#125; void cleanupUpdateFile() &#123; if (mCopiedUpdateFile != null &amp;&amp; mCopiedUpdateFile.exists()) &#123; mCopiedUpdateFile.delete(); &#125; &#125; protected void notifyCallbackOnError(int errorCode, String errorMessage) &#123; cleanupUpdateFile(); DevicePolicyEventLogger .createEvent(DevicePolicyEnums.INSTALL_SYSTEM_UPDATE_ERROR) .setInt(errorCode) .write(); try &#123; mCallback.onStartInstallingUpdateError(errorCode, errorMessage); &#125; catch (RemoteException e) &#123; Log.d(TAG, &quot;Error while calling callback&quot;, e); &#125; &#125; protected void notifyCallbackOnSuccess() &#123; cleanupUpdateFile(); mInjector.powerManagerReboot(PowerManager.REBOOT_REQUESTED_BY_DEVICE_OWNER); &#125;&#125; 可以看到代码非常简单：将 OTA 文件拷贝到 &#x2F;data&#x2F;ota_package 目录下，通过File.createTempFile生成一个 updateXXXXXX.zip 的临时文件，然后调用RecoverySystem.installPackage传入这个临时文件，就可以进行 OTA 升级了。于是我也按照这个方案，重新改写了 RomUpdater 类，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187object RomUpdater &#123; private const val TAG = &quot;RomUpdater&quot; private const val SP_KEY = &quot;RomVersion&quot; private const val S_IRWXU: Int = 448 private const val S_IRGRP: Int = 32 private const val S_IROTH: Int = 4 /** * 应用 ROM 更新 * @param context 上下文对象 * @param updateFile 更新包文件（需确保路径可被 Recovery 访问） * @param versionCode 服务器返回的版本号 */ @SuppressLint(&quot;MissingPermission&quot;) fun applyUpdate(context: Context, updateFile: File, versionCode: Int) &#123; Config.execute &#123; kotlin.runCatching &#123; // 1. 检测本地是否存在文件，存在则弹窗升级 val model = getOTAModel(context) val localVersion = AppUtil.getRomVersion() if (localVersion != null &amp;&amp; model != null &amp;&amp; localVersion &lt; model.versionCode) &#123; showInstallDialog(context, updateFile) return@execute &#125; // 2. 不存在校验更新包签名 if (!verifySignature(updateFile)) &#123; throw Exception(&quot;更新包签名校验失败，$&#123;versionCode&#125;&quot;) &#125; // 3. 比较版本号，通过后拷贝文件，写入 SP val updateVersion = AppUtil.parseOtaPackage(updateFile.absolutePath) if (updateVersion != null &amp;&amp; updateVersion == versionCode &amp;&amp; localVersion != null &amp;&amp; updateVersion &gt; localVersion) &#123; val file = createNewFileWithPermissions() FileUtils.copyFile(updateFile, file) val text = JSON.toJSONString(OTAModel().apply &#123; this.versionCode = versionCode this.path = file.absolutePath &#125;) SPUtils.putString(SP_KEY, text, context) LogUtils.e(TAG, &quot;设置本地路径，$&#123;text&#125;&quot;) &#125; else &#123; throw Exception(&quot;更新包版本号不匹配，realVersion=$&#123;updateVersion&#125;，serverVersion=$&#123;versionCode&#125;，localVersion=$&#123;localVersion&#125;&quot;) &#125; // 4. 弹窗提示升级 showInstallDialog(context, updateFile) &#125;.onFailure &#123; LogUtils.e(TAG, &quot;applyUpdate fail:&quot; + it.message) clear(context, updateFile) &#125; &#125; &#125; /** * 清除本地文件 */ fun clear(context: Context, updateFile: File?) &#123; if (updateFile != null) &#123; FileUtils.deleteFile(updateFile) &#125; val model = getOTAModel(context) ?: return FileUtils.deleteFile(File(model.path)) SPUtils.putString(SP_KEY, null, context) &#125; @SuppressLint(&quot;MissingPermission&quot;) private fun showInstallDialog(context: Context, updateFile: File?) &#123; MainThreadUtils.post &#123; AlertDialog.Builder(Config.getCurrentActivity()) .setTitle(&quot;系统升级&quot;) .setMessage(&quot;检测到系统升级，是否需要立即安装更新？&quot;) .setPositiveButton(&quot;立即安装&quot;) &#123; _, _ -&gt; kotlin.runCatching &#123; val model = getOTAModel(context) if (model != null) &#123; val file = File(model.path) if (file.exists() &amp;&amp; file.length() &gt; 0) &#123; RecoverySystem.installPackage(context, file) &#125; &#125; else &#123; throw Exception(&quot;本地文件缺失&quot;) &#125; &#125;.onFailure &#123; LogUtils.e(TAG, &quot;install fail:&quot; + it.message) clear(context, updateFile) &#125; &#125; .setNegativeButton(&quot;下次再说&quot;, null) .create() .show() &#125; &#125; /** * 升级包放到根目录 update.zip 地址 */ fun getUpdateZipPath(): String &#123; return &quot;/$&#123;Environment.getExternalStorageDirectory().path&#125;/update.zip&quot; &#125; /** * 删除 zip 地址 */ fun deleteZipFile() &#123; File(getUpdateZipPath()).delete() &#125; /** * 对比版本 */ fun checkRomUpdate(context: Context) &#123; // 旧方案文件删除 deleteZipFile() // 对比版本，若无需更新，将本地文件清除 val romVersion = AppUtil.getRomVersion() val model = getOTAModel(context) if (romVersion == null || model == null || romVersion &gt;= model.versionCode) &#123; clear(context, null) &#125; &#125; /** * 校验更新包签名（简化版） * 实际开发中应使用设备厂商的公钥验证 */ private fun verifySignature(file: File): Boolean &#123; return try &#123; // 实际应替换为厂商公钥验证 RecoverySystem.verifyPackage(file, null, null) true &#125; catch (e: GeneralSecurityException) &#123; LogUtils.e(TAG, &quot;验证签名报错1:&quot; + e.message) false &#125; catch (e: IOException) &#123; LogUtils.e(TAG, &quot;验证签名报错2:&quot; + e.message) false &#125; &#125; /** * 创建 ota 升级包 File */ private fun createNewFileWithPermissions(): File &#123; val destination = File.createTempFile( &quot;update&quot;, &quot;.zip&quot;, File(Environment.getDataDirectory().toString() + &quot;/ota_package&quot;) ) setPermissions( /* path= */ destination.absolutePath, /* mode= */ S_IRWXU or S_IRGRP or S_IROTH, /* uid= */ -1, /* gid= */-1 ) return destination &#125; /** * 给权限 */ private fun setPermissions(path: String, mode: Int, uid: Int, gid: Int): Int &#123; try &#123; Os.chmod(path, mode) &#125; catch (e: ErrnoException) &#123; LogUtils.e(TAG, &quot;Failed to chmod($path): $e&quot;) return e.errno &#125; if (uid &gt;= 0 || gid &gt;= 0) &#123; try &#123; Os.chown(path, uid, gid) &#125; catch (e: ErrnoException) &#123; LogUtils.e(TAG, &quot;Failed to chown($path): $e&quot;) return e.errno &#125; &#125; return 0 &#125; private fun getOTAModel(context: Context): OTAModel? &#123; return JSON.parseObject(SPUtils.getString(SP_KEY, null, context), OTAModel::class.java) &#125; class OTAModel : Serializable &#123; var versionCode: Int = 0 var path: String? = null &#125;&#125; 我将代码拷贝过来，然后把 OTA 文件复制到这个 File 中，最后调用RecoverySystem.installPackage，竟然真的升级成功了！敢情这个方法若要能成功进行升级，还必须将 OTA 文件放到 &#x2F;data&#x2F;ota_package 目录下。后面为了方便管理，我尝试在此目录下，通过 new File 的形式，传入固定的文件名，比如 update20250711.zip 这样，但是调试的时候发现文件拷贝的时候，每次只有 4096 个字节就停止了，导致进行升级时，出现错误。而恢复成File.createTempFile就一切正常，实在是摸不着头脑。但也不影响整体，通过这样的优化方案，省去了重启设备这个多余的步骤，另外也不会出现一闪而过的弹窗，相比上文的方案要好上不少。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android Launcher 升级 Rom","date":"2025-06-27T09:21:47.000Z","path":"2025/06/27/rom-update/","text":"近期接到一个需求：利用 Launcher 对系统 Rom 进行升级。OTA 包由其他同事提供，Launcher 与服务器通信判断是否有新的升级包，若有升级包则下载到本地，由 Launcher 进行 Rom 升级。过程不算顺利，写下此文记录一下。 RecoverySystemRecoverySystem 有一个 installPackage 方法，可以直接进行 Rom 升级，只需要声明 REBOOT 权限即可。通过 AI 很快得到如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243object RomUpdater &#123; private const val TAG = &quot;RomUpdater&quot; /** * 应用 ROM 更新 * @param context 上下文对象 * @param updateFile 更新包文件（需确保路径可被 Recovery 访问） */ @SuppressLint(&quot;MissingPermission&quot;) fun applyUpdate(context: Context, updateFile: File) &#123; // 1. 校验更新包签名 if (!verifySignature(updateFile)) &#123; LogUtils.e(TAG, &quot;更新包签名校验失败&quot;) return &#125; // 2. 使用 RecoverySystem API 触发更新 try &#123; RecoverySystem.installPackage(context, updateFile) LogUtils.i(TAG, &quot;已成功触发系统更新&quot;) &#125; catch (e: IOException) &#123; LogUtils.e(TAG, &quot;写入 Recovery 指令失败&quot;, e) &#125; catch (e: SecurityException) &#123; LogUtils.e(TAG, &quot;权限不足，需要系统签名&quot;, e) &#125; &#125; /** * 校验更新包签名（简化版） * 实际开发中应使用设备厂商的公钥验证 */ private fun verifySignature(file: File): Boolean &#123; return try &#123; // 实际应替换为厂商公钥验证 RecoverySystem.verifyPackage(file, null, null) true &#125; catch (e: GeneralSecurityException) &#123; false &#125; catch (e: IOException) &#123; false &#125; &#125;&#125; 代码流程非常简单，先验证文件签名，然后进行安装。可一阵尝试下来后，每次进入系统更新界面，就会弹出来一个错误，也没有写明具体的原因。通过修改 update.zip 的文件地址，比如放到 &#x2F;cache 目录，或者放到 &#x2F;sdcard 根目录，都无法升级成功。更有甚者，刷机失败导致系统无限自动重启，只能断电重新刷机。无奈之下最终放弃。 UpdateEngine通过 AI 又打开了 UpdateEngine 的思路。于是查看 UpdateEngine 代码。它位于android.os包下，同时被标记为@SystemApi，项目代码无法引用到。也是通过 AI 找到了三种方式。 compile only通过 compileOnly android.jar 文件，给项目提供编译环境，使项目中可以引用到 UpdateEngine。可当我如此做了之后，发现依然引用不到。最后查看 android.jar，发现这个 jar 本身就不会包含 UpdateEngine 类，应该是 android 在打包的时候，将这些不对外的 api 全部剔除掉了。于是只能使用下一种方式了。 反射结合 AI 很快得到了如下反射代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import android.content.Context;import android.util.Log;import java.io.File;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class UpdateEngineReflector &#123; private static final String TAG = &quot;UpdateEngineReflector&quot;; public static void startOtaUpdateReflected(Context context, String otaPackageFilePath) &#123; try &#123; // 1. 获取 UpdateEngine 类 Class&lt;?&gt; updateEngineClass = Class.forName(&quot;android.os.UpdateEngine&quot;); // 2. 获取 UpdateEngineCallback 接口及其方法 Class&lt;?&gt; updateEngineCallbackClass = Class.forName(&quot;android.os.UpdateEngineCallback&quot;); // 查找 onStatusUpdate 方法 Method onStatusUpdateMethod = updateEngineCallbackClass.getMethod(&quot;onStatusUpdate&quot;, int.class, float.class); // 查找 onPayloadApplicationComplete 方法 Method onPayloadApplicationCompleteMethod = updateEngineCallbackClass.getMethod(&quot;onPayloadApplicationComplete&quot;, int.class); // 3. 创建 UpdateEngineCallback 的代理实例 // Android 中的动态代理 Object updateEngineCallbackInstance = java.lang.reflect.Proxy.newProxyInstance( updateEngineCallbackClass.getClassLoader(), new Class&lt;?&gt;[]&#123;updateEngineCallbackClass&#125;, (proxy, method, args) -&gt; &#123; if (method.getName().equals(&quot;onStatusUpdate&quot;)) &#123; int status = (int) args[0]; float percent = (float) args[1]; Log.d(TAG, &quot;Reflected Update Status: &quot; + status + &quot;, percent: &quot; + (percent * 100) + &quot;%&quot;); // TODO: 根据 status 处理逻辑，例如触发重启 if (status == 5 /* UpdateEngine.UpdateStatusConstants.UPDATED_NEED_REBOOT */) &#123; // 在这里调用你的重启逻辑，同样可能需要反射或系统权限 // PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE); // pm.reboot(&quot;system_update&quot;); &#125; &#125; else if (method.getName().equals(&quot;onPayloadApplicationComplete&quot;)) &#123; int errorCode = (int) args[0]; Log.d(TAG, &quot;Reflected Update Complete with error code: &quot; + errorCode); // TODO: 处理完成或错误 &#125; return null; &#125; ); // 4. 获取 UpdateEngine 构造函数 // 某些Android版本UpdateEngine构造函数是无参的，某些可能带Context Constructor&lt;?&gt; constructor; try &#123; constructor = updateEngineClass.getConstructor(); // 尝试无参构造 &#125; catch (NoSuchMethodException e) &#123; constructor = updateEngineClass.getConstructor(Context.class); // 尝试带Context构造 &#125; // 5. 创建 UpdateEngine 实例 Object updateEngineInstance; if (constructor.getParameterCount() == 0) &#123; updateEngineInstance = constructor.newInstance(); &#125; else &#123; updateEngineInstance = constructor.newInstance(context); &#125; // 6. 获取 bind 方法并调用 Method bindMethod = updateEngineClass.getMethod(&quot;bind&quot;, updateEngineCallbackClass); bindMethod.invoke(updateEngineInstance, updateEngineCallbackInstance); // 7. 获取 applyPayload 方法并调用 Method applyPayloadMethod = updateEngineClass.getMethod(&quot;applyPayload&quot;, String.class, long.class, long.class, String[].class); File otaFile = new File(otaPackageFilePath); if (!otaFile.exists() || !otaFile.isFile()) &#123; Log.e(TAG, &quot;Reflected OTA package file not found or is not a file: &quot; + otaPackageFilePath); return; &#125; // 8. 调用 applyPayload applyPayloadMethod.invoke(updateEngineInstance, &quot;file://&quot; + otaPackageFilePath, 0L, // offset for full package otaFile.length(), // length for full package new String[]&#123;&#125; // headers for full package ); Log.i(TAG, &quot;Reflected OTA update started for: &quot; + otaPackageFilePath); &#125; catch (ClassNotFoundException e) &#123; Log.e(TAG, &quot;Class not found (UpdateEngine or Callback): &quot; + e.getMessage()); &#125; catch (NoSuchMethodException e) &#123; Log.e(TAG, &quot;Method not found: &quot; + e.getMessage()); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Error using reflection for UpdateEngine: &quot; + e.getMessage(), e); &#125; &#125; // 可以在 onDestroy 中添加 unbind 方法的反射调用 public static void unbindUpdateEngineReflected(Object updateEngineInstance) &#123; if (updateEngineInstance != null) &#123; try &#123; Class&lt;?&gt; updateEngineClass = Class.forName(&quot;android.os.UpdateEngine&quot;); Method unbindMethod = updateEngineClass.getMethod(&quot;unbind&quot;); unbindMethod.invoke(updateEngineInstance); Log.i(TAG, &quot;Reflected UpdateEngine unbound.&quot;); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Failed to unbind UpdateEngine via reflection: &quot; + e.getMessage()); &#125; &#125; &#125;&#125; 不出意外的话很快就会有意外了，在 newProxyInstance 执行时报错： java.lang.IllegalArgumentException: android.os.UpdateEnginecallback is not an interface 确实，UpdateEnginecallback 这个类是一个抽象类，而不是接口，newProxyInstance 是用不了的。于是想了很多其他方案，比如自建 android.os 包，提供 UpdateEngine 类的空壳，将其抽到一个单独的 lib 中，项目 module compileOnly 这个 lib。然后通过new UpdateEngine()获取到 UpdateEngine 的实例，代码编译是没问题了，可是运行代码进行mUpdateEngine.bind(mUpdateEngineCallback)的时候仍然报错： java.lang.nullPointerException: Attempt to invoke interface method “boolean android.os.IupdateEngine.bind(androidos,IupdateEngineCaltback) 查看代码 new UpdateEngine() 时，内部会创建一个 mUpdateEngine： 1234public UpdateEngine() &#123; mUpdateEngine = IUpdateEngine.Stub.asInterface( ServiceManager.getService(UPDATE_ENGINE_SERVICE));&#125; 通过此种方式 new 出来的，这个 mUpdateEngine 对象是 null。折腾了好久还是无法成功调用，无奈只能放弃了。 AOSP 源码构建环境这个方案应该是流程最简单、逻辑最清晰的，都直接改源码编译了。但可执行性不高，也非常复杂，不到最后不会花费大力气做这个事情。 系统原生升级通过 AI 获取的 RecoverySystem、UpdateEngine 方式全部失败后，我对 AI 丧失了一些信心。在验证 update.zip 是否能正常对系统更新时，发现了一个当前系统原生升级的逻辑：当把 update.zip 放到 &#x2F;sdcard 根目录时，设备重启后，会自动弹窗发现一个升级文件，询问是否需要进行升级。 点击安装按钮后，系统会进入更新，且能更新成功。就像这样： 于是有了一个新思路：将 OTA 包下载后放到 &#x2F;sdcard 根目录，然后重启设备，这个时候系统会弹窗是否进行升级，然后结合 Launcher 的系统能力，做自动点击，就可以走系统原生的升级了。 系统升级成功后，会有一个弹窗提醒删掉 OTA 文件，这个时候自动点击确认删除，即可完成系统升级。 若此 OTA 文件不删除，设备重启时会继续提示升级，但是点击按钮会报错，影响体验，所以还是需要删掉。 通过这个方案，就只剩下自动点击需要额外代码实现了，结合 AI 加不断的调试，最终得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class SystemUpdateService : AccessibilityService() &#123; private val TAG = &quot;SystemUpdateService&quot; private val updatePkg = &quot;android.rockchip.update.service&quot; //------- 安装固件，一个标题，一个按钮，升级系统--------- private val updateTitle = &quot;固件升级&quot; private val installText = &quot;安装&quot; private val cancelText = &quot;放弃&quot; //------- 安装成功后，一个标题，一个按钮，删除文件--------- private val successTitle = &quot;系统升级&quot; private val yesText = &quot;是&quot; // 服务配置参数 override fun onServiceConnected() &#123; LogUtils.e(TAG, &quot;onServiceConnected&quot;) val info = AccessibilityServiceInfo().apply &#123; eventTypes = AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED or AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC notificationTimeout = 100 &#125; serviceInfo = info &#125; // 事件处理核心逻辑 override fun onAccessibilityEvent(event: AccessibilityEvent) &#123; when (event.eventType) &#123; AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED -&gt; handleWindowChange(event) AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED -&gt; handleContentChange(event) &#125; &#125; override fun onInterrupt() &#123; &#125; private fun handleWindowChange(event: AccessibilityEvent) &#123; handleEvent(event) &#125; private fun handleContentChange(event: AccessibilityEvent) &#123; handleEvent(event) &#125; private fun handleEvent(event: AccessibilityEvent) &#123; kotlin.runCatching &#123; event.source?.let &#123; source -&gt; if (source.packageName == updatePkg) &#123; findAndClickInstallButton(source) &#125; &#125; &#125;.onFailure &#123; LogUtils.e(TAG, it.message) &#125; &#125; // 核心点击逻辑 private fun findAndClickInstallButton(rootNode: AccessibilityNodeInfo) &#123; try &#123; val startTime = System.currentTimeMillis() val upgradeTitle = rootNode.findAccessibilityNodeInfosByText(updateTitle) if (upgradeTitle.isNotEmpty()) &#123; val installButtons = rootNode.findAccessibilityNodeInfosByText(installText) if (installButtons.isNotEmpty()) &#123; val localVersion = AppUtil.getRomVersion() ThreadConfig.execute &#123; val updateVersion = AppUtil.parseOtaPackage(RomUpdater.getUpdateZipPath()) MainThreadUtils.post &#123; if (localVersion != null &amp;&amp; updateVersion != null &amp;&amp; localVersion &lt; updateVersion) &#123; performClick(installButtons) &#125; else &#123; val cancelButtons = rootNode.findAccessibilityNodeInfosByText(cancelText) if (cancelButtons.isNotEmpty()) &#123; performClick(cancelButtons) RomUpdater.deleteZipFile() &#125; &#125; &#125; &#125; &#125; &#125; else &#123; val successTitle = rootNode.findAccessibilityNodeInfosByText(successTitle) if (successTitle.isNotEmpty()) &#123; val yesButtons = rootNode.findAccessibilityNodeInfosByText(yesText) if (yesButtons.isNotEmpty()) &#123; performClick(yesButtons) &#125; &#125; &#125; &#125; finally &#123; rootNode.recycle() &#125; &#125; private fun performClick(nodes: List&lt;AccessibilityNodeInfo&gt;) &#123; nodes.forEach &#123; node -&gt; if (node.isClickable) &#123; node.performAction(AccessibilityNodeInfo.ACTION_CLICK) node.recycle() &#125; &#125; &#125;&#125; 在点击安装时，先判断一下版本。 12345678910111213141516171819202122232425262728293031323334353637383940414243fun getRomVersion(): Int? &#123; LogUtils.e(TAG, &quot;display:&quot; + Build.DISPLAY + &quot;,fingerprint:&quot; + Build.FINGERPRINT) val input = Build.DISPLAY val regex = Regex(&quot;$&#123;ROM_PREFIX&#125;(.*?)A1&quot;) val matchedPart = regex.find(input)?.groupValues?.get(1) ?: return null val digitsOnly = matchedPart.filter &#123; it.isDigit() &#125; return digitsOnly.toIntOrNull()&#125;fun parseOtaPackage(otaPath: String): Int? &#123; var result: Int? = null try &#123; val zipInputStream = ZipInputStream(FileInputStream(otaPath)) var entry: ZipEntry? while (zipInputStream.nextEntry.also &#123; entry = it &#125; != null) &#123; if (entry?.name == &quot;META-INF/com/android/metadata&quot;) &#123; val reader = BufferedReader(InputStreamReader(zipInputStream)) var line: String? while (reader.readLine().also &#123; line = it &#125; != null) &#123; if (line?.startsWith(POST_BUILD) == true &amp;&amp; line?.contains(ROM_PREFIX) == true) &#123; LogUtils.e(TAG, line) val input = line ?: &quot;&quot; val regex = Regex(&quot;$&#123;ROM_PREFIX&#125;(.*?)A1&quot;) val matchedPart = regex.find(input)?.groupValues?.get(1) val digitsOnly = matchedPart?.filter &#123; it.isDigit() &#125; result = digitsOnly?.toIntOrNull() if (result != null) &#123; break &#125; &#125; &#125; reader.close() if (result != null) &#123; break &#125; &#125; &#125; zipInputStream.close() &#125; catch (e: IOException) &#123; e.printStackTrace() &#125; return result&#125; 我们系统的版本号是这样的格式：ROM_PREFIX.250627.001.A1 这样的格式。只需要解析出 250627001 作为版本号即可。OTA 包中，通过解析 zip 包获取 ZipEntry，通过** META-INF&#x2F;com&#x2F;android&#x2F;metadata** 的 entry name 拿到** post_build** 字段，来分析出对应的版本号，然后进行对比，本地版本低才进行升级。在 AndroidManifest.xml 中如下声明： 1234567891011&lt;service android:name=&quot;cn.packageName.launcher.ui.SystemUpdateService&quot; android:exported=&quot;true&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/accessibility_service_config&quot; /&gt;&lt;/service&gt; 在 res 目录下创建 xml 文件夹，accessibility_service_config 如下： 12345678&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeWindowStateChanged|typeWindowContentChanged&quot; android:accessibilityFeedbackType=&quot;feedbackGeneric&quot; android:canRequestFilterKeyEvents=&quot;true&quot; android:canRequestTouchExplorationMode=&quot;true&quot; android:canRetrieveWindowContent=&quot;true&quot; android:description=&quot;@string/system_update&quot; android:notificationTimeout=&quot;100&quot; /&gt; 在 Application 启动时，默认启动无障碍服务： 12345678910111213141516171819202122232425262728// 获取当前已启用的服务列表val originalServices = Settings.Secure.getString( contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES) ?: &quot;&quot;// 构造新的服务列表（避免重复添加）val newService = &quot;cn.mucang.android.launcher/cn.mucang.android.launcher.ui.SystemUpdateService&quot;val updatedServices = if (originalServices.isEmpty()) &#123; newService&#125; else &#123; if (!originalServices.contains(newService)) &#123; &quot;$originalServices:$newService&quot; // 使用冒号分隔（Android标准格式） &#125; else &#123; originalServices &#125;&#125;// 更新设置Settings.Secure.putString( contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, updatedServices)Settings.Secure.putInt( contentResolver, Settings.Secure.ACCESSIBILITY_ENABLED, 1) 这个代码需要系统级 App 才行，不然得到设置页专门打开无障碍服务。这里会先获取系统的无障碍服务，然后将当前的添加进去，然后启动，不然的话可能会将其他应用的无障碍服务设置成关闭了。至此，基本代码全部完成，运行后也符合预期，系统能升级成功。升级成功后，也能自动点击，删掉 OTA 文件。只是设备会多重启一次，体验略差，后续为了优化体验，准备研究刷机 Rom 的源码了。在调试最终方案的过程中，也有一些小插曲。 升级弹窗在系统升级弹窗出现时，准备通过关键词研究一下相关代码，看能否直接将刷机的 Rom 的 Api 拿过来直接使用，当时使用如下指令，拿到了弹窗的层级信息： 12adb shell uiautomator dump /sdcard/window_dump.xmladb pull /sdcard/window_dump.xml 得到的文件如下： 12345678910111213141516171819202122232425&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27; standalone=&#x27;yes&#x27; ?&gt;&lt;hierarchy rotation=&quot;0&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.FrameLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[525,357][1395,669]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.LinearLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[537,369][1383,657]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;android:id/title_container&quot; class=&quot;android.widget.LinearLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[537,369][1383,465]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;android:id/left_icon&quot; class=&quot;android.widget.ImageView&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[561,393][609,441]&quot; /&gt; &lt;node index=&quot;1&quot; text=&quot;固件升级&quot; resource-id=&quot;android:id/title&quot; class=&quot;android.widget.TextView&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[621,395][753,439]&quot; /&gt; &lt;node index=&quot;2&quot; text=&quot;&quot; resource-id=&quot;android:id/right_icon&quot; class=&quot;android.widget.ImageView&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[765,393][813,441]&quot; /&gt;&lt;/node&gt; &lt;node index=&quot;1&quot; text=&quot;&quot; resource-id=&quot;android:id/titleDivider&quot; class=&quot;android.view.View&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[537,465][1383,467]&quot; /&gt; &lt;node index=&quot;2&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.FrameLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[537,467][1383,657]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;android:id/content&quot; class=&quot;android.widget.FrameLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[537,467][1383,657]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.LinearLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[537,467][1383,657]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.ScrollView&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;true&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[543,473][1377,579]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.LinearLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[543,473][1377,579]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;发现一个升级包 : &#x27;/storage/emulated/0/update.zip&#x27;. 是否要安装升级包?&quot; resource-id=&quot;android.rockchip.update.service:id/notify&quot; class=&quot;android.widget.TextView&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;true&quot; enabled=&quot;true&quot; focusable=&quot;true&quot; focused=&quot;true&quot; scrollable=&quot;false&quot; long-clickable=&quot;true&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[543,473][1377,542]&quot; /&gt;&lt;/node&gt; &lt;/node&gt; &lt;node index=&quot;1&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.LinearLayout&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[543,579][1377,651]&quot;&gt; &lt;node index=&quot;0&quot; text=&quot;放弃&quot; resource-id=&quot;android.rockchip.update.service:id/button_cancel&quot; class=&quot;android.widget.Button&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;true&quot; enabled=&quot;true&quot; focusable=&quot;true&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[543,579][959,651]&quot; /&gt; &lt;node index=&quot;1&quot; text=&quot;安装&quot; resource-id=&quot;android.rockchip.update.service:id/button_ok&quot; class=&quot;android.widget.Button&quot; package=&quot;android.rockchip.update.service&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;true&quot; enabled=&quot;true&quot; focusable=&quot;true&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[961,579][1377,651]&quot; /&gt;&lt;/node&gt; &lt;/node&gt; &lt;/node&gt; &lt;/node&gt; &lt;/node&gt; &lt;/node&gt;&lt;/hierarchy&gt; 可以看到包名是android.rockchip.update.service，后续就可以往这个方向研究源码了。这也是代码里会加上包名过滤的原因，避免影响其他的弹窗。 getRootInActiveWindow之前是使用 getRootInActiveWindow 方法来获取想要的 AccessibilityNodeInfo。结果发现有时候能拿到当前弹窗的 Node，通过 findAccessibilityNodeInfosByText 可以找到想要的按钮，可是有时候又找不到。后面还发现升级成功后的删除弹窗， 竟然不是一个 Dialog，而是一个 Activity。 1adb shell dumpsys window | grep -A 5 &quot;Window #&quot; 得到的结果如下： 当前的弹窗它竟然是一个 Activity ！！！ android.rockchip.update.service&#x2F;android.rockchip.update.service.NotifyDeleteActivity 可能是因为 Activity，getRootInActiveWindow 就无法获取到弹窗的 Node 了。实在搞不懂为什么 Rom 会这样区分对待。getRootInActiveWindow 不好使，最后发现 onAccessibilityEvent 回调方法里的参数 event: AccessibilityEvent，它有个 source 属性，直接就可以返回 AccessibilityNodeInfo，那这个 Node 能不能找到对应的按钮呢？试了一下，果然可以。所以直接用回调里的 event 即可了。 Service 无响应在调试过程中，Service 一启动就会无响应，因为也是通过 AI 拿到的代码，不是所有代码都清楚作用，于是一行一行代码注释，终于找到罪魁祸首： 123456789101112131415override fun onServiceConnected() &#123; LogUtils.e(TAG, &quot;onServiceConnected&quot;) val info = AccessibilityServiceInfo().apply &#123; eventTypes = AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED or AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC notificationTimeout = 100 flags = AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS or AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; flags = flags or AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE &#125; &#125; serviceInfo = info&#125; 在 onServiceConnected 方法里，给 info 设置的 flags 会导致 Service 无响应。当把 flags 设置代码去掉之后，Service 就恢复正常了。这几个 flag 简单了解了一下，去掉也不影响当前业务。 Service 崩溃为了测试自动点击，我写了个测试代码， 123456789101112131415161718192021222324debug.setOnClickListener &#123; try &#123; // 1. 构造Intent并设置ComponentName val intent = Intent() val component = ComponentName( &quot;android.rockchip.update.service&quot;, // 包名 &quot;android.rockchip.update.service.NotifyDeleteActivity&quot; // 完整类名 ) intent.setComponent(component) // 2. 添加系统级Flags（可选） intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP) // 3. 验证并启动Activity if (intent.resolveActivity(packageManager) != null) &#123; startActivity(intent) &#125; else &#123; Log.e(&quot;Launch&quot;, &quot;Activity不存在或无权访问&quot;) &#125; &#125; catch (e: SecurityException) &#123; Log.e(&quot;Launch&quot;, &quot;权限不足: &quot; + e.message) // 尝试通过系统签名或Root权限提升 &#125;&#125; 代码会打开一个升级后删除 OTA 的弹窗，我进行模拟点击。测试时，发现只要进行第二次模拟点击时，Service 就会崩溃。最终找到原因，是 Node 执行完必须进行 recycle，不然就会崩溃。这通过 AI 写代码，我也挺崩溃的- -。最后加上 finally 块： 123finally &#123; rootNode.recycle()&#125; 至此所有流程全部结束，等待后续源码阅读，看是否可以优化。 总结因为有 Launcher，具备一定的系统权限，我们能做的事情就比较多，这次升级 Rom 也算是顺利完成。本文通过 AI 给出了很多代码，但是能用的非常少，而且它不会告诉你它做不到，这也是我之前就说过的 AI 的缺点，它一定会给你一个答案，然后你尝试之后发现根本不能用，浪费很多时间，所以针对 AI 的学习还是要辩证着看，取其精华，去其糟粕。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"新疆九天环游记","date":"2025-05-13T06:18:11.000Z","path":"2025/05/13/xinjiang/","text":"四月的某个工作日，在一次外出测试途中，因频繁刹车导致晕眩不适，遂下车小憩。偶然间在朋友圈瞥见新疆旅游的广告，唤醒了深埋心底多年的北疆之梦。当即联系旅行社咨询详情，在妥善安排好孩子的照管事宜后，毅然决定5月1日启程新疆。随后的几天里，迅速采购了各类旅行必需品，从决策到出发仅用数日，足见决心之坚定。 5月1日：初抵乌鲁木齐飞机降落在乌鲁木齐天山国际机场，这座西域都市的晚风还带着丝丝凉意。入住酒店后，为明日长途跋涉养精蓄锐。 5月2日：奔赴赛里木湖清晨9点出发，沿连霍高速向西疾驰。8小时车程后，终于抵达”大西洋最后一滴眼泪”——赛里木湖。天上下着小雨，阴云笼罩下的湖面宛如一块灰蒙蒙的玉石。出发前每天都在查看伊犁的天气，到了赛里木湖看着此刻的景象，只能祈祷后面的天气能放晴。天气不给力，只能匆匆游览后便回酒店休息。 5月3日：赛里木湖的日出与环湖日出奇遇凌晨6点半，睡眼惺忪中被唤醒看日出。简单洗漱后摸黑出发，却因方向错误与最佳观景点失之交臂。最终在一片无名湖畔停下，看着： 云破日出：朝阳从云层裂隙中透出金光 湖光山色：阳光在湖面洒下碎金，为雪山戴上金冠 晨雾缭绕：薄雾如轻纱般在湖面飘荡虽然没能到达预定地点，但这意外的邂逅反而更显珍贵。 环湖仙境看完日出回酒店吃早饭，休息后，10点开始环湖游览，天气奇迹般放晴。赛里木湖展现出她最动人的一面： 湖水：在不同角度呈现从蒂芙尼蓝到翡翠绿的渐变，清澈得能看见水下10米的鹅卵石 雪山：远处的雪山倒映湖中，形成完美的对称景观 天鹅：几只白天鹅优雅游过，划出V型水纹 下午体验了帆船项目，当船行至湖心，360度被雪山环抱，仿佛漂浮在天堂的蓝宝石上。游完赛里木湖，开始往伊宁方向行驶。当傍晚途经果子沟大桥，这座峡谷间的钢铁巨龙在夕阳下熠熠生辉。桥面距谷底200米的落差让人心跳加速，透过车窗俯瞰，蜿蜒的果子沟在暮色中如同一条发光的长龙。 伊宁六星街之夜晚上7点多抵达伊宁，直奔充满异域风情的六星街。这里的街巷呈放射状分布，中心广场的喷泉在灯光下变幻色彩。我们品尝了当地有名的尕巷子粉汤，汤头浓郁，粉条Q弹，配上刚出炉的馕，是奔波一天后最好的慰藉。 街角的酸奶摊前排着长队，老板用木勺从陶罐中舀出浓稠的酸奶，撒上白砂糖和果仁碎。入口的瞬间，酸味在舌尖炸开，随后是淡淡的奶香回甘。本想尝试网红古兰丹姆冰淇淋，但看着蜿蜒的队伍和已经鼓胀的胃，只好作罢。 夜晚的六星街越发热闹，手工艺品店的铜器在灯光下闪烁，街头艺人的冬不拉琴声飘荡在空气中。直到11点打车离开时，整条街依然人头攒动，我们的出租车在狭窄的巷道中艰难穿行，司机怕我等得不耐烦提前跟我打电话确认，我站在街头感受着异域的生活气息。 5月4日：夏塔古道探秘坎坷路途早餐后启程前往夏塔，却遭遇： 道路施工：原路线封闭，被迫绕行新路 限速困扰：频繁的40、60限速让行程异常缓慢 时间压力：下午3点半才抵达景区入口 古道风光区间车穿行在云杉长廊中，最终到达将军桥。这里的景观层次分明： 远景：终年不化的雪山巍然耸立 中景：笔直的云杉如同绿色卫兵 近景：野花点缀的草甸与湍急溪流 徒步返回时，松涛与溪流合奏出自然的交响乐，让人不禁想象千年前丝绸之路商队途经此地的场景。夏塔景区游玩结束后，返回昭苏入住酒店休息。 5月5日：琼库什台的魔法森林由于行程紧凑，不得不忍痛取消昭苏湿地公园观赏天马浴河的计划，转而直奔琼库什台。下午1时30分抵达目的地，简单用餐后于2时20分进入景区。沿着蜿蜒的溪流行进，眼前的景致恍若《哈利波特》中的魔法禁林： 溪流：水晶般清澈的雪水叮咚流淌 古树：形态各异的古松枝干虬结，挂满苔藓 光影：阳光透过树冠洒下斑驳光点 徜徉至下午5时开始返程，继而转往后山区域。后山的景致更为壮阔，仿佛离天空更近了一步，洁白的云朵近在咫尺。不料天公不作美，骤然而至的雨势打断了我们的探索。为避免雨势加剧，我们匆忙撤回车上，向当晚的住宿地特克斯进发。 特克斯夜市奇遇晚上在特克斯八卦城的美食街，见识了新疆夜市的豪迈。询问酒店老板，说是”阿臻味道”这家店非常不错，于是便寻了起来。终于被我们找到了，吃了这些天以来最令人回味的一餐。 烤全羊在馕坑里旋转，油脂滴落激起阵阵白烟；西瓜摊主表演着”一刀准”的绝活，十公斤的西瓜总能切出刚好一公斤的份额。最惊喜的是发现一家做包尔萨克（油炸小点心）的老店，老板娘手法娴熟，面团在她手中翻飞，入油锅瞬间膨胀成金黄色的气球，蘸着蜂蜜吃，外脆内软，甜而不腻。 夜市中央的广场上，当地居民跳起欢快的麦西来甫，有位白胡子老爷爷跳得格外起劲，旋转时绣花帽上的银铃叮当作响。我们捧着石榴汁围观，直到深夜才依依不舍地离开。 5月6日：恰西草原的骑马奇遇湖畔序曲清晨从特克斯出发，途经恰普其海时，被它的秀美景色所震撼： 湖光山色：碧蓝的湖水倒映着雪山，宛如一块镶嵌在草原上的蓝宝石 牧场景象：成群的牛羊在湖边悠闲吃草，牧民的毡房点缀其间 骑马探险中午12点抵达恰西草原，简单用餐后开始了期待已久的骑马之旅： 准备阶段： 挑选马匹时，被新疆马的高大健壮所震撼 在牧民帮助下上马，感受到马儿温热的体温和结实的肌肉 行进体验： 马儿踏着稳健的步伐上山，身体随着马背自然摇摆 虽然不能独自驾驭（考虑到安全因素），但有牧民牵引反而能更专注欣赏风景 巅峰时刻： 到达山顶时，眼前豁然开朗——近处是如茵草原，远处是皑皑雪山 激动地拍摄了多组”旱地拔葱”创意视频（骑马版与徒步版各一组） 新疆时光下午4点结束游玩，前往那拉提。新疆的昼夜节律让我们体验了独特的作息： 晚上10点的下午茶：在舟车劳顿后享受悠闲的茶点时光 深夜11点的晚餐：在星空下享用丰盛的新疆美食，感受别样的生活节奏 民宿夜话：入住那拉提名宿后，与旅伴们回味这一天的奇妙经历 5月7日：那拉提极致体验网红桥打卡清晨的那拉提空中草原，网红桥前早已排起长龙。耐心等待后的回报是： 构图完美：小桥流水与雪山草原的自然框景 光线柔和：晨光为一切镀上金边 倒影绝佳：溪水如镜，映出完整对称的世界 骑马进阶这次骑马体验让我真正理解了”驰骋”的含义： 适应期：前10分钟紧张得全身僵硬 享受期：找到节奏后，与马儿和谐共舞 巅峰期：小跑时的颠簸感，让人既害怕又兴奋 途经开阔地时，雪山近在咫尺，仿佛伸手就能触到雪线。虽然大腿内侧火辣辣的疼，但这种痛并快乐着的体验实在难得。 滑草惊魂那拉提滑草的刺激程度超乎想象： 准备阶段：工作人员讲解时还不以为意 启动阶段：轻轻一推，速度瞬间提升 冲刺阶段：最后近乎垂直的下坡，让尖叫声划破长空 回味阶段：结束后双腿发软，却迫不及待想再试一次 惊魂218国道原定从那拉提返回精河的行程，因全团一致反对走回头路而改变。经过与旅行社的激烈”谈判”，我们终于获准改走218国道前往和静。没想到这成了全程最刺激的冒险： 下午5点半开始堵车时，大家还很乐观，拿出馕和葡萄干野餐。但随着天色渐暗，情况变得严峻——修路路段只有单行道，半小时才放行一次。晚上9点通车后，真正的考验才开始： 天山夜路：连续不断的发卡弯，车灯照在悬崖边的护栏上反着冷光 炮弹坑阵：每隔几米就有深坑，颠簸得行李在车厢里”跳舞” 卡车长龙：数不清的大卡车排成长队，尾灯像一条红色蜈蚣蜿蜒在山间 深夜寻宿：凌晨2、3点到达巴伦台镇时，才找到一家小旅馆入住休息 这段9小时的路程，让全车人从说笑到沉默再到互相鼓励，成为最难忘的”团队建设”。 5月8日：沙漠落日清晨9时许，告别前夜的疲惫，我们重新启程前往鄯善库木塔格沙漠。沿途景观与伊犁地区截然不同，荒凉的戈壁与嶙峋的山峦构成了一幅苍劲的画卷。途经火焰山时，我们驻足远观，那赤红色的山体在烈日下仿佛真的在燃烧。 下午7时抵达酒店稍作休整后，便前往库木塔格沙漠景区。这里的沙丘呈现出令人惊叹的美： 沙丘：柔美的曲线如同大地的呼吸，在夕阳下由金黄渐变为暗红 光影：随着太阳西沉，沙丘的阴影不断变换着神秘的图案 触感：赤足行走时，细沙从趾间流过，温度由温热逐渐转为微凉 尽管相机难以完全捕捉眼前的美景，我们仍执着地等待日落时分。那轮红日看似悬停在天际，却在转瞬间沉入地平线，只留下漫天霞光为我们的旅程画上句点。当晚，领队组织了一场温馨的告别晚宴，在烧烤与啤酒的陪伴下，我们回味着这几天的点点滴滴。 5月9日：归途与感悟回程飞机上，透过舷窗俯瞰这片神奇的土地，思绪万千： 视觉盛宴 色彩：从赛里木湖的蓝到那拉提的绿，再到沙漠的金 线条：雪山的棱角、草原的曲线、沙漠的波纹 光影：日出日落时分魔幻的光线变化 心灵触动 自然之力：面对天山、沙漠的壮阔，深感人类渺小 文化交融：在伊宁街头感受到的多民族和谐共处 旅途真谛：最美的风景往往在计划之外，如那意外的日出和惊险的218国道 这9天的每一帧画面，都如同精心调色的电影镜头，将在记忆的长廊中永远闪耀。 总结本篇文章主要由 AI 结合我的行程描述进行生成，某些幻觉部分没有进行修改，不影响整体描述，保留着 AI 的原汁原味儿。最后附上一些照片吧，真的太美了，不虚此行！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"},{"name":"AI","slug":"AI","permalink":"http://lijia92.github.io/tags/AI/"}]},{"title":"如何面对 AI 浪潮","date":"2025-04-10T02:29:11.000Z","path":"2025/04/10/cline/","text":"前言自 ChatGpt 诞生以来，全世界每天都在承受 AI 的冲击。今年年初的 DeepSeek 更是让中国 AI 沸腾。作为安卓工程师还是很焦虑的。要如何面对这一波的 AI 浪潮？只能不断学习。起初使用 AI 也仅仅是在 Android Studio 中装一些插件，比如 Baidu Comate。但是这玩意感觉不太好用，通过对话框来回粘贴复制代码，着实费劲。后经同事介绍，了解到了 Cline，可以自动生成文件、修改代码，无需手动粘贴复制，下面便来介绍一下 Cline 的使用。 Cline 介绍Cline 是 VS Code 的一款插件。它可以自动生成代码，无需粘贴复制。集成价格优惠的 DeepSeek 也相当方便。 输入提示词可能需要手动操作： 可以直接勾选 Auto-approve，大多数场景就可以吃瓜等着了。 虽然它是个 VS Code 插件，但使用过程完全不需要操心 VS Code。本文的思路便是只用它来生成代码，然后在 Android Studio 中去运行。 生成 Hello World 安卓代码首先输入提示词： 生成一个 Hello world 安卓程序代码，语言为 kotlin。将相应的目录结构和文件生成出来。 生成了相应的 activity_main.xml，AndroidManifest.xml 等文件。等到生成 gradle 文件时，执行相关指令报错。 停止任务输入新提示词： 直接生成所有的文件，不需要执行 gradle 的指令。 最终生成以上结构的一些文件。看了一下，大差不差，不过使用的版本过高，于是输入提示词进行修改： 将 gradle wrapper 版本改为 6.5；gradle tools 改为 4.1.0 识别指令不仅仅是修改提示词中的两个版本，而是将所有的版本进行了统一的修改，避免了不匹配的情况。最后查看文件目录如下： 打开 Android Studio 进行编译，报错提示： 于是继续输入提示词： 指定 java 版本为 1.8 得到如下输出： 继续编译，还是报错。然后详细对比文件目录，发现少了一个 gradle&#x2F;wrapper 下面少了一个 jar 包，根目录下少了 gradlew、gradle.bat 文件。 于是输入提示词： gradle wrapper 目录下少了一个 jar 文件； 根目录下少了 gradlew 、gradlew.bat 文件；将以上缺失文件进行补全 这里也有个疑问：针对 jar 包这类文件，AI 会如何处理？等待过程中发现它的思路： Thinking好的，我现在需要帮助用户解决Gradle Wrapper文件缺失的问题。根据用户的反馈，他们发现gradle&#x2F;wrapper目录下缺少jar文件，并且根目录下缺少gradlew和gradlew.bat文件。用户已经尝试了一些命令，但似乎遇到了权限问题和类找不到的错误。 首先，我需要确认用户已经执行了哪些步骤。用户之前尝试了执行./gradlew wrapper --gradle-version 6.5，但遇到了权限被拒绝的问题，之后通过chmod +x gradlew修复了权限。但随后运行时又出现找不到GradleWrapperMain类的错误，这表明gradle-wrapper.jar文件确实缺失。 接下来，我需要确定如何正确生成这些缺失的文件。通常，Gradle Wrapper的正确生成方式是通过运行gradle wrapper命令，这会自动生成所需的脚本和jar文件。但用户的环境可能没有安装Gradle，或者项目配置有问题。 用户尝试使用./gradlew命令时出现错误，说明当前目录下的gradle-wrapper.jar不存在或损坏。这时候，手动下载并解压该文件可能是最快的解决办法。根据用户之前的建议，使用curl和unzip命令从Gradle官方下载并提取jar文件到正确的位置。 需要注意的是，用户可能不熟悉命令行操作，或者对路径处理不太熟悉，因此在建议命令时需要确保路径正确。例如，解压时使用-d gradle/wrapper/来指定目标目录，确保jar文件被放置在正确的位置。 另外，用户可能希望避免再次遇到权限问题，所以在下载和解压后，再次运行chmod +x gradlew来确保脚本可执行。 最后，验证步骤很重要，用户需要确认所有文件已正确生成，并且Gradle命令可以正常运行。建议用户运行./gradlew tasks --stacktrace来测试，如果还有问题，可以查看详细的错误信息。 总结来说，用户的问题在于缺失必要的Gradle Wrapper文件，解决方法是通过手动下载并配置这些文件，确保权限正确，然后验证配置是否成功。 然后就是等待下载 gradle： 终于快下完了： 下载完之后提示这个： 这里 Retry 仍然会报错，只能 Start New Task 了，输入： 生成 gradle-wrapper.jar 文件，放到对应的目录中 又开始进行了很多的 gradle 指令，环境不对，各类报错： 最终放弃，手动完善了 Gradle 环境，并升到了 7.2，可以编译通过了。然后 AndroidManifest.xml 中定义的 mipmap、style 都是缺失的，程序肯定是运行不了的。继续通过提示词进行完善： AndroidManifest 中引入了不存在的 mipmap，请加入相关文件@style&#x2F;AppTheme 缺失，进行补全 执行过程如下： 继续回到 Android Studio 运行 App，报错： Unable to make field private final java.lang.String java.io.File.path accessible: module java.base does not “opens java.io” to unnamed module @3671927e 继续塞给 cline 看如何解决。 一顿操作猛如虎，改了一些配置文件，运行也还是很多报错，主要是版本匹配问题。（已经快没耐心了）最后给出如下指令： gradle wrapper：gradle-6.5-binbuild tool：4.1.0compileSdkVersion 29buildToolsVersion “29.0.3”minSdkVersion 22targetSdkVersion 31java版本 1.8请按照如上配置，修改所有的配置信息，并执行指令 .&#x2F;gradlew app:assembleDebug。若运行出错，请解决对应错误，并重新运行指令。 结果运行一段时间来了个： 至此已经彻底放弃使用 Cline 通过提示词来生成一个可以运行的 Hello World 安卓程序了。 实现简易计算器手动改造安卓程序环境，能正常运行 App 了。 回到 Cline 输入提示词： 当前目录是一个安卓程序，运行后会展示一个 “hello world”的文案，给它添加一个点击事件，达到如下效果：1.打开一个新页面，这个页面展示简易计算器的相关 UI，展示0～9的数字、加减符号等等;2.可以执行简易计算器的加减乘除功能，并展示结果。使用 java 语言开发。 这个思路看起来是没问题的。 等待任务结束，回到 AS 查看修改文件。 运行。 界面有点不太显眼。先输入提示词，提交代码： 将当前代码进行 git 提交 继续输入提示词： 计算器页面过于丑陋，请基于横向屏幕重新设计，不要引入额外的库 执行完毕后运行： 界面确实好看一些了，而且是基于横屏显示，但是缺失了一些按钮和符号。继续输入提示词： 计算器界面风格不错，但是缺失了其他数字和符号，比如“1”、“2”、“+”等。保持这个界面风格的基础上，完善其他的数字、操作符号。 完成后运行：简易计算器的 UI 元素完整了，但是数字和操作符分隔开了。继续输入提示词： 数字和操作符布局分隔开了，调整一下，使符号按钮在一块，数字按钮在一块。 完成任务后运行：这样看着界面就舒服多了。操作几番得到的结果也都是准确的。继续输入提示词： 在计算器界面增加一个功能：实时渲染输入的表达式。 完成任务后运行： 还有点小毛病，但基本完成了。全程没写一行代码，完成了一个简易计算器的界面。 其他错误 题外 Tip使用 Cline 有访问本地文件的能力，那就可以做一些本地文件的处理了。正好电脑提示磁盘不足，本地 gradle 版本太多，准备删掉一些，这个时候也可以用 AI 来进行排查筛选。 输入提示词： 遍历本地 mucang 文件夹，查找所有的 gradle-wrapper.properties 文件，查出 distributionUrl 字段的值。将其去重后，按项目个数进行倒序排序，且需要展示项目名称，以列表形式进行展示。 将上述结果以一个 html 进行展示 本地就会生成一个 html，打开后就能很直观看到了。 小结整体使用下来，个人感觉 Cline 有以下几个优点： 虽然它是个 VS Code 插件，但使用过程可以全程与 VS Code 无关，减少了学习成本； 直接在对应目录下生成文件，无需自行粘贴复制； 使用 Auto-approve 可以跳过大多数中间的操作确认，可以边嗑瓜子边等任务完成； 给了访问本地文件的权限，那就可以帮忙做很多事情了； 依赖提示词，可以直接生成固定格式的文本代码； 集成其他大模型很方便，简单设置一下即可。 对应的当然也有些缺点： 对于 Android 环境的搭建，还是不太行。它不会明确告诉你“做不到”。它一定会给出一个“答案”，即使最后运行的时候你发现它是错的。依赖它进行问题自查并解决，在现阶段还是比较困难的； 无法生成图片、jar 包这类文件； 运行过程耗时不确定，有时候很快，有时候要等很久，也不知道是哪里卡住了； 一个 Task 过长很容易提示 token 超出了，只能重新创建 Task，不知道这时候是否还具备相应的上下文。 总而言之，作为一名“技术”，面对 AI 浪潮，只能拥抱它。保持学习吧！","tags":[{"name":"AI","slug":"AI","permalink":"http://lijia92.github.io/tags/AI/"}]},{"title":"记一次离奇的手机号被封的经历","date":"2025-04-05T06:26:06.000Z","path":"2025/04/05/phone/","text":"3月29日12点34分，吃完午饭躺在床上玩手机的我收到了一条短信： 尊敬的用户，此号码是我公司接国家执法部门要求进行关停的，您可以持本人身份证件、涉案号卡前往附近的自办营业厅进行身份核验，是否可以开机最终以国家执法部门核实后的结果为准。如有异议请详询10086。感谢您的理解与支持！ 起初以为是一条诈骗信息，然后定睛细看发件人，赫然发现是中国移动10086，内心突然就觉得不太妙。赶紧让老婆打我电话，打了两次，第一次打通了，第二次就提示手机已停机，同时家里的 WiFi 也无法上网了（与手机号绑定移动宽带）。至此，我的噩梦正式开始。 我反思了一阵，我的手机号这几天都没怎么打过电话，也没发过短信，通话记录寥寥无几，也没有接过类似诈骗的电话，怎么就会被封停呢？思考无果，下午1点左右，我带上身份证拿着手机，前往附近的移动营业厅。大堂经理输入我的手机号，查询结果是： 手机号是被公安机关要求封停的，单纯移动无法解封。需要你打027-96110进行查询，看是哪个立案机构给封停的，然后再跟进后面的事情。之前也有用户出现过这样的情况。按照过往经验，需要立案机构出具盖章的证明，到时候就可以申请给手机号解封了。 于是我打027-96110（武汉反诈骗中心电话），是个机器人，我只能按照提示输入手机号、身份证等信息进行登记，然后就只能被动等着回复了。等到下午5点多，仍然没有任何消息，我继续找中国移动客服进行询问，也都没有明确的结果。中间 battle 了无数次，反正就是让等消息。至于等多久，也没有明确的结果。 3月30日，终于收到了96110的回电： 你这是被河南省焦作市孟州市那边封停的，你查一下那边对应的区号，再打96110问问。 于是我打开元宝，查询河南省焦作市孟州市的区号，得到的结果是0391。于是继续拨打0391-96110。唉（二声），这时候是个人工，不是机器人： 我给你一个电话号码 *******(简称为 A 吧)，你手机号是那边封停的，你打这个电话问问。 然后我又拨通号码A，人工接的电话： 把你的手机号、姓名、身份证说一下我登记一下。今天周末没有警卫工作人员，你明天9点再打个电话，8点到9点他们要开会。 3月31日，周一，早上9点，我准时打电话过去，接的人工将电话转给了另一个人： -你知道你这个手机号为什么被封吗？-不知道。-我这里查到是我们这边有个被诈骗人，给你这个手机号充过300元话费，然后他现在报案了，就给充值的手机号封停了。但是我没有权限处理这个事情，我们队长（模模糊糊听的）出差了，要3～4天才回来，你到时候再打个电话问问。 所以我是因为充值话费被封停的？开始回想：3月20日，我收到短信说话费快要没了，于是我很自然的给老婆发了条微信，让她帮我充值。解释一下：之前在咸鱼上看到过移动充值话费，能便宜一丢丢，她咸鱼用得很多，尝试充了几次话费，也都正常到账了。这一次我也是和往常一样，然后她找了个咸鱼商家，是285充值300元的活动，话费后面也确实到账了。使用咸鱼也是非常经济的手段，我以为就像电影票类似的，商家有渠道拿到内部价格，但是又用不上，所以拿到咸鱼上来卖，我认为是非常合理的。而且少的金额也不多，很难让人想到这会和诈骗联系上。所以结论就是，给我手机号充值300元的，并不是咸鱼的这个商家。而是被诈骗人，被诈骗，骗他说给我的这个手机号充值300元话费。应该不止这一笔交易，金额大起来了，被诈骗人反应过来后就报案了，然后我手机号便被封停了。离大谱，什么诈骗会让你去充值话费呢？不过越是这类低级的诈骗手法，越能过滤掉那些不会被诈骗的人，从而提高诈骗成功率。国家在打击诈骗这块也是不遗余力的。既如此，我也就只能被动等待案件的调查结果了。 4月1日，愚人节，收到一个微信加好友申请，备注是武汉市的刑侦大队，我心一惊：不会搁上什么大事了吧。通过后，直接给我打了个微信电话： 我这边是武汉市刑侦大队，前几天你手机被封，我这边需要你来派出所做个笔录，你看看啥时候有时间。你要是过来的话，到了打 *******（简称为 B 吧）电话。 然后给我发了个派出所的定位。起初我有点疑心，但是一想什么诈骗犯敢在派出所搞事情？于是决定请假前往派出所做笔录。自从手机号被封，我随身带着身份证和少量现金，直接拦了个的士前往派出所。到了派出所后，找工作人员拨通了电话B。等了一会，便安排我做笔录了。录入各种信息，对着诈骗稿大声朗读，不准戴眼镜，不准穿鞋，坐在审讯椅上，为什么答什么。流程走完，签字画押。说我没什么问题，可以走了。从派出所出来，我真希望这几天的经历是上天给我开的一个玩笑。 4月3日，我继续拨通电话A，这次接通后给了这样的答复： 我给你一个手机号，是我们官方的工作号，你添加这个手机号的微信，把你的姓名、手机号、笔录派出所和时间发过来，我们会找对应的公安机关进行核查。 我按照提示，将相关信息发了过去，收到一个回复“ok”。后续便是漫长的等待了，隔几天打个电话，收到的回复都是“正在处理”，要处理多久，什么时候会有结果，都不清楚。 这个时候我才意料到，这个事情不会那么快结束的。这几天，我只要脱离 WiFi的环境，便是一个隐形人，其他人都无法联系到我，生活非常的不便。无奈之下，只能用我老婆的身份证（对，我的身份证还被封了）重新办了个备用手机号。现在可以上网，可以用微信，也可以打电话，生活便利了许多，但就怕出现什么场景，让我必须用原手机号进行操作，那就完犊子了。可担心没有什么用处，只能着眼于当下，过好眼下的日子。 事情远没有结束，要等到什么时候只能看天意了。但经过这次事情，我也涨了个经验：凡是涉及到手机号、微信号、QQ号类似进行充值的，只要不是即刻到账的那种（有延迟），那就可能会有风险，一律拒绝操作。因为你不知道给你充值的钱，到底是从哪里来的。尽量选用官方平台，进行操作，勿贪小便宜。吃一堑长一智。咸鱼，你真该死啊，有问题的商家你放上来干什么？完全依赖消费者进行区分吗？消费者具备这样的能力吗？另外我想对公家说：为什么封停的时候这么简单，可要想解封得当事人来回打电话自己跟进事情进度，像刑警破案一样。现在这个社会，没有手机号可太难了。为什么确认没问题了，不能立刻解封呢？小老百姓只能长叹一口气：唉～ 后续4月23日，继续打电话询问，联系上了办理此案件的警察同志。短暂沟通过后，加上了微信，发送了必要的一些信息。不久，他就给我出具了一个排除作案嫌疑的证明书。于是我拿着证明前往营业厅申请解封，当天手机号便恢复正常了。可以收发短信、上网、打电话，只是某些电话打不通而已，但已经不影响使用了。至此，历经近一个月的时间，我的手机号终于解封了。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"2024年总结","date":"2025-02-05T00:00:00.000Z","path":"2025/02/05/summary-2024/","text":"2024年，一整年都没怎么写博客，第一是公司业务缩减，日常工作以修修补补为主，少有整体、完整的事情去做。另外经历 AI 的冲击，尝试基于安卓开发者的身份，去接受去学习，以适应新的时代，但值得记录的东西并不多。目前学习了一些 AI 技术，想要有所产出变得更容易了，便先从一篇 AI 总结写起吧。 以下文字由 AI 生成，略有修改 2024年是充满变化与挑战的一年。在这一年里，我经历了职业生涯的转折，见证了孩子的成长，也带着家人享受了难得的旅行时光。站在2025年开工的第一天，回顾这不平凡的一年，感慨良多。 工作：转型与挑战2024年对互联网行业来说是艰难的一年。全球经济下行压力加大，公司业务规模不得不缩减，我也经历了人生中第一次裁员潮。面对突如其来的变化，从最初的焦虑到逐渐调整心态，我开始将更多精力投入到AI技术的学习中。 这一年，AI技术突飞猛进，我利用业余时间学习AI相关知识，为职业转型做准备。虽然行业寒冬让人不安，但这段学习经历却为我打开了新的视野。 带娃：成长的惊喜2024年，我家的小宝贝从1岁多长到了2岁多，每一天都能看到新的变化。年初时还只会说简单的词语，到年底已经能完整表达自己的想法了。最让我感动的是，他开始有了自己的小脾气和喜好，会主动要求听故事、玩积木。 看着孩子从蹒跚学步到能跑能跳，从咿呀学语到能说完整的句子，每一天都能感受到他的成长变化。作为父亲，我深深体会到陪伴孩子成长的幸福。 国庆襄阳之旅国庆假期，我们全家去了襄阳旅游。唐城的宏伟建筑让人震撼，走在景区内仿佛穿越回了盛唐时期。孩子特别喜欢在唐城里跑来跑去，对每一处建筑都充满好奇。 我们还去了华侨城的奇遇童年和奇幻谷。奇遇童年里各种亲子互动项目让孩子玩得不亦乐乎，而奇幻谷的夜场灯光秀则让我们全家大开眼界。最难忘的是在官家巷品尝地道的襄阳牛肉面，那浓郁的汤底和劲道的面条至今想起来还让人回味。 2024年的社会记忆2024年，OpenAI发布的GPT-5再次引发全球关注，AI生成内容的质量达到了令人惊叹的水平。国内大模型也迎来爆发式发展，各行各业都在探索AI应用的可能性。 日本核污水排海事件持续发酵，引发全民对海洋环境的高度关注。多地出现抢盐风波，我们也囤了一些，后来发现完全没必要。 《热辣滚烫》成为春节档票房冠军，贾玲成功减重100斤的故事激励了无数人。我和妻子也受此影响开始了健身计划，虽然没能坚持太久… 展望2025站在新年的起点，虽然前路仍有不确定性，但我相信每一次挑战都是成长的机会。2025年，我希望能： 在AI领域找到新的职业方向 花更多时间陪伴孩子成长 带家人去更多地方旅行 2024年教会我，生活不会总是一帆风顺，但只要我们保持学习和成长的心态，就一定能找到属于自己的精彩。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"迟来的 2023 年终总结","date":"2024-02-20T06:03:48.000Z","path":"2024/02/20/2023/","text":"新年开工第三天，写写过去的 2023 年吧。 整个 2023 年是陪女儿长大的一年。三抬、四翻、六坐、七滚、八爬、九扶、立周会走。女儿每个成长的瞬间，我都不曾错过。看着她一点点长大，嘴里喊着爸爸、妈妈，内心的源动力就不断的涌出来。孩子就是这样一个特殊的存在，父母含辛茹苦地陪孩子长大，充满疲惫，但当孩子用稚嫩的奶音一声声地喊着“爸爸”、“妈妈”，你就会获得力量，然后重新开始。我以前挺讨厌小孩，因为我见过太多“不服管教”的小孩，你不让他做什么，他就偏要做。调皮，捣蛋，是我贴在孩子身上很久的标签。直到我有了自己的孩子，才发觉主要责任都在我们父母身上。孩子就像一张白纸，你可以往上面画任何的颜色，也可以蹂躏折叠，后面即使能铺平也会免不了折痕。种什么因，得什么果。后面的日子，我会努力成为一个称职的父亲。陪伴孩子长大的这段时光，让我对老婆十分愧疚。老婆没有工作社交，一天到晚在家带小孩，虽然有老妈的帮忙，可辛苦还是不言而喻，尤其害怕孩子生病。每次孩子生病，就喜欢粘着妈妈，治疗也不配合，还没法和她讲道理，疲惫指数直接拉满。这既是我的修行，也是我老婆的修行。只希望一家人健健康康，平平安安。 4 月 1 号愚人节，我开始锻炼身体。我选取的是「爬楼梯」运动。从早上空腹爬，改成了晚上爬（爬完要洗澡太麻烦了）。后面公司通知要加班到 9 点，回家后便没有气力继续爬楼梯了。历经了 2 个月左右，我成功减掉了 12 斤。从最开始的爬 10 层楼就气喘吁吁，到后面一口气从 4 楼爬到 34 楼。身体的这种改变让我沉迷，锻炼可以说是最有回报的一项付出。只要你做了，你就能有收获，最难的还是坚持。爬楼梯也省去了很多麻烦，换好衣裤就可以直接开始，不论刮风下雨，你都可以沉浸在自己的世界里。隐性成本低了很多，那么坚持下来的可能性就更大了。至于伤膝盖的疑问，我觉得先动起来吧，反正就目前来看，我爬 30~40 分钟累计 120 层楼梯，膝盖还没有疼过。今年要重新开启这项运动，若无意外，希望能一直持续。 让我对老婆愧疚的另一点就是一年都没怎么带她出去玩儿。因为女儿还没断奶，去哪都有很多限制。几乎没有任何旅游计划，基本就是在市内、老家玩一玩，可年轻人总还是想着能偶尔出去浪一浪的。今年公司加完班，组织了一波庐山团建，我孤身前往，前前后后 2 天半，但坐了将近 1 天的车，也没玩到啥。爬了下庐山，观望了教员的庭院，基本每天都在两万步，也算是简单锻炼了一下。自从成家之后，这种旅行已经没什么意思了。我心里有牵挂，就不能专心地欣赏眼前的景色了。去哪里旅游并不重要，重要的是和谁一起。等孩子大点了，我要带着家人多看看这个世界。 2020 年的时候高位接盘了一套房。开发商各种暴雷，延迟交房，精装修质量差得令人发指。在广大业主的努力下，延迟了 2 个月交房，小区质量勉勉强强过关，但和当初买房时的承诺已经不一样了。“高端”小区变成了勉勉强强能交房的小区，大小问题不断，多数只能自己解决，大市场如此，只能含泪收房。收房后，花费了不少精力，封了阳台，做了通铺，打了柜子，现在终于像点样了。第一次亲身经历装修这些东西，里面的门道可太多了。还好找了做这行的三舅帮忙，省了不少心。房地产被一棒子打死，现在想救可太难了。房地产带动的家装行业，不知道影响了多少人。我们这些普普通通的老百姓，也都成了时代列车滚滚向前的燃料了。所以以后不要再说“xxx和我月薪3000有什么关系”这类的话了，时代发展最终都会落到我们每一个老百姓头上。 至于工作，依然是不温不火的一年。整个国家经济都不景气，公司也略显疲态，我这个职级能知道的就裁了一波员了。肩上担子重了，牵挂多了，工资不涨也不敢瞎搞了，能苟就苟着吧。年底公司还莫名的忙了起来，短时间就出了两次差，一次去珠海，一次去河南新乡。早期做出来的产品，现在慢慢地卖到市场中去了，做的东西能真真正正的给到驾校去用，还是有点小成就感的。只是可惜今年啥奖都没混到，都是销售、商务的天下了。Anyway，新年新气象，祝大家龙行龘龘(dá)，前程朤朤(lǎng)，生活䲜䲜(yè)，事业燚燚(yì)！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Android 版本升级","date":"2023-11-09T09:14:26.000Z","path":"2023/11/09/android-upgrade/","text":"公司内部有一套自己的基础库，各 App 或者模块都使用这个基础库进行开发。基础库有自己的迭代版本，可能是需求开发，也可能是 bugfix。项目初期，基于 16 版本的基础库进行开发，后续有若干个性化需求或者 bug 需要调整，便基于 16 的版本创建了 16-jky 的个性版本，用于自己这个项目。后面便独立出来了，不再跟进基础库的版本升级了，自己有 bug 或者需求自己改，自己升版本，自己用。项目后期有一个 SDK 的需求，抽出项目中的一些功能，给出一个 SDK 由公司另一个 App 集成。这个 SDK 是基于 16-jky 版本进行开发。近期公司基础库做了很大的升级，升到了 18，适配到了 Android 14。集成的 App 也需要升级，便要求我们出一个基于最新版本基础库的 SDK。于是便开始了一次 Android 版本升级之旅，小小记录一下，万一后面项目也需要升级呢。 此次升级，有若干版本升级： 1234567minSdkVersion = 24compileSdkVersion = 34buildToolsVersion = 34.0.0targetSdkVersion = 34javaVersion = 17kotlinVersion = 1.8.22AGP = 8.1.0 升级 Android Studio为了升级 AGP 到 8.1.0，需要升级 Android Studio。Android Studio 于 AGP 的版本适配关系如下图：通过 Android 官网下载最新稳定版 Android Studio Giraffe 是支持 AGP 8.1.0 的。 下载 JDK通过下面的步骤将项目的 JDK 17 环境下载好： 配置修改几个必备的资源准备好了之后，下面就是通过各种代码配置相应的东西了。 项目根目录 build.gradle 设置 AGP 和 kotlin：123456buildscript &#123; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:8.1.0&#x27; classpath &#x27;org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.22&#x27; &#125;&#125; 在 build.gradle 的 android 目录下设置相应的 JDK 版本：12345678910android &#123; compileOptions &#123; sourceCompatibility project.androidsdk.javaVersion targetCompatibility project.androidsdk.javaVersion &#125; kotlinOptions &#123; jvmTarget = project.androidsdk.javaVersion &#125;&#125; gradle wrapper 设置成 8.0：1distributionUrl=https\\://services.gradle.org/distributions/gradle-8.0-bin.zip settings.gradle 设置插件环境：1234567891011pluginManagement &#123; repositories &#123; mavenLocal() mavenCentral() google() &#125; plugins &#123; id &#x27;cn.mc.simple.plugins.mc-deploy&#x27; version &#x27;4.0.3&#x27; &#125;&#125; 定义了mc-deploy的插件，并设置了版本，在其他 module 需要用到插件时在 module 的 gradle 文件设置：123plugins &#123; id &#x27;cn.mc.simple.plugins.mc-deploy&#x27;&#125; 注意，这个时候就不要定义版本号了，否则容易版本冲突，报如下的错误： Error resolving plugin Plugin request for plugin already on the classpath must not include a version. 即在 settings.gradle 中设置好所有插件的版本，其他 gradle 文件直接引用即可，不要再单独指定版本号。关于 plugins 的使用还有一些限制：buildScript 必须放 plugins 之前等等，这个在使用时需要注意。5. 设置 buildConfig。碰到如下错误： Build Type contains custom BuildConfig fields, but the feature is disabled. 在 module 的 build.gradle 设置： 12345android &#123; buildFeatures &#123; buildConfig = true &#125;&#125; namespace 设置：123android &#123; namespace = &quot;xx.xx.xx.xx&quot;&#125; Manifest merger failed with multiple errors。Manifest 文件在合并时出现多个错误。通常日志一次就显示一条错误，甚至不显示，这里直接使用如下指令：1./gradlew processReleaseManifest --stacktrace 这样会将所有的错误全部罗列完，然后照着改就好了。 android 14 适配。在 android 14 有一些特性的调整，但 SDK 代码不多，目前就调整了一个广播相关的：1ContextCompat.registerReceiver(context, receiver, filter, ContextCompat.RECEIVER_NOT_EXPORTED) 动态广播注册需要显示指定相应的 Flag。至于其他适配，那便是需要修改什么就改什么了。 去掉 kotlin stdlib 的声明： You no longer need to declare a dependency on the stdlib library in any Kotlin Gradle project, including a multiplatform one. The dependency is added by default.The automatically added standard library will be the same version of the Kotlin Gradle plugin, since they have the same versioning.For platform-specific source sets, the corresponding platform-specific variant of the library is used, while a common standard library is added to the rest. The Kotlin Gradle plugin will select the appropriate JVM standard library depending on the kotlinOptions.jvmTarget compiler option of your Gradle build script. 小结整个升级过程持续了三小时，中途碰到的问题不止文中描述的，记录一下方便后面其他项目升级时使用。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"使用 Python 分析坐标","date":"2023-11-08T06:20:10.000Z","path":"2023/11/08/python/","text":"项目中会用到坐标系，会有一系列的坐标点，通过这些坐标点的运算才判断某些业务。因为车子位置是移动的，所以这些坐标会不停的变化，通过日志记录下一串坐标如下： 1&#x3D;Pos{x&#x3D;-11, y&#x3D;-1, z&#x3D;2771}，2&#x3D;Pos{x&#x3D;0, y&#x3D;0, z&#x3D;2771}，3&#x3D;Pos{x&#x3D;84, y&#x3D;-5, z&#x3D;54}，4&#x3D;Pos{x&#x3D;703, y&#x3D;-823, z&#x3D;51}，5&#x3D;Pos{x&#x3D;862, y&#x3D;-801, z&#x3D;51}，6&#x3D;Pos{x&#x3D;72, y&#x3D;74, z&#x3D;51}，7&#x3D;Pos{x&#x3D;83, y&#x3D;-84, z&#x3D;51}，8&#x3D;Pos{x&#x3D;-75, y&#x3D;1063, z&#x3D;12}，9&#x3D;Pos{x&#x3D;70, y&#x3D;-1084, z&#x3D;11}，10&#x3D;Pos{x&#x3D;-59, y&#x3D;392, z&#x3D;51}，11&#x3D;Pos{x&#x3D;-122, y&#x3D;442, z&#x3D;51}，12&#x3D;Pos{x&#x3D;3, y&#x3D;343, z&#x3D;51} 其中 1 代表上一时刻车辆的位置，2 代表当前车辆的位置。因为坐标系使用的车身坐标系，基于车子位置实时建立坐标系，所以当前车辆的位置坐标永远是（0，0）。3 是一个教学点的 位置，6、7 是教学点延伸出来的 2 个点。8、9 是延长 10 米的点，用来判断线段是否相交。当车子与 8、9 连线相交时，会评判一个轨迹偏移的业务。那有了这样的一组坐标，我想要直观地感受到是否相交，所以需要将这些坐标点画出来。在项目的工程中当然可以画，但是不够灵活，编译时间也会比较慢，最后还是选取的 Python 作为工具。 引入 matplotlib 库通过搜索，Python 中用来绘制坐标系的常用库是 matplotlib。于是在 PyCharm 中敲入import matplotlib，会有 install package 的提示，点一下就开始安装包了。但是给了一个错误提示： no such option: –build-dir 在 stackoverflow 上搜到，是 PyCharm 版本太低导致的，升一下就可以安装成功了。 启动黑屏引入 matplotlib 库后，随便写点测试代码绘制，运行后发现只有一个黑屏的弹窗，啥也看不到，就像这样：最后在 这个论坛 找到个代码： 123456import matplotlibimport platformif platform.system() == &#x27;Darwin&#x27;: matplotlib.use(&#x27;MacOSX&#x27;)else: matplotlib.use(&#x27;TkAgg&#x27;) 于是加上去（我是 MacOSX），运行后果然可以看到正常的内容绘制了。 坐标错乱虽然内容可以绘制了，可还是不太对：坐标没有按顺序递增，画出来的全是一条线。后面在 这里 找到是坐标值的原因，我解析出来就是个文本，对比不了大小，需要转成数值类型。于是将 value 转成 int 类型，重新绘制：如此非常一目了然了，红线与长的绿线果然是相交了，代码中的问题也暴露出来了：我以为 3、6、7 三个点是一条线，可实际不是的，需要调整策略了。 代码最终代码如下： 123456789101112131415161718192021222324252627282930313233343536import jsonimport platformimport matplotlibfrom matplotlib import pyplot as pltif platform.system() == &#x27;Darwin&#x27;: matplotlib.use(&#x27;MacOSX&#x27;)else: matplotlib.use(&#x27;TkAgg&#x27;)f = open(&quot;data/point.txt&quot;)value = f.read()d = value.split(&quot;，&quot;)index_list = [0, 1, 2, 5, 6, 7, 8] // 数组 index 对应日志里的数值需要 -1x = []y = []xx = []yy = []for i in range(len(d)): if not index_list.__contains__(i): continue s = d[i] index = s.find(&quot;&#123;&quot;) value = s[index:len(s)].replace(&quot;&#123;&quot;, &quot;&#123;\\&quot;&quot;).replace(&quot;=&quot;, &quot;\\&quot;:&quot;).replace(&quot;, &quot;, &quot;,\\&quot;&quot;) p = json.loads(value) if i == 0 or i == 1: x.append(int(p[&#x27;x&#x27;])) y.append(int(p[&#x27;y&#x27;])) else: xx.append(int(p[&#x27;x&#x27;])) yy.append(int(p[&#x27;y&#x27;]))plt.plot(x, y, c=&#x27;#ff0000&#x27;)plt.plot(xx, yy, c=&#x27;#00ff00&#x27;)plt.show() 先将日志放到一个文件里，通过read()得到一个字符串。通过split(“，”)得到单个1=Pos&#123;x=-11, y=-1, z=2771&#125;类似的串。通过 i 将不需要的数据过滤掉，直接 continue。针对想要的数据将前面的1=Pos给去掉得到&#123;x=-11, y=-1, z=2771&#125;这样的串，将 x、y、z 用引号包起来，等号改成冒号，这样就可以用 json 序列化了。最后使用p[&#39;x&#39;]的方式拿到 x、y 坐标，然后放到集合中，通过 plot 绘制出来。 小结本篇文章主要记录一下，借助 Python 做一些数据分析、坐标绘制，会很方便。环境搭建好了之后，使用 matplotlib 库，绘制代码网上一搜一大把，都十分简单易懂，一分钟就能有一个能跑起来的工具。后续有其他数据分析，也可以任意改造代码，运行起来非常快，十分高效！","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"女儿“过三关斩六将之旅”","date":"2023-11-06T07:36:02.000Z","path":"2023/11/06/daughter-1/","text":"以往的十月是金秋十月，丹桂飘香。可今年这刚刚过去的十月，却是我这三十多年来最揪心的一个月。去年的 10 月 27 日，女儿在医院呱呱坠地，从此我的人生多了一份牵挂。今年的 10 月 27 日，女儿刚刚满一岁，本应是喜庆的日子，女儿却来医院打针了。从十月初给女儿过完周岁礼，女儿就断断续续出现各种不好的症状。 这第一关是拉肚子，一天拉十多次，持续了两三天不见好，便带到医院检查。做了一次灌肠，开了益生菌和蒙脱石散，每天喂药和打仗一样，女儿嗷嗷哭一点都不配合吃药，只能“硬灌”。所幸灌进去的一点点药有点效果，拉肚子的症状慢慢好了。也不知道到底是什么原因导致女儿拉肚子，只能怀疑期间吃过的任何杂七杂八的食物，有土豆泥、炸薯条（扒掉外层的炸皮喂的），还有一些水果等等，最后觉得是炸薯条最可疑，因为有油。这也是因为我和老婆享受在吃西餐，没有其他东西给娃喂了，偷懒喂的，下次一定不能这样了。紧接着第二关来了：女儿便秘大便拉不出了。每次坐着使劲但又拉不出来，用力使得肛门疼痛，然后就开始哭，听得老父亲的心都揪成一团乱麻了。一个夜晚发现女儿的大便已经到肛门口了，可就是拉不出来，人工尝试扒拉了一下可效果甚微，女儿还是不停地哭。火急火燎的带到社区医院寻求治病办法，可社区说：这要去医院看，社区没有急诊。顿时心里一番 mmp，我要这社区医院有何用！？又抓紧送到医院去看，不来不知道，一来吓一跳。晚上八九点的医院，儿科门诊竟然还排到了 370 多号，当前叫号才 300 出头。如果排队等医生看诊，保守估计得等两三个小时，这怎么能等得及！和护士沟通，护士建议自己回家治疗，可以使用点开塞露，尝试帮忙把大便排出来。只能回到家，买了开塞露使用，结合老婆之前便秘时吃的果糖糖浆，还好女儿比较给力，使劲将大便给拉出来了。还好还好，只要这最硬的一坨大便出来，后面应该会好很多了。后续几天尝试给她吃利便的食物，辅以果糖、开塞露，慢慢地便控制住了。怀疑是之前灌肠导致的后遗症，效果太强烈，考虑以后娃出现腹泻情况先考虑温和一点的药物治疗，不要鲁莽地灌肠了。第二关过去，最难的第三关便来了。23、24 号老妈说：这几天要关注下瑶瑶，感觉有点咳嗽。果不其然，晚上开始有点发烧，25 号一大早就带到医院检查。抽了血，大多数指标都在正常范围，仅有一两项略高或略低。医生诊断症状很轻，只简单的开了咳喘灵、百蕊颗粒，让回家吃药然后观察。26 号晚上又开始烧了，而且烧得有点高，持续时间比较久。27 号带到医院说有点严重，要打针。就这样，女儿在满周岁的这一天在医院挨了针。打针辅以吃药、做雾化，持续到 29 号。本以为再打一天针女儿便能慢慢好了，可医生检查觉得症状更重了。拍了片子，医生一看，得，肺炎了。只能住院了。准备工作做完，来到住院部，我又震惊了。床位一个不剩，走道里塞了不少临时床位，甚至连一个单一的座位，都是作为一个“床位”存在，而我家的瑶瑶，就是分配到了这样的一个座位上，等待住院部医生诊断。经过漫长地等待，终于轮到我家了，医生诊断是喘息性支气管肺炎，开了一堆的点滴，雾化，吃的药，开始进行治疗。医生给我开了西替利嗪滴剂、环酯红霉素这两样药，让我去买。我问：医院没卖的吗？答：医院没有环酯红霉素。于是我去外面的药店跑了一圈，全部都没有卖的。我就很纳闷了：为什么医生开的药，却买不到呢？后面换了个医生和我说，去省妇幼医院有卖的。于是屁颠屁颠的坐地铁跑到省妇幼，随便挂了一个号，让医生帮忙开了两盒环酯红霉素，终于拿到药了。可很不幸的，老婆这几天也生病了，有轻微发烧，浑身乏力，伴随着咳嗽。走道里到处都是此起彼伏的咳嗽声，我们一家三大一小就在这样的一个环境里，慢慢熬。真的太难熬了😭😭😭。。。女儿太小，打针会哭，吃药会哭，做雾化也会哭，生病还特别黏老婆，我和老妈都不怎么要了。老婆生病浑身乏力，发烧咳嗽，还得面对这样的一个小家伙。我和老妈倒还好，可心里着实不是滋味。只能趁着女儿状态好要我的时候，多带一带，让老婆、老妈休息一下。女儿很喜欢爬楼梯，没生病的时候只要一爬楼梯就认为是要出去玩，高兴得不得了。这住院期间，住院部的楼梯都被我不知道爬了多少遍了。老婆担心自己是支原体感染，也去挂了个号检查了一下，还好不是。开了哺乳期也能吃的百蕊颗粒，后面应该是退烧了，老婆慢慢地好起来了。住院期间，根据入院顺序，先是将我们的座位升级成了走道里的病床，后面升级成房间里的病床。床位环境慢慢变好了，老婆孩子也慢慢好起来了。在走道病床的时候，到了傍晚，很多孩子打完针做完治疗就回家了。我逛了一下走道、房间，发现一些房间里的病床一个孩子都没有，整个房间都是空的。我顿时大感不公：为什么我家的孩子只能睡走道，可别人家的孩子有房间里的正常病床却不用！于是我去问值班护士，能不能到房间的病床里去睡？走道里太吵了，根本没办法好好休息。护士说：也可以，不过你得在别人回来之前搬离。我忙说好好好。然后忙活了一番，准备搬到一间完全无人的房间里休息（用了我们自己的床上用品）。但是这个时候，老妈又担心病床不安全，可能有病毒感染什么的，孩子支原体肺炎感染不可谓不多。于是提议回家睡，第二天早上再过来，就像空着病床不住的孩子们那样。这个时候，我内心释然了，为什么会产生这样的空病床，感觉就像是资源浪费。可这样的情况持续了不到一天，第二天晚上我们也是回家睡。女儿到了晚上 10 点多都无法安然入睡，一吃奶就开始哭（女儿已经习惯奶睡）。老婆怀疑是女儿鼻孔堵住了，当嘴用来吃奶的时候，便没有其他的器官能呼吸了，就会嗷嗷哭。纠结了一下，收拾好物品直接奔医院而来。可住院部的医生坐诊去了，一时半会回不来。只有一个值班的护士，说可以吸一下鼻腔，把里面的鼻屎等脏东西吸出来，可能就能顺畅呼吸了。相比等着看医生，我问了一下吸鼻腔没有副作用，便让护士开始吸。女儿的哭声遍布寂静的走道，还好吸完后女儿可以边吃奶边呼吸了。今晚肯定就在医院过夜了，然后老婆带着女儿在病床上睡觉了。老妈让我回家睡觉，我不忍心自己的妈妈和老婆女儿在医院“遭罪”，我却在家里安然大睡。但实际想想晚上也没什么事情，我可以休息好了，第二天来多帮帮忙。在开车回家的路上，想想这几天的经历，我差点哭了出来。后面换到房间的床位里，有三张病床，另外两张还没有小孩子入住。下午一两点，女儿正好睡着，老婆给她做雾化。不多久进来一个三四岁的小女孩。从进房间的一刻起，就开始哭，她爸爸妈妈都在身边，女孩是第一次做雾化，很抵抗，一直哭。我在旁边内心揪成一团麻，生怕哭声吵醒女儿。我尝试去开导女孩，做雾化不疼，吸一下很快就好了，可没用。我如坐针毡，很想上去说一些狠话，我甚至想向护士投诉，期望她们可以给和女孩父母说，如果一直哭可以移到走道上做雾化的场所。但最后还是忍住了，没有哪个孩子想生病，没有哪个父母想自己的孩子一直哭，都是没办法。果不其然，哭声吵醒了女儿，这下好了，两个孩子都开始哭，比谁的声音大，女儿的雾化也做不了了，只能另寻机会。还好大点的孩子更好教导，小女孩渐渐习惯了做雾化，后面不怎么哭了。而我也是请了 2 天假，不适合再请假了。在单独的病房里，女儿慢慢接受治疗，只能辛苦老妈和老婆多担待一下了。到住院第五天，也就是周四 11 月 2 号，医生说可以出院了，出院后继续吃药做雾化，在家观察，不要去人多的地方，避免感染。直到今天，老婆还略有咳嗽，但没什么其他症状了，精气神好了很多。女儿也恢复得比较好，基本不怎么咳嗽了。出院就一直在家里呆着，也不出门了，周末在家带了 2 天女儿，女儿现在很亲我，一切都在往好的方向发展，我们熬过来了。这个多事之秋，我怀疑了很多事情，也因为很多现状而感到愤怒。为什么孩子生个病看医生这么难，要排那么久的队？孩子情况很紧急，为什么不能得到及时治疗？为什么住院情况那么恶劣，一堆感染的小孩都挤在走道里？有的孩子有床位而不住，但有的孩子却连一个正常的床位都没有？为什么提前了这么多天看医生，最终也没能阻止肺炎的发生？为什么孩子一生病就这药、那药，活生生成了一个药罐子？后面才发现，这个秋冬季节，支原体、合胞病毒、诺如病毒，包括持续几年的新冠病毒，太多太多了，整个医院的儿科都是人满为患。像咱们家好歹看到医生了，住院得到治疗了，有些医院可能连医生的面都见不到，挂了号到后面只能退号。任何城市或国家的医疗，如果遭到这样的医疗挤兑，都会产生一定的“不合理性”。这么来看，我内心的愤怒和抱怨便一点都不重要了，重要的是一家人能够平平安安，健健康康地。这个多事之秋，多靠自己吧。戴好口罩，注重防护，保护好家人，保护好自己。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"HashMap 序列化小结","date":"2023-09-13T08:45:45.000Z","path":"2023/09/13/serial/","text":"本地有一个 HashMap 的对象，有序列化的需求，直接使用 SharedPreferences 进行存储： 123private val map = HashMap&lt;Byte, MutableList&lt;BrakeModel&gt;&gt;()PreUtils.setString(KEY, JSON.toJSONString(map)) 然后将 String 反序列化时，报错了： 1java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to BrakeModel 项目中使用的 fastjson，使用的 TypeReference 将 String 转成 Map。将场景复刻，写了一个测试用例： 12345678910111213@Testfun addition_isCorrect() &#123; val text = &quot;&#123;1:[&#123;xxx&#125;]&#125;&quot; val newCaches = JSON.parseObject(text, object : TypeReference&lt;Map&lt;Byte, List&lt;BrakeModel&gt;&gt;&gt;() &#123;&#125;) if (newCaches != null) &#123; println(newCaches.size)// val list = newCaches.get(1)// val any = list?.firstOrNull()// println(any?.javaClass?.simpleName) &#125; else &#123; println(&quot;newCaches is null&quot;) &#125;&#125; 此时测试用例运行通过，输出：1。当时写代码也是因为这个大意了，以为测试用例通过就没问题了。但其实打上断点看看 newCaches 的内容就会发现：它是一个 HashMap 对象，Key 是 Byte，但 Value 却是 JSONArray，其 Item 是 JSONObject 对象。若是不涉及到 Value Item 的读取，仅仅调用 newCaches.size 是不会有问题的。但凡涉及到 Value Item 的读取，就会报 ClassCastException 的错误，因为这个 Map 指定的泛型是 BrakeModel，但反序列化得到的实际对象却是 JSONObject。测试一下，将注释代码放开，测试用例则会在 val any 那一行就报错了。刚开始方向跑偏了，发现 List 接口是 Kotlin 自实现的，并没有继承 Serializable 接口，于是认为是 List 的原因。将 List 修改成 ArrayList、MutableList、java.util.ArrayList 都通通没效果。后面回过头发觉：这特喵的不是个 Map 吗？看到 Kotlin 实现的 Map 接口也没有继承 Serializable 接口。于是仅仅将 Map 改成 HashMap 之后，测试用例便通过了，Value Item 也可以正常访问了。改成 HashMap 之后无论是 List、ArrayList、MutableList 等等，得到的结构都是 ArrayList，没什么区别。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 结合 Unity 彻底退出应用","date":"2023-08-17T07:44:59.000Z","path":"2023/08/17/exit/","text":"最近测试频繁出现一个问题：在登录页点关闭车机，倒计时结束后，应用卡住不动了，不一会便弹应用无响应的弹窗了。 倒计时退出相关代码是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849fun LifecycleOwner.exitCountDown(viewBinding: LayoutExitAppBinding, onExit: () -&gt; Unit) &#123; lifecycleScope.launch &#123; flow &#123; for (i in 5 downTo 1) &#123; emit(i) delay(1000) &#125; &#125;.onStart &#123; viewBinding.root.visibility = View.VISIBLE &#125;.onCompletion &#123; onExit() &#125;.collect &#123; viewBinding.countDownTv.text = it.toString() &#125; &#125;&#125;private fun exitCountDown() &#123; exitCountDown(viewBinding.countDownCl) &#123; exit() &#125;&#125;/** * 退出 */private fun exit() &#123; finishUnity() finish()&#125;/** * 主动退出登录页面，如果 Unity 页面还存活，要 finish 掉 */private fun finishUnity() &#123; val activity = weakReference?.get() activity?.finish()&#125;@JvmStaticfun launch(context: Context) &#123; val isUnityPage = isUnityPage(context) if (isUnityPage == true) &#123; val activity = ActivityUtils.getActivity(context) ?: return weakReference = WeakReference(activity) &#125; ActivityUtils.startIntent(context, Intent(context, LoginActivity::class.java))&#125; 登录页启动时，会判断 context 是否是 Unity Activity，如果是的话，用 weakReference 保存起来。当需要退出时，调用各自的 finish 方法，从而退出应用。通过拉取 trace 日志，发现如下信息： “main” prio&#x3D;5 tid&#x3D;1 Native | group&#x3D;”main” sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x752fa640 self&#x3D;0xed585400 | sysTid&#x3D;29419 nice&#x3D;-10 cgrp&#x3D;default sched&#x3D;0&#x2F;0 handle&#x3D;0xf0303534 | state&#x3D;S schedstat&#x3D;( 814378259296 185199035946 982842 ) utm&#x3D;65595 stm&#x3D;15842 core&#x3D;3 HZ&#x3D;100 | stack&#x3D;0xff47d000-0xff47f000 stackSize&#x3D;8MB | held mutexes&#x3D; kernel: __switch_to+0x8c&#x2F;0xb4 kernel: hrtimer_nanosleep+0x98&#x2F;0x13c kernel: compat_SyS_nanosleep+0xa8&#x2F;0x114 kernel: el0_svc_naked+0x24&#x2F;0x28 native: #00 pc 00049560 &#x2F;system&#x2F;lib&#x2F;libc.so (nanosleep+12) native: #01 pc 003af7a3 &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #02 pc 0041e0b7 &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #03 pc 00261560 &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libmonobdwgc-2.0.so (mono_chain_signal+180) native: #04 pc 000713c0 &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libmonobdwgc-2.0.so (???) native: #05 pc 00001f71 &#x2F;system&#x2F;bin&#x2F;app_process32 (InvokeUserSignalHandler+156) native: #06 pc 0014b687 &#x2F;system&#x2F;lib&#x2F;libart.so (_ZN3art12FaultManager11HandleFaultEiP7siginfoPv+222) native: #07 pc 000170a4 &#x2F;system&#x2F;lib&#x2F;libc.so (???) native: #08 pc 002e28ce &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #09 pc 002e285f &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #10 pc 002a6ad9 &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #11 pc 002a668b &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #12 pc 002a6671 &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #13 pc 00205531 &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #14 pc 0020545b &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #15 pc 00204b5d &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) native: #16 pc 00cc7acd &#x2F;data&#x2F;app&#x2F;cn.xx.xx.xx.xx-1&#x2F;lib&#x2F;arm&#x2F;libunity.so (???) at com.unity3d.player.NativeLoader.unload(Native method) at com.unity3d.player.UnityPlayer.unloadNative(unavailable:-1) at com.unity3d.player.UnityPlayer.destroy(unavailable:-1) at com.unity3d.player.UnityPlayer.quit(unavailable:-1) at cn.mucang.android.jiakaoyi.unity.activity.UnityMainActivity.finish(UnityMainActivity.java:92) 看到 Unity 代码，在 Unity Activity 退出的时候，会调用 UnityPlayer 的 destroy 方法，最后在 unload 方法时出现了 anr。libunity.so 也没法改，于是尝试使用另外的思路退出应用：直接手动杀进程。将 exit 方法改成如下： 123private fun exit() &#123; Process.killProcess(Process.myPid())&#125; 倒计时结束后，App 确实会退出，但是立刻又会将 Unity Activity 给拉起来，这不符合预期，继续尝试。 123private fun exit() &#123; System.exit(status)&#125; 和之前的情况一致，再继续尝试。 1234private fun exit() &#123; moveTaskToBack(true) exitProcess(1) // kotlin 方法，实际也是调用的 System.exit&#125; 发现 App 确实正常退出了。但是当手动点击应用图标尝试启动时，App 直接从 Unity Activity 启动了，前置的起屏页等页面都没有执行。很奇怪，继续尝试。 1234private fun exit() &#123; finishAffinity() exitProcess(0)&#125; 如此之后，App 正常退出了。点击图标启动时，也是正常地从起屏页开始，问题终于解决。没想到，结合 Unity 的一个 App 退出的功能竟然花费了大量时间。 在当前场景（单进程）中，通过测试，exitProcess(0)、exitProcess(1)、Process.killProcess(Process.myPid()) 三个方法退出进程，并没有什么明显的不同。值得一提的是 exitProcess 方法会有 activity 正常退出的动画效果，相对平滑一点。而 killProcess 会直接顿一下，然后回到桌面。故采用的 exitProcess 方式。 通过后续了解，大概知道一些东西： System.exit() does not kill your app if you have more than one activity on the stack. What actually happens is that the process is killed and immediately restarted with one fewer activity on the stack. This is also what happens when your app is killed by the Force Close dialog, or even when you try to kill the process from DDMS. This is a fact that is entirely undocumented, to my knowledge. 当栈里有超过一个 activity 时，System.exit() 并不会直接杀掉 App。它会立刻重启栈里的 fewer activity。这就和测试的现象吻合啊，会把 Unity Activity 给重启。但是这个并没有一个官方的文档解释，只是开发者的一个经验讲述。 当添加 moveTaskToBack 后，会将任务栈放到后台，这个时候再去结束进程就不会重新拉起 Activity 了。猜测是都处于后台了，就没有必要去重新拉起了。但是点击图标时，可能系统认为上一次不是正常退出，还保留着之前任务栈，于是会从最底部的 Activity 给重新启动。盲猜一把：如果结束进程的时间足够长，系统应该不会保留任务栈，从而将应用从起屏页重新打开。待测试。 当使用 finishAffinity 方法时，它会将栈里的所有 activity 都 finish 掉，那么栈里超过一个 activity 的限制条件便不存在了，这个时候结束进程便可以正常结束了，App 重新启动也是正常启动了。 参考 How to exit an Android app programmatically? Is quitting an application frowned upon? Android 彻底关闭—-退出程序","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"写在女儿生病后","date":"2023-07-05T07:13:29.000Z","path":"2023/07/05/daughter/","text":"养儿方知父母恩。最近才深刻理解这句话。 端午带着老婆、女儿回了一趟娘家，第一天夜里女儿有点发烧，估计也是难受，睡得特别不安稳。简单量了一下体温，不配合，37.7度。第二天好像就退烧了，但还是不放心，就近带到卫生院让医生看了一下，说：可能是上呼吸道感染，开点药吃吧。如果不见好，就去大医院。吃药也是十分不配合，小孩子都精着呢，不好吃(喝)的东西，完全不会配合，一个劲的嗷嗷哭，憋着嘴不喝药。想着不烧了，后面可能就好了，就没有太在意。节后回到家，女儿慢慢开始咳嗽，到后面越咳越厉害，甚至咳到吐奶。一晚上听着女儿半小时就咳一次，别提多揪心了。一大早上，赶紧清好东西带到医院看医生。拍了胸片，验了血，医生诊断是支气管炎，还好不是肺炎。鉴于病情严重，建议打针，配合雾化进行治疗。八个月大的女儿，就这样挨了她的第一针。嗷嗷哭😭😭😭。看着病恹恹的女儿，这几天真是茶不思饭不想，心里总有个大石头，十分难受。所幸病情比较明显，积极治疗，应该会慢慢好转。总共打了四天针，做了六天雾化，辅以“吃药”，女儿的病情终于好转了。这几天看着女儿笑颜重开，心里的大石头终于是落地了。真是养儿方知父母恩啊！ 可以理解为什么现在的年轻人越来越不想生孩子了。生孩子意味着责任，有的人会选择“逃避”，我和老婆选择了接受。从怀孕到生孩子，从孩子呱呱落地到现在八个月大，老婆付出了太多太多。身体上的痛苦；离开职场，与社会脱节；几乎睡不了一个整觉；等等这些，都让我们产生了“为什么要生孩子”的质疑。但当你看着这个小不点一点点长大的时候，看着她对着你笑的时候，你又会觉得这一切都是值得的。养育孩子就是这样一个撕裂的过程，不断地否定，又不断地肯定。但我们也正是因为有了这样的经历，而让人生变得不一样了。当然也有其他的方式让自己的人生变得精彩，都是自我选择，坚定自己的立场就好了。 现在越发的觉得把我们抚养成人的父母有多么厉害，多么不容易了。在我们父母那个年代，普遍都比较穷，受教育程度也比较低，但是仍然能将我们健健康康的拉扯大，这已经是尽最大的努力了。现在看到一些“白眼狼”的新闻，总会觉得很可惜。诚然，有些父母的养育方式可能是“不对”的，对我们造成了不良影响，但随着我们慢慢长大，我们的能力越来越强，我们需要学会思考，学会自我修复，建立正确的三观，而不是将所有的问题都归咎到父母的身上。毕竟父母不是超人，也不是圣人，他们也会有缺点，也会犯错。多一点理解与体谅，少一点杠精和逆反吧。 除了健康长大，受到的教育也是至关重要的。这也是作为父母最难的一点：怎么教育好子女？一万个父母会有一万个答案，但是肯定都不容易。初为人父，未来的路很长，只能摸着石头过河，尽自己最大努力给女儿一个美满的人生。路漫漫其修远兮，吾将上下而求索。 趁现在，岁月静好，好好孝敬父母，好好爱老婆，好好养育子女吧！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Android 对视频进行切割、添加转场效果","date":"2023-06-19T09:52:19.000Z","path":"2023/06/19/opengl/","text":"在Android 倍速压缩视频时长中，实现了针对完整视频进行倍速压缩的功能。用户反馈说，这样的一个倍速视频就和看轨迹回放一样的效果，从头到尾完整播放一遍，体现不出“牛逼”的地方。于是想着针对学员“操作”的地方进行切片，比如打方向盘、挂挡等。当出现这些操作时，对整个视频进行切割，生成若干个片段，然后再拼接到一起。片段衔接处添加转场效果，让切换看起来更丝滑。这样处理后的视频，可能就是一个富含学员“精彩操作”的视频，学员查看和分享的欲望可能就更强烈了。基于这样的一个需求场景，需要做的事情就确定了： 对完整视频进行切片，分割成若干个片段； 将片段结合转场效果合并到一起，生成最终视频。 切片经过产品讨论，目前设定的操作切片逻辑如下： 进入项目的三秒内； 离开项目的三秒前； 拉手刹； 停车； 打方向盘超过360度； 侧方接触36线时。 生成的切片无非就是若干个时间片段（相对时间）。基于 VideoProcessor 的 VideoDecodeThread 类，做了相关修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289public class VideoDecodeThread extends Thread &#123; private MediaExtractor mExtractor; private MediaCodec mDecoder; private Integer mStartTimeMs; private Integer mEndTimeMs; private Float mSpeed; private AtomicBoolean mDecodeDone; private Exception mException; private int mVideoIndex; private IVideoEncodeThread mVideoEncodeThread; private InputSurface mInputSurface; private OutputSurface mOutputSurface; private Integer mDstFrameRate; private Integer mSrcFrameRate; private boolean mDropFrames; private FrameDropper mFrameDropper; private List&lt;Pair&lt;Long, Long&gt;&gt; mCutSegments; public VideoDecodeThread(IVideoEncodeThread videoEncodeThread, MediaExtractor extractor, @Nullable Integer startTimeMs, @Nullable Integer endTimeMs, @Nullable Integer srcFrameRate, @Nullable Integer dstFrameRate, @Nullable Float speed, boolean dropFrames, int videoIndex, AtomicBoolean decodeDone ) &#123; this(videoEncodeThread, extractor, startTimeMs, endTimeMs, null, srcFrameRate, dstFrameRate, speed, dropFrames, videoIndex, decodeDone); &#125; public VideoDecodeThread(IVideoEncodeThread videoEncodeThread, MediaExtractor extractor, @Nullable Integer startTimeMs, @Nullable Integer endTimeMs, List&lt;Pair&lt;Long, Long&gt;&gt; cutSegments, @Nullable Integer srcFrameRate, @Nullable Integer dstFrameRate, @Nullable Float speed, boolean dropFrames, int videoIndex, AtomicBoolean decodeDone ) &#123; super(&quot;VideoProcessDecodeThread&quot;); mExtractor = extractor; mStartTimeMs = startTimeMs; mEndTimeMs = endTimeMs; mCutSegments = cutSegments; mSpeed = speed != null ? speed : 1f; mVideoIndex = videoIndex; mDecodeDone = decodeDone; mVideoEncodeThread = videoEncodeThread; mDstFrameRate = dstFrameRate; mSrcFrameRate = srcFrameRate; mDropFrames = dropFrames; &#125; @Override public void run() &#123; super.run(); try &#123; doDecode(); &#125; catch (Exception e) &#123; mException = e; CL.e(e); &#125; finally &#123; if (mInputSurface != null) &#123; mInputSurface.release(); &#125; if (mOutputSurface != null) &#123; mOutputSurface.release(); &#125; try &#123; if (mDecoder != null) &#123; mDecoder.stop(); mDecoder.release(); &#125; &#125; catch (Exception e) &#123; mException = mException == null ? e : mException; CL.e(e); &#125; &#125; &#125; private void doDecode() throws IOException &#123; CountDownLatch eglContextLatch = mVideoEncodeThread.getEglContextLatch(); try &#123; boolean await = eglContextLatch.await(5, TimeUnit.SECONDS); if (!await) &#123; mException = new TimeoutException(&quot;wait eglContext timeout!&quot;); return; &#125; &#125; catch (InterruptedException e) &#123; CL.e(e); mException = e; return; &#125; Surface encodeSurface = mVideoEncodeThread.getSurface(); mInputSurface = new InputSurface(encodeSurface); mInputSurface.makeCurrent(); MediaFormat inputFormat = mExtractor.getTrackFormat(mVideoIndex); //初始化解码器 mDecoder = MediaCodec.createDecoderByType(inputFormat.getString(MediaFormat.KEY_MIME)); mOutputSurface = new OutputSurface(); mDecoder.configure(inputFormat, mOutputSurface.getSurface(), null, 0); mDecoder.start(); //丢帧判断 int frameIndex = 0; if (mDropFrames &amp;&amp; mSrcFrameRate != null &amp;&amp; mDstFrameRate != null) &#123; if (mSpeed != null) &#123; mSrcFrameRate = (int) (mSrcFrameRate * mSpeed); &#125; if (mSrcFrameRate &gt; mDstFrameRate) &#123; mFrameDropper = new FrameDropper(mSrcFrameRate, mDstFrameRate); CL.w(&quot;帧率过高，需要丢帧:&quot; + mSrcFrameRate + &quot;-&gt;&quot; + mDstFrameRate); &#125; &#125; //开始解码 MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); boolean decoderDone = false; boolean inputDone = false; long videoStartTimeUs = -1; int decodeTryAgainCount = 0; while (!decoderDone) &#123; //还有帧数据，输入解码器 if (!inputDone) &#123; boolean eof = false; int index = mExtractor.getSampleTrackIndex(); if (index == mVideoIndex) &#123; int inputBufIndex = mDecoder.dequeueInputBuffer(TIMEOUT_USEC); if (inputBufIndex &gt;= 0) &#123; ByteBuffer inputBuf = mDecoder.getInputBuffer(inputBufIndex); int chunkSize = mExtractor.readSampleData(inputBuf, 0); if (chunkSize &lt; 0) &#123; mDecoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM); decoderDone = true; &#125; else &#123; long sampleTime = mExtractor.getSampleTime(); mDecoder.queueInputBuffer(inputBufIndex, 0, chunkSize, sampleTime, 0); mExtractor.advance(); &#125; &#125; &#125; else if (index == -1) &#123; eof = true; &#125; if (eof) &#123; //解码输入结束 CL.i(&quot;inputDone&quot;); int inputBufIndex = mDecoder.dequeueInputBuffer(TIMEOUT_USEC); if (inputBufIndex &gt;= 0) &#123; mDecoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM); inputDone = true; &#125; &#125; &#125; boolean decoderOutputAvailable = !decoderDone; if (decoderDone) &#123; CL.i(&quot;decoderOutputAvailable:&quot; + decoderOutputAvailable); &#125; while (decoderOutputAvailable) &#123; int outputBufferIndex = mDecoder.dequeueOutputBuffer(info, TIMEOUT_USEC); CL.i(&quot;outputBufferIndex = &quot; + outputBufferIndex); if (inputDone &amp;&amp; outputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) &#123; decodeTryAgainCount++; if (decodeTryAgainCount &gt; 10) &#123; //小米2上出现BUFFER_FLAG_END_OF_STREAM之后一直tryAgain的问题 CL.e(&quot;INFO_TRY_AGAIN_LATER 10 times,force End!&quot;); decoderDone = true; break; &#125; &#125; else &#123; decodeTryAgainCount = 0; &#125; if (outputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) &#123; break; &#125; else if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; MediaFormat newFormat = mDecoder.getOutputFormat(); CL.i(&quot;decode newFormat = &quot; + newFormat); &#125; else if (outputBufferIndex &lt; 0) &#123; //ignore CL.e(&quot;unexpected result from decoder.dequeueOutputBuffer: &quot; + outputBufferIndex); &#125; else &#123; boolean doRender = true; //解码数据可用 if (mEndTimeMs != null &amp;&amp; info.presentationTimeUs &gt;= mEndTimeMs * 1000) &#123; inputDone = true; decoderDone = true; doRender = false; info.flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM; &#125; if (mStartTimeMs != null &amp;&amp; info.presentationTimeUs &lt; mStartTimeMs * 1000) &#123; doRender = false; CL.e(&quot;drop frame startTime = &quot; + mStartTimeMs + &quot; present time = &quot; + info.presentationTimeUs / 1000); &#125; if (mEndTimeMs == null &amp;&amp; mStartTimeMs == null) &#123; if (mCutSegments != null) &#123; doRender = false; // 在时间片段内的才渲染 for (Pair&lt;Long, Long&gt; segment : mCutSegments) &#123; if (info.presentationTimeUs &gt;= segment.first &amp;&amp; info.presentationTimeUs &lt;= segment.second) &#123; doRender = true; break; &#125; &#125; &#125; &#125; if (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123; decoderDone = true; mDecoder.releaseOutputBuffer(outputBufferIndex, false); CL.i(&quot;decoderDone&quot;); break; &#125; //检查是否需要丢帧 if (mFrameDropper != null &amp;&amp; mFrameDropper.checkDrop(frameIndex)) &#123; CL.w(&quot;帧率过高，丢帧:&quot; + frameIndex); doRender = false; &#125; frameIndex++; mDecoder.releaseOutputBuffer(outputBufferIndex, doRender); if (doRender) &#123; boolean errorWait = false; try &#123; mOutputSurface.awaitNewImage(); &#125; catch (Exception e) &#123; errorWait = true; CL.e(e.getMessage()); &#125; if (!errorWait) &#123; long presentationTimeNs = 0; float percent = 1; if (mEndTimeMs == null &amp;&amp; mStartTimeMs == null) &#123; if (mCutSegments != null) &#123; long gap = 0; for (int i = 0; i &lt; mCutSegments.size(); i++) &#123; // 计算所属时间片段 Pair&lt;Long, Long&gt; segment = mCutSegments.get(i); if (info.presentationTimeUs &gt;= segment.first &amp;&amp; info.presentationTimeUs &lt;= segment.second) &#123; presentationTimeNs = info.presentationTimeUs - segment.first + gap; long start = info.presentationTimeUs - segment.first; long end = segment.second - info.presentationTimeUs; // 透明度百分比动画500毫秒 if (start &lt; end) &#123; // 第一个片段的开始，不做动画 percent = start / (500f * 1000 * mSpeed); if (i == 0) &#123; percent = 1f; &#125; &#125; else &#123; percent = end / (500f * 1000 * mSpeed); // 最后一个片段的结束，不做动画 if (i == mCutSegments.size() - 1) &#123; percent = 1f; &#125; &#125; if (percent &gt; 1f) &#123; percent = 1f; &#125; if (percent &lt; 0f) &#123; percent = 0f; &#125; break; &#125; else &#123; gap += segment.second - segment.first; &#125; &#125; &#125; &#125; else &#123; if (videoStartTimeUs == -1) &#123; videoStartTimeUs = info.presentationTimeUs; CL.i(&quot;videoStartTime:&quot; + videoStartTimeUs / 1000); &#125; presentationTimeNs = (info.presentationTimeUs - videoStartTimeUs) * 1000; &#125; presentationTimeNs /= mSpeed; mVideoEncodeThread.setTime(presentationTimeNs); mOutputSurface.drawImage(false, percent); CL.i(&quot;drawImage,setPresentationTimeMs:&quot; + presentationTimeNs / 1000 / 1000); mInputSurface.setPresentationTime(presentationTimeNs); mInputSurface.swapBuffers(); break; &#125; &#125; &#125; &#125; &#125; CL.i(&quot;Video Decode Done!&quot;); mDecodeDone.set(true); &#125; public Exception getException() &#123; return mException; &#125;&#125; VideoDecodeThread 类主要做的就是将视频解码，绘制到 Surface 上。针对倍速、截取视频长短，无非就是控制绘制的逻辑。代码里有 doRender 参数的设置，为 true 时才会绘制。添加了一个List&lt;Pair&lt;Long, Long&gt;&gt; mCutSegments的参数，由外部传入，就是需要切片的时间段，示例如下：当 info.presentationTimeUs 处于时间片段内时，doRender 才设置成 true，才会执行绘制逻辑。经过测试确实可以切片了，但是还有一个问题：视频切片的长度，并不是近似等于时间片段的总时长。使用示例数据，应该是生成 11 秒上下的视频，用两个测试视频进行测试，一个视频最终只有 9 秒，另一个视频却有 13 秒。最终定位到问题：decode 是解码进行 Surface 绘制，但是真正写 mp4 文件的还是 encode 类，encode 时的 presentationTimeUs 不是严格对齐的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203public class VideoEncodeThread extends Thread implements IVideoEncodeThread &#123; private MediaCodec mEncoder; private MediaMuxer mMuxer; private AtomicBoolean mDecodeDone; private CountDownLatch mMuxerStartLatch; private Exception mException; private int mBitrate; private int mResultWidth; private int mResultHeight; private int mIFrameInterval; private int mFrameRate; private MediaExtractor mExtractor; private int mVideoIndex; // private volatile InputSurface mInputSurface; private volatile CountDownLatch mEglContextLatch; private volatile Surface mSurface; private VideoProgressAve mProgressAve; private volatile long time = -1; public VideoEncodeThread(MediaExtractor extractor, MediaMuxer muxer, int bitrate, int resultWidth, int resultHeight, int iFrameInterval, int frameRate, int videoIndex, AtomicBoolean decodeDone, CountDownLatch muxerStartLatch) &#123; super(&quot;VideoProcessEncodeThread&quot;); mMuxer = muxer; mDecodeDone = decodeDone; mMuxerStartLatch = muxerStartLatch; mExtractor = extractor; mBitrate = bitrate; mResultHeight = resultHeight; mResultWidth = resultWidth; mIFrameInterval = iFrameInterval; mVideoIndex = videoIndex; mFrameRate = frameRate; mEglContextLatch = new CountDownLatch(1); &#125; @Override public void run() &#123; super.run(); try &#123; doEncode(); &#125; catch (Exception e) &#123; CL.e(e); mException = e; &#125; finally &#123; try &#123; if (mEncoder != null) &#123; mEncoder.stop(); mEncoder.release(); &#125; &#125; catch (Exception e) &#123; mException = mException == null ? e : mException; CL.e(e); &#125; &#125; &#125; private void doEncode() throws IOException &#123; MediaFormat inputFormat = mExtractor.getTrackFormat(mVideoIndex); //初始化编码器 int frameRate; if (mFrameRate &gt; 0) &#123; frameRate = mFrameRate; &#125; else &#123; frameRate = inputFormat.containsKey(MediaFormat.KEY_FRAME_RATE) ? inputFormat.getInteger(inputFormat.KEY_FRAME_RATE) : DEFAULT_FRAME_RATE; &#125; String mimeType = VideoProcessor.OUTPUT_MIME_TYPE; MediaFormat outputFormat = MediaFormat.createVideoFormat(mimeType, mResultWidth, mResultHeight); outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface); outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate); outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, mIFrameInterval); mEncoder = MediaCodec.createEncoderByType(mimeType); boolean supportProfileHigh = VideoUtil.trySetProfileAndLevel(mEncoder, mimeType, outputFormat, MediaCodecInfo.CodecProfileLevel.AVCProfileHigh, MediaCodecInfo.CodecProfileLevel.AVCLevel31 ); if (supportProfileHigh) &#123; CL.i(&quot;supportProfileHigh,enable ProfileHigh&quot;); &#125; int maxBitrate = VideoUtil.getMaxSupportBitrate(mEncoder,mimeType); if (maxBitrate &gt; 0 &amp;&amp; mBitrate &gt; maxBitrate) &#123; CL.e(mBitrate + &quot; bitrate too large,set to:&quot; + maxBitrate); mBitrate = (int) (maxBitrate * 0.8f);//直接设置最大值小米2报错 &#125; outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, mBitrate); mEncoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mSurface = mEncoder.createInputSurface();// mInputSurface = new InputSurface(encodeSurface);// mInputSurface.makeCurrent(); mEncoder.start(); mEglContextLatch.countDown(); boolean signalEncodeEnd = false; MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); int encodeTryAgainCount = 0; int videoTrackIndex = -5; boolean detectTimeError = false; final int VIDEO_FRAME_TIME_US = (int) (1000 * 1000f / frameRate); long lastVideoFrameTimeUs = -1; //开始编码 //输出 while (true) &#123; if (mDecodeDone.get() &amp;&amp; !signalEncodeEnd) &#123; signalEncodeEnd = true; mEncoder.signalEndOfInputStream(); &#125; int outputBufferIndex = mEncoder.dequeueOutputBuffer(info, TIMEOUT_USEC); CL.i(&quot;encode outputBufferIndex = &quot; + outputBufferIndex); if (signalEncodeEnd &amp;&amp; outputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) &#123; encodeTryAgainCount++; if (encodeTryAgainCount &gt; 10) &#123; //三星S8上出现signalEndOfInputStream之后一直tryAgain的问题 CL.e(&quot;INFO_TRY_AGAIN_LATER 10 times,force End!&quot;); break; &#125; &#125; else &#123; encodeTryAgainCount = 0; &#125; if (outputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) &#123; continue; &#125; else if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; MediaFormat newFormat = mEncoder.getOutputFormat(); if (videoTrackIndex == -5) &#123; videoTrackIndex = mMuxer.addTrack(newFormat); mMuxer.start(); mMuxerStartLatch.countDown(); &#125; CL.i(&quot;encode newFormat = &quot; + newFormat); &#125; else if (outputBufferIndex &lt; 0) &#123; //ignore CL.e(&quot;unexpected result from decoder.dequeueOutputBuffer: &quot; + outputBufferIndex); &#125; else &#123; //编码数据可用 ByteBuffer outputBuffer = mEncoder.getOutputBuffer(outputBufferIndex); if (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM &amp;&amp; info.presentationTimeUs &lt; 0) &#123; info.presentationTimeUs = 0; &#125; //写入视频 if (!detectTimeError &amp;&amp; lastVideoFrameTimeUs != -1 &amp;&amp; info.presentationTimeUs &lt; lastVideoFrameTimeUs + VIDEO_FRAME_TIME_US / 2) &#123; //某些视频帧时间会出错 CL.e(&quot;video 时间戳错误，lastVideoFrameTimeUs:&quot; + lastVideoFrameTimeUs + &quot; &quot; + &quot;info.presentationTimeUs:&quot; + info.presentationTimeUs + &quot; VIDEO_FRAME_TIME_US:&quot; + VIDEO_FRAME_TIME_US); detectTimeError = true; &#125; if (detectTimeError) &#123; info.presentationTimeUs = lastVideoFrameTimeUs + VIDEO_FRAME_TIME_US; CL.e(&quot;video 时间戳错误，使用修正的时间戳:&quot; + info.presentationTimeUs); detectTimeError = false; &#125; if (info.flags != MediaCodec.BUFFER_FLAG_CODEC_CONFIG) &#123; lastVideoFrameTimeUs = info.presentationTimeUs; &#125; if (time != -1) &#123; info.presentationTimeUs = time; &#125; CL.i(&quot;writeSampleData,size:&quot; + info.size + &quot; time:&quot; + info.presentationTimeUs / 1000); mMuxer.writeSampleData(videoTrackIndex, outputBuffer, info); notifyProgress(info); mEncoder.releaseOutputBuffer(outputBufferIndex, false); if (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123; CL.i(&quot;encoderDone&quot;); break; &#125; &#125; &#125; CL.i(&quot;Video Encode Done!&quot;); &#125; private void notifyProgress(MediaCodec.BufferInfo info) &#123; if (mProgressAve == null) &#123; return; &#125; mProgressAve.setEncodeTimeStamp((info.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) &gt; 0 ? Long.MAX_VALUE : info.presentationTimeUs); &#125; @Override public Surface getSurface() &#123; return mSurface; &#125; @Override public CountDownLatch getEglContextLatch() &#123; return mEglContextLatch; &#125; @Override public void setTime(long time) &#123; this.time = time; &#125; public Exception getException() &#123; return mException; &#125; public void setProgressAve(VideoProgressAve progressAve) &#123; mProgressAve = progressAve; &#125;&#125; mMuxer.writeSampleData 才是对视频文件的最终写入。所以参数 info 的 presentationTimeUs 至关重要，它会控制视频的整体时长。但是针对视频分片，只能用解码的 presentationTimeUs 进行处理，索性便将解码的 presentationTimeUs 直接传到编码这边直接用了： 123if (time != -1) &#123; info.presentationTimeUs = time;&#125; 如此操作之后，生成的视频长度便符合预期了。 转场Android 对视频添加转场效果，之前没什么经验，搜索出来的都是针对两个视频添加转场效果。在当前场景中，这只能作为最下下下策方案。不然生成若干个小视频，再两两拼接，这耗时可就太久了，最好的就是在写 mp4 时直接就生成好。再搜索一番，发现可以利用 OpenGL 添加转场效果。VideoProcessor 库实现视频编解码正好利用到了 OpenGL： 123456789101112131415161718192021222324252627282930public void drawFrame(SurfaceTexture st, boolean invert, float percent) &#123; checkGlError(&quot;onDrawFrame start&quot;); st.getTransformMatrix(mSTMatrix); if (invert) &#123; mSTMatrix[5] = -mSTMatrix[5]; mSTMatrix[13] = 1.0f - mSTMatrix[13]; &#125; vPercent[0] = percent; GLES20.glUseProgram(mProgram); checkGlError(&quot;glUseProgram&quot;); GLES20.glActiveTexture(GLES20.GL_TEXTURE0); GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTextureID); mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET); GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices); checkGlError(&quot;glVertexAttribPointer maPosition&quot;); GLES20.glEnableVertexAttribArray(maPositionHandle); checkGlError(&quot;glEnableVertexAttribArray maPositionHandle&quot;); mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET); GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices); checkGlError(&quot;glVertexAttribPointer maTextureHandle&quot;); GLES20.glEnableVertexAttribArray(maTextureHandle); checkGlError(&quot;glEnableVertexAttribArray maTextureHandle&quot;); GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0); GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0); GLES20.glUniform2fv(mPercent, 1, vPercent, 0); GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4); checkGlError(&quot;glDrawArrays&quot;); GLES20.glFinish();&#125; 研究了若干文章，都是针对两个图片帧实现的效果。GLTransitions这个项目实现的效果可太酷炫了，可要怎么移植到 Android 中呢？曾经妄想能直接找到对应的着色器直接使用，毫无疑问全部失败。经过一阵无厘头的摸索之后恍然醒悟：需要自己做动画百分比，让当前帧达到一个预想的中间态。就和安卓中最普通的动画一样。所以通过时间戳计算出一个 percent： 1234567891011121314151617181920212223242526272829303132for (int i = 0; i &lt; mCutSegments.size(); i++) &#123; // 计算所属时间片段 Pair&lt;Long, Long&gt; segment = mCutSegments.get(i); if (info.presentationTimeUs &gt;= segment.first &amp;&amp; info.presentationTimeUs &lt;= segment.second) &#123; presentationTimeNs = info.presentationTimeUs - segment.first + gap; long start = info.presentationTimeUs - segment.first; long end = segment.second - info.presentationTimeUs; // 透明度百分比动画500毫秒 if (start &lt; end) &#123; // 第一个片段的开始，不做动画 percent = start / (500f * 1000 * mSpeed); if (i == 0) &#123; percent = 1f; &#125; &#125; else &#123; percent = end / (500f * 1000 * mSpeed); // 最后一个片段的结束，不做动画 if (i == mCutSegments.size() - 1) &#123; percent = 1f; &#125; &#125; if (percent &gt; 1f) &#123; percent = 1f; &#125; if (percent &lt; 0f) &#123; percent = 0f; &#125; break; &#125; else &#123; gap += segment.second - segment.first; &#125;&#125; 然后在 drawFrame 时，传入到 OpenGL 中。那么 OpenGL 如何自定义参数呢？ 123456789101112131415161718192021private static final String VERTEX_SHADER = &quot;uniform mat4 uMVPMatrix;\\n&quot; + &quot;uniform mat4 uSTMatrix;\\n&quot; + &quot;attribute vec4 aPosition;\\n&quot; + &quot;attribute vec4 aTextureCoord;\\n&quot; + &quot;varying vec2 vTextureCoord;\\n&quot; + &quot;void main() &#123;\\n&quot; + &quot; gl_Position = uMVPMatrix * aPosition;\\n&quot; + &quot; vTextureCoord = (uSTMatrix * aTextureCoord).xy;\\n&quot; + &quot;&#125;\\n&quot;;private static final String FRAGMENT_SHADER = &quot;#extension GL_OES_EGL_image_external : require\\n&quot; + &quot;precision mediump float;\\n&quot; + &quot;varying vec2 vTextureCoord;\\n&quot; + &quot;uniform vec2 vPercent;\\n&quot; + &quot;uniform samplerExternalOES sTexture;\\n&quot; + &quot;void main() &#123;\\n&quot; + &quot; vec4 c = texture2D(sTexture, vTextureCoord);\\n&quot; + &quot; gl_FragColor = vec4(c.r * vPercent[0], c.g * vPercent[0], c.b * vPercent[0], 1.0);\\n&quot; + &quot;&#125;\\n&quot;; 参照着代码中定义的参数，定义了一个 vPercent 的参数，并在 main 方法中使用了起来：使用 rgb 乘以一个类似 alpha 的系数，那么最终的效果就是慢慢变暗，再慢慢变亮。先定义变量： 12private int mPercent;private float[] vPercent = new float[2]; 然后映射属性： 1mPercent = GLES20.glGetUniformLocation(mProgram, &quot;vPercent&quot;); 对 vPercent 进行赋值： 1vPercent[0] = percent; 最终使用到 OpenGl： 1GLES20.glUniform2fv(mPercent, 1, vPercent, 0); 最终实现效果如下：Your browser does not support the video tag. 小结通过时间戳，控制 surface 的渲染，从而实现分片。同时在绘制 surface 时，结合 OpenGL 的能力，设置透明度，从而实现最简单的转场。分片逻辑好说，比较清晰，无非就是怎么通过时间片段完善代码。但是 OpenGL 的研究真的是熬死人了，它是一个很系统化的知识点，能力也确实强大。但是又没有很宽松的时间从头开始学习，只能边研究边实现功能，很多东西都是囫囵吞枣，一撇而过。不过好在研究出来了，至少最简单的转场功能是实现了。后续若想做更酷炫的转场动画，相信也是能搞出来的！ 参考 LearnOpenGL OpenGL ES 动效滤镜实现 GLTransitions Android 视频编辑系列-视频转场(下) 如何使用Android中的OpenGL ES媒体效果 OpenGL ES 绘制纹理 移动应用中使用OpenGL生成转场特效 OpenGL ES 变量、结构体、语句、函数、精度","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"记一次 DialogFragment 的错误使用","date":"2023-05-22T05:55:51.000Z","path":"2023/05/22/dialog-fragment/","text":"最近测试同学反馈一个问题：一个弹窗展示出来之后，点击按钮消失了。然后回到登录页再切回来时，这个弹窗又展示出来了。看到具体的代码： 12345678910111213141516171819202122public class HintDialog extends DialogFragment &#123; private String content; private View.OnClickListener positiveClickListener; private String positive; public static HintDialog show(FragmentManager fm, String content, String positive, View.OnClickListener positiveClickListener) &#123; HintDialog hintDialog = new HintDialog(); hintDialog.content = content; hintDialog.positive = positive; hintDialog.positiveClickListener = positiveClickListener; hintDialog.show(fm, &quot;HintDialog&quot;); return hintDialog; &#125; @NonNull @Override public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) &#123; return JCommonDialog.createDialog(getActivity(), content, positive, positiveClickListener); &#125;&#125; 然后看到 JCommonDialog createDialog 方法： 12345678910111213141516fun createDialog(context: Context, title: String, btnText: String, listener: View.OnClickListener): Dialog &#123; return if (isRobot()) &#123; JCommonDialog( context, DialogParams(title, &quot;&quot;, null, null, btnText, listener, false) ) &#125; else &#123; AlertDialog.Builder(context) .setMessage(title) .setCancelable(false) .setPositiveButton(btnText) &#123; _: DialogInterface?, _: Int -&gt; listener.onClick(null) &#125; .create() &#125;&#125; isRobot 为 true 时，便会出现那个问题，如果是 false，使用 AlterDialog 便不会有那个问题。JCommonDialog 只是使用了一个自定义的布局，包含通用的标题、描述、左边按钮、右边按钮等元素，支持设置各种参数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class JCommonDialog(context: Context, private val params: DialogParams) : Dialog(context, R.style.dialog)&#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setData() &#125; private fun setData() &#123; viewBinding.titleTv.isGone = TextUtils.isEmpty(params.title) viewBinding.titleTv.text = params.title viewBinding.descTv.isGone = !TextUtils.isEmpty(params.title) &amp;&amp; TextUtils.isEmpty(params.desc) viewBinding.descTv.text = params.desc params.rightText?.let &#123; viewBinding.rightTv.visibility = View.VISIBLE viewBinding.rightTv.text = params.rightText viewBinding.rightTv.setOnClickListener &#123; if (params.autoDismiss) &#123; dismiss() &#125; params.rightClickListener?.onClick(it) &#125; &#125; ?: kotlin.run &#123; viewBinding.rightTv.visibility = View.GONE &#125; params.leftText?.let &#123; if (viewBinding.rightTv.visibility == View.GONE) &#123; viewBinding.leftTv.visibility = View.GONE viewBinding.rightTv.visibility = View.VISIBLE viewBinding.rightTv.text = params.leftText viewBinding.rightTv.setOnClickListener &#123; if (params.autoDismiss) &#123; dismiss() &#125; params.leftClickListener?.onClick(it) &#125; &#125; else &#123; viewBinding.leftTv.visibility = View.VISIBLE viewBinding.leftTv.text = params.leftText viewBinding.leftTv.setOnClickListener &#123; dismiss() params.leftClickListener?.onClick(it) &#125; &#125; &#125; ?: kotlin.run &#123; viewBinding.leftTv.visibility = View.GONE &#125; viewBinding.btnLl.isVisible = viewBinding.leftTv.isVisible || viewBinding.rightTv.isVisible viewBinding.leftTv.isSelected = params.selectedLeft viewBinding.rightTv.isSelected = !params.selectedLeft setOnDismissListener &#123; params.closeClickListener?.onClick(viewBinding.closeIv) &#125; &#125;&#125; 场景中，autoDismiss 为 true，所以点击按钮后会调 dismiss 方法。从实际情况来看，也确实消失了。只不过在 Activity 重新 onResume 的时候，它又展示出来了。因为是继承自 DialogFragment，怀疑是虽然调了 dialog dismiss 方法，但是这个 fragment 还在。通过如下代码打印相关日志： 12val fragment = supportFragmentManager.findFragmentByTag(&quot;HintDialog&quot;)LogUtils.e(&quot;TAG&quot;,&quot;fragment:$&#123;fragment?.isAdded&#125;,$&#123;fragment?.isDetached&#125;,$&#123;fragment?.isInLayout&#125;&quot;) 得到的结果是： true,false,false 而如果使用的是 AlertDialog，结果是： null,null,null 通过日志印证了猜测，因为场景中并没有用到 DialogFragment 的任何特性，于是直接改成了正常的 Dialog。修改之后问题便没有再出现了。但仍然有个问题困扰着我：都是使用 DialogFragment 的方式，为什么 JCommonDialog 会有问题，而系统的 AlertDialog 则不会有问题呢？起初怀疑 AlterDialog dismiss 有自己的逻辑，但是看到的源码中并没有覆写 dismiss 方法，最终调用的都是 Dialog 的 dismiss 方法，将 JCommonDialog 改成继承自 AlertDialog 问题依然存在。有没有可能是 style 引起的？可惜去掉 style 问题依然存在。然后看到 AlertDialog 的其他源码，使用的都是 AlertController 类，看到源码也没啥特别的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private final View.OnClickListener mButtonHandler = new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; final Message m; if (v == mButtonPositive &amp;&amp; mButtonPositiveMessage != null) &#123; m = Message.obtain(mButtonPositiveMessage); &#125; else if (v == mButtonNegative &amp;&amp; mButtonNegativeMessage != null) &#123; m = Message.obtain(mButtonNegativeMessage); &#125; else if (v == mButtonNeutral &amp;&amp; mButtonNeutralMessage != null) &#123; m = Message.obtain(mButtonNeutralMessage); &#125; else &#123; m = null; &#125; if (m != null) &#123; m.sendToTarget(); &#125; // Post a message so we dismiss after the above handlers are executed mHandler.obtainMessage(ButtonHandler.MSG_DISMISS_DIALOG, mDialogInterface) .sendToTarget(); &#125;&#125;;private static final class ButtonHandler extends Handler &#123; // Button clicks have Message.what as the BUTTON&#123;1,2,3&#125; constant private static final int MSG_DISMISS_DIALOG = 1; private WeakReference&lt;DialogInterface&gt; mDialog; public ButtonHandler(DialogInterface dialog) &#123; mDialog = new WeakReference&lt;&gt;(dialog); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case DialogInterface.BUTTON_POSITIVE: case DialogInterface.BUTTON_NEGATIVE: case DialogInterface.BUTTON_NEUTRAL: ((DialogInterface.OnClickListener) msg.obj).onClick(mDialog.get(), msg.what); break; case MSG_DISMISS_DIALOG: ((DialogInterface) msg.obj).dismiss(); &#125; &#125;&#125; 点击一个按钮后，会执行相应的逻辑，然后立马就发一个 dismiss 的 message，执行的也是 Dialog 自身的 dismiss 方法，问题应该不在 AlterDialog。于是尝试屏蔽 JCommonDialog 的代码，不停尝试。最终发现：去掉 setOnDismissListener 之后问题便不出现了。于是怀疑是这个代码导致的，给 AlterDialog 也设置了 setOnDismissListener 对比测试一下，结果弹窗消失了，但压根没回调 onDismiss。突然转念一想，这不是用的 DialogFragment 嘛，为什么一直停留在 AlertDialog 上去寻找问题呢？于是看了看 DialogFragment 代码，一下子就清晰了： 12345678910111213141516171819202122232425262728293031private void prepareDialog(@Nullable Bundle savedInstanceState) &#123; if (!mShowsDialog) &#123; return; &#125; if (!mDialogCreated) &#123; try &#123; mCreatingDialog = true; mDialog = onCreateDialog(savedInstanceState); // mShowsDialog might have changed in onCreateDialog, so we should only proceed // with setting up the dialog if mShowsDialog is still true if (mShowsDialog) &#123; setupDialog(mDialog, mStyle); final Context context = getContext(); if (context instanceof Activity) &#123; mDialog.setOwnerActivity((Activity) context); &#125; mDialog.setCancelable(mCancelable); mDialog.setOnCancelListener(mOnCancelListener); mDialog.setOnDismissListener(mOnDismissListener); mDialogCreated = true; &#125; else &#123; // Ensure that when mShowsDialog is set to false in onCreateDialog // that getDialog() returns null mDialog = null; &#125; &#125; finally &#123; mCreatingDialog = false; &#125; &#125;&#125; DialogFragment 中的 prepareDialog 方法，会将创建出来的 Dialog 的 setCancelable、setOnCancelListener、setOnDismissListener 改成 DialogFragment 自己的 listener： 123456789101112131415161718192021private DialogInterface.OnCancelListener mOnCancelListener = new DialogInterface.OnCancelListener() &#123; @SuppressLint(&quot;SyntheticAccessor&quot;) @Override public void onCancel(@Nullable DialogInterface dialog) &#123; if (mDialog != null) &#123; DialogFragment.this.onCancel(mDialog); &#125; &#125;&#125;;private DialogInterface.OnDismissListener mOnDismissListener = new DialogInterface.OnDismissListener() &#123; @SuppressLint(&quot;SyntheticAccessor&quot;) @Override public void onDismiss(@Nullable DialogInterface dialog) &#123; if (mDialog != null) &#123; DialogFragment.this.onDismiss(mDialog); &#125; &#125;&#125;; 使用 AlertDialog 的方式，因为是在 Builder 里调用 setOnDismissListener，这个监听在 DialogFragment 创建出 Dialog 之后，马上就进行覆盖了。而使用 JCommonDialog 的方式，是在 Dialog 的 onCreate 方法进行设置的，而这个方法很显然是在 DialogFragment 设置监听之后。也就是 DialogFragment 设置的监听，后面被 Dialog onCreate 方法里自己设置的监听给覆盖掉了，导致DialogFragment.this.onDismiss(mDialog)压根没有得到调用，那么 Fragment 相关的逻辑自然就丢失了。这也印证了前面去掉 setOnDismissListener 问题便不再出现了。因为解决问题的思路没搞对，所以排查起来浪费了不少时间，值得记录一下。后续使用 DialogFragment 时，一定要注意 setCancelable、setOnCancelListener、setOnDismissListener 几个方法的使用！","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android PAG 之初体验","date":"2023-04-26T06:51:42.000Z","path":"2023/04/26/pag/","text":"基于公司发展，App 需要配合不定期的进行一次大版本更新。改动主要是启屏页的产品宣传，以及应用主页的 UI 效果。说白了，动画越来越花哨，让人感觉起来更加“高大上”。已经经历过启屏的好几个版本更新了，每次更新都需要配合实现一大堆的动画效果，以及与设计师沟通切图细节等等，十分花费精力。这不，近期又来了一个启屏升级的需求，设计效果感觉都快和游戏差不多了，纯安卓也能做，但是很多光效、粒子等效果，最快的实现方式还是切图。在与设计师沟通的过程中，设计师提供了另一种实现思路：PAG。于是顺着这个思路研究了一下，最终觉得这个方案更好，在此记录一下。 PAG 简介 PAG 即 Portable Animated Graphics，是一套完整的动效工作流解决方案。目标是降低或消除动效相关的研发成本，能够一键将设计师在 AE（Adobe After Effects）中制作的动效内容导出成素材文件，并快速上线应用于几乎所有的主流平台。 是由腾讯开源的一套动效解决方案，和之前的 Lottie 相似，二者有各自的优劣势。网上关于多种动画方案的对比有很多，这里只摘录一个图： 集成gradle 依赖： 1implementation &#x27;com.tencent.tav:libpag:4.2.61&#x27; 混淆： 123# pag-keep class org.libpag.** &#123;*;&#125;-keep class androidx.exifinterface.** &#123;*;&#125; 使用： 1234pagFile = PAGFile.Load(getAssets(), &quot;demo.pag&quot;);pagView.setComposition(pagFile);pagView.setRepeatCount(0);pagView.play(); 非常简单明了了。 真实场景将 PAG 库集成之后，准备嵌入到真实项目里。需求是这样的：启屏先是执行一段版本动画，然后出来一些元素，元素全部显示完之后进行“弹一弹”动效。因为启屏页要做很多事情，也不确定什么时候做完，所以需要动画有循环播放的能力。假设启屏时间无限长，那就需要动画重复播放后面的“弹一弹”特效。起初尝试了用两个 PAG 结合 PAGComposition 实现： 1234567891011121314val pagFile1 = PAGFile.Load(assets, &quot;first.pag&quot;)val pagFile2 = PAGFile.Load(assets, &quot;second.pag&quot;)val composition = PAGComposition.Make(pagFile1.width(), pagFile1.height())pagFile1.setTimeStretchMode(PAGTimeStretchMode.None)pagFile1.setStartTime(0)pagFile1.setDuration(8000000)pagFile2.setTimeStretchMode(PAGTimeStretchMode.Repeat)pagFile2.setStartTime(8000000)pagFile2.setDuration(7200 * 100000 * 1000000L)composition.addLayer(pagFile1)composition.addLayer(pagFile2)binding.pagView1.composition = compositionbinding.pagView1.setRepeatCount(0)binding.pagView1.play() 启屏动画前八秒是第一段，后八秒是重复动效，所以从后八秒开始，需要循环播放。但研究下来使用 PAGComposition 设置循环播放好像只能通过 setDuration 来。于是将 pageFile2 的 duration 设置成尽可能大。调试下来，发现 first.pag 切到 second.pag 会有个短暂的“卡顿”，感受很明显。然后尝试准备用两个 PAGView 来实现： 12345678910111213141516val pagFile1 = PAGFile.Load(assets, &quot;first.pag&quot;)val pagFile2 = PAGFile.Load(assets, &quot;second.pag&quot;)var startTime = System.currentTimeMillis()binding.pagView1.addListener(object : PAGViewListener &#123; override fun onAnimationEnd(p0: PAGView?) &#123; binding.pagView1.visibility = View.GONE binding.pagView2.visibility = View.VISIBLE binding.pagView2.play() &#125;&#125;)binding.pagView1.composition = pagFile1binding.pagView1.play()binding.pagView2.composition = pagFile2binding.pagView2.flush()binding.pagView2.setRepeatCount(0) 第一个 pagView 动画执行完之后消失，第二个 pagView 显示然后开始无限循环播放。但是很可惜，测试下来，仍然会有切换的“卡顿”感受。继续研究了一阵，没有发现很好的办法，逛论坛时发现可以通过 setProgress 来控制动画进度，于是转变了思路：使用一个 PAG 动画，当动画执行完之后，手动设置进度到 0.5。代码如下： 12345678910val pagFile = PAGFile.Load(assets, &quot;total.pag&quot;)binding.pagView.composition = pagFilebinding.pagView.setRepeatCount(0)binding.pagView.addListener(object : PAGImageViewListener &#123; override fun onAnimationRepeat(p0: PAGImageView?) &#123; binding.pagView.pagFile.progress = 0.5 &#125;&#125;)binding.pagView.composition = pagFilebinding.pagView.play() 测试下来，感受不到“卡顿”了。虽然动画从最后一帧，一下子切到一半进度的那一帧，有些许不连贯，但是已经达到期望效果了。 优化不论使用一个 PAG 还是两个 PAG 方案时，都发现一个问题：前八秒的动画执行到某一刻，总会很明显的卡一下。前面八秒的动画设计到品牌宣传，必须得优化好。通过 addPAGFlushListener，发现有时候刷新间隔竟然超过了 200ms。于是将当前进度也打出来，发现总是固定的 0.21 左右的进度时，flush 间隔会比较久，导致感受到卡顿。 1234567891011121314binding.pagView.addPAGFlushListener(object : PAGView.PAGFlushListener &#123; override fun onFlush() &#123; if (flushTime == 0L) &#123; flushTime = System.currentTimeMillis() &#125; else &#123; val current = System.currentTimeMillis() val tmp = current - flushTime if (tmp &gt; 100) &#123; Log.e(&quot;PAG&quot;, &quot;progress:&quot; + binding.pagView.progress + &quot;，duration:&quot; + tmp) &#125; flushTime = current &#125; &#125;&#125;) 观察 PAG 动画，大概就是 0.2 进度时，会展示全屏的背景动画。怀疑是全屏尺寸(1920*1080)太大，导致内存一下子上涨，从而引起卡顿。那能不能提前将这一帧缓冲好，等缓冲好了再从头开始播放动画呢？当然是可以的。只是设置缓冲进度时，View 必须可见，那么就必须搞个黑色背景盖在上面了。当缓冲完事开始播放动画时，再将这个黑色背景移除掉。最终代码如下： 12345678910111213141516171819202122val pagFile = PAGFile.Load(activity.assets, &quot;splash.pag&quot;)binding.pagView.composition = pagFilebinding.pagView.progress = 0.21binding.pagView.addPAGFlushListener(object : PAGView.PAGFlushListener &#123; override fun onFlush() &#123; binding.pagView.removePAGFlushListener(this) binding.pagView.addPAGFlushListener(object : PAGView.PAGFlushListener &#123; override fun onFlush() &#123; binding.maskView.visibility = View.GONE binding.pagView.removePAGFlushListener(this) &#125; &#125;) binding.pagView.progress = 0.0 binding.pagView.addListener(object : SimplePAGViewListener() &#123; override fun onAnimationRepeat(p0: PAGView?) &#123; binding.pagView.progress = 0.5 &#125; &#125;) binding.pagView.setRepeatCount(0) binding.pagView.play() &#125;&#125;) 测试下来效果还不错，产品、设计、研发都比较满意，几天的辛苦没有白费。附上一个测试视频：Your browser does not support the video tag.另外有个点需要注意下，PAG 文件是有分辨率的，当 View 宽高和这个分辨率不一致时，可能会有黑边。项目设备分辨率是固定的 1920*1080，但是当导航栏出现时，会占用一定的高度，导致左右有黑边。于是给启屏页设置了这样的 flag： 123window.decorView.apply &#123; systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION&#125; 这样的话导航栏将盖在 activity 之上，不会影响 activity 的宽高了。 总结通过 PAG 方案实现了新的启屏效果，后续若有类似的版本升级，只需要设计师设计新的 PAG 文件即可，达到了一劳永逸的效果。当然也可以直接使用视频实现，但是视频占用空间会更大，也没有 PAG 这样代码控制灵活。这是第一次使用 PAG，在研究的过程中，越来越佩服这样的技术了，极大的改善了动画交付效果。保持 open，虚心学习吧！ 参考 PAG 官网 PAG 论坛 PAG Github PAG 安卓文档 PAG 动效方案使用总结","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"录屏权限 clone 使用","date":"2023-03-07T07:55:21.000Z","path":"2023/03/07/screen-record-2/","text":"在关于录屏权限的问题一文中，通过与 Launcher 的结合，实现了权限无感自动申请的功能。这没过几天，就有反馈说有问题：开始录屏的时候会有权限申请弹窗一闪而过。最初怀疑是平板性能差，会打开一个 activity，然后马上消失，由于性能问题导致这样的“一闪而过”。但研究下来发现这个怀疑不成立。通过调试知道了MediaProjectionManager.createScreenCaptureIntent()返回的 intent 对应的 activity 是 MediaProjectionPermissionActivity。于是查看其代码，在 onCreate 方法中有这样的片段： 1234567891011try &#123; if (mService.hasProjectionPermission(mUid, mPackageName)) &#123; setResult(RESULT_OK, getMediaProjectionIntent(mUid, mPackageName)); finish(); return; &#125;&#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;Error checking projection permissions&quot;, e); finish(); return;&#125; 即如果有权限，则直接设置 RESULT_OK 并且 finish 掉。如果没权限，则走到下面了： 1234567891011121314151617181920View dialogTitleView = View.inflate(this, R.layout.media_projection_dialog_title, null);TextView titleText = (TextView) dialogTitleView.findViewById(R.id.dialog_title);titleText.setText(dialogTitle);mDialog = new AlertDialog.Builder(this) .setCustomTitle(dialogTitleView) .setMessage(dialogText) .setPositiveButton(R.string.media_projection_action_text, this) .setNegativeButton(android.R.string.cancel, this) .setOnCancelListener(this) .create();mDialog.create();mDialog.getButton(DialogInterface.BUTTON_POSITIVE).setFilterTouchesWhenObscured(true);final Window w = mDialog.getWindow();w.setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);w.addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);mDialog.show(); 会展示一个弹窗，这个弹窗便是权限申请的弹窗。并且这个弹窗默认是可以外部点击消失的。所以这个逻辑便是这样的：如果有权限则直接返回结果，是不会弹窗的。如果弹窗了，则一定是判断没权限。那为什么这个弹窗出来后马上就消失了？起初怀疑发送模拟点击坐标不对，导致点到了外面的部分，弹窗便消失了。可后面检查代码，压根就没有发送模拟点击的广播（只会在启屏的时候发送一次广播，真正录制的时候不会发送）。可这个弹窗为什么就消失了呢？排查了很久也没找到原因，而且办公室无法复现，这就很尴尬了，可问题还是需要解决的。由上面的分析可知，肯定是打开了权限申请的 activity 才会导致弹窗展示出来。那如果我不申请权限了呢？利用上文末尾说到的 clone 的方式。于是改造了一下代码，在启屏页申请权限，然后将 intent 保存起来，真正要录屏时再使用 clone 方法重新生成一个 intent 传入进去。 1234567891011121314151617181920212223public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode == Activity.RESULT_OK) &#123; Manager.setMediaProjectionCloneData(data); &#125;&#125;fun startRecord() &#123; if (Manager.mediaProjectionCloneData == null) &#123; // 正常申请权限... &#125; else &#123; realStart(Manager.mediaProjectionCloneData!!.clone() as Intent) &#125;&#125;private fun realStart(data: Intent) &#123; mp?.stop() mp = mediaProjectionManager!!.getMediaProjection(Activity.RESULT_OK, data) virtualDisplay = mp?.createVirtualDisplay( &quot;ScreenCapture&quot;, videoWidth, videoHeight, metrics.densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, mediaRecorder?.surface, null, null ) mediaRecorder?.start()&#125; 注意每次 mp 的创建，使用完之后一定要注意调用 stop 方法，不然下次再使用时会导致崩溃： 123456java.lang.IllegalStateException: Cannot start already started MediaProjection at android.os.Parcel.readException(Parcel.java:1692) at android.os.Parcel.readException(Parcel.java:1637) at android.media.projection.IMediaProjection$Stub$Proxy.start(IMediaProjection.java:140) at android.media.projection.MediaProjection.&lt;init&gt;(MediaProjection.java:59) at android.media.projection.MediaProjectionManager.getMediaProjection(MediaProjectionManager.java:102) 字面意思很明显了，所以用完一定要记得 stop，下次才能继续 clone 进行使用。这种方式需要至少同意一次录屏权限，如果没有 Launcher 的帮助，做不到自动授权的情况下，在 App 启动的时候只申请一次问题应该也不大，后续使用就利用 clone 的方式即可。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"关于录屏权限的问题","date":"2023-02-28T07:17:44.000Z","path":"2023/02/28/screen-record-1/","text":"在Android 倍速压缩视频时长中，会先录屏然后对视频进行处理，录屏需要通过调用MediaProjectionManager.createScreenCaptureIntent()申请权限，这时会弹出系统的权限申请弹窗，用户可以选择同意或者拒绝，同时有不再询问的选项，就像这样： 在手机端这样的场景很常见，用户操作成本也比较低，大多数用户会选择同意进行后续流程。但在当前项目场景中，App 是运行在车载平板上的。App 启动后，通过语音指导用户进行教学，当然也有一些交互提供其他的功能。录屏是在练习项目开始的时候发起权限申请，在这个场景下，学员是全神贯注开着车准备练习的，若还需要他看屏幕弹窗去点击授权，这个体验会相当割裂，同时会有一定的安全隐患。 那有没有什么办法可以跳过这个权限申请，或者自动授权呢？通过一定时间的调研，发现这个权限是跳不过去的，自从 Android 6.0 以来，系统对权限的控制便越发严格、精准，自然是不允许这种不申请权限就使用录屏功能的。否则的话随便一个 App 启动后就开始录屏，用户在干什么全都一目了然。 那么问题便只能聚焦于如何自动授权了。如果能模拟用户点击，或许就能实现自动授权了。最初想到的便是无障碍服务，通过无障碍服务可以模拟做一些事情，但是研究后发现：也需要申请权限，或者手动去设置页面进行设置，这不是恶性循环了嘛，只能放弃。继续研究模拟点击，发现如下代码可以尝试： 123Instrumentation ins = new Instrumentation();ins.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(),SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, 200, 500, 0));ins.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(),SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, 200, 500, 0)); 尝试之后发现两点： 只能在非主线程里调用； 必须拥有系统权限才可以。 第一点好说，第二点，系统权限？若有所思地思考着的时候，旁边同事来了一句：用 Launcher 试试？因为项目对接车载平板，平板都是由合作供应商生产，同时接入了自己的 Launcher，便于管理。而 Launcher 很自然的就有系统权限。于是事情就简单了：App 将需要点击的事件封装好，通过广播发送出去。Launcher 接受广播执行点击代码即可。代码很简单： 12345678910111213141516171819202122232425262728293031/** * 给 launcher 发送模拟点击的事件 */class ClickEventModel : Serializable &#123; var action: Int = 0 var x: Float = 0f var y: Float = 0f constructor() constructor(action: Int, x: Float, y: Float) &#123; this.action = action this.x = x this.y = y &#125;&#125;object LauncherBroadcastSender &#123; const val action = &quot;android.launcher.action&quot; const val CLICK_EVENT = 1000 // 点击事件 fun send(eventId: Int, model: Any) &#123; val intent = Intent(action) intent.putExtra(&quot;data&quot;, JSON.toJSONString(model)) intent.putExtra(&quot;package&quot;, getPackageName()) intent.putExtra(&quot;eventId&quot;, eventId) MucangConfig.getContext().sendBroadcast(intent) &#125;&#125; 通过截屏或者开发者选项-指针位置获取权限申请弹窗中不再询问、立即开始按钮的坐标，然后执行广播发送： 1234567891011121314151617@JvmStaticfun sendClickBroadCast() &#123; MainScope().launch &#123; delay(500) sendBroadcast(MotionEvent.ACTION_DOWN, 515f, 527f) sendBroadcast(MotionEvent.ACTION_UP, 515f, 527f) sendBroadcast(MotionEvent.ACTION_DOWN, 1418f, 570f) sendBroadcast(MotionEvent.ACTION_UP, 1418f, 570f) &#125;&#125;private fun sendBroadcast(action: Int, x: Float, y: Float) &#123; LauncherBroadcastSender.send( LauncherBroadcastSender.CLICK_EVENT, ClickEventModel(action, x, y) )&#125; delay(500) 是等着系统弹窗显示出来，不然弹窗还没出来广播就发过去，就是无效点击了。因为是定制平板，按钮的坐标点也是固定的，所以先写死了。Launcher 接受广播执行点击的代码就更简单了，参考上面sendPointerSync()片段。经测试，肉眼几乎看不到权限申请的弹窗了，同时也能拥有权限进行录屏。站在 Launcher 的肩膀上，实现了“不可能实现的任务”。 题外话MediaProjectionManager.createScreenCaptureIntent()方法是返回一个 Intent，然后通过 startActivityForResult 的方式进行调用，那么就会涉及到 Activity 的页面切换。若当前页面有 onResume、onPause 的处理逻辑，得考虑一下 Activity 切换可能导致的异常。 123456789101112131415/** * Returns an Intent that &lt;b&gt;must&lt;/b&gt; be passed to startActivityForResult() * in order to start screen capture. The activity will prompt * the user whether to allow screen capture. The result of this * activity should be passed to getMediaProjection. */public Intent createScreenCaptureIntent() &#123; Intent i = new Intent(); final ComponentName mediaProjectionPermissionDialogComponent = ComponentName.unflattenFromString(mContext.getResources().getString( com.android.internal.R.string .config_mediaProjectionPermissionDialogComponent)); i.setComponent(mediaProjectionPermissionDialogComponent); return i;&#125; 这个权限申请的 Activity 是 MediaProjectionPermissionActivity。通过如下代码设置权限的： 12345678private Intent getMediaProjectionIntent(int uid, String packageName) throws RemoteException &#123; IMediaProjection projection = mService.createProjection(uid, packageName, MediaProjectionManager.TYPE_SCREEN_CAPTURE, false /* permanentGrant */); Intent intent = new Intent(); intent.putExtra(MediaProjectionManager.EXTRA_MEDIA_PROJECTION, projection.asBinder()); return intent;&#125; 所以其实返回的就是一个 intent，通过这个 intent 获取 MediaProjection。在 stackoverflow 上，有针对 intent 进行 clone 保存的，这样当用户没有勾选“不再询问”时，也可以通过这个 intent 跳过权限申请，实现录屏功能。可以参考How do I get MediaProjectionManager without disturbing the current foreground process, except to ask for permission?","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"使用 Dialog 的两个问题","date":"2023-02-21T08:54:17.000Z","path":"2023/02/21/dialog-1/","text":"近期在使用 Dialog 的过程中，出现过两个问题，也记录一下。 TextureView当 Dialog 布局有 TextureView 时，运行报错： 123456java.lang.UnsupportedOperationException: TextureView doesn&#x27;t support displaying a background drawable at android.view.TextureView.setBackgroundDrawable(TextureView.java:315) at android.view.View.setBackground(View.java:18124) at android.view.View.&lt;init&gt;(View.java:4573) at android.view.View.&lt;init&gt;(View.java:4082) at android.view.TextureView.&lt;init&gt;(TextureView.java:159) 说是 TextureView 不支持设置 background。可布局文件里压根就没设置 background。于是尝试将所有 View 的 background 全部去掉，仍然崩溃。然后尝试把 TexureView 从 xml 去掉，能正常运行。所以肯定还是 TextureView 的问题。Google 了很久，也没找到问题所在，主要是很“无厘头”的崩溃，也没什么关键字。后面突然灵光一身，Dialog 会有 style，有没有可能是 style 导致的呢？使用的 style 是这样的： 1234567891011&lt;style name=&quot;dialog__style&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:background&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowSoftInputMode&quot;&gt;stateHidden|adjustResize&lt;/item&gt;&lt;/style&gt; 于是去掉 style，确实就没崩溃了。然后加上 style，挨个屏蔽属性，最终定位到是 android:background 属性导致崩溃的，猜测是这个属性会迭代 Dialog 中的 view 挨个去设置 background 导致的。所以，在 Dialog 中使用 TextureView 时，Dialog 一定不要设置 android:background 的 style。 VideoView在 Dialog 中使用 VideoView 时，播放视频感觉会是“很暗”的感觉。查阅资料最终发现 VideoView 是继承自 SurfaceView 的，Surface 是纵深排序(Z-ordered)的，很有可能就是这个排序导致的。于是调用setZOrderOnTop(true)果然就好了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 倍速压缩视频时长","date":"2023-02-21T07:00:19.000Z","path":"2023/02/21/video-record/","text":"最近有个“精彩时刻”的需求，记录学员精彩练车瞬间。当学员此次项目练习过程中，没有出现任何错误，则定义为“精彩时刻”。需要将学员从项目开始到结束行走轨迹记录下来，输出一个视频。然后再将视频时长压缩到 20 秒，同时附加一个音频上去，生成最终的视频。这个时候，写博客的好处就来了。参考之前写的几篇文章录制仿 Keep 轨迹动画视频、无声视频合成音频、无声视频合成音频（续），记录了关于录屏、合成音频的代码，可以直接参考来用。那么剩下的问题便是视频时长压缩到 20 秒了，通过调研发现了两种方式，记录一下。 VideoProcessorVideoProcessor 是在 Github 找到的一个库，通过 README 了解到对相关功能进行了高度封装，示例如下： 123456789101112131415VideoProcessor.processor(context) .input(inputVideoPath) // .input(inputVideoUri) .output(outputVideoPath) //以下参数全部为可选 .outWidth(width) .outHeight(height) .startTimeMs(startTimeMs)//用于剪辑视频 .endTimeMs(endTimeMs) //用于剪辑视频 .speed(speed) //改变视频速率，用于快慢放 .changeAudioSpeed(changeAudioSpeed) //改变视频速率时，音频是否同步变化 .bitrate(bitrate) //输出视频比特率 .frameRate(frameRate) //帧率 .iFrameInterval(iFrameInterval) //关键帧距，为0时可输出全关键帧视频（部分机器上需为-1） .progressListener(listener) //可输出视频处理进度 .process(); 若要进行倍速播放，直接设置一下 speed 即可，还是挺简洁的。于是将项目 clone 下来，把 demo 跑起来，运行倍速播放出现了崩溃，后面定位问题是视频旋转角度、比特率属性拿不到，然后强转 Integer 崩溃了： 123456789101112131415/** * 支持裁剪缩放快慢放 */public static void processVideo(@NotNull Context context, @NotNull Processor processor) throws Exception &#123; MediaMetadataRetriever retriever = new MediaMetadataRetriever(); processor.input.setDataSource(retriever); int originWidth = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)); int originHeight = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)); int rotationValue = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION)); int oriBitrate = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE)); int durationMs = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)); ...&#125; 因为项目用不到旋转角度，就直接写成 0 了，至于 bitRate 设置了一个默认值： 123456int rotationValue = 0;int oriBitrate = DEFAULT_BITRATE;String bitRate = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE);if (bitRate != null) &#123; oriBitrate = Integer.parseInt(bitRate);&#125; 开始 demo 可以跑起来了，也确实可以倍速压缩，只不过时长有点久，不过目前还没找到更快的其他方案。后面跟进源代码，发现这个倍速压缩原理就像画画一样，本来 1 秒画一张画，现在改成 2 秒画一张，便实现了倍速播放。核心代码如下： 12345678910111213141516171819202122232425mDecoder.releaseOutputBuffer(outputBufferIndex, doRender);if (doRender) &#123; boolean errorWait = false; try &#123; mOutputSurface.awaitNewImage(); &#125; catch (Exception e) &#123; errorWait = true; CL.e(e.getMessage()); &#125; if (!errorWait) &#123; if (videoStartTimeUs == -1) &#123; videoStartTimeUs = info.presentationTimeUs; CL.i(&quot;videoStartTime:&quot; + videoStartTimeUs / 1000); &#125; mOutputSurface.drawImage(false); long presentationTimeNs = (info.presentationTimeUs - videoStartTimeUs) * 1000; if (mSpeed != null) &#123; presentationTimeNs /= mSpeed; &#125; CL.i(&quot;drawImage,setPresentationTimeMs:&quot; + presentationTimeNs / 1000 / 1000); mInputSurface.setPresentationTime(presentationTimeNs); mInputSurface.swapBuffers(); break; &#125;&#125; 通过 mSpeed 改变 presentationTimeNs，改变画画的时间间隔，然后两个 surface 一个写，一个读，从而生成倍速视频。原理还是挺简单的，而且基于原生 MediaCodec 实现，没有额外引入复杂的三方库，体积可控。 ffmpeg说到音视频处理，那么必然会想到 ffmpeg。只是 ffmpeg 功能过于强大，占包体积自然也更大，入手难度也更高。借着这次需求开发，也正好可以了解了解 ffmpeg。在 Github 上同样找到了编译好的库ffmpeg-android-java。这个库提供两个个基本方法： 12loadBinary(FFmpegLoadBinaryResponseHandler ffmpegLoadBinaryResponseHandler) throws FFmpegNotSupportedExceptionexecute(String cmd, FFmpegExecuteResponseHandler ffmpegExecuteResponseHandler) throws FFmpegCommandAlreadyRunningException 一个加载库，一个执行 ffmpeg 的指令。将代码跑起来，可以自行输入 ffmpeg 指令，然后返回相应的结果。调研下来最终可以执行的指令是这样的： 1ffmpeg -i /sdcard/DCIM/intput.mp4 -threads 5 -preset medium -b:v 633k -filter:v setpts=0.5*PTS -r 33 /sdcard/DCIM/output.mp4&quot; -i 之后跟着的是输入路径； -threads 5 是多线程数量； -preset medium 是指压缩速度，有 ultrafast、superfast、fast、medium、slower、veryslow 等等一些档次，不同速度对应着不同的压缩质量，同时也会影响压缩的耗时，速度越快，视频越模糊，压缩耗时越短； -b:v 633k 是设置视频轨道的比特率； -filter:v setpts&#x3D;0.5*PTS 是设置 2 倍速，注意不要加任何引号； -r 是设置视频的帧率，放到前面设置好像没什么用，后面挪到 output path 前面就生效了。还有很多其他的指令，可以在 ffmpeg 官网查询。 小结通过两种方式，都实现了想要的效果，考虑到包体积大小、使用简易程度，最终还是选择了 VideoProcessor 方案。后面若有更复杂的视频需求，可能才是 ffmpeg 出马的时候。最后附上一个最终效果的视频：Your browser does not support the video tag.","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"不平凡的 2022","date":"2023-01-19T06:35:29.000Z","path":"2023/01/19/summary-2022/","text":"今天是今年最后一天上班了，坐在工位上早已无心上班，有什么事情年后再说吧。 回顾这一整年，最大的收获莫过于我的小棉袄了。这一路走来，中间的艰辛与不易，懂的都懂。也正是经历了这些，才越发懂得父母的伟大。下面就记个流水账，记录下这一年是怎么过的。2月底，老婆怀孕了。为了保胎，找了一位老中医，吃了一个月中药，真是辛苦老婆了。中医说老婆内火旺，不要吃牛、羊、鸡、虾，好家伙好歹还给咱剩了个猪、鱼能吃，也不至于太拤的慌。同时也让老婆辞职了，专心养胎。这俩月哪也没去，也没什么社交了，主要就在小区里活动。安全度过前面三个月，后面就稍微好些了，按照医院要求定期孕检即可。NT、无创、糖耐、大小排畸都正常，心里石头落下一大块。然后回老家时抽空看了下月子中心，本来我没想到这个的，因为也没经历过，但是老妈提了一句，索性决定去看看。在老家看了三家月子中心，然后挑了一家感觉最好的，也是最贵的（但也比武汉便宜不少），将相关的细节都确定了一下就来武汉了。还因为这个月子中心和老爸有过一次不愉快，只是个小插曲了。再到后面就是快要生产了，定期检查更勤了，一周一次。临近生产，将待产包全部整理好，产褥垫、刀纸、一次性内裤等等，都用箱子、手提包整理好，就等发动信号了。24号晚上老婆说有点发动的感觉，但没有着急，等到了早上和老妈说了，老妈说赶紧去医院，我也是有点担心就来医院了。那时还在查核酸，要入院陪护还得做核酸，在等核酸结果的间隙吃了个午饭，下午来医院办理入住。好家伙，相对实惠的单人间全没了，只剩三人间和1280&#x2F;天的单间，我看着我、老妈、我老婆这三人，挤三人间可太难了，于是咬咬牙定了1280的单间。不得不说，贵就是好啊（老康至理名言），这个单间是产房一体的，到时候就直接在房间里生产。房间也够大，1张床1张沙发，我和老妈可以更好地休息。这第一天没啥动静，我有点犯愁了，这小家伙要是再拖几天，老爸这钱包可兜不住啊。第二天开始打催产素，到下午5点也没有发动的迹象。第三天了继续打，终于有感觉快要发作了。这时候接产护士就直接坐在房间里了，时刻观察。然后将各种接产器械推了进来，说就快要生了。下午2点开始安排无痛，无痛打完老婆就开始要生了。我穿着防护服就站在旁边，陪着老婆，给她擦汗，给她喝水，给她打气。老婆也很努力，经过2个多小时的奋战，10月27日下午4点23分，我的小棉袄诞生了！老婆辛苦了！！哇哇哇的哭，心窝子一下子就暖了。随后2天就是正常的医护阶段，每天检查下老婆、宝宝的状态，也没啥其他事情了。我这第一次当爸爸，也是在慢慢适应，学着泡奶粉，给娃喂，主要是睡不好，感觉熬得有点辛苦。在快出院的时候，月子中心说因为疫情也不能派车来接，只能尝试自己开车回去了。此时正是疫情爆发期，到处都查得挺严的，还好我们在医院也是每天做单管核酸，归程比较顺利，有惊无险到了月子中心。哇，终于解放了。全天我和老婆都可以不管娃了（理论上），想看看就看看，想睡觉就睡觉，舒坦。老婆在月子中心度过了28天，有了这样的一个过渡期，后面就能更好的习惯照顾宝宝了。我在月子中心陪护到产假结束，就得回去上班了，毕竟家里得有人挣钱不是。体验过这么一回之后，不得不说，月子中心这钱也花得值！期间也把宝宝的出生证明、户口、医保卡都搞定了，也花时间研究了下保险，把我自己的保险和宝宝的报险也都买了（老婆的已经有了），后面就是努力挣钱了。再就到了12月，国家宣布放开新冠疫情防控，然后就一下子炸开了。之前周围的人没有得新冠的，一放开之后，几乎身边的人全阳了，我这一家人也不例外。应该是12月份给宝宝办满月酒的时候染上的。哎，该来的都会来，躲不过去的。还好现在基本都恢复得差不多了。一眨眼，宝宝马上就快满三个月了，也马上就要过新年了，时间过得可真快呐~ 流水账就这样写完了，相信2022年很多人都很难，防了11个月的新冠，然后12月阳了，有点哭笑不得的辛酸。于我而言，刚出生的小棉袄便是那一盏灯，照亮了我的整个2022。当然也会担心宝宝感染新冠，包括后面打疫苗，就感觉从宝宝出生，这颗心便不再完整的属于自己了，它总会分出一些怕宝宝这里难受，那里不舒服。同时我也晋升成了爸爸，有了更多的责任与担当，还好我肩膀够厚实，我会抗住的，也能抗住的。emmm…至于工作，今年的重心基本就不在工作上了，就正常表现，无功无过，到后面几个月也是因为宝宝的原因，都没怎么写博客了，后面会逐渐恢复，技术人对技术总归需要一点追求。新的一年，继续加油吧！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"onDestroy 没有立刻执行","date":"2022-08-31T10:09:29.000Z","path":"2022/08/31/anr-1/","text":"做了个需求：给按钮加个倒计时，时间到了之后触发点击事件（结束当前页面，打开另一个页面），当然也可以手动点击。代码是这样写的： 123456789101112131415161718192021viewBinding.jumpTv.setOnClickListener &#123; LoginActivity.launch(it.context) finish()&#125;job = lifecycleScope.launch &#123; flow &#123; for (i in 5 downTo 1) &#123; emit(i) delay(1000) &#125; &#125;.onStart &#123; viewBinding.jumpTv.text = &quot;检测完成(5s)&quot; &#125;.onCompletion &#123; cause -&gt; if (cause == null) &#123; viewBinding.jumpTv.performClick() &#125; &#125;.collect &#123; viewBinding.jumpTv.text = &quot;检测完成($&#123;it&#125;s)&quot; &#125;&#125; 感觉挺简单的一个需求，代码也比较清晰，利用协程的 flow 实现，相当好用。但是后面却发现一个问题：假设倒计时到两秒了，手动点击按钮，打开了新页面。然后等待约两秒，又会打开一次这个页面。很明显，第二次打开的页面是由这个 job 触发的：倒计时结束了。可代码里用的已经是 lifecycleScope 了，按道理 activity 执行 finish 之后，这个 job 就会失效了，为什么还会执行呢？起初我查找了很久的资料，查阅 lifecycleScope 的相关特性，没发现什么问题。后面想了一下，先在 onDestroy 里打一个日志吧。结果发现 activity 执行 finish 之后，并没有很快的调用 onDestroy，等了差不多有十秒钟才执行，导致 lifecycleScope 一直是有效的状态，job 就会一直运行。那么问题就很简单了：activity 执行 finish 之后，为什么 onDestroy 没有立刻执行？这个问题比较普遍了，在网上一搜一大把，最终的结论大概就是：主线程消息队列中有源源不断的同步消息屏障，让执行 onDestroy 的 IdleHandler 没有机会执行。但是会有一个十秒的兜底，也就是最多会延迟十秒就会执行 onDestroy。所以现在来排查一下启动的页面：LoginActivity。经过排查，发现 LoginActivity 确实会有动画效果： 1234567891011121314151617181920212223242526private fun startAnimation() &#123; if (!rotateAnimator.isStarted) &#123; rotateAnimator.interpolator = LinearInterpolator() rotateAnimator.repeatCount = ValueAnimator.INFINITE rotateAnimator.setTarget(binding.circleIv) rotateAnimator.addUpdateListener &#123; binding.circleIv.rotation = (it.animatedValue as Int).toFloat() &#125; rotateAnimator.start() &#125; scanAnimator?.apply &#123; if (!isStarted) &#123; interpolator = LinearInterpolator() repeatCount = ValueAnimator.INFINITE setTarget(binding.scanView) addUpdateListener &#123; val height = it.animatedValue as Int val lp = binding.scanView.layoutParams lp.height = height binding.scanView.layoutParams = lp &#125; start() &#125; &#125; binding.scanView.isVisible = true&#125; 将 LoginActivity 换成一个其他的简单 Activity，onDestroy 确实就很快的执行了。显然不能通过改切换的页面来规避这个问题，只能把 job 手动 cancel 了： 12345viewBinding.jumpTv.setOnClickListener &#123; job?.cancel() LoginActivity.launch(it.context) finish()&#125; 以后碰到类似问题，一定要注意打开的页面是否有动画效果。后面有时间还得重新看一波 Handler 的消息发送机制啊~ 参考Android 在执行完finish()方法后为什么没有立即执行onDestroy()Activity.onStop() 延迟10秒？检测、定位、修复它！","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Usb 端口在文件系统中的 index 它果然变化了...","date":"2022-07-18T08:18:09.000Z","path":"2022/07/18/usb-1/","text":"在之前的一篇文章Usb 摄像头绑定中，想要将实际 Usb 端口绑定到具体业务上，利用 Usb 端口在文件系统中的 index 来做的绑定。在外发的设备上暂时没有发现 index 发生变化的情况，所以就没处理了。但是最近还是有反馈说，设备重启后绑定关系就错了，应该就是 index 发生变化了。哎，该趟的坑一个都跑不掉啊。正如「墨菲定律」：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。 那么还能采用什么方式来做这种绑定呢？查阅很多资料也找不到相关的讯息，只能自己慢慢研究了。通过查看系统文件，发现了一个可能用来做唯一标识的属性：serial，就像这样：也不能确定是否能好使，只能先用了再说，看后续有没有反馈。相关代码由其他同事实现，本文摘录一下，方便后面使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * @param serial：serial 文件中读到的字符串 */data class UsbSerial(val devBus: Int, val serial: String)/** * 获取设备 Usb 的设备序列号，并初始化默认绑定关系 */private fun initUsbSerialBind(context: Context) &#123; usbSerialList.clear() MainScope().launch &#123; withContext(Dispatchers.IO) &#123; val serialList = UsbUtils.getAllSerial() JLog.normal(&quot;initUsbSerialBind : $&#123;JSON.toJSONString(serialList)&#125;&quot;) var devBusList = UsbUtils.getDevBusByDriver() if (devBusList.isEmpty()) &#123; devBusList = UsbUtils.getDevBus() JLog.normal(&quot;getDevBusByVendor : $&#123;JSON.toJSONString(devBusList)&#125;&quot;) &#125; val oldPorts = File(&quot;/dev/bus/usb&quot;).listFiles()?.map &#123; it.absolutePath &#125;?.sorted() var index = 0 CameraIntent.cacheList.forEach &#123; intent -&gt; //1.已近绑定过了就跳过 if (!intent.isSerialNoBind()) return@forEach //2.设置绑定关系 if (intent.getDevice() != -1) &#123; //2.1.检查老的绑定关系，并转换成新的绑定 oldPorts?.getOrNull(intent.getDevice())?.let &#123; name -&gt; serialList.find &#123; it.devBus == UsbUtils.getDevBusByName(name) &#125;?.let &#123; JLog.normal(&quot;旧转新绑定关系-$intent: \\nold: $&#123;name&#125;\\nnew: usb$&#123;it.devBus&#125;-&gt;$&#123;it.serial&#125;&quot;) intent.bindSerial(it.serial) &#125; &#125; &#125; else if (devBusList.isNotEmpty()) &#123; //2.2.从未绑定过则设置新的默认绑定关系 serialList.find &#123; it.devBus == devBusList.getOrNull(index % devBusList.size) &#125;?.let &#123; JLog.normal(&quot;设置默认绑定关系-$intent: \\nusb$&#123;it.devBus&#125;-&gt;$&#123;it.serial&#125;&quot;) intent.bindSerial(it.serial) &#125; index++ &#125; &#125; serialList &#125;.let &#123; usbSerialList.addAll(it) &#125; usbMonitor = USBMonitor(context, this@UsbCameraManager) usbMonitor?.register() &#125;&#125;@WorkerThreadfun getAllSerial(): List&lt;UsbSerial&gt; &#123; val driverBus = getDevBusByDriver() val list = HashMap&lt;String, UsbSerial&gt;() File(&quot;sys/bus/usb/devices&quot;).listFiles &#123; _, name -&gt; name.contains(&quot;usb&quot;) &#125;?.forEach &#123; val serail = kotlin.runCatching &#123; File(it, &quot;serial&quot;).readLines().getOrNull(0) &#125;.getOrNull() val devBus = Regex(&quot;usb(.+)&quot;).find(it.name)?.groupValues?.getOrNull(1)?.toIntOrNull() if (serail != null &amp;&amp; devBus != null) &#123; if (list.containsKey(serail)) &#123; if (driverBus.contains(devBus)) &#123; list[serail] = UsbSerial(devBus, serail) &#125; &#125; else &#123; list[serail] = UsbSerial(devBus, serail) &#125; &#125; &#125; return list.values.sortedBy &#123; it.devBus &#125;&#125;/** * 查找摄像头usb驱动所在的设备 */@WorkerThreadfun getDevBusByDriver(): List&lt;Int&gt; &#123; val usbDriver = File(&quot;sys/bus/usb/drivers/usb&quot;) val usbList = HashSet&lt;Int&gt;() var hubBus = -1 var hubHasDriver = false usbDriver.listFiles()?.forEach &#123; parent -&gt; if (!parent.isDirectory) return@forEach val result = Regex(&quot;^(\\\\d)-\\\\d\\\\.?(\\\\d?)&quot;).find(parent.name) ?: return@forEach val bus = result.groupValues.getOrNull(1)?.toIntOrNull()//总线号 val hubNum = result.groupValues.getOrNull(2)?.toIntOrNull()//扩展口编号 if (bus != null &amp;&amp; hubNum != null) &#123; //有扩展口 hubBus = bus if (hubNum &lt;= 3 &amp;&amp; isVideoDriver(parent)) &#123;//3个扩展口 hubHasDriver = true &#125; &#125; else if (bus != null &amp;&amp; isVideoDriver(parent)) &#123; usbList.add(bus) &#125; &#125; if (hubBus != -1) &#123; if (hubHasDriver) &#123; usbList.add(hubBus) &#125; else &#123; usbList.remove(hubBus) &#125; &#125; JLog.normal(&quot;getDevBusByDriver : $usbList&quot;) return usbList.toList()&#125;private fun isVideoDriver(parent: File): Boolean &#123; var drcount = 0 //排除掉音频设备等 parent.listFiles()?.forEach drcount@&#123; child -&gt; if (!child.isDirectory) return@drcount if (drcount &gt; 2) return false if (Regex(&quot;^(\\\\d)-\\\\d\\\\.?(\\\\d?):&quot;).find(child.name) != null) &#123; drcount++ &#125; &#125; return drcount != 1&#125; 相关方法差不多就这些，主要就是遍历文件系统，找到对应的 Usb 端口的 serial，结合驱动来做一些判断。至于这样的方案是不是真正解决问题了，就只能交给时间了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"重温线程知识","date":"2022-06-24T07:24:30.000Z","path":"2022/06/24/thread/","text":"有一个长耗时任务，需要持续性的发送数据，发送的包收到回应后，继续发送下一包，如此反复，直到数据发送完。起始时没什么好的思路，线程的知识都不太记得了，wait nofity 等方法都好久没用过了，后面看了下廖雪峰的博客，把知识重新温习了一遍，便有了如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@WorkerThreadpublic static void sendPath(List&lt;Trace&gt; path, Callback&lt;Boolean&gt; callback) &#123; final AtomicInteger retryCount = new AtomicInteger(); final AtomicBoolean isError = new AtomicBoolean(); isError.set(false); final Object lock = new Object(); final AtomicInteger sendStart = new AtomicInteger(); // 监听 final Callback&lt;Callback&gt; cb = data -&gt; &#123; if (data.start == sendStart.get() &amp;&amp; data.success) &#123; // 成功 &#125; else &#123; // 失败 isError.set(true); &#125; synchronized (lock) &#123; lock.notifyAll(); &#125; &#125;; // 注册 Tiger.register(cb, Callback.class); final int PackageSize = 18; int size = path.size(); int index = 0; while (index &lt; size) &#123; if (retryCount.get() &gt; 3) &#123; //最多重试3次 isError.set(true); &#125; if (isError.get()) &#123; break; &#125; //开始索引 int start = index; //结束索引的前一个 int end = start + PackageSize; if (end &gt; size) &#123; end = size; &#125; //是否最后一包 final boolean isEnd = end == size; WriteBytes wb = new WriteBytes(true); // wb 添加数据 sendStart.set(start); byte[] sendData = wb.toBytes(); // 发送数据 CommunicatorManager.getInstance().send(sendData); // 加锁 synchronized (lock) &#123; try &#123; // 等待三秒 long time = System.currentTimeMillis(); lock.wait(3000); if (System.currentTimeMillis() - time &gt; WaitTime - 50) &#123; // 超时了 if (isError.get()) &#123; // 失败了不再重试 break; &#125; // 超时了还没失败，就重试 retryCount.getAndIncrement(); continue; &#125; retryCount.set(0); &#125; catch (InterruptedException e) &#123; isError.set(true); break; &#125; &#125; index = end; &#125; // 注销 Tiger.unregister(cb, Callback.class); if (isError.get()) &#123; callback.callback(false); &#125; else &#123; callback.callback(true); &#125;&#125; 方法大意是：path 是一个点集合，单个包最多发送不超过 500 个字节的数据给硬件，所以按照 500 个字节的限制，将 path 分割成若干个包。先发送第一个包，硬件回复成功后，再发下一个包。硬件回复失败，或者超时没有回复，则进行重发当前包，一个包最多重试 3 次，重试 3 次还失败则整个发送行为失败。 大概知识点如下： 在线程中，通过 synchronized (lock) 进行加锁，在锁代码块中，可以执行 wait()，此时线程进入等待状态，必须由其他线程唤醒后，该线程才继续执行。需要注意，wait() 可以传入一个超时时间，当超出这个时间后，并不会抛 InterruptedException 异常，所以需要自己处理超时逻辑。 在发送数据消息回调中，需要使用同一个锁对象进行加锁，并调用它的 notifyAll()。使用 notifyAll() 将唤醒所有当前正在 this 锁等待的线程，而 notify() 只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。 wait() 方法执行后，会使当前线程释放锁，所以才可以让其他线程拿到锁，从而调用 notify 相关方法进行唤醒。那么 wait() 之后的代码是没有锁的，若有多线程安全相关的考量，则需要重新获取锁。本例中 wait() 方法之后的代码块使用了 Atomic 相关类，所以便没有加入重新获取锁的逻辑。Thread.sleep() 也是会暂停当前线程并让出 cpu 执行时间，但 sleep() 不会释放锁，到时候后会继续执行。 Atomic 相关类，内部使用无锁的方式实现的线程安全，主要原理用的 CAS：Compare and Set。简化多线程编程，适用于计数器，累加器等。","tags":[{"name":"Java","slug":"Java","permalink":"http://lijia92.github.io/tags/Java/"}]},{"title":"Dialog 新姿势","date":"2022-05-31T08:16:34.000Z","path":"2022/05/31/dialog/","text":"近日测试同学报了一个 bug，当界面展示了雷达距离弹窗时，登录页面的按钮竟然还可以点击，点击 EditText 可以唤醒系统键盘，但是点击系统键盘后无法输出到 EditText 上。布局大概是这样： 负责这个的同事请假了，只能自己看代码排查了，看了下弹窗的类： 1class RadarSignalDialog(context: Context) : Dialog(context, R.style.out_side_click_dialog) 确实是继承自 Dialog 的，在我之前的认知中：Dialog 出现后，下面的布局是无法点击的，必须要把 Dialog 消失掉才可以点击。可为什么会出现这个情况呢？看到 Dialog 类的具体实现，发现如下代码： 12345678window?.setFlags( WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL, WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL)window?.setFlags( WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH, WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) 于是 Google 这些 Flag 的作用： FLAG_NOT_TOUCH_MODAL：Window flag: even when this window is focusable (its FLAG_NOT_FOCUSABLE is not set), allow any pointer events outside of the window to be sent to the windows behind it.FLAG_NOT_FOCUSABLE：Window flag: this window won’t ever get key input focus, so the user can not send key or other button events to it.FLAG_WATCH_OUTSIDE_TOUCH：Window flag: if you have set FLAG_NOT_TOUCH_MODAL, you can set this flag to receive a single special MotionEvent with the action MotionEvent.ACTION_OUTSIDE for touches that occur outside of your window. 所以就很了然了：即使是 Dialog，也可以通过给 Window 设置 Flag 来达到 Dialog 外的 View 也可以被点击。为了修复 EditText 无法输入的问题，我将 Flag 改成了 FLAG_NOT_FOCUSABLE。但是如果弹窗内部也有 EditText，就无法获取焦点，也没法输入了。所以，当 Dialog 内、外都有 EditText 时，是没办法两全的，届时就得考虑其他方法实现了，比如系统浮窗。所以后面如果有类似的场景，可以直接使用 Dialog 设置 Flag，比系统浮窗会更方便，同时也避免了系统浮窗的权限问题。这一波是涨姿势了~ 题外话实现一个自定义 View，让 Dialog 可以像系统浮窗一样，随意拖动： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class ScrollableView : FrameLayout &#123; constructor(context: Context) : this(context, null) constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0) constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) private var lastX = 0f private var lastY = 0f private var onScrollListener: OnScrollListener? = null fun setScrollListener(onScrollListener: OnScrollListener) &#123; this.onScrollListener = onScrollListener &#125; override fun onInterceptTouchEvent(ev: MotionEvent): Boolean &#123; when (ev.action) &#123; MotionEvent.ACTION_DOWN -&gt; &#123; lastX = ev.x lastY = ev.y &#125; MotionEvent.ACTION_MOVE -&gt; &#123; val dx = ev.x - lastX val dy = ev.y - lastY if (abs(dx) &gt; ViewConfiguration.get(context).scaledTouchSlop || abs(dy) &gt; ViewConfiguration.get(context).scaledTouchSlop ) &#123; return true &#125; &#125; &#125; return false &#125; override fun onTouchEvent(event: MotionEvent): Boolean &#123; if (event.action == MotionEvent.ACTION_MOVE) &#123; onScrollListener?.onScroll( ((event.x - lastX) / 3).toInt(), ((event.y - lastY) / 3).toInt() ) &#125; return true &#125; interface OnScrollListener &#123; fun onScroll(distanceX: Int, distanceY: Int) &#125;&#125;viewBinding.scrollableView.setScrollListener(object : ScrollableView.OnScrollListener &#123; override fun onScroll(distanceX: Int, distanceY: Int) &#123; val params = window?.attributes ?: return params.x += distanceX params.y -= distanceY checkValidPos() onWindowAttributesChanged(params) &#125;&#125;) 实现思路很新颖，记录一下，万一以后用得到呢。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"云基站概述","date":"2022-04-21T02:39:24.000Z","path":"2022/04/21/station/","text":"在科二考试系统一文中，实现一个科二考试系统依赖于「高精度定位」。以此文来记录下相关技术思路。 定位要实现高精度定位，需要两个定位设备。设备支持设置 流动站 或者 基站 两种工作模式。当设置为基站之后，设备会将自己的 rtcm 数据（简单理解为差分数据）发送出去。然后流动站接收这个差分数据，再结合自身收到的卫星 gps 数据进行运算，便可以得出一个「基于基站的高精度坐标」了。 在设置基站模式时，需要同时给基站设置一个坐标，这个坐标可以是低精度的，也可以是高精度的。项目中有 3d 场景，利用流动站连接基站采集的高精度坐标数据，是 2d 的。为了让 3d 与 2d 对齐，取用这个基站设置的坐标当做 原点。这样 3d 建模的场景根据原点进行偏移，便可以与 2d 对应了。即车子开到这个侧方停车区域，3d 显示的便也是这个侧方停车区域。就像这样：多个流动站可以连接到一个基站，进行高精度定位。 地图偏移基于上述技术实现的产品需求，会伴随着一个问题：当基站架设的实际物理位置变动了，或者原点变化了，都会导致地图发生偏移，即车子在 3D 模型中的位置与实际位置不一致。 而这在实际场景中是十分有可能发生的： 实际位置变动可能是因为驾校改装，或者基站周围环境发生变化，必须迁移位置。 基站配置设置的坐标变化是因为设备断电重启会自己设置一次原点（项目中采用设备硬件厂商的问题）。 当地图发生偏移了，需要将与该基站关联的所有地图数据进行偏移操作。偏移操作的理论很简单：将同一个实际的物理位置，连接新基站采点，计算差量，做数据偏移。举个例子：选定一个实际的物理位置（一般选倒库的点，好找一点），在地图中的坐标假设是 (100,100)。再连接新基站（基站移动或者坐标变化，需要重新设置，便不再是之前的那个基站了）之后在这个位置上采集到一个坐标假设是 (99,101)，根据这两个坐标计算的差量是 (-1,1)，然后将所有地图坐标根据这个差量运算一次，保存新的坐标即可。理论虽然简单，但实际操作会有一定风险： 需要人为定位实际的物理位置，多多少少会有偏差。 有地域局限性。比如广西的基站发生偏移了，那么一定得去广西连接这个基站的某个驾校进行定位，重新采集新的坐标。 迁移操作不可逆，如果发现没迁移对，得重新迁移，就会导致坐标不停的变化，可能带来一些其他的问题。 如果这个基站关联的地图很多，那么就需要操作更多的数据，工作量更大且不可控。 也是因为这些原因，项目中已经废弃这个方案了。 云基站既然基站移动会到导致上述问题，那是不是可以 选取一个基站，这个基站永远不会变更位置，且不会因为断电重启的原因导致设置坐标变化 呢？应该是可以的，比如在某个大楼的楼顶，只要楼不塌，位置肯定不会变，正常情况下也能保证不会断电重启。好，现在将这个基站架设好了，代号为 A。现在来了一个实施需求，需要在某某驾校架设基站 B。组建云基站的操作也很简单：先将 B 基站架设好，同时将 B 设置为流动站，连接上 A 基站。B 根据 A 下发的 rtcm 数据解析出一个高精度坐标 X。再将 B 设置成基站模式，同时将这个高精度坐标 X 设置进去，这样 B 基站便云化了。假设后面 B 需要移动位置重新架设，那么就只需要把这个操作重新执行一遍就可以了，不需要偏移已经采集好的地图数据。因为基站本身就只能辐射几十公里的范围，云基站也是一样的。处于云基站系统 A 区域内，就使用云基站系统 A 里的基站，A1、A2、A3 等等，离哪个基站近就连哪个。如果处于云基站系统 B 的区域，就使用云基站系统 B。假设在系统 A 下面采集了，结果又要在系统 B 去使用，就会导致偏移问题。但考虑到实际场景，是地域性特别强的科二考试，不存在这样交叉使用的情况。再经过了许许多多的问题与躺坑后，才有了现在相对“完美”的方案。技术也是需要持续优化、进步的呀！","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"Usb 摄像头绑定","date":"2022-04-12T08:44:45.000Z","path":"2022/04/12/camera/","text":"在之前的文章中，写了一个 CameraIntent 的类，代表用到摄像头的业务。App 允许连接多个 Usb 摄像头，然后将业务绑定到一个确定的 Usb 端口。如果这个端口插入了摄像头，则可以直接使用摄像头产生的数据进行业务处理，如果没插入摄像头，则相应的业务不做处理或中断。通过 UsbManager.ACTION_USB_DEVICE_ATTACHED、UsbManager.ACTION_USB_DEVICE_DETACHED 广播可以知道 Usb 设备插入、拔出的时机。通过 intent 获取到的是一个 UsbDevice 对象。如何通过这样的一个 UsbDevice 确定物理实际的 Usb 端口呢？ 通过 deviceName先打印一下 UsbDevice 的内容： UsbDevice[mName&#x3D;&#x2F;dev&#x2F;bus&#x2F;usb&#x2F;007&#x2F;007,mVendorId&#x3D;3141,mProductId&#x3D;25771,mClass&#x3D;239,mSubclass&#x3D;2,mProtocol&#x3D;1,mManufacturerName&#x3D;CLSJ-H63-210317,mProductName&#x3D;Integrated Camera,mVersion&#x3D;2.1,mSerialNumber&#x3D;null …] mVendorId、mProductId、mProductName 都是这个 Usb 设备自身的属性，无法和实际的 Usb 端口对应上。通过查阅 UsbDevice 相关文档，初步觉得可以使用 mName 这个属性来进行绑定。进行测试，来回插拔多个不同 Usb 设备到同一个物理端口，发现 mName 是固定的一个字符串 &#x2F;dev&#x2F;bus&#x2F;usb&#x2F;007&#x2F;00X。每插拔一次，后面的 X 会自增一次。那是不是可以使用前面的 &#x2F;dev&#x2F;bus&#x2F;usb&#x2F;007 来确定这个物理端口呢？先试一把再说，于是就有了 CameraIntent 的 saveDevice、getDevice 方法，匹配的都是 String 类型的参数和返回值，对应的就是 &#x2F;dev&#x2F;bus&#x2F;usb&#x2F;007 这样的串。来回插拔多次，使用不同硬件设备也试过，好像没什么问题，都可以对应上。 意外起初以为没什么问题了，结果后面测试同学过来报 bug：Usb 摄像头对应关系错了。于是问相关操作，包含了一系列的插拔、绑定等等，还有 设备重启 。单纯插拔、App 进行绑定已经经过自己的充分测试了，唯独 设备重启 当时没有考虑到。针对重启测试一轮，重启多次后发现，确实是出现了同一个物理端口，但 deviceName 从 &#x2F;dev&#x2F;bus&#x2F;usb&#x2F;007 变成 &#x2F;dev&#x2F;bus&#x2F;usb&#x2F;005 的情况。！@#！@￥@#%￥%……*&amp;……（*&amp;））（*——（）+）——+——@#！shit，感觉没什么思路了… index后面上级提了个思路：可不可以利用 index 来做绑定关系？做了相关了解后，&#x2F;dev&#x2F;bus&#x2F;usb 这个路径其实就是对应到文件系统里的文件路径。经过多次重启，查看文件路径如下：确实发现 005、007 会来回变，但是在文件系统中顺序没变。于是尝试用 index 来做绑定关系。将之前的 String 改成 Int。如何确定 index 呢？直接遍历文件系统： 1234567891011121314/** * 获取设备 Usb 的端口路径 */private fun initUsbPorts() &#123; ports.clear() val file = File(&quot;/dev/bus/usb&quot;) if (file.isDirectory) &#123; file.listFiles()?.forEach &#123; ports.add(it.absolutePath) &#125; &#125; ports.sortBy &#123; it &#125; JLog.normal(&quot;initUsbPorts : $&#123;JSON.toJSONString(ports)&#125;&quot;)&#125; 按道理这种操作在正常手机系统里是不行的，需要系统权限。但是我们的设备都是自己生产的，也不存在设备适配的情况，所以暂时先忽略这个问题。拿到 Path 列表后，通过 UsbDevice 的 deviceName 去对比是第几个，就可以拿到 index 进行业务绑定了。 再来个意外经过一段时间的测试，测试同学后面又来报 bug 了。wtf…后面跟进排查，发现同一个物理端口，重启后在文件系统的 index 确实不一样了，但是这个设备是之前生产的样机，不是最终外发的设备。于是用最终的设备重新进行测试，暂时没发现这个情况。如果最终外发的设备后面还是出现了这个情况，就得再想别的方法了。so，就先这样吧…","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"关于枚举类初始化的一个“耳光”","date":"2022-03-07T06:00:53.000Z","path":"2022/03/07/enum/","text":"项目中需要使用 Usb 摄像头，摄像头产生数据，然后业务方拿到数据后做自己的事情：推流、人脸登录、AI 检测等等。于是写了一个枚举类 CameraIntent 用来标识摄像头的意图。在 CameraIntent 每个枚举项初始化的时候，设置一个 key，然后根据这个 key 拿到 SharedPreferences 中绑定 UsbDevice 的名称，以此找到对应 UsbDevice 的摄像头，从而获取数据。 所以写了这样的一个类： 123456789101112131415161718192021222324252627282930313233343536enum class CameraIntent(val desc: String, val key: String) &#123; PUSH(&quot;视频推流&quot;, KEY_PUSH), AI(&quot;AI识别&quot;, KEY_ACTION), FACE(&quot;人脸识别&quot;, KEY_FACE); private val cache = ValueCache.create(key, getDefaultValue(), String::class.java) /** * 将业务绑定到具体的摄像头，可以多个业务绑定到同一个摄像头 */ fun saveDevice(device: String) &#123; cache.save(device) &#125; fun getDevice(): String &#123; return cache.get() &#125; private fun getDefaultValue(): String &#123; return when (this.key) &#123; KEY_FACE -&gt; &#123; MucangConfig.getContext().resources.getString(R.string.default_face_camera) &#125; KEY_ACTION -&gt; &#123; MucangConfig.getContext().resources.getString(R.string.default_action_camera) &#125; KEY_PUSH -&gt; &#123; MucangConfig.getContext().resources.getString(R.string.default_push_camera) &#125; else -&gt; &#123; &quot;&quot; &#125; &#125; &#125;&#125; 自信满满跑了一把，然后…收获了崩溃。日志是这样的…报了两个错：ExceptionInInitializerError、空指针异常。然后围绕着这两个错误进行了大量的搜索，也没找到有效的信息。然后再回过头仔细看看代码，豁然开朗！枚举类也是类，枚举项即是类对象。在使用对象之前，一般都得先 new 一个，枚举类无非就是 Java 自动 new 了，但是它仍然可以理解为一个对象。一个对象在没有初始化完成的时候，它是不可用的状态，调用其属性、方法肯定是会报错的。再看到代码：在 cache 属性的创建过程中，使用了 this 关键字，而 cache 的创建过程是属于这个类对象初始化过程的，也就是在类还没有初始化完成的时候就去使用它了，必然报错。先有鸡还是先有蛋？当然这个问题我也不知道答案是什么。但是文中的答案是确定的：先有对象，再有属性。所以改成这样： 123456789101112131415161718192021222324252627282930313233343536enum class CameraIntent(val desc: String, val key: String) &#123; PUSH(&quot;视频推流&quot;, KEY_PUSH), AI(&quot;AI识别&quot;, KEY_ACTION), FACE(&quot;人脸识别&quot;, KEY_FACE); private val cache = ValueCache.create(key, getDefaultValue(key), String::class.java) /** * 将业务绑定到具体的摄像头，可以多个业务绑定到同一个摄像头 */ fun saveDevice(device: String) &#123; cache.save(device) &#125; fun getDevice(): String &#123; return cache.get() &#125; private fun getDefaultValue(key: String): String &#123; return when (key) &#123; KEY_FACE -&gt; &#123; MucangConfig.getContext().resources.getString(R.string.default_face_camera) &#125; KEY_ACTION -&gt; &#123; MucangConfig.getContext().resources.getString(R.string.default_action_camera) &#125; KEY_PUSH -&gt; &#123; MucangConfig.getContext().resources.getString(R.string.default_push_camera) &#125; else -&gt; &#123; &quot;&quot; &#125; &#125; &#125;&#125; getDefaultValue 直接使用构造函数中的 key，这样在对象初始化的时候，依赖的都是外部的属性。编译一把，正常运行。所以啊，碰到问题了先看看代码，自己分析一下。可能有些问题是不需要 Google 的，它只需要结合逻辑思维，多想一下，可能答案就会出来了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"记一次阿里云推流问题排查的辛酸历史","date":"2022-02-18T07:16:51.000Z","path":"2022/02/18/ali/","text":"说下问题背景：App 接入摄像头，摄像头产生的每一帧数据（byte 数组），经由阿里云推流的 api 推到监控中心。摄像头的管理用 HandlerThread 实现，当摄像头打开之后，拿到每一帧的数据回调出去。 123456789101112131415161718192021/** * 每一帧的数据 */override fun onFrame(frame: ByteBuffer) &#123; val len = frame.capacity() if (yuv == null || yuv!!.size != len) &#123; yuv = ByteArray(len) &#125; frame.get(yuv!!) callback.onPreviewFrame(device, yuv!!)&#125;/** * 摄像头需要的回调 */interface UsbCameraCallback &#123; /** * 帧数据回调 */ fun onPreviewFrame(cameraDevice: UsbDevice?, data: ByteArray)&#125; 最终会回调到推流管理类的 onFrame 方法： 1234567override fun onFrame(byteArray: ByteArray, width: Int, height: Int, stride: Int, size: Int, timeUs: Long, rotation: Int) &#123; frameLost = false FpsUtils.compute() if (isPushStart == true) &#123; mAlivcLivePusher?.inputStreamVideoData(byteArray, width, height, stride, size, timeUs, rotation) &#125;&#125; 就这样将摄像头产生的流推到监控中心了，同时监控中心可以下发指令来开启或者关闭推流。在测试过程中，发现一个问题：监控中心的画面会出现偶发性的黑屏，通过下发开启推流指令也无法恢复。于是从帧数据产生的源头，将数据传递的每一个方法中都打上了日志，然后观察日志。发现源数据生产的日志都没有了，也就是说摄像头自身都没有产生数据了，并且发现每次黑屏都会有特定的日志出现。然后找到 释放推流 日志的地方： 12345678910111213141516private fun releasePush() &#123; JLog.normal(&quot;释放推流&quot;) reconnectJob?.cancel() pushScope?.cancel() mAlivcLivePusher?.setLivePushNetworkListener(null) kotlin.runCatching &#123; mAlivcLivePusher?.stopPush() &#125; kotlin.runCatching &#123; mAlivcLivePusher?.destroy() &#125; reconnectJob = null pushScope = null mAlivcLivePusher = null isPushStart = null&#125; 仔细分析：onFrame 产生的数据是从摄像头的 HandlerThread 中回调出来的，直接调用阿里云的 inputStreamVideoData 方法进行推流，在子线程。而这个 releasePush 是接受 LiveData 的值进行调用的，是在主线程。所以就有理由怀疑了：mAlivcLivePusher 的 inputStreamVideoData、stopPush、destroy 这些方法，并不是线程安全的。主线程调用 stopPush、destroy 之后，再在子线程调用 inputStreamVideoData，可能内部发生死锁或者其他的什么原因，导致子线程直接挂了，或者阻塞了，不能正常生产数据了。查看阿里云推流的文档中也没看到相关的描述。只能简单实验一把：将 onFrame 的回调放到主线程。然后打包测试，监控中心的画面可以持续很久的正常展示了，不论下发多少次开启、关闭的指令，流都可以正常关闭、推送了。为了确保问题解决，需要更多的信息。可惜 mAlivcLivePusher 的方法都是 native 的，看不到什么有用的东西，只能使用其他方法从侧面进行验证了。将线程修改先还原，在 inputStreamVideoData 调用前，调用后打上日志，同时加上 try catch 看是否可以看到可以的日志： 1234567JLog.normal(&quot;push in&quot;)try &#123; mAlivcLivePusher?.inputStreamVideoData(byteArray, width, height, stride, size, timeUs, rotation)&#125; catch (e: Throwable) &#123; JLog.normal(&quot;push error:&quot; + e.message)&#125;JLog.normal(&quot;push out&quot;) 出现黑屏情况时，看到日志只有 in 没有 out，也没有 error。这已经可以初步验证猜想了：推送的线程已经被玩坏了。继续使用 Android Studio 的 Profiler 来查看线程的状态。正常时线程是可以工作的状态，出现黑屏之后线程就变成了持续的 sleeping 了。至此问题基本解决，将帧数据回调改成主线程，重新打包发布，目前没有问题反馈。 感慨问题排查的过程远没有文章描述的简单，它耗费三个人力，一整天的时间才排查到。抱着怀疑一切的态度，从数据产生开始，一层一层抽丝剥茧。怀疑过数据回调监听失效了，也怀疑 HandlerThread 因为某些原因被回收了，后面一点点地才将日志链路补全，再根据日志理性分析可能的原因。然后进行验证，解决之后继续验证，最终将问题解决。主要代码不是一个人写的，某同事负责摄像头的封装，某同事负责阿里云的接入，就很容易忽略这类线程问题。另外，这阿里云推流的文档是真的简单，碰到问题找客服下工单估计几天就过去了，只能自己排查。经此一役，得给自己提个醒了，自己封装代码时需要指明回调的线程，方便他人使用。集成 SDK 严格按照文档来，文档说明不充分的，尽量一个线程里使用。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"动画小记","date":"2022-02-17T07:59:05.000Z","path":"2022/02/17/robot-anim/","text":"嗯，产品需求要将语音机器人交互实现文中的动画效果进行修改，改成什么样呢？演示视频太大了，随便截了几个图： 可以看到，整体变简洁了，整体效果主要有两个动画： 背景框缩小的动画，同时圆角慢慢变大； 中间提示文案的闪烁效果，变灰然后变亮；机器人上下眨眼睛的动画，搞个 Gif 图就完事儿了，让我自己画也是画不出来的。 缩小动画因为有圆角改变的动画，所以单独弄个图，ImageView 进行缩放是实现不了的：没法改变圆角。然后找到一个可以设置圆角的类：GradientDrawable。那么思路就比较明确了：先说服设计背景色就使用渐变色实现，下面就好实现了： 123456789101112131415161718192021private val drawable = GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT, intArrayOf(Color.parseColor(&quot;#1B3461&quot;), Color.parseColor(&quot;#0A1C42&quot;)))private fun zoomOut() &#123; val anim = ValueAnimator.ofFloat(0F, 1F) anim.duration = 200 anim.addUpdateListener &#123; val value: Float = it.animatedValue as Float val width = maxWidth - (maxWidth - minWidth) * value val height = maxHeight - (maxHeight - minHeight) * value val radius = minRadius + (maxRadius - minRadius) * value drawable.cornerRadius = radius val lp = viewBinding.bgView.layoutParams lp.width = width.toInt() lp.height = height.toInt() viewBinding.bgView.layoutParams = lp viewBinding.bgView.background = drawable if (value == 1F) &#123; // 动画完成做些事情 &#125; &#125;&#125; 使用属性动画，计算每一刻的属性，然后赋值即可。需要放大的时候，将动画返回来即可。 文字闪烁文字闪烁的动画应该是在哪里见过的，但是一时想不起来了，搜索的时候也找不准关键字，于是找我的大腿舍友询问一波：于是思路就来了：给 Paint 设置渐变的 Shader(LinearGradient)，然后改变 Shader 的坐标或者位移，就可以实现动画效果了。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class ShiningTextView(context: Context, attrs: AttributeSet?) : View(context, attrs) &#123; private val tipList = context.resources.getStringArray(R.array.voice__robot_tips) private var tipIndex = -1 private var text = nextTip() private var mHeight = 0 private var mWidth = 0 private var distance = 0f private var mBaseline = 0f private val paint = Paint() private val mMatrix = Matrix() private var darkGradient: LinearGradient? = null private var lightGradient: LinearGradient? = null init &#123; paint.isAntiAlias = true paint.textSize = context.resources.getDimension(R.dimen.text_53) paint.color = Color.parseColor(&quot;#FAFBFB&quot;) val fontMetrics = paint.fontMetrics distance = (fontMetrics.bottom - fontMetrics.top) / 2 - fontMetrics.bottom darkGradient = LinearGradient(0f, 0f, 100f, 0f, Color.parseColor(&quot;#48597f&quot;), Color.WHITE, Shader.TileMode.CLAMP) lightGradient = LinearGradient(0f, 0f, 100f, 0f, Color.WHITE, Color.parseColor(&quot;#48597f&quot;), Shader.TileMode.CLAMP) mMatrix.setTranslate(-100f, 0f) darkGradient?.setLocalMatrix(mMatrix) paint.shader = darkGradient &#125; fun dark() &#123; MainScope().launch &#123; delay(2000L) val darkAnim = ValueAnimator.ofFloat(0F, 1F) darkAnim.duration = 200 darkAnim.addUpdateListener &#123; val value = it.animatedValue as Float mMatrix.setTranslate(-100f + mWidth * value, 0f) darkGradient?.setLocalMatrix(mMatrix) paint.shader = darkGradient invalidate() if (value == 1F) &#123; light() &#125; &#125; darkAnim.start() &#125; &#125; private fun light() &#123; text = nextTip() val lightAnim = ValueAnimator.ofFloat(0F, 1F) lightAnim.duration = 200 lightAnim.addUpdateListener &#123; val value = it.animatedFraction as Float mMatrix.setTranslate(100f + mWidth * value, 0f) lightGradient?.setLocalMatrix(mMatrix) paint.shader = lightGradient invalidate() if (value == 1F) &#123; dark() &#125; &#125; lightAnim.start() &#125; override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) canvas.drawText(text, 0f, mBaseline, paint) &#125; override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) mHeight = h mWidth = w mBaseline = mHeight / 2 + distance &#125; /** * 返回下一个 Tip */ private fun nextTip(): String &#123; tipIndex++ return tipList[tipIndex.rem(tipList.size)] &#125;&#125; 几点 Tips: 给 LinearGradient 设置 Matrix，使用 Matrix 进行 translate，就可以一点点改变文本的颜色。 drawText 的第二个参数是 baseline 的值，所以需要结合画笔的设置，计算 baseline。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"2021 年度总结","date":"2022-01-28T11:01:42.000Z","path":"2022/01/28/2021/","text":"还有两天就要过年了，今天是最后一天班，抓住时间的尾巴，还是记录一下吧。 … 回顾了一年，好像并没有什么特别的事情，工作、生活有条不紊的来回交替，但平凡即伟大，就算是流水账也还是可以记录一些的。 疫情自从新冠疫情爆发以来，戴口罩已经成了习惯，差不多也有3年了。疫情并没有消散，时不时就会爆发一波，好在大家的防护意识都挺强了，做好个人防护，剩下的交给国家。 减肥新年刚开始便立下 flag，每天至少运动半小时。刚开始还坚持了一顿时间，后面总会因为这样那样的原因就放弃了。关于这个话题，每次都是雷声大，雨点小。怎么婚后想减肥就这么难呢？道理我都懂：管住嘴，迈开腿。坚持就是胜利！可是人的天性真的是好难克服啊。索性后面直接去健身房办卡了，健身房环境还不错，可以跑步、椭圆机，也有游泳池，想无氧做力量训练也是可以的。基于目前的大体重，我起先选择了椭圆机与游泳的组合。椭圆机就是单纯的有氧，而游泳是媳妇儿想学的。起初并没有设定减肥目标，相信只要动起来，总会慢慢改善身体的状态的。每周去个3、4次，坚持到现在感觉还不错。 EDG 牛逼今年的 LPL 世界赛，EDG 牛逼就完事了，其他的不用多说。 户外也是因为办健身卡的缘故，整个人都动起来了，有机会还是比较愿意进行下户外运动。带着老婆跟着公司团建去了神农架滑雪，这次我选了个单板。出发前网上看了几小时的教学视频，感觉 so easy。然后去到滑雪场被摔成傻逼- -。元旦的时候，约着老康爬了一波山，也很 nice还是要多多运动啊。 游戏作为一个中年人，每天阅读连岳的文章，发现有很多文中的“老公”在步入中年之后就容易变成一个“赌徒”。为了不变成一个赌徒，我选了梦幻西游端游来当做理财手段（手动狗头），今年经历过巅峰之后，变慢慢回归刷任务吧。买个青花瓷号刷任务也挺香的，爆肝 300 鬼。 工作当然不得不说的还有工作，今年还算可以吧。在当前这个项目组做的还比较开心，一直以主人翁的态度尽可能负责更多的事情，承担起更多的责任。当然也有不错的收获，工资涨了两波，不与他人比，自己满意就好。技术层面更多的使用了协程的一些知识，尝试理解更多的数学计算，也有一点点的提升吧。做各种需求功能时，尽量站在系统的角度去思考去设计，而不是单纯的堆砌代码，希望未来能有更大的成长。 新年愿景：努力工作，好好生活！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"使用 Ping 指令判断网络","date":"2021-12-31T06:34:09.000Z","path":"2021/12/31/ping/","text":"有个需求，需要判断网络是否连接，如果是正常的移动网络或者 WiFi，是可以判断出来的，但是目标设备使用的是以太网，就像台式机插入的网线一样。假设拔掉机器这边的网线，很显然就是没有网络的，通过 Android 的 ConnectivityManager 的 getActiveNetworkInfo 也可以判断出来。但如果拔掉的是网线的另一端，通过 Android SDK 获取的网络会仍然是 CONNECTED。这显然是有问题的，因为此时此刻设备连访问百度的能力都没有了。所以打算使用 ping 指令，不断的去 ping 一个 host，如果能正常返回，则说明网络是没问题的。 代码很简单，就一个方法： 123456789101112131415161718192021222324252627282930313233343536/** * ping 域名的工具类 */object PingUtils &#123; private var networkConnected = false @JvmStatic fun startPing(host: String = &quot;www.baidu.com&quot;) &#123; MainScope().launch &#123; // 无限循环，1秒 ping 1次 while (true) &#123; delay(1000) val ping = async(Dispatchers.IO) &#123; var result = false try &#123; val process = Runtime.getRuntime().exec(&quot;ping -c 1 $host&quot;) result = process.waitFor() == 0 &#125; catch (e: Exception) &#123; JLog.normal(&quot;域名$host ping 失败了，错误：&quot; + e.localizedMessage) &#125; result &#125; val result = withTimeoutOrNull(5000) &#123; ping.await() &#125; networkConnected = result ?: false &#125; &#125; &#125; @JvmStatic fun isNetWorkConnected(): Boolean &#123; return networkConnected &#125;&#125; 核心思路就是每隔一秒钟 ping 一次，如果在 5 秒内返回了结果，则认为网络连接正常，否则就是未连接。结合 Kotlin 协程的一些方法，让代码写起来简单直接，也算是学习一把协程。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"写在 30 岁的第一天","date":"2021-11-30T07:39:18.000Z","path":"2021/11/30/30/","text":"按照阳历日子，今天是我踏入「30 岁」的第一天，以后对外介绍自己的年龄时，得是“三十多岁”了。感谢老妈、老婆昨天给我过的生日。时间怎么就过得这么快呢。想起当时大学时期，20 出头的年纪，天天和室友调侃着“奔三”了。读书，工作，结婚，一路走过来，感觉也就一瞬间的事儿。很多事情，也在这一瞬间就变了。 父母老了，真正称得上“老人”了。老爸日渐稀疏的头发，每次回家过年都靠着染发让自己看起来更年轻。操劳大半辈子的老妈，体力也大不如从前了。是的，我一直依靠着的巨人，已经慢慢佝偻，我在巨人的保护下，健康成长。现在，我自己也要成为巨人，来保护他们。朋友间的关系也淡了。结婚之后，更多的精力都是消耗在小家庭的维系中，朋友们偶尔的邀约，也可能因为一个小原因就拒绝了。更可怕的是，内心好像在抵触一些聚会了。在网络上，可以各抒己见聊天聊地，没什么话说了，也不显得尴尬。线下邀约，就很怕没话说，围绕着一个话题来回翻炒。一年见不到几次的朋友，对他们的了解基本定格在几年前了。这几年他们经历了什么，改变了什么，我都不曾参与、见证。但经过时间的考验，十多年的感情，就显得愈发珍贵了。我们的共同话题可以越来越少，但我们仍然是最亲密的朋友。工作的压力也大了。现在想想之前一年换三份工作的“辉煌”经历，不禁唏嘘。13 年开始工作，到现在也有 8 年多了，在职场多年的摸滚打爬，逐渐形成了我现在的工作性格。从之前的短视、激情，变为现在的长久、求稳，代表了我对这个现实社会的妥协。但这应该也是大多数人的选择吧，我只是一个普通人，过着普通的日子就很好了。以主人翁的心态来对待每一个任务，多考虑一点，多承担一点，尽量多产出，让自己变得更有价值。我也变了很多。以前追求刺激，喜欢体验新东西。现在听到蹦极就害怕，“小命要紧”。没吃过的东西也不想尝试了，即使它再好吃。吃不了辣，吃不了火锅，聚餐最喜欢的是炒菜，吃完喝点汤。不愿意动脑筋了，简单的算术都会忍不住打开计算器。逻辑稍微复杂一点的东西，很难深入思考，理清它的脉络，反正也无所谓，是吧。变胖了，变懒了。老婆形容我：有一点「油腻」。啊，油腻的中年男人，从来没想过我也会被冠上这样的名头。十分的无奈，却也选择妥协了。我知道这样不对，但缺少坚持下去的毅力。 道理我都懂，却还是过不好这一生。 后半句需要换个意思，太消极了。怎么样的生活都是我们自己的选择，遵从自己的内心努力下去就好了呀。三十而已，像顾佳她们学习，未来十分美好！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"一个人可以小心眼到什么地步","date":"2021-11-11T06:00:14.000Z","path":"2021/11/11/people/","text":"周末的时候，又去了一次地大北街，吃之前吃过的韩餐。我和老婆骑共享单车到地方之后，我找好地方停完车就先去店里点餐了。我点好餐，过了好一会，老婆才来点店里，说：你要不去把自行车帮忙摆一下，我没找到地方停。我当时并不在意：共享单车啊，随便找个地方停着就可以了，没事~。然后饥肠辘辘地等着上餐了，看起来可真不错呀。 基于上次的经验，这次少点了些菜，味道都还不错，就是五花肉的肥肉有点多了，口感差了点。吃饱之后满足的离店准备前往下一个目的地。刚出门就发现一个男人恶狠狠的瞪着我，我刚开始有点懵逼，发现旁边也没有其他人，确认他果然就是在盯着我。然后想起来老婆进店说的自行车的事，看到他脚下有辆歪着的自行车，我大概就猜到了这应该就是我老婆停的车，摆在他店的门口边缘，让他不爽了。凶神恶煞的看着我，真让我有点虚：他看起来想揪住这个机会跟我干一架，可我没给他机会。一个女的（应该是男人的老婆）也跟着恶狠狠地说：以后出去别说是地大的，地大丢不起这个脸。不知道说的什么语言，听了半天才听明白。我一边随意应付着，一边把车子扶起来，然后找到一个没店面的街边停着了，然后和老婆离开了。走在路上，我和老婆就开始讨论起来了：“就因为你没把车子停好，这男的就这样瞪着咱吗？”“是的，从我进店面，他就盯着我看。所以我说让你出去帮忙弄一下。”“我靠，这么狠。咱们吃了一个多小时，他就盯着看了一个多小时吗？”“是的。”“牛逼！早说我就和你换个位置坐嘛。不过一个自行车，五大三粗的爷们挪一下问题不大吧，何苦和你一个女生这么计较呢。”“我本来是停你旁边的，旁边超出一点有个奶茶店，也不让我停，我就停到对面他们那家店门口一点，也不让我停，我说又没怎么挡到，怎么就不能停了，他们还在那说，我就啥也没管，直接把车子丢那就直接下来了。”“…有点厉害啊。惹谁都不能惹女人““…”“所以一个人可以小心眼到什么地步呢？一个开餐饮店的店家，因为我们这样一个不经意的举动，恶心了一个多小时，就像吃了屎一样，凶神恶煞。一个小时一直盯着我们，也不知道店里的生意怎么样，有这样的闲工夫盯着咱们看，大概率也是没啥生意的。大中午12点的，正是吃饭高峰期，没什么人，也不想想为啥生意不行。咱停个车还能假装店内人气很旺的样子。凡事只从最简单的表面看，看到啥就是啥，目光也真的是十分短浅，格局小了。”“是啊，搞不懂。我还以为你要跟他干起来，没想到你直接就走了。”“这种也没必要和别人干啊，确实是我们做的不好，引起了这样的一个事件。因为这个事情，那男的如此表现，说明性格就是小肚鸡肠，还跟他干，那就是咱格局小了。万一把他搞毛了，抄把刀出来也不是不可能。和任何人发生冲突，一定要在矛盾升级前抽身离去，你永远不知道你面对的人是不是一个神经病。”“有道理。”“还是要尽量提高自己的大局观，格局要打开。那女的也有意思，说什么丢地大的脸。你就算清华北大的学生也会有在路边撒尿的。揪住对方的一个小问题谈道德，就有点上纲上线了。就像你开车有行人闯了红绿灯，就跑过去跟他说：你闯红灯不对，影响自己开车了，你要怎么样怎么样。在别人眼里只会觉得你傻逼。”“嗯。不过竟然以为我们还是地大的学生，说明我们看起来还挺像学生的，哈哈哈。”“…”我们一路聊着，一路走着，往东湖走去，故事也差不多就结束了。 小结 我们要尽量减少做不对的、不合适的事情，这个依赖于我们的见识、格局观，只能说一步一步修炼。 当自身碰到这样的事情之后，要先从解决问题出发，把问题解决就可以了。可以发发牢骚，但不要太往心里去，毕竟气坏了身子，去医院看病还得花钱呢。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Compose 初识","date":"2021-11-10T09:14:27.000Z","path":"2021/11/10/compose/","text":"最近对 Kotlin 的协程、Flow 简单了解一下，也在实际开发中尝试使用了，还是挺香的。凯哥也出了 Compose 的课程，我同学买了课，群里发个群收款，想看的就付个款，免费的大家就不会看了，手忍不住地就付了。确实是因为付了钱，所以觉得不看就亏了，然后下班回家还硬着头皮看了两节课，这可是我少有的在下班时间研究技术了，金钱的魔力呀。因为暂且可能还不会用 Compose，好记性不如烂笔头，就简单记录一下。 什么是 Compose Jetpack Compose 是用于构建原生 Android 界面的新工具包。它可简化并加快 Android 上的界面开发，使用更少的代码、强大的工具和直观的 Kotlin API，快速让应用生动而精彩。 简单来说，就是一套 UI 框架，可以编写 Kotlin 代码来替代原先的 xml 工作，这样就不用 xml 与 Java&#x2F;Kotlin 代码间来回切换了。 声明式 UICompose 的核心就是「声明式 UI」。何为「声明式 UI」？ 所谓的「声明式 UI」：你只要声明界面是什么样子，不用手动去更新，因为界面会自动更新。而传统的写法里，数据发生了改变，我们得手动用 Java 代码或者 Kotlin 代码去把新数据更新到界面。你给出详细的步骤，去命令界面进行更新，这就是所谓的「命令式 UI」。 这个就有点像 DataBinding 做到的事情，只处理数据，页面自动刷新。但： Data Binding （不管是这个库还是这种编程模式）并不能做到「声明式 UI」，或者说，声明式 UI 是一种比数据绑定更强的数据绑定。 接下来就有个我认为更加牛逼的特性：你可以通过数据，来控制整个 View 的渲染。举个例子： 1234567var show = xxxColumn &#123; if (show) &#123; Text() &#125; Button()&#125; 注意，当 show 先是 true 然后又变成 false 的时候，不是设置了一个 setVisibility(GONE) 这样的做法，而是直接上面的 Text() 在界面中消失了。每次数据改变所导致的界面更新，看起来就跟界面关闭又重启、并用新的数据重新初始化了一遍一样。这，才叫声明式 UI，这是数据绑定做不到的。而且 Compose 并不是真的把界面重启了，它只会刷新那些需要刷新的部分，这样的话就能保证，它自动的更新界面跟我们手动更新一样高效。比如上面这里 show 的值从 true 变成 false 了，if 里面的 Text() 会被重新调用一次，但是外面的 Column() 和里面的 Text() 却不会被重新调用。很神奇吧？怎么做到的？靠的 code&gt;@Composable 关键字，或者说靠的 Compose 的编译器插件，这个插件通过对编译过程的干预，把代码的逻辑拆到了我们看不到的细粒度，让这种看起来是连续的代码可以做到互相独立地执行。 结合收费课程自我理解一下：Compose 是一套独立的 View 系统，区别于我们熟悉的 View、ViewGroup 那一套。之前的父 View、子 View 的改变会互相影响，而 Compose 会将所有 View 独立，这样在数据改变时只需要改变对应的 View 即可，而其他的 View 纹丝不动。可以想象一下：这样的话，View 层级对渲染性能的影响将消失，界面刷新的效率也会更高，我们开发者能做的事情也是可以无限想象了，但我们可能得重新学习 Compose 中 View、ViewGroup 的相关知识（触摸事件传递等）了(ಥ_ಥ)。View 嵌套不影响性能，主要依赖于 Compose 的「intrinsic measurement」。传统的 View 是因为会二次测量，甚至多次测量，层级越深，测量的次数就会是指数级增长，从而影响性能。而 Compose 就直接不允许二次测量了，引入「intrinsic measurement」来帮助测量，从根本上解决问题。 简单使用通过 AndoirdStudio 建立一个 Compose 工程，编译通过可以看到是这样的：可以看到，不需要 xml，仅仅通过 Compose 相关函数，就可以看到一个基本的页面。左边 Kotlin 代码，通过 Preview 注解在右边实时预览 Compose 函数生成的 UI 长什么样子。看了凯哥的第一课 「两小时写一个微信界面」之后，我大概了解 Compose 写代码要怎么写了，但是这个就和刚开始学习安卓写 xml 布局类似，需要边写边学。写代码的方式与当前的 Flutter 等都类似，声明式声明式，感觉未来就是声明式的天下了！ 小结 去掉 xml，单纯 Kotlin 代码写一切，基于 Kotlin 语言的各种方法糖，更自由更方便。之前是先写 xml，然后再写逻辑。使用 Compose 的话，就是 UI、逻辑一块写了，更加一气呵成。 声明式 UI，动态更新只需要更新的 View，其他 View 不会改变。代码更少，更直观，更快，更强！ 参考使用 Jetpack Compose 更快地打造更出色的应用Compose 布局中的固有特性测量谷歌开发者大会扔物线演讲原稿整理：Jetpack Compose声明式 UI？Android 官方怒推的 Jetpack Compose 到底是什么","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Flow 初识","date":"2021-10-27T03:11:20.000Z","path":"2021/10/27/flow/","text":"继上一篇文章，协程里有一个很大的特性就是 Flow。经过一阵尝试、学习，可能有一点点的收获，还是记录一下吧。「流」这个词，相信现在越来越多的开发者都接触并喜欢这个概念了。当 RxJava 风靡全球时，就有了「流」这个概念。基于 Kotlin，我们可以流式的写并发代码；基于 Flow，我们也可以流式的处理数据。面对复杂的数据逻辑，写出来的代码也可以像流淌的溪水一样干净，漂亮。 依赖使用 Flow，需要添加依赖： 12implementation &#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:版本号&#x27;implementation &#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:版本号&#x27; 我们使用 lifecycle-runtime 或者 viewmodel 的 kotlin 扩展时，本身就会依赖此库。如果使用的 api 依赖，便可以直接使用 Flow。 简单使用创建数据流: 12345678910private fun count(): Flow&lt;Int&gt; = flow &#123; var x = 0 while (true) &#123; if (x &gt; 20) &#123; break &#125; emit(x) x = x.plus(1) &#125;&#125; 监听数据流： 1234567891011GlobalScope.launch &#123; count().map &#123; &quot;$&#123;it / 0&#125;&quot; &#125;.catch &#123; ex -&gt; ex.printStackTrace() Log.d(&quot;Coroutine&quot;, ex.toString()) emit(&quot;-1&quot;) &#125;.collect &#123; Log.d(&quot;Coroutine&quot;, it) &#125;&#125; flow 构建器函数会创建数据流；emit 函数发送新值至数据流；map 函数修改数据流；collect 函数收集数据流；catch 函数捕获异常。 map 等属于中间运算符，可在应用于数据流时，设置一系列暂不执行的链式运算，留待将来使用值时执行。仅将一个中间运算符应用于数据流不会启动数据流收集。 collect 等终端运算符可触发数据流开始监听值。由于 collect 是挂起函数，因此需要在协程中执行。 catch 函数只能捕获上游的异常，无法捕获下游的异常。 catch 函数捕获到异常后，collect 函数无法执行。可以考虑通过 catch 函数执行 emit 操作处理后续逻辑。 callbackFlowcallbackFlow 可以将基于回调的 API 转换为数据流。以文本框输入监听为例，结合上面的网络请求示例。 12345678910111213141516private fun TextView.textWatcherFlow(): Flow&lt;String&gt; = callbackFlow&lt;String&gt; &#123; val textWatcher = object : TextWatcher &#123; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; &#125; override fun afterTextChanged(s: Editable?) &#123; offer(s.toString()) // 发送值 &#125; &#125; addTextChangedListener(textWatcher) awaitClose &#123; removeTextChangedListener(textWatcher) &#125;&#125;.buffer(Channel.CONFLATED) .debounce(300L) 采集数据流： 12345lifecycleScope.launchWhenStarted &#123; mBinding.etSearch.textWatcherFlow().collect &#123; viewModel.getArticles(it) &#125;&#125; 这个写法看起来就很舒服了，可以将 listener 的注册与注销，与生命周期进行绑定，写一个拓展方法即可。同时数据转成 Flow 发出来，可以做后续的各种处理，非常奈斯~ 冷流、热流 冷流是按需创建的，并且会在它们被观察时发送数据；热流则总是活跃，无论是否被观察，它们都能发送数据。 直接通过 flow{} 构造出来的流，是冷流。StateFlow、SharedFlow 则是热流（1.4.0 版本才引入）。 12345678910111213141516171819202122232425262728class LatestNewsViewModel( private val newsRepository: NewsRepository) : ViewModel() &#123; // Backing property to avoid state updates from other classes private val _uiState = MutableStateFlow(LatestNewsUiState.Success(emptyList())) // The UI collects from this StateFlow to get its state updates val uiState: StateFlow&lt;LatestNewsUiState&gt; = _uiState init &#123; viewModelScope.launch &#123; newsRepository.favoriteLatestNews // Update View with the latest favorite news // Writes to the value property of MutableStateFlow, // adding a new element to the flow and updating all // of its collectors .collect &#123; favoriteNews -&gt; _uiState.value = LatestNewsUiState.Success(favoriteNews) &#125; &#125; &#125;&#125;// Represents different states for the LatestNews screensealed class LatestNewsUiState &#123; data class Success(news: List&lt;ArticleHeadline&gt;): LatestNewsUiState() data class Error(exception: Throwable): LatestNewsUiState()&#125; 采集数据流： 123456789101112131415161718192021222324class LatestNewsActivity : AppCompatActivity() &#123; private val latestNewsViewModel = // getViewModel() override fun onCreate(savedInstanceState: Bundle?) &#123; ... // Start a coroutine in the lifecycle scope lifecycleScope.launch &#123; // repeatOnLifecycle launches the block in a new coroutine every time the // lifecycle is in the STARTED state (or above) and cancels it when it&#x27;s STOPPED. repeatOnLifecycle(Lifecycle.State.STARTED) &#123; // Trigger the flow and start listening for values. // Note that this happens when lifecycle is STARTED and stops // collecting when the lifecycle is STOPPED latestNewsViewModel.uiState.collect &#123; uiState -&gt; // New value received when (uiState) &#123; is LatestNewsUiState.Success -&gt; showFavoriteNews(uiState.news) is LatestNewsUiState.Error -&gt; showError(uiState.exception) &#125; &#125; &#125; &#125; &#125;&#125; 这些看起来和 LiveData 类似： StateFlow 需要将初始状态传递给构造函数，而 LiveData 不需要。 当 View 进入 STOPPED 状态时，LiveData.observe() 会自动取消注册使用方，而从 StateFlow 或任何其他数据流收集数据的操作并不会自动停止。如需实现相同的行为，您需要从 Lifecycle.repeatOnLifecycle 块收集数据流。 说白了就是数据一直在产生，LiveData observe 的时候本身就是在可见时，才进行回调。而 collect 会一直回调，需要结合 repeatOnLifecycle 一块使用。关于冷流、热流的概念，现在还很模糊，只能后面边用边摸索了~ 总的来说，Flow 非常强大，能做的事情也很多。所以网上也有说法：出了 Flow 就可以废弃 LiveData 了。这个可以看一下凯哥的视频LiveData：还没普及就让我去世？我去你的 Kotlin 协程。简而言之，我们可以有很多种技术来实现某一些特定的场景，并不一定就得是 A 技术替换 B 技术。萝卜白菜，各有所爱。当然我们还是得依据自身场景，尽量使用主流的技术。 续一把正好就用到 Flow 来做了一把倒计时的需求： 1234567891011121314151617private fun exitCountDown() &#123; lifecycleScope.launch &#123; flow &#123; for (i in 5 downTo 1) &#123; emit(i) delay(1000) &#125; &#125;.onStart &#123; viewBinding.countDownCl.visibility = View.VISIBLE viewBinding.appVersionTv.text = &quot;Version$&#123;SystemUtils.getVersionName()&#125;&quot; &#125;.onCompletion &#123; exit() &#125;.collect &#123; viewBinding.countDownTv.text = it.toString() &#125; &#125;&#125; 看起来可太简单了，整个流程就在这一个方法里。如果不用 Flow，大概率就是 handler.postDelay，或者 Timer 了，逻辑就会分散在各处，不方便查看。香，真香！另外这里需要注意一下，假设可以中断这个倒计时，那么就会将这个 launch 返回的 job 保存起来，然后调用 job.cancel()，这个时候也会执行 onCompletion 方法。即调用了 job.cancel()，却仍然执行了 exit() 方法，这是不符合预期的。所以需要修改一下代码，就像这样： 12345678910111213141516171819private fun exitCountDown() &#123; lifecycleScope.launch &#123; flow &#123; for (i in 5 downTo 1) &#123; emit(i) delay(1000) &#125; &#125;.onStart &#123; viewBinding.countDownCl.visibility = View.VISIBLE viewBinding.appVersionTv.text = &quot;Version$&#123;SystemUtils.getVersionName()&#125;&quot; &#125;.onCompletion &#123; cause -&gt; if (cause == null) &#123; exit() &#125; &#125;.collect &#123; viewBinding.countDownTv.text = it.toString() &#125; &#125;&#125; 当没有调用 cancel 时，cause 会是 null，代表正常结束。如果调用了 cancel，cause 则会是个 JobCancellationException。 1onCompletion:kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@db2855a 嗯，然后又做了一个网络监听的需求，封装了一个类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253object GlobalNetWorkMonitor &#123; private val context = MucangConfig.getContext() private var listeners = mutableListOf&lt;WeakReference&lt;NetWorkChangeListener?&gt;&gt;() private val connect = callbackFlow &#123; val receiver = object : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; offer(NetworkUtils.isNetworkConnected()) &#125; &#125; val filter = IntentFilter() filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION) context.registerReceiver(receiver, filter) &#125; init &#123; MainScope().launch &#123; connect.collect &#123; if (it) &#123; listeners.forEach &#123; item -&gt; item.get()?.onNetworkConnected() item.clear() &#125; &#125; &#125; &#125; &#125; @JvmStatic fun addListener(listener: NetWorkChangeListener?) &#123; listeners.forEach &#123; if (it.get() == listener) &#123; return &#125; &#125; listeners.add(WeakReference(listener)) &#125; @JvmStatic fun removeListener(listener: NetWorkChangeListener?) &#123; listeners.forEach &#123; if (it.get() == listener) &#123; it.clear() return &#125; &#125; &#125; interface NetWorkChangeListener &#123; fun onNetworkConnected() &#125;&#125; 信心满满的跑了一把，结果网络一发生变化就崩溃了：ClosedSendChannelException: Channel was closed。后面找到原因：Reason is that callbackFlow block closes the (hidden under the hood) channel, as soon, as everything within 123callbackFlow &#123;...&#125; 也就是当括号里的代码执行完了之后， callbackFlow 自动就 close 了，这个时候还去 offer 就会报错，需要添加 awaitClose。于是改成： 123456789101112private val connect = callbackFlow &#123; val receiver = object : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; offer(NetworkUtils.isNetworkConnected()) &#125; &#125; val filter = IntentFilter() filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION) context.registerReceiver(receiver, filter) // 这句是重点，使 flow 一直 active awaitClose &#123; context.unregisterReceiver(receiver) &#125;&#125; 参考Kotlin Flow场景化学习[正确]的使用Kotlin Flow进行搜索优化Android 上的 Kotlin 数据流ClosedSendChannelException for callbackFlow","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Kotlin 协程小实践","date":"2021-10-15T06:34:25.000Z","path":"2021/10/15/corutines/","text":"太久没有注重 Android 开发知识了，打算学习下协程，算是未来的趋势吧。二话不多说，凯哥视频三连~Kotlin 的协程「用力瞥一眼」Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了到底什么是「非阻塞式」挂起？协程真的比线程更轻量级吗？ 站在凯哥的肩膀上，我大概建立了以下几个概念： 协程就是一个线程框架，它可以很方便地进行线程切换； 非阻塞式挂起，也就是协程内部切线程了，所以当前调用协程的线程不会被阻塞，它可以继续做其他的事情。假设协程内部不切线程，那么其实也是阻塞（同步）的； 使用协程可以将异步代码平铺，看起来就像同步代码一样，避免线程切换的各种回调和缩进。 所以当有切线程这样的场景时，就可以使用协程了。 举个栗子一个方案「启用」按钮，点击之后需要告诉服务器：我现在要启用这个方案了，服务器返回成功了之后，需要更新 UI，当前这个方案被启用。同时，这个方案启用了之后，有一些后续的事情需要做：加载这个方案的资源数据，是一个耗时任务。现在看看代码是怎么写的： 1234567891011121314151617holder.viewBinding.enableTv.setOnClickListener &#123; lifecycleScope.launch &#123; val dialog = JLoadingDialog(this@PlanActivity) dialog.showLoading(&quot;正在启用&quot;) val result = enablePlan(item) // 启用成功了才走后面的逻辑 if (result) &#123; PlanUtil.savePlanId(item.id) adapter.notifyDataSetChanged() syncRes() MainThreadUtils.toast(&quot;启用成功&quot;) &#125; else &#123; MainThreadUtils.toast(&quot;启用失败&quot;) &#125; dialog.safeDismiss() &#125;&#125; 然后 2 个 suspend 方法： 1234567891011121314151617181920212223/** * 启用方案 */suspend fun enablePlan(item: PlanItemModel): Boolean &#123; var result = false withContext(Dispatchers.IO) &#123; try &#123; result = PlanApi().enablePlan(item.id) &#125; catch (e: Exception) &#123; LogUtils.e(&quot;TAG&quot;, e.toString()) &#125; &#125; return result&#125;/** * 同步资源 */suspend fun syncRes() &#123; withContext(Dispatchers.IO) &#123; ResourceManager.syncData(null, mutableListOf(ResourceManager.Resource.Plan)) &#125;&#125; 简单看一下，使用 lifecycleScope.launch 开启一个协程，这个协程是在主线程里调用的，那么这个协程的 context 就是 Dispatchers.Main。然后展示一个 loading 弹窗，当前也在主线程，没问题。然后调用 suspend 方法：enablePlan。内部用了 withContext 切换到 IO 线程了，也就是从这个时候开始，线程从主线程切到子线程去了，主线程就是正常的挂起，同时可以处理其他的 UI 消息，并不会阻塞。然后子线程就会去执行网络请求，当网络请求执行完了，就会走到 return result 返回结果。因为用的是协程，所以当协程代码执行完了之后，会自动切回调用协程的那个线程，在这个场景里，也就是主线程了。所以 result 后面的代码就是在主线程了，网络请求成功之后，本地更新数据，并且调用 adapter.notifyDataSetChanged() 更新 UI。这个并不会报错，因为协程自动切回了主线程。随后再切到子线程执行 syncRes() 方法，当这个方法执行完之后，又自动切回主线程然后 Toast 启用成功。可以看到，我们用同步代码块的方式，实现了 2 次主线程、子线程切换的效果，代码平铺，没有任何切换回调和缩进。 日志上面的一顿分析猛如虎，那么实际情况是不是这样呢？打个日志验证一下： 1234567891011121314151617181920holder.viewBinding.enablePlan.setOnClickListener &#123; lifecycleScope.launch &#123; LogUtils.e(&quot;coroutines&quot;, &quot;isMainThread1:&quot; + MainThreadUtils.isMainThread()) val dialog = JLoadingDialog(this@PlanrActivity) dialog.showLoading(&quot;正在启用&quot;) val result = enablePlan(item) LogUtils.e(&quot;coroutines&quot;, &quot;isMainThread5:&quot; + MainThreadUtils.isMainThread()) // 启用成功了才走后面的逻辑 if (result) &#123; PlanUtil.savePlanId(item.id) adapter.notifyDataSetChanged() syncRes() LogUtils.e(&quot;coroutines&quot;, &quot;isMainThread7:&quot; + MainThreadUtils.isMainThread()) MainThreadUtils.toast(&quot;启用成功&quot;) &#125; else &#123; MainThreadUtils.toast(&quot;启用失败&quot;) &#125; dialog.safeDismiss() &#125;&#125; 123456789101112131415161718192021222324252627/** * 启用方案 */suspend fun enablePlan(item: TeachPlanItemModel): Boolean &#123; LogUtils.e(&quot;coroutines&quot;, &quot;isMainThread2:&quot; + MainThreadUtils.isMainThread()) var result = false withContext(Dispatchers.IO) &#123; try &#123; LogUtils.e(&quot;coroutines&quot;, &quot;isMainThread3:&quot; + MainThreadUtils.isMainThread()) result = PlanApi().enablePlan(item.id) &#125; catch (e: Exception) &#123; LogUtils.e(&quot;TAG&quot;, e.toString()) &#125; &#125; LogUtils.e(&quot;coroutines&quot;, &quot;isMainThread4:&quot; + MainThreadUtils.isMainThread()) return result&#125;/** * 同步资源 */suspend fun syncRes() &#123; withContext(Dispatchers.IO) &#123; LogUtils.e(&quot;coroutines&quot;, &quot;isMainThread6:&quot; + MainThreadUtils.isMainThread()) ResourceManager.syncData(null, mutableListOf(ResourceManager.Resource.Plan)) &#125;&#125; 看下打的日志： 1234567isMainThread1:trueisMainThread2:trueisMainThread3:falseisMainThread4:trueisMainThread5:trueisMainThread6:falseisMainThread7:true 可以看到，完全符合分析，只有被 withContext(Dispatchers.IO) 包裹的代码是运行在子线程的。enablePlan 这个方法，就可以理解为：起一个子线程做耗时任务，任务执行完之后返回结果。就有点像带返回值的线程，也就是 Java 里的 Callable + FutureTask 的组合。后续可以研究一下内部实现。 小结 协程切换线程之后，会自动切回调用的线程，假设我们用正常的代码写这样的功能，大概会是这样：12345678910111213141516171819202122232425262728293031323334353637holder.viewBinding.enablePlan.setOnClickListener &#123; val dialog = JLoadingDialog(this@PlanActivity) dialog.showLoading(&quot;正在启用&quot;) // 切线程 ThreadUtils.execute &#123; try &#123; val result = PlanApi().enablePlan(item.id) if (result) &#123; // 我再切 MainThreadUtils.post &#123; PlanUtil.savePlanId(item.id) adapter.notifyDataSetChanged() // 我还切 ThreadUtils.execute &#123; ResourceManager.syncData(null, mutableListOf(ResourceManager.Resource.Plan)) // 我切切切 MainThreadUtils.post &#123; MainThreadUtils.toast(&quot;启用成功&quot;) &#125; &#125; &#125; &#125; else &#123; MainThreadUtils.post &#123; dialog.safeDismiss() &#125; MainThreadUtils.toast(&quot;启用失败&quot;) &#125; &#125; catch (e: Exception) &#123; MainThreadUtils.post &#123; dialog.safeDismiss() &#125; MainThreadUtils.toast(&quot;启用失败&quot;) &#125; &#125;&#125; 这线程切得也太累了，这个场景还非常简单，假设场景再复杂一点，写起来就更麻烦了。可能有人会说，协程的方式单独写了 2 个方法，所以看起来简洁一点，如果把正常的代码也封装下方法，其实也差不多了。我只能说：too young too simple，naive!不使用协程，手动切换线程所带来的回调和缩进，是很难避免的。 suspend 方法只是一个标记，标记这个方法是协程方法，需要在协程里进行调用。假设 suspend 方法体内部没有用到任何协程的代码，那么这个标记是可以去掉的，不要把它想得太玄乎。 挂起其实就是切线程切走了，所以当前线程不会被阻塞，可以继续做其他的事情。但是一个网络请求，总是会有一个线程去等待请求返回结果的，结果返回之前，这个线程就会一直等待，也就是阻塞了，没有任何方法或者途径，可以减去这个线程的开销。 使用带生命周期感知功能的 scope，比如 lifecycleScope，可以当生命周期不可见的时候，自行取消线程回调。假设 enablePlan 接口执行 10 秒钟超时了，而 activity 在第 3 秒的时候就关闭了，那么当接口执行完之后就不切回到主线程了，也就是 return result（包括更后面的代码）压根就不执行了，这样可以避免一些问题，就和 Handler postDelay 需要做保护一样的道理。 总得来说，协程用起来相当的方便，后续我应该会持续学习并使用协程，最近出的 Flow 听说也很不错。路漫漫其修远兮啊~~~","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"科二考试系统-评判","date":"2021-07-14T08:10:06.000Z","path":"2021/07/14/gps-4/","text":"继上篇文章，通过高精度数据可以知道当前车辆的位置，结合考试地图建立好坐标系。那么车辆在这个地图中的一切行为轨迹都将是可以计算的，可以想象成一张蜘蛛网中蜘蛛的移动。那么接下来就是要利用这些数据来做评判了：判断当前车辆是否压线，以及打灯的时长是否足够等等。 信号评判信号评判是通过车辆信号来做条件评判，看是否需要扣分。举个栗子： 123456789101112131415161718/** * 进入直角转弯项目后，未关闭转向灯 */public class K2_ZhiJiaoZhuanWan_305100_Event extends OneDeductEvent&lt;K2ZhiJiaoZhuanWanConfig&gt; &#123; @Override protected boolean handleSuccess(SignalGetter signal, ExamProcessor processor, StepHandler stepEvent) &#123; ZhiJiaoStateData data = stepEvent.getStepData(); setDoNotExecute(true); if (data.checker.isTurnLeft &amp;&amp; signal.getCar().isLightOn(Light.TurnLeftLight)) &#123; return false; &#125; if (!data.checker.isTurnLeft &amp;&amp; signal.getCar().isLightOn(Light.TurnRightLight)) &#123; return false; &#125; return true; &#125;&#125; 当项目开始后，检测项开始检测是否需要扣分。如果是左转弯，进项目时不能打右转灯；如果是右转弯，进项目是时不能打左转灯。根据产品需求，需要写很多这样类似的评判，覆盖到方方面面。 碰撞评判信号只是最基础的一类评判，在科二考试系统中还有个最重要的一种评判就是「碰撞评判」，通俗解释就是车子是否压线，这个线可以是实际考场中的一条线，也可以是产品需求定义的一条虚拟的线。前面的多篇文章，获取高精度数据就是为了实现「碰撞评判」。通过建立坐标系，将整个地图绘制成各种类型的线（包括曲线），同时将车子建模，可以近似当成一个矩形。那么压线就可以抽象成一个数学题了：矩形是否与线段（或直线）相交。于是便有了很多的数学模型及工具类方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * 坐标系中的点，基本对象 */public class Pos implements Serializable &#123; public double x; public double y; /** * z坐标表示高度，只是用来暂存高度，不会做处理 */ public double z; public Pos() &#123; &#125; public Pos(double x, double y) &#123; this(x, y, 0); &#125; public Pos(double x, double y, double z) &#123; this.x = x; this.y = y; this.z = z; &#125; public Pos(Pos pos) &#123; this(pos.x, pos.y, pos.z); &#125; /** * 平移 */ public Pos translate(double dx, double dy) &#123; x += dx; y += dy; return this; &#125; /** * 从这个点指向pos的向量，返回一个新的Pos */ public Pos vectorTo(Pos pos) &#123; Pos vec = new Pos(pos); vec.translate(-x, -y); return vec; &#125; /** * 缩放 */ public Pos scale(double scale) &#123; x *= scale; y *= scale; return this; &#125; /** * 点乘另一个向量，都表示以原点为起点的向量。 * 点乘的数学意义是，对于向量a、b: * a.dot(b) = distance(a,0)*distance(b,0)*cos(ab) * 即点乘等于a的模乘以b的模乘以a和b的夹角的cos * 进一步的：dot = a.dot(b), * 1、当dot&gt;0，说明a和b的夹角绝对值小于90度 * 2、当dot=0，说明a和b垂直 * 3、当dot&lt;0，说明a和b的夹角的绝对值大于90度，小于180度 * * @param b 另一个向量 * @return 内积，点乘 */ public double dot(Pos b) &#123; return x * b.x + y * b.y; &#125; /** * 叉乘一个向量，都表示以原点为起点的向量。 * 叉乘的数学意义是，axb : 根据右手螺旋法则从a向量转向b向量，形成的一个法向量，其模为： * |a×b|=|a||b|sin&lt; a, b&gt; * 进一步的，在右手坐标系中， c = a.cross(b) * 1.当c&gt;0时，b在a的左边 * 2.当c=0时，a和b共线 * 3.当c&lt;0时，b在a的右边 * * @param b 向量b * @return 返回一个标量，这其实是一个z轴上的一个向量 */ public double cross(Pos b) &#123; return x * b.y - y * b.x; &#125; /** * 到另一个点的距离：二维欧式距离 */ public double distanceTo(Pos pos) &#123; double dx = x - pos.x; double dy = y - pos.y; return Math.sqrt(dx * dx + dy * dy); &#125; /** * 到另一个点的角度, 返回弧度 */ public double angleTo(Pos pos) &#123; return Math.atan2(pos.y - y, pos.x - x); &#125; /** * 和新的点求平均值 */ public Pos meanWith(Pos pos) &#123; x = (x + pos.x) * 0.5; y = (y + pos.y) * 0.5; z = (z + pos.z) * 0.5; return this; &#125; /** * 坐标旋转 */ public Pos rotate(double cosA, double sinA) &#123; double sx = x; double sy = y; this.x = sx * cosA - sy * sinA; this.y = sx * sinA + sy * cosA; return this; &#125; /** * 以 center 为中心旋转A度 */ public Pos rotate(Pos center, double cosA, double sinA) &#123; // 先平移到0点 double sx = x - center.x; double sy = y - center.y; // 然后旋转 double nx = sx * cosA - sy * sinA; double ny = sx * sinA + sy * cosA; // 然后再平移回来 this.x = nx + center.x; this.y = ny + center.y; return this; &#125; /** * 二维的模 */ public double model() &#123; return Math.sqrt(x * x + y * y); &#125; /** * 两个向量的夹角，当前pos和vector都表示向量。返回弧度。可以减少一个sqrt运算 */ public double vectorAngle(Pos vector) &#123; return Math.acos(dot(vector) / (Math.sqrt((x * x + y * y) * (vector.x * vector.x + vector.y * vector.y)))); &#125;&#125; 线： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752/** * 直线 */public class Line implements Serializable &#123; /** * 起点 */ public Pos start; /** * 结束点 */ public Pos end; /** * 线宽 */ public double lineWidth;&#125;/** * 基于左手坐标系，线段的工具类 */public class LineUtils &#123; /** * 硬编码，速度可以快一倍。明确坐标系 */ private static final boolean HardCode = true; public static final double THRESHOLD = 0.45 * 100; /** * 计算平均值 */ public static Pos calMiddle(List&lt;Pos&gt; posList) &#123; Pos middle = new Pos(); for (Pos p : posList) &#123; middle.x += p.x; middle.y += p.y; middle.z += p.z; &#125; middle.x /= posList.size(); middle.y /= posList.size(); middle.z /= posList.size(); return middle; &#125; /** * 求两条直线的交点.如果两直线共线，则返回null */ public static Pos getCrossPoint(Pos p11, Pos p12, Pos p21, Pos p22) &#123; // 直线方程是 A * x + B * y + C = 0; double A1 = p12.y - p11.y; double B1 = p11.x - p12.x; double C1 = (p12.x - p11.x) * p11.y - (p12.y - p11.y) * p11.x; double A2 = p22.y - p21.y; double B2 = p21.x - p22.x; double C2 = (p22.x - p21.x) * p21.y - (p22.y - p21.y) * p21.x; // 法向量的叉乘 double D = A1 * B2 - A2 * B1; // 说明共线 if (Math.abs(D) &lt; 1e-20) &#123; return null; &#125; double x = (B1 * C2 - B2 * C1) / D; double y = (C1 * A2 - C2 * A1) / D; double z; double dx = p12.x - p11.x; double dy = p12.y - p11.y; if (Math.abs(dx) &gt; 1e-8) &#123; z = (x - p11.x) / dx * (p12.z - p11.z) + p11.z; &#125; else &#123; z = (y - p11.y) / dy * (p12.z - p11.z) + p11.z; &#125; return new Pos(x, y, z); &#125; public static Pos getCrossPoint(Line line1, Line line2) &#123; return getCrossPoint(line1.start, line1.end, line2.start, line2.end); &#125; /** * 根据两条直线，获取调整的点 */ public static Pos getTrimPos(Pos p1, Pos p2, Pos target, double distance) &#123; return getPosFromThreePos(getPointOnExtend(p1, target, distance), target, getPointOnExtend(p2, target, distance)); &#125; /** * 根据矩形的3个点，求第四个点.这三个点是顺序的,p2是中间点 */ public static Pos getPosFromThreePos(Pos p1, Pos p2, Pos p3) &#123; double angle = p2.angleTo(p1); double cos = Math.cos(-angle); double sin = Math.sin(-angle); Pos p11 = new Pos(p1).rotate(p2, cos, sin); Pos p31 = new Pos(p3).rotate(p2, cos, sin); Pos pos = new Pos(p11.x, p31.y, (p11.z + p3.z) * 0.5); return pos.rotate(p2, cos, -sin); &#125; /** * 点在两点所在直线之间 */ public static boolean isBetweenTwoPoint(Pos pos, Pos start, Pos end) &#123; return (start.x - pos.x) * (pos.x - end.x) &gt;= 0 &amp;&amp; (start.y - pos.y) * (pos.y - end.y) &gt;= 0; &#125; public static boolean isBetweenTwoPoint(double x, double y, Pos start, Pos end) &#123; return (start.x - x) * (x - end.x) &gt;= 0 &amp;&amp; (start.y - y) * (y - end.y) &gt;= 0; &#125; /** * 点是否在直线上,单位都是厘米 */ public static boolean isOnLine(Pos point, Pos pos1, Pos pos2, Pos target, Matrix matrix) &#123; double threshold = Scale.t(THRESHOLD); float[] values = new float[9]; matrix.getValues(values); threshold *= 1 / Math.sqrt(values[0] * values[0] + values[1] * values[1]); // 如果离第1个点近 if (point.distanceTo(pos1) &lt; threshold * 1.5) &#123; target.setPos(pos1); return true; &#125; // 如果离第2个点近 if (point.distanceTo(pos2) &lt; threshold * 1.5) &#123; target.setPos(pos2); return true; &#125; // 如果垂足在两个点之间，并且离直线很近 Pos footer = getFooter(point, pos1, pos2); if (footer.x &lt;= pos2.x &amp;&amp; footer.x &gt;= pos1.x || footer.x &lt;= pos1.x &amp;&amp; footer.x &gt;= pos2.x) &#123; double distance = footer.distanceTo(point); Log.e(&quot;TAG&quot;, &quot;distance is &quot; + distance + &quot; , threshold : &quot; + threshold); return distance &lt;= threshold; &#125; return false; &#125; /** * 点击点是距离线的距离,单位都是厘米 * * @param target 点击位置，如果距离端点很近，默认为端点；如果很远，且在线段之间，默认为触摸点 */ public static double clickDistanceToLine(Pos point, Pos pos1, Pos pos2, Pos target, double threshold) &#123; // 如果离第1个点近 double distance = point.distanceTo(pos1); if (distance &lt;= threshold) &#123; target.setPos(pos1); return distance; &#125; // 如果离第2个点近 distance = point.distanceTo(pos2); if (distance &lt;= threshold) &#123; target.setPos(pos2); return distance; &#125; // 如果垂足在两个点之间，并且离直线很近 Pos footer = getFooter(point, pos1, pos2); if ((footer.x - pos1.x) * (pos2.x - footer.x) &gt;= 0 &amp;&amp; (footer.y - pos1.y) * (pos2.y - footer.y) &gt;= 0) &#123; distance = footer.distanceTo(point); if (distance &lt;= threshold) &#123; target.setPos(point); return distance; &#125; &#125; return 100000000000.; &#125; /** * 计算点到其他两点所在直线的垂足坐标 * * @param pt 要计算的点 * @param beginPt 直线点1 * @param endPt 直线点2 */ public static Pos getFooter(Pos pt, Pos beginPt, Pos endPt) &#123; double dx = beginPt.x - endPt.x; double dy = beginPt.y - endPt.y; // 如果两点离得非常近 if (Math.abs(dx) &lt; 1e-8 &amp;&amp; Math.abs(dy) &lt; 1e-8) &#123; return new Pos(beginPt); &#125; double u = (pt.x - beginPt.x) * (beginPt.x - endPt .x) + (pt.y - beginPt.y) * (beginPt.y - endPt.y); u = u / (dx * dx + dy * dy); double x = beginPt.x + u * dx; double y = beginPt.y + u * dy; double z; if (Math.abs(dx) &gt; 1e-8) &#123; z = (beginPt.x - x) / dx * (endPt.z - beginPt.z) + beginPt.z; &#125; else &#123; z = (beginPt.y - y) / dy * (endPt.z - beginPt.z) + beginPt.z; &#125; return new Pos(x, y, z); &#125; /** * 垂点在两点之间 */ public static boolean footerIsOnLine(Pos pt, Pos beginPt, Pos endPt, Pos footer) &#123; double dx = beginPt.x - endPt.x; double dy = beginPt.y - endPt.y; // 如果两点离得非常近 if (Math.abs(dx) &lt; 1e-8 &amp;&amp; Math.abs(dy) &lt; 1e-8) &#123; return false; &#125; double u = (pt.x - beginPt.x) * (beginPt.x - endPt .x) + (pt.y - beginPt.y) * (beginPt.y - endPt.y); u = u / (dx * dx + dy * dy); double x = beginPt.x + u * dx; double y = beginPt.y + u * dy; // 如果要向外传垂足，则设置垂足位置 if (footer != null) &#123; footer.setPos(x, y); &#125; return (beginPt.x - x) * (x - endPt.x) &gt;= 0 &amp;&amp; (beginPt.y - y) * (y - endPt.y) &gt;= 0; &#125; /** * 计算点到直线的距离 */ public static double getDistanceToLine(Pos pt, Pos beginPt, Pos endPt) &#123; // 先求垂点坐标 double dx = beginPt.x - endPt.x; double dy = beginPt.y - endPt.y; // 如果两点离得非常近 if (Math.abs(dx) &lt; 1e-8 &amp;&amp; Math.abs(dy) &lt; 1e-8) &#123; return pt.distanceTo(beginPt); &#125; double u = (pt.x - beginPt.x) * (beginPt.x - endPt .x) + (pt.y - beginPt.y) * (beginPt.y - endPt.y); u = u / (dx * dx + dy * dy); double x = beginPt.x + u * dx; double y = beginPt.y + u * dy; dx = x - pt.x; dy = y - pt.y; // 然后计算两个点的距离 return Math.sqrt(dx * dx + dy * dy); &#125; /** * 计算点到直线的距离的平方，这样用来比较的时候不用开方，只需要外部被比较的做个平方就行，可以极大减小计算量 */ public static double getDistanceToLineSquare(Pos pt, Pos beginPt, Pos endPt, double[] xy) &#123; // 先求垂点坐标 double dx = beginPt.x - endPt.x; double dy = beginPt.y - endPt.y; // 如果两点离得非常近 if (Math.abs(dx) &lt; 1e-8 &amp;&amp; Math.abs(dy) &lt; 1e-8) &#123; dx = pt.x - beginPt.x; dy = pt.y - beginPt.y; xy[0] = beginPt.x + dx * 0.5; xy[1] = beginPt.y + dy * 0.5; return dx * dx + dy * dy; &#125; double u = (pt.x - beginPt.x) * (beginPt.x - endPt .x) + (pt.y - beginPt.y) * (beginPt.y - endPt.y); u = u / (dx * dx + dy * dy); double x = beginPt.x + u * dx; double y = beginPt.y + u * dy; dx = x - pt.x; dy = y - pt.y; xy[0] = x; xy[1] = y; // 然后计算两个点的距离 return dx * dx + dy * dy; &#125; /** * 点到线的距离的平方 */ public static double getDistanceToLineSquare(Pos pt, Pos beginPt, Pos endPt) &#123; // 先求垂点坐标 double dx = beginPt.x - endPt.x; double dy = beginPt.y - endPt.y; // 如果两点离得非常近 if (Math.abs(dx) &lt; 1e-8 &amp;&amp; Math.abs(dy) &lt; 1e-8) &#123; dx = pt.x - beginPt.x; dy = pt.y - beginPt.y; return dx * dx + dy * dy; &#125; double u = (pt.x - beginPt.x) * (beginPt.x - endPt .x) + (pt.y - beginPt.y) * (beginPt.y - endPt.y); u = u / (dx * dx + dy * dy); double x = beginPt.x + u * dx; double y = beginPt.y + u * dy; dx = x - pt.x; dy = y - pt.y; // 然后计算两个点的距离 return dx * dx + dy * dy; &#125; /** * 在线段的延长线上根据给定距离取一个点。这个距离可以是负值，这样就是在线段内部取一点了 * 只保证水平距离，垂直的不考虑 */ public static Pos getPointOnExtend(Pos start, Pos end, double distance) &#123; double dx = end.x - start.x; double dy = end.y - start.y; double dz = end.z - start.z; double a = Math.sqrt(dx * dx + dy * dy + 1e-100); double x = distance * dx / a + end.x; double y = distance * dy / a + end.y; double z = distance * dz / a + end.z; return new Pos(x, y, z); &#125; /** * 两点之间取一个点 * 只保证水平距离，垂直的不考虑 */ public static Pos getPointOnLine(Pos start, Pos end, double distance) &#123; double dx = end.x - start.x; double dy = end.y - start.y; double dz = end.z - start.z; double a = Math.sqrt(dx * dx + dy * dy + 1e-100); double x = distance * dx / a + start.x; double y = distance * dy / a + start.y; double z = distance * dz / a + start.z; return new Pos(x, y, z); &#125; /** * 两条曲线是否相交,都是不闭合的曲线 */ public static boolean isCurveCross(List&lt;Pos&gt; posList1, List&lt;Pos&gt; posList2) &#123; // 先判断边界是否相交 Bound bound1 = bounds(posList1); Bound bound2 = bounds(posList2); if (bound1.isNotCross(bound2)) &#123; return false; &#125; for (int i = 0; i &lt; posList1.size() - 1; i++) &#123; Pos p1 = posList1.get(i); Pos p2 = posList1.get(i + 1); for (int j = 0; j &lt; posList2.size() - 1; j++) &#123; if (isLineCross(p1, p2, posList2.get(j), posList2.get(j + 1))) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 求曲线边界：xy的最大最小值，结果是：minX,minY,maxX,maxY */ public static Bound bounds(List&lt;Pos&gt; posList) &#123; double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, maxX = -Double.MAX_VALUE, maxY = -Double.MAX_VALUE; for (Pos p : posList) &#123; if (minX &gt; p.x) &#123; minX = p.x; &#125; if (minY &gt; p.y) &#123; minY = p.y; &#125; if (maxX &lt; p.x) &#123; maxX = p.x; &#125; if (maxY &lt; p.y) &#123; maxY = p.y; &#125; &#125; return new Bound(minX, minY, maxX, maxY); &#125; public static Bound bound(Line line) &#123; double minX = line.start.x, minY = line.start.y, maxX = line.start.x, maxY = line.start.y; Pos p = line.end; if (minX &gt; p.x) &#123; minX = p.x; &#125; if (minY &gt; p.y) &#123; minY = p.y; &#125; if (maxX &lt; p.x) &#123; maxX = p.x; &#125; if (maxY &lt; p.y) &#123; maxY = p.y; &#125; return new Bound(minX, minY, maxX, maxY); &#125; /** * 判断两线段是否相交 */ public static boolean isLineCross(Pos p11, Pos p12, Pos p21, Pos p22) &#123; if (p11 == null || p12 == null || p21 == null || p22 == null) &#123; return false; &#125; if (Math.max(p21.x, p22.x) &lt; Math.min(p11.x, p12.x)) &#123; return false; &#125; if (Math.max(p11.x, p12.x) &lt; Math.min(p21.x, p22.x)) &#123; return false; &#125; if (Math.max(p21.y, p22.y) &lt; Math.min(p11.y, p12.y)) &#123; return false; &#125; if (Math.max(p11.y, p12.y) &lt; Math.min(p21.y, p22.y)) &#123; return false; &#125; double y2221 = p22.y - p21.y; double x2211 = p22.x - p11.x; double y2211 = p22.y - p11.y; double x2212 = p22.x - p12.x; double y2212 = p22.y - p12.y; double x2221 = p22.x - p21.x; if ((x2211 * y2221 - y2211 * x2221) * (x2212 * y2221 - y2212 * x2221) &gt; 0) &#123; return false; &#125; double x2111 = p21.x - p11.x; double y1211 = p12.y - p11.y; double y2111 = p21.y - p11.y; double x1211 = p12.x - p11.x; if ((x2111 * y1211 - y2111 * x1211) * (x2211 * y1211 - y2211 * x1211) &gt; 0) &#123; return false; &#125; return true; &#125; /** * 判断两线段是否相交 */ public static boolean isLineCross(double p11_x, double p11_y, double p12_x, double p12_y, double p21_x, double p21_y, double p22_x, double p22_y) &#123; if (Math.max(p21_x, p22_x) &lt; Math.min(p11_x, p12_x)) &#123; return false; &#125; if (Math.max(p11_x, p12_x) &lt; Math.min(p21_x, p22_x)) &#123; return false; &#125; if (Math.max(p21_y, p22_y) &lt; Math.min(p11_y, p12_y)) &#123; return false; &#125; if (Math.max(p11_y, p12_y) &lt; Math.min(p21_y, p22_y)) &#123; return false; &#125; double y2221 = p22_y - p21_y; double x2211 = p22_x - p11_x; double y2211 = p22_y - p11_y; double x2212 = p22_x - p12_x; double y2212 = p22_y - p12_y; double x2221 = p22_x - p21_x; if ((x2211 * y2221 - y2211 * x2221) * (x2212 * y2221 - y2212 * x2221) &gt; 0) &#123; return false; &#125; double x2111 = p21_x - p11_x; double y1211 = p12_y - p11_y; double y2111 = p21_y - p11_y; double x1211 = p12_x - p11_x; if ((x2111 * y1211 - y2111 * x1211) * (x2211 * y1211 - y2211 * x1211) &gt; 0) &#123; return false; &#125; return true; &#125; /** * 线段是否和曲线(由一系列点构成的曲线)相交，曲线是否闭合 */ public static boolean isCurveCross(Pos p1, Pos p2, List&lt;Pos&gt; path, boolean pathIsClose) &#123; for (int i = 0; i &lt; path.size() - 1; i++) &#123; if (isLineCross(p1, p2, path.get(i), path.get(i + 1))) &#123; return true; &#125; &#125; // 如果路线是闭合的，则再算一次第一个点和最后一个点的连线 if (pathIsClose) &#123; return isLineCross(p1, p2, path.get(0), path.get(path.size() - 1)); &#125; return false; &#125; /** * 根据两点和线宽，得到4个点:从p1到p2，得到一个矩形，矩形的长是p1到p2，宽是width，垂直于直线p1p2 * 为直线准备 */ public static Rectangle getRectWithLineCenter(Pos p1, Pos p2, double width) &#123; double h = width * 0.5; double a = p2.x - p1.x; double b = p2.y - p1.y; double ab = Math.sqrt(a * a + b * b + 1e-100); double ah = a * h / ab; double bh = b * h / ab; double y1 = p1.y + ah; double x1 = p1.x - bh; double y4 = p1.y - ah; double x4 = p1.x + bh; double y2 = y1 + b; double x2 = x1 + a; double y3 = y4 + b; double x3 = x4 + a; return new Rectangle( new Pos(x1, y1), new Pos(x2, y2), new Pos(x3, y3), new Pos(x4, y4)); &#125; /** * 在两点的右边构建一个矩形 * 根据两点和线宽，得到4个点：以start为起点，end为结束点，start-end为一边，在右边构建一个另一边为width的矩形 */ public static Rectangle getRectWithLineRight(Pos start, Pos end, double width) &#123; if (HardCode) &#123; Line pingxing = getLineAtRight(start, end, width); return new Rectangle(new Pos(start), pingxing.start, pingxing.end, new Pos(end)); &#125; double dx = end.x - start.x; double dy = end.y - start.y; double angle = Math.atan2(dy, dx) + Math.PI * 0.5; double x2 = start.x + width * Math.cos(angle); double y2 = start.y + width * Math.sin(angle); double x3 = x2 + dx; double y3 = y2 + dy; return new Rectangle(new Pos(start), new Pos(x2, y2), new Pos(x3, y3), new Pos(end)); &#125; /** * 在两点的左边构建一个矩形 * 根据两点和线宽，得到4个点：以start为起点，end为结束点，start-end为一边，在左边构建一个另一边为width的矩形 */ public static Rectangle getRectWithLineLeft(Pos start, Pos end, double width) &#123; if (HardCode) &#123; Line pingxing = getLineAtLeft(start, end, width); return new Rectangle(new Pos(start), pingxing.start, pingxing.end, new Pos(end)); &#125; double dx = end.x - start.x; double dy = end.y - start.y; double angle = Math.atan2(dy, dx) - Math.PI * 0.5; double x2 = start.x + width * Math.cos(angle); double y2 = start.y + width * Math.sin(angle); double x3 = x2 + dx; double y3 = y2 + dy; return new Rectangle(new Pos(start), new Pos(x2, y2), new Pos(x3, y3), new Pos(end)); &#125; /** * 在两点的右边构建一条平行线，给定距离 */ public static Line getLineAtRight(Pos start, Pos end, double distance) &#123; if (HardCode) &#123; return getLine(start, end, distance, false); &#125; double dx = end.x - start.x; double dy = end.y - start.y; double angle = Math.atan2(dy, dx) + Math.PI * 0.5; double x2 = start.x + distance * Math.cos(angle); double y2 = start.y + distance * Math.sin(angle); double x3 = x2 + dx; double y3 = y2 + dy; return new Line(new Pos(x2, y2), new Pos(x3, y3)); &#125; /** * 简单的将曲线向右或向左移动，只取中点，不考虑微小变形 */ public static List&lt;Pos&gt; moveLines(List&lt;Pos&gt; list, double distance, boolean atLeft) &#123; List&lt;Pos&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size() - 1; i++) &#123; Line line = LineUtils.getLine(list.get(i), list.get(i + 1), distance, atLeft); if (i == 0) &#123; result.add(line.start); &#125; else &#123; // 简单处理，只求均值，不求交点，因为曲线一般弯曲程度不大 Pos last = result.get(result.size() - 1); last.meanWith(line.start); &#125; result.add(line.end); &#125; return result; &#125; /** * 在两点的左边构建一个平行线，给定距离 */ public static Line getLineAtLeft(Pos start, Pos end, double distance) &#123; if (HardCode) &#123; return getLine(start, end, distance, true); &#125; double dx = end.x - start.x; double dy = end.y - start.y; double angle = Math.atan2(dy, dx) - Math.PI * 0.5; double x2 = start.x + distance * Math.cos(angle); double y2 = start.y + distance * Math.sin(angle); double x3 = x2 + dx; double y3 = y2 + dy; return new Line(new Pos(x2, y2), new Pos(x3, y3)); &#125; /** * 采用解方程的方式求平行线，时间比夹角的方式快一倍 */ public static Line getLine(Pos start, Pos end, double distance, boolean atLeft) &#123; double a = end.x - start.x; double b = end.y - start.y; double ab = Math.sqrt(a * a + b * b + 1e-100); double distanceAB = distance / ab; double y1 = start.y + a * distanceAB; double x1 = start.x - b * distanceAB; double y4 = start.y - a * distanceAB; double x4 = start.x + b * distanceAB; double x, y; // 根据向量叉乘检测哪一个在左边 double cross = (end.x - start.x) * (y1 - start.y) - (end.y - start.y) * (x1 - start.x); if (atLeft) &#123; if (cross &lt; 0) &#123; x = x1; y = y1; &#125; else &#123; x = x4; y = y4; &#125; &#125; else &#123; if (cross &gt; 0) &#123; x = x1; y = y1; &#125; else &#123; x = x4; y = y4; &#125; &#125; return new Line( new Pos(x, y, start.z), new Pos(x + a, y + b, end.z)); &#125; /** * 获取右边的rect */ public static Rectangle getRectAtRight(Pos start, Pos end, double width) &#123; double a = end.x - start.x; double b = end.y - start.y; double ab = Math.sqrt(a * a + b * b + 1e-100); double y1 = start.y + a * width / ab; double x1 = start.x - b * width / ab; double y4 = start.y - a * width / ab; double x4 = start.x + b * width / ab; double x, y; // 根据向量叉乘检测哪一个在右边 if ((end.x - start.x) * (y1 - start.y) - (end.y - start.y) * (x1 - start.x) &gt; 0) &#123; x = x1; y = y1; &#125; else &#123; x = x4; y = y4; &#125; return new Rectangle( new Pos(start), new Pos(x, y), new Pos(x + a, y + b), new Pos(end)); &#125; /** * 求两个向量的外积。这两个向量是:p1-p2,p1-p。结果的正负号表示从p1-p2到p1-p的相对关系（左边，右边，还是共线） */ public static double getCross(Pos p1, Pos p2, Pos p) &#123; return (p2.x - p1.x) * (p.y - p1.y) - (p.x - p1.x) * (p2.y - p1.y); &#125; /** * 在角平分线上取一个点，可以是负数，负数表示在外面 */ public static Pos createPosAtMean(Pos start, Pos middle, Pos end, double distance) &#123; if (start == null || end == null || middle == null) &#123; return null; &#125; double angle1 = middle.angleTo(start); double angle2 = middle.angleTo(end); double angle = Math.atan2(Math.sin(angle1) + Math.sin(angle2), Math.cos(angle1) + Math.cos(angle2)); return new Pos(middle.x + distance * Math.cos(angle), middle.y + distance * Math.sin(angle), (start.z + end.z) * 0.5); &#125;&#125; 三角形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * 三角形 */public class Triangle &#123; public final Pos p1; public final Pos p2; public final Pos p3; public final List&lt;Pos&gt; posList; /** * 外心 */ public final Pos center; /** * 外接圆半径 */ public final float radius; public Triangle(Pos p1, Pos p2, Pos p3) &#123; this.p1 = p1; this.p2 = p2; this.p3 = p3; posList = new ArrayList&lt;&gt;(); posList.add(p1); posList.add(p2); posList.add(p3); center = calculateCenter(); radius = (float) Math.max(center.distanceTo(p1), Math.max(center.distanceTo(p2), center.distanceTo(p3))); &#125; private Pos calculateCenter() &#123; double fm = 2 * ((p3.y - p2.y) * (p2.x - p1.x) - (p2.y - p1.y) * (p3.x - p2.x)); if (fm == 0) &#123; //这样就用中心来模拟 return new Pos((p1.x + p2.x + p3.x) / 3, (p1.y + p2.y + p3.y) / 3); &#125; else &#123; double m1 = p1.x * p1.x + p1.y * p1.y; double m2 = p2.x * p2.x + p2.y * p2.y; double m3 = p3.x * p3.x + p3.y * p3.y; double d1 = m2 - m1; double d2 = m3 - m2; double x = (p3.y - p2.y) * d1 - (p2.y - p1.y) * d2; double y = (p2.x - p1.x) * d2 - (p3.x - p2.x) * d1; return new Pos(x / fm, y / fm); &#125; &#125; /** * 某个点是否在里面 */ public boolean contains(Pos pos) &#123; return RectangleUtils.pnpoly(pos, posList); &#125; /** * 是否相交 */ public boolean trigger(CarPos car) &#123; //距离大于两个外切圆，则必定不相交 if (center.distanceTo(car.center) &gt; radius + car.carRect.maxRadius + 1) &#123; return false; &#125; if (cross(car.carRect.pos2, car.carRect.pos3)) &#123; return true; &#125; if (cross(car.carRect.pos3, car.carRect.pos4)) &#123; return true; &#125; if (cross(car.carRect.pos4, car.carRect.pos1)) &#123; return true; &#125; if (cross(car.carRect.pos1, car.carRect.pos2)) &#123; return true; &#125; if (RectangleUtils.contains(car.carRect, center)) &#123; return true; &#125; if (contains(car.center)) &#123; return true; &#125; return false; &#125; /** * 是否和直线相交 */ public boolean cross(Pos pos1, Pos pos2) &#123; ///如果外心到线的距离超过半径，则不会相交 if (LineUtils.getDistanceToLine(center, pos1, pos2) &gt; radius) &#123; return false; &#125; if (contains(pos1)) &#123; return true; &#125; if (contains(pos2)) &#123; return true; &#125; if (LineUtils.isLineCross(p1, p2, pos1, pos2)) &#123; return true; &#125; if (LineUtils.isLineCross(p2, p3, pos1, pos2)) &#123; return true; &#125; if (LineUtils.isLineCross(p3, p1, pos1, pos2)) &#123; return true; &#125; return false; &#125;&#125; 矩形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267/** * 矩形:由四个顺序点决定的矩形 */public class Rectangle &#123; public final Pos pos1; public final Pos pos2; public final Pos pos3; public final Pos pos4; public final Bound bound; public double maxRadius; public double minDistance; public final List&lt;Pos&gt; posList; public final Pos center; public Rectangle(Pos pos1, Pos pos2, Pos pos3, Pos pos4) &#123; this.pos1 = pos1; this.pos2 = pos2; this.pos3 = pos3; this.pos4 = pos4; posList = new ArrayList&lt;&gt;(); posList.add(pos1); posList.add(pos2); posList.add(pos3); posList.add(pos4); bound = bounds(posList); maxRadius = Math.max(pos1.distanceTo(pos3), pos2.distanceTo(pos4)) * 0.5; minDistance = Math.min(pos1.distanceTo(pos2), pos2.distanceTo(pos3)) * 0.5; center = new Pos(pos1).meanWith(pos3); &#125; public void reset(Pos pos1, Pos pos2, Pos pos3, Pos pos4) &#123; this.pos1.setPos(pos1); this.pos2.setPos(pos2); this.pos3.setPos(pos3); this.pos4.setPos(pos4); bound.set(bounds(posList)); maxRadius = Math.max(pos1.distanceTo(pos3), pos2.distanceTo(pos4)) * 0.5; minDistance = Math.min(pos1.distanceTo(pos2), pos2.distanceTo(pos3)) * 0.5; center.setPos(new Pos(pos1).meanWith(pos3)); &#125; /** * 求这个矩形的中心点:求1、3的中点或者2、4的中点都可以 */ public Pos center() &#123; return center; &#125; /** * 求曲线边界：xy的最大最小值，结果是：minX,minY,maxX,maxY */ public static Bound bounds(List&lt;Pos&gt; posList) &#123; double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, maxX = -Double.MAX_VALUE, maxY = -Double.MAX_VALUE; for (Pos p : posList) &#123; if (minX &gt; p.x) &#123; minX = p.x; &#125; if (minY &gt; p.y) &#123; minY = p.y; &#125; if (maxX &lt; p.x) &#123; maxX = p.x; &#125; if (maxY &lt; p.y) &#123; maxY = p.y; &#125; &#125; return new Bound(minX, minY, maxX, maxY); &#125;&#125;/** * 矩形计算工具类 */public class RectangleUtils &#123; /** * 两个矩形是否相交:有一条边相交，或者包含 */ public static boolean isCross(Rectangle self, Rectangle rect) &#123; if (contains(self, rect.center())) &#123; return true; &#125; if (contains(rect, self.center())) &#123; return true; &#125; Pos[] me = &#123;self.pos1, self.pos2, self.pos3, self.pos4&#125;; Pos[] other = &#123;rect.pos1, rect.pos2, rect.pos3, rect.pos4&#125;; for (int i = 0; i &lt; me.length; i++) &#123; Pos p1 = me[i]; Pos p2; if (i == me.length - 1) &#123; p2 = me[0]; &#125; else &#123; p2 = me[i + 1]; &#125; for (int j = 0; j &lt; other.length; j++) &#123; Pos p21 = other[j]; Pos p22; if (j == other.length - 1) &#123; p22 = other[0]; &#125; else &#123; p22 = other[j + 1]; &#125; if (LineUtils.isLineCross(p1, p2, p21, p22)) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 是否和曲线相交,计算矩形的每一条边是否和曲线相交 * * @param path 曲线 * @param pathIsClose 曲线是否闭合，比如车身是闭合的，一般的曲线是不闭合的 */ public static boolean isCross(Rectangle self, List&lt;Pos&gt; path, boolean pathIsClose) &#123; if (LineUtils.isCurveCross(self.pos1, self.pos2, path, pathIsClose)) &#123; return true; &#125; if (LineUtils.isCurveCross(self.pos2, self.pos3, path, pathIsClose)) &#123; return true; &#125; if (LineUtils.isCurveCross(self.pos3, self.pos4, path, pathIsClose)) &#123; return true; &#125; return LineUtils.isCurveCross(self.pos4, self.pos1, path, pathIsClose); &#125; /** * 是否和线段相交:有一条边相交,或者包含了其中的一个点 */ public static boolean isCross(Rectangle self, Pos p1, Pos p2) &#123; double minX = Math.min(p1.x, p2.x); double minY = Math.min(p1.y, p2.y); double maxX = Math.max(p1.x, p2.x); double maxY = Math.max(p1.y, p2.y); if (minX &gt; self.bound.maxX) &#123; return false; &#125; if (minY &gt; self.bound.maxY) &#123; return false; &#125; if (maxX &lt; self.bound.minX) &#123; return false; &#125; if (maxY &lt; self.bound.minY) &#123; return false; &#125; if (contains(self, p1)) &#123; return true; &#125; if (contains(self, p2)) &#123; return true; &#125; if (LineUtils.isLineCross(self.pos1, self.pos2, p1, p2)) &#123; return true; &#125; if (LineUtils.isLineCross(self.pos2, self.pos3, p1, p2)) &#123; return true; &#125; if (LineUtils.isLineCross(self.pos3, self.pos4, p1, p2)) &#123; return true; &#125; if (LineUtils.isLineCross(self.pos4, self.pos1, p1, p2)) &#123; return true; &#125; return false; &#125; /** * 矩形是否包含某个点 */ public static boolean contains(Rectangle self, Pos p) &#123; return LineUtils.getCross(self.pos1, self.pos2, p) * LineUtils.getCross(self.pos3, self.pos4, p) &gt;= 0 &amp;&amp; LineUtils.getCross(self.pos2, self.pos3, p) * LineUtils.getCross(self.pos4, self.pos1, p) &gt;= 0; &#125; /** * 矩形是否包含某个点，并且点不在边线上 */ public static boolean containsFull(Rectangle self, Pos p) &#123; return LineUtils.getCross(self.pos1, self.pos2, p) * LineUtils.getCross(self.pos3, self.pos4, p) &gt; 0 &amp;&amp; LineUtils.getCross(self.pos2, self.pos3, p) * LineUtils.getCross(self.pos4, self.pos1, p) &gt; 0; &#125; /** * 判断一个点是否在多边形内部（PNPOLY算法） * &lt;p&gt; * int pnpoly(int n, float pos_x, float pos_y, float (*vert)[2]) * &#123; * int i, j, c = 0; * &lt;p&gt; * for (i = 0, j = n - 1; i &lt; n; j = i++) * &#123; * if (((vert[i][1] &gt; pos_y) != (vert[j][1] &gt; pos_y)) &amp;&amp; * (pos_x &lt; (vert[j][0] - vert[i][0]) * (pos_y - vert[i][1]) / (vert[j][1] - vert[i][1]) + vert[i][0])) * &#123; * c = !c; * &#125; * &#125; * &lt;p&gt; * return c; * &#125; */ public static boolean pnpoly(Pos pos, List&lt;Pos&gt; posList) &#123; int i, j; boolean contains = false; double pos_x = pos.x; double pos_y = pos.y; int n = posList.size(); for (i = 0, j = n - 1; i &lt; n; j = i++) &#123; Pos pos_i = posList.get(i); Pos pos_j = posList.get(j); if (((pos_i.y &gt; pos_y) != (pos_j.y &gt; pos_y)) &amp;&amp; (pos_x &lt; (pos_j.x - pos_i.x) * (pos_y - pos_i.y) / (pos_j.y - pos_i.y) + pos_i.x)) &#123; contains = !contains; &#125; &#125; return contains; &#125; /** * 求点距离矩形的最近距离 */ public static double distanceToPos(Rectangle rectangle, Pos centerPos) &#123; if (contains(rectangle, centerPos)) &#123; return -1; &#125; double min = Math.min(LineUtils.getDistanceToLine(centerPos, rectangle.pos1, rectangle.pos2), LineUtils.getDistanceToLine(centerPos, rectangle.pos2, rectangle.pos3)); min = Math.min(min, LineUtils.getDistanceToLine(centerPos, rectangle.pos3, rectangle.pos4)); min = Math.min(min, LineUtils.getDistanceToLine(centerPos, rectangle.pos4, rectangle.pos1)); return min; &#125; /** * 根据两条线段的两个端点来组成一个矩形，跟两个端点的顺序无关 */ public static Rectangle createRect(Pos line1Pos1, Pos line1Pos2, Pos line2Pos1, Pos line2Pos2) &#123; if (LineUtils.isLineCross(line1Pos1, line2Pos2, line1Pos2, line2Pos1)) &#123; return new Rectangle(line1Pos1, line1Pos2, line2Pos2, line2Pos1); &#125; return new Rectangle(line1Pos1, line1Pos2, line2Pos1, line2Pos2); &#125;&#125; 将车子抽象成一个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 车子的实时位置数据 */public class CarPos implements Serializable &#123; /** * 车子周身的若干个点 */ public List&lt;Pos&gt; carPoints; /** * 前定位点 */ public Pos front; /** * 后定位点 */ public Pos back; /** * 航向角，角度 */ public double degree; /** * 左前轮 */ public Pos wheelLeftFront; /** * 左后轮 */ public Pos wheelLeftBack; /** * 右前轮 */ public Pos wheelRightFront; /** * 右后轮 */ public Pos wheelRightBack; /** * 上一次的左前轮 */ public Pos wheelLeftFrontLast; /** * 上一次的左后轮 */ public Pos wheelLeftBackLast; /** * 上一次的右前轮 */ public Pos wheelRightFrontLast; /** * 上一次的右后轮 */ public Pos wheelRightBackLast; /** * 前点,车头最靠近中间的点 */ public Pos headerPoint; /** * 尾点，车位最靠近中间的点 */ public Pos tailPoint; /** * 车子的中心点,这个算起来估计有点麻烦 */ public Pos center; /** * 上一次的中心点 */ public Pos lastCenter; /** * 车子的俯仰角 */ public double pitch; /** * 车子的最小外包矩形：二维渲染的时候要用，三维不需要 * &lt;p&gt; * p1,p2,p3,p4的结构是:&lt;br/&gt; * &lt;p&gt; * p4*******************************p3&lt;br/&gt; * 车尾*****back*******front*******车头&lt;br/&gt; * p1*******************************p2&lt;br/&gt; */ public Rectangle carRect; /** * 边界矩形,用来初步判断是否相交 */ public Bound bound; /** * 外扩后的边界矩形,用来初步判断是否相交 */ public Bound bigBound;&#125; 然后车子碰撞的工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538/** * 车辆碰撞工具 */public class CarPosUtils &#123; private static final int DefaultLineWidthSquare = 15 * 15; /** * 车子是否和曲线接触 */ public static boolean carTouchPath(CarPos car, List&lt;Pos&gt; path) &#123; return carTouchPath(car, path, 1); &#125; /** * 和曲线相交的时候，可以选择步长，不用每个点都测试，因为曲线在很短的距离内，可以认为近似直线 */ public static boolean carTouchPath(CarPos car, List&lt;Pos&gt; path, int step) &#123; if (CollectionUtils.isEmpty(path)) &#123; return false; &#125; for (int i = 0; i &lt; path.size() - step; i += step) &#123; Pos p1 = path.get(i); int next = i + step; next = Math.min(next, path.size() - 1); Pos p2 = path.get(next); double minX = Math.min(p1.x, p2.x); double maxX = Math.max(p1.x, p2.x); double minY = Math.min(p1.y, p2.y); double maxY = Math.max(p1.y, p2.y); if (maxX &lt; car.bound.getMinX()) &#123; continue; &#125; if (minX &gt; car.bound.getMaxX()) &#123; continue; &#125; if (minY &gt; car.bound.getMaxY()) &#123; continue; &#125; if (maxY &lt; car.bound.getMinY()) &#123; continue; &#125; // 如果不和矩形接触，也不检查 if (!RectangleUtils.isCross(car.carRect, p1, p2)) &#123; continue; &#125; if (carTouchLine(car, p1, p2)) &#123; return true; &#125; &#125; return false; &#125; /** * 轮子是否和曲线触碰 */ public static boolean wheelTriggerPath(CarPos carPos, List&lt;Pos&gt; path) &#123; for (int i = 0; i &lt; path.size() - 1; i++) &#123; if (LineUtils.isLineCross(carPos.wheelLeftFront, carPos.wheelRightFront, path.get(i), path.get(i + 1)) || LineUtils.isLineCross(carPos.wheelLeftBack, carPos.wheelRightBack, path.get(i), path.get(i + 1))) &#123; return true; &#125; &#125; return false; &#125; /** * 前轮是否触线 */ public static boolean frontWheelTriggerLine(CarPos carPos, Line line) &#123; return wheelTriggerLine(carPos.wheelLeftFront, carPos.wheelLeftFrontLast, carPos.wheelRightFront, carPos.wheelRightFrontLast, line.start, line.end); &#125; /** * 后轮是否触线 */ public static boolean backWheelTriggerLine(CarPos carPos, Line line) &#123; return wheelTriggerLine(carPos.wheelRightBack, carPos.wheelRightBackLast, carPos.wheelLeftBack, carPos.wheelLeftBackLast, line.start, line.end); &#125; /** * 指定的轮子是否碰线 */ public static boolean wheelTouchLine(Wheel wheel, CarPos carPos, Line line) &#123; if (wheel == Wheel.LeftBack) &#123; return LineUtils.isLineCross(carPos.wheelLeftBack, carPos.wheelLeftBackLast, line.start, line.end); &#125; else if (wheel == Wheel.LeftFront) &#123; return LineUtils.isLineCross(carPos.wheelLeftFront, carPos.wheelLeftFrontLast, line.start, line.end); &#125; else if (wheel == Wheel.RightFront) &#123; return LineUtils.isLineCross(carPos.wheelRightFront, carPos.wheelRightFrontLast, line.start, line.end); &#125; else &#123; return LineUtils.isLineCross(carPos.wheelRightBack, carPos.wheelRightBackLast, line.start, line.end); &#125; &#125; private static boolean wheelTriggerLine(Pos p11, Pos p12, Pos p21, Pos p22, Pos start, Pos end) &#123; if (LineUtils.isLineCross(p11, p12, start, end)) &#123; return true; &#125; if (LineUtils.isLineCross(p21, p22, start, end)) &#123; return true; &#125; return false; &#125; /** * 碰到这根线的是哪个轮子.轮子和线的距离必须小于一定值 */ public static Wheel touchLineWheel(CarPos carPos, Line line) &#123; return touchLineWheel(carPos, line.start, line.end); &#125; private static void set(Pos src, Pos dst) &#123; dst.x = (int) src.x; dst.y = (int) src.y; dst.z = (int) src.z; &#125; private static class ThreadPos &#123; private ThreadLocal&lt;Pos&gt; posRef = new ThreadLocal&lt;&gt;(); Pos get() &#123; Pos pos = posRef.get(); if (pos == null) &#123; pos = new Pos(); posRef.set(pos); &#125; return pos; &#125; &#125; /** * 点的缓存 */ private static final ThreadPos ref1 = new ThreadPos(); private static final ThreadPos ref2 = new ThreadPos(); private static final ThreadPos ref3 = new ThreadPos(); private static final ThreadPos ref4 = new ThreadPos(); public static Wheel touchLineWheel(CarPos carPos, Pos start, Pos end) &#123; // 精确到整数 Pos p11 = ref1.get(); Pos p12 = ref2.get(); Pos p21 = ref3.get(); Pos p22 = ref4.get(); set(start, p21); set(end, p22); set(carPos.wheelLeftFront, p11); set(carPos.wheelLeftFrontLast, p12); // 碰到前轮了 if (LineUtils.isLineCross(p11, p12, p21, p22)) &#123; return Wheel.LeftFront; &#125; set(carPos.wheelRightFront, p11); set(carPos.wheelRightFrontLast, p12); if (LineUtils.isLineCross(p11, p12, p21, p22)) &#123; return Wheel.RightFront; &#125; set(carPos.wheelRightBack, p11); set(carPos.wheelRightBackLast, p12); if (LineUtils.isLineCross(p11, p12, p21, p22)) &#123; return Wheel.RightBack; &#125; set(carPos.wheelLeftBack, p11); set(carPos.wheelLeftBackLast, p12); if (LineUtils.isLineCross(p11, p12, p21, p22)) &#123; return Wheel.LeftBack; &#125; set(carPos.wheelLeftFront, p11); set(carPos.wheelRightFront, p12); if (LineUtils.isLineCross(p11, p12, p21, p22)) &#123; double leftDistance = LineUtils.getDistanceToLineSquare(carPos.wheelLeftFront, start, end); double rightDistance = LineUtils.getDistanceToLineSquare(carPos.wheelRightFront, start, end); if (leftDistance &gt; rightDistance &amp;&amp; rightDistance &lt; DefaultLineWidthSquare) &#123; return Wheel.RightFront; &#125; else if (leftDistance &lt; DefaultLineWidthSquare) &#123; return Wheel.LeftFront; &#125; &#125; set(carPos.wheelLeftBack, p11); set(carPos.wheelRightBack, p12); if (LineUtils.isLineCross(p11, p12, p21, p22)) &#123; double leftDistance = LineUtils.getDistanceToLineSquare(carPos.wheelLeftBack, start, end); double rightDistance = LineUtils.getDistanceToLineSquare(carPos.wheelRightBack, start, end); if (leftDistance &gt; rightDistance &amp;&amp; rightDistance &lt; DefaultLineWidthSquare) &#123; return Wheel.RightBack; &#125; else if (leftDistance &lt; DefaultLineWidthSquare) &#123; return Wheel.LeftBack; &#125; &#125; return Wheel.None; &#125; /** * 轮子是否触碰曲线 */ public static Wheel touchPathWheel(CarPos carPos, List&lt;Pos&gt; posList) &#123; for (int i = 0; i &lt; posList.size() - 1; i++) &#123; Wheel wheel = touchLineWheel(carPos, posList.get(i), posList.get(i + 1)); if (wheel != Wheel.None) &#123; return wheel; &#125; &#125; return Wheel.None; &#125; /** * 车子和四边形是否重合 */ public static boolean carIsCrossWithRectangle(CarPos carPos, Rectangle rect) &#123; if (carPos.bound.isNotCross(rect.bound)) &#123; return false; &#125; Pos rectCenter = rect.center(); /* * 如果中心距离大于两个半径之和，必然不会相交 */ if (carPos.center.distanceTo(rectCenter) &gt; rect.maxRadius + carPos.carRect.maxRadius + 0.01) &#123; return false; &#125; // 外包矩形必然相交，否则不会相交 if (!RectangleUtils.isCross(carPos.carRect, rect)) &#123; return false; &#125; if (RectangleUtils.contains(rect, carPos.center)) &#123; return true; &#125; // 依次判断每个点，是否相连 for (int i = 0; i &lt; carPos.carPoints.size(); i++) &#123; Pos p1 = carPos.carPoints.get(i); Pos p2; if (i == carPos.carPoints.size() - 1) &#123; p2 = carPos.carPoints.get(0); &#125; else &#123; p2 = carPos.carPoints.get(i + 1); &#125; if (LineUtils.getDistanceToLine(rectCenter, p1, p2) &gt; rect.maxRadius) &#123; continue; &#125; if (RectangleUtils.contains(rect, p1)) &#123; return true; &#125; final List&lt;Pos&gt; posList = rect.posList; for (int k = 0; k &lt; posList.size(); k++) &#123; Pos p11 = posList.get(k); Pos p12; if (k == posList.size() - 1) &#123; p12 = posList.get(0); &#125; else &#123; p12 = posList.get(k + 1); &#125; if (LineUtils.isLineCross(p11, p12, p1, p2)) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 车子是否完全在矩形内，没有边重合 */ public static boolean carIsInRectangleFull(CarPos carPos, Rectangle rect) &#123; if (carPos.bound.isNotCross(rect.bound)) &#123; return false; &#125; /* * 如果中心距离大于矩形最大半径，必然不会相交 */ if (carPos.center.distanceTo(rect.center()) &gt; rect.maxRadius + carPos.carRect.maxRadius) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.center)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.wheelLeftBack)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.wheelLeftFront)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.wheelRightBack)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.wheelRightFront)) &#123; return false; &#125; // 如果车子的外包矩形完全在矩形内，也可以 if (rectIsInRectangleFull(carPos.carRect, rect)) &#123; return true; &#125; for (Pos p : carPos.carPoints) &#123; if (!RectangleUtils.containsFull(rect, p)) &#123; return false; &#125; &#125; return true; &#125; /** * 一个矩形完全在另一个矩形里面 */ public static boolean rectIsInRectangleFull(Rectangle carPos, Rectangle rect) &#123; if (carPos.bound.isNotCross(rect.bound)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.pos1)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.pos2)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.pos3)) &#123; return false; &#125; if (!RectangleUtils.containsFull(rect, carPos.pos4)) &#123; return false; &#125; return true; &#125; /** * 车身是否触线，在做这个检测之前，会先检测bound是否相交 */ public static boolean carBodyTouchLine(CarPos carPos, Line line) &#123; return carBodyTouchLine(carPos, line.start, line.end); &#125; /** * 车身是否触线，在做这个检测之前，会先检测bound是否相交 */ public static boolean carBodyTouchLine(CarPos carPos, Pos start, Pos end) &#123; if (!RectangleUtils.isCross(carPos.carRect, start, end)) &#123; return false; &#125; return LineUtils.isCurveCross(start, end, carPos.carPoints, true); &#125; /** * 车子包含轮子是否触线，在做这个检测之前，会先检测bound是否相交 */ public static boolean carTouchLine(CarPos carPos, Pos start, Pos end) &#123; if (LineUtils.isLineCross(carPos.wheelLeftBack, carPos.wheelRightBack, start, end)) &#123; return true; &#125; if (LineUtils.isLineCross(carPos.wheelLeftFront, carPos.wheelRightFront, start, end)) &#123; return true; &#125; if (LineUtils.isLineCross(carPos.wheelLeftBack, carPos.wheelRightFront, start, end)) &#123; return true; &#125; if (LineUtils.isLineCross(carPos.wheelLeftFront, carPos.wheelRightBack, start, end)) &#123; return true; &#125; return carBodyTouchLine(carPos, start, end); &#125; /** * 车身距离某条直线的距离:将车身数据旋转，然后求最小值 * 当线和车身相交时，会返回负值 */ public static double distanceToLine(CarPos carPos, Line line) &#123; return distanceToLine(carPos, line.start, line.end); &#125; /** * 车身距离某条直线的距离:将车身数据旋转，然后求最小值。 * 当线和车身相交时，会返回负值 * 点的顺序无关 * 点的顺序无关 * 点的顺序无关 */ public static double distanceToLine(CarPos carPos, Pos start, Pos end) &#123; // 先绕直线上任一点旋转 Pos center = new Pos(start).meanWith(end); double theta = start.angleTo(end); // 反方向旋转,使直线和x轴平行 double sinA = Math.sin(-theta); double cosA = Math.cos(-theta); double distanceMin = Double.MAX_VALUE; double distanceMax = -Double.MAX_VALUE; // 然后计算y轴的差值 for (Pos p : carPos.carPoints) &#123; Pos pos = new Pos(p).rotate(center, cosA, sinA); double dis = (pos.y - center.y); if (dis &lt; distanceMin) &#123; distanceMin = dis; &#125; if (dis &gt; distanceMax) &#123; distanceMax = dis; &#125; &#125; // 都大于0 if (distanceMax &gt;= 0 &amp;&amp; distanceMin &gt;= 0) &#123; return distanceMin; &#125; // 都小于0 if (distanceMax &lt;= 0 &amp;&amp; distanceMin &lt;= 0) &#123; return Math.abs(distanceMax); &#125; // 压线了,取绝对值小的那个,并且是负值 return -(Math.min(Math.abs(distanceMax), Math.abs(distanceMin))); &#125; /** * car距离点的最近距离 * * @return 等于-1 代表在车身里面 */ public static double carDistancePos(List&lt;Pos&gt; carPoints, Pos pos) &#123; boolean pnpoly = RectangleUtils.pnpoly(pos, carPoints); if (!pnpoly) &#123; double distance = 0; for (Pos carPoint : carPoints) &#123; double value = carPoint.distanceTo(pos); if (value &lt; distance) &#123; distance = value; &#125; &#125; return distance; &#125; return -1; &#125; /** * 车子是否在远离点 */ public static boolean isFarawayPos(CarPos carPos, Pos center) &#123; // 上一刻的点存在，则使用当前点与上一刻的点的向量，点乘当前的点到 center 的向量，大于 0 说明在远离 if (carPos.wheelLeftFrontLast != null &amp;&amp; carPos.wheelRightFrontLast != null) &#123; Pos last = new Pos(carPos.wheelLeftFrontLast).meanWith(carPos.wheelRightFrontLast); Pos current = new Pos(carPos.wheelLeftFront).meanWith(carPos.wheelRightFront); return current.vectorTo(last).dot(current.vectorTo(center)) &gt; 0; &#125; return carPos.back.vectorTo(carPos.front).dot(carPos.back.vectorTo(center)) &lt; 0; &#125; /** * 车子是否在靠近点 */ public static boolean isNearToPos(CarPos carPos, Pos center) &#123; return carPos.back.vectorTo(carPos.front).dot(carPos.back.vectorTo(center)) &gt; 0; &#125; /** * 车子是否在靠近进入点 */ public static boolean isNearEnterToPos(CarPos carPos, Pos startLineCenter, Pos center) &#123; return carPos.back.vectorTo(carPos.front).dot(startLineCenter.vectorTo(center)) &gt; 0 &amp;&amp; carPos.back.vectorTo(carPos.front).dot(carPos.back.vectorTo(center)) &gt; 0; &#125; /** * 车子是否在倒退的靠近点 */ public static boolean isBackNearToPos(CarPos carPos, Pos center) &#123; return carPos.front.vectorTo(carPos.back).dot(carPos.front.vectorTo(center)) &gt; 0; &#125; /** * 一种非常简单的相交判断，看车身中线是否和线相交，在有些地方需要用 */ public static boolean simpleCrossWithLine(CarPos carPos, Pos p1, Pos p2) &#123; Pos back = new Pos(carPos.carRect.pos1).meanWith(carPos.carRect.pos4); Pos front = new Pos(carPos.carRect.pos2).meanWith(carPos.carRect.pos3); return LineUtils.isLineCross(back, front, p1, p2); &#125; /** * 根据前轮转角，预测倒车时后轮的轨迹。预测n秒轨迹 * * @param n 预测的时间，单位秒 */ public static BackWheelTrackModel calculateTrack(SignalGetter signal, int n) &#123; CarPos carPos = signal.getCarPos(); // 前轮转向角度，一般0-33度，向右为正，向左为负 double wheelAngle = signal.getCar().wheelAngel; // 如果小于这个值 if (Math.abs(wheelAngle) &lt; 1e-5) &#123; wheelAngle = 1e-5 * (wheelAngle &gt;= 0 ? 1 : -1); &#125; final double radius = Math.toRadians(wheelAngle); // 前后轮间距 final double L = (carPos.wheelRightBack.distanceTo(carPos.wheelRightFront) + carPos.wheelLeftBack.distanceTo(carPos.wheelLeftFront)) * 0.5; // 轮子的宽度，以爱丽舍的为标准，相差几厘米关系不大 final double WheelDis = 18.5; // 后轮轮距 final double W = carPos.wheelLeftBack.distanceTo(carPos.wheelRightBack) - WheelDis; // 转弯半径，以前后轮轴心计算，用绝对值 final double R = Math.abs(L / Math.tan(radius)); // 左后轮半径 final double RL = R + W * 0.5 * (wheelAngle &gt;= 0 ? 1 : -1); // 右后轮半径 final double RR = R - W * 0.5 * (wheelAngle &gt;= 0 ? 1 : -1); // 圆心指向后轮轴心的角度 double theta = carPos.degree + 90 * (wheelAngle &gt; 0 ? -1 : 1); theta = Math.toRadians(theta); // 后轮轴心坐标 final Pos backCenter = new Pos(carPos.wheelLeftBack).meanWith(carPos.wheelRightBack); // 圆心坐标 final Pos center = new Pos(backCenter.x + R * Math.sin(-theta), backCenter.y + R * Math.cos(-theta), backCenter.z); // 预测时间间隔，0.2秒 final double time = 0.2; // 一秒采集5次，一共采集5秒，也可以用距离来计算 final int size = (int) (n / time); BackWheelTrackModel track = new BackWheelTrackModel(); track.leftTracks = new ArrayList&lt;&gt;(); track.rightTracks = new ArrayList&lt;&gt;(); // 当前速度,厘米/秒 final double speed = signal.getCar().gpsSpeed * 100 / 3.6; double t = 0; for (int i = 0; i &lt; size; i++) &#123; // 当前时间 t += time; // 在坐标系里的角度 double thetaI = theta - speed * t / R; double cos = Math.cos(thetaI); double sin = Math.sin(thetaI); // 将轨迹添加进去 track.leftTracks.add(new Pos(center.x + RL * sin, center.y + RL * cos, center.z)); track.rightTracks.add(new Pos(center.x + RR * sin, center.y + RR * cos, center.z)); &#125; return track; &#125;&#125; 主要就是一些数学概念：坐标系、点、向量、线、三角形、矩形，然后勾股定理，向量的点乘、叉乘等方法。方法非常多，也不是一下子就写完的，都是业务需求一点点完善，发展到现在这个样子，很多方法还没深入研究它的原理。毕业之后数学便丢得差不多了，现在要捡起来还得费点工夫。依赖上述那些便可以做「碰撞评判」了： 1234567891011121314151617181920/** * 车身出线 */public class K2_ZhiJiaoZhuanWan_305108_Event extends OneDeductEvent&lt;K2ZhiJiaoZhuanWanConfig&gt; &#123; @Override protected boolean handleSuccess(SignalGetter signal, ExamProcessor processor, StepHandler stepEvent) &#123; ZhiJiaoStateData data = stepEvent.getStepData(); if (data.checker.bodyIsTriggerLine) &#123; return false; &#125; return true; &#125;&#125;//检查车身触线bodyIsTriggerLine = CarPosUtils.carBodyTouchLine(carPos, currentData.line23) || CarPosUtils.carBodyTouchLine(carPos, currentData.line34) || CarPosUtils.carBodyTouchLine(carPos, currentData.line56) || CarPosUtils.carBodyTouchLine(carPos, currentData.line61); 总结科二考试系统这个系列文章算是写完了，主要根据项目经验做的一点总结，代码几乎都是些工具类方法，主要还是核心思想。系列文章链接来一波： 关于「引擎」设计的小结 科二考试系统 科二考试系统-续 科二考试系统-矩阵","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"科二考试系统-矩阵","date":"2021-07-13T06:15:30.000Z","path":"2021/07/13/gps-3/","text":"在上篇文章中，遗留一个问题：世界坐标系里的坐标，假设 Pos(1000,1000) 这个点即是相对原点往北 10 米，往东 10 米的一个点，而安卓原点在左上角，如何将这个点绘制在安卓屏幕上呢？其实很简单：直接画。假设屏幕像素为1920*1080，简单一点让地图 MapView 的宽高也是这个，那么这个点就会在屏幕 (1000,1000) 的位置被绘制出来。世界坐标系中的其他所有的点，也都可以这样直接绘制。只是这样绘制之后，某些点可能在 MapView 上看不到而已，但是所有点的相对位置都是对的。接下来就要祭出大杀器「Matrix」了。 数学中的 Matrix 矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合，元素是实数的矩阵称为实矩阵，元素是复数的矩阵称为复矩阵。而行数与列数都等于 n 的矩阵称为 n 阶矩阵或 n 阶方阵。 由 m × n 个数 aij 排成的 m 行 n 列的数表称为 m 行 n 列的矩阵，简称 m × n 矩阵。记作：矩阵有加法：有减法：也可以进行转置：最后还有…乘法。乘以常数：若乘以矩阵，我们要计算行与列的「点积」。第一步：第二步：最后一步：矩阵的乘法，在生活中也有实际的运用。假设一家饼店，各类饼的价格如下： 牛肉派卖￥3一个 鸡肉派卖￥4一个 素菜派卖￥2一个过去 4 天卖饼的数目：如果要得出星期一的销售额：牛肉派的销售额 + 鸡肉派的销售额 + 素菜派的销售额 -&gt; $3×13 + $4×8 + $2×6 &#x3D; $83。最终我们可以得到这样的矩阵运算：如果要统计 4 天的销售额，将结果累加即可。 乘法有了，那除法呢？实际上并不会使用除法，而是使用逆矩阵进行乘法。 A&#x2F;B &#x3D; A × (1&#x2F;B) &#x3D; A × B-1其中 B-1 是 B 的 “逆矩阵”。 矩阵与其逆矩阵相乘，结果是单位矩阵 I： 基本概念了解结束，做下小结： 只有对于两个行数、列数分别相等的矩阵（即同型矩阵），加减法运算才有意义，即加减运算是可行的。加减法满足交换律与结合律； 矩阵与数的乘法满足结合律和分配律； 矩阵与矩阵的乘法，必须满足一个条件：左矩阵的列数＝右矩阵的行数。1 × 3 的矩阵乘以 3 × 1 的矩阵，结果是 3 × 3 的矩阵，如果反过来则是 1 × 1 的矩阵了，可见矩阵的乘法不满足交换律; 单位矩阵是一个特殊的矩阵，对角线全是1，其他全是0。 安卓中的 Matrix简单在代码中创建一个矩阵，打印出来是这样的： 1Matrix&#123;[1.0, 0.0, 0.0][0.0, 1.0, 0.0][0.0, 0.0, 1.0]&#125; 可以发现，安卓中的默认 Matrix 是一个 3 × 3 的单位矩阵。它各行各列的作用是这样的：第三行的 MPERSP 参数主要在 3D 效果中运用，通常为 [0.0, 0.0, 1.0]，本文不做讲解。安卓矩阵提供四种基本的变换： Translate：平移变换 Rotate：旋转变换 Scale：缩放变换 Skew：错切变换关于这四类基本变换，可以参考Android中图像变换Matrix的原理、代码验证和应用。 你可能注意到了，我们坐标多了一个 1，这是使用了齐次坐标系的缘故，在数学中我们的点和向量都是这样表示的(x, y)，两者看起来一样，计算机无法区分，为此让计算机也可以区分它们，增加了一个标志位，增加之后看起来是这样:(x, y, 1) - 点(x, y, 0) - 向量 然后再来看看 Matrix 提供的方法：这里重点说下，pre 和 post，一个是左乘，一个是右乘，根据前面所说，矩阵的乘法是不具备交换律的，所以一定要注意调用的方法及顺序。 最后最后回到开头，世界坐标系其实并不需要映射，直接绘制在安卓界面上即可。只不过矩阵默认 scale &#x3D; 1，translate &#x3D; 0，就会导致一些点不在界面的可见范围内。但是地图肯定是支持拖动以及缩放的，那么识别具体的手势动作，设置相应的 Matrix 即可进行变换了。在初始化时针对坐标、MapView 的大小，以及原点计算一个缩放比例，调用 postScale 方法即可，可以指定以哪个点进行缩放： 1234567/** * Postconcats the matrix with the specified scale. M&#x27; = S(sx, sy, px, py) * M */public boolean postScale(float sx, float sy, float px, float py) &#123; nPostScale(native_instance, sx, sy, px, py); return true;&#125; 设置矩阵转化前：设置矩阵转化后： 参考 理解矩阵（一） 理解矩阵（二） 理解矩阵（三） 矩阵的运算及其运算规则 矩阵 Android中图像变换Matrix的原理、代码验证和应用 安卓自定义View进阶-Matrix原理","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"科二考试系统-续","date":"2021-07-09T01:46:31.000Z","path":"2021/07/09/gps-2/","text":"上篇文章已经基本把「科二考试系统」的核心思路描述清楚了，接下来记录一下稍微具体的知识点。 建立世界坐标系真实的经纬度点，通过高斯投影转化成平面坐标，需要经过一系列运算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235public class ProjectConverter &#123; public static final String TAG = &quot;ProjectConverter&quot;; /** * 设置经度中央经线，只能在这个经度附近使用，否则会有非常大的误差&lt;br/&gt; * 经过测试，10公里内的误差是1毫米左右，5公里内的误差是0.5毫米，3公里内的误差是0.1毫米，1公里以内误差是0.01毫米。 * 所以科目二的误差是0.001毫米左右，科目三的误差是0.1毫米左右，不会放大Gps本身的厘米级的误差，完全满足要求. */ public static ProjectConverter createWgs84(double longitude) &#123; return new ProjectConverter(2, longitude, 0, 0, 0); &#125; private double a;//&#x27;椭球体长半轴 private double b;// &#x27;椭球体短半轴 private double f; //&#x27;扁率 private double e;// &#x27;第一偏心率 private double e1; //&#x27;第二偏心率 private double FE;//&#x27;东偏移 private double FN;//&#x27;北偏移 private double L0;//&#x27;中央经度 private double W0;//&#x27;原点纬线 private double k0;//&#x27;比例因子 //一些计算常数 private double e12; private double e14; private double e16; private double e18; private double e2; private double e4; private double e6; private double e8; /** * 说明: 用于初始化转换参数 * * @param tuoqiuCanshu 枚举类型，提供北京54、西安80和WGS84三个椭球参数 * @param centralMeridian 中央经线 * @param OriginLatitude 原点纬度，如果是标准的分幅，则该参数是0 * @param EastOffset 东偏移 * @param NorthOffset 北偏移 */ public ProjectConverter(int tuoqiuCanshu, double centralMeridian, double OriginLatitude, double EastOffset, double NorthOffset) &#123; /** * &#x27;Krassovsky （北京54采用） 6378245 6356863.0188 * &#x27;IAG 75（西安80采用） 6378140 6356755.2882 * &#x27;WGS 84 6378137 6356752.3142 * &#x27;CGC 2000 6378137 6356752.31414 */ if (tuoqiuCanshu == 0)//北京五四 &#123; a = 6378245; b = 6356863.0188; &#125; else if (tuoqiuCanshu == 1)// &#x27;西安八零 &#123; a = 6378140; b = 6356755.2882; &#125; if (tuoqiuCanshu == 2)//&#x27;WGS84 &#123; a = 6378137; b = 6356752.3142; &#125; if (tuoqiuCanshu == 3)//&#x27;CGC2000坐标 &#123; a = 6378137; b = 6356752.31414; &#125; f = (a - b) / a;//扁率 //e = Math.sqrt(1 - MZ((b / a) ,2));//&#x27;第一偏心率 e = Math.sqrt(2 * f - f * f);//&#x27;第一偏心率 //eq = Math.sqrt(MZ((a / b) , 2) - 1);//&#x27;第二偏心率 e1 = e / Math.sqrt(1 - e * e);//&#x27;第二偏心率 L0 = centralMeridian;//中央经 W0 = OriginLatitude;//原点纬线 k0 = 1;//&#x27;比例因子 FE = EastOffset;//东偏移 FN = NorthOffset;//北偏移 e12 = e1 * e1; e14 = e12 * e12; e16 = e14 * e12; e18 = e16 * e12; e2 = e * e; e4 = e2 * e2; e6 = e4 * e2; e8 = e6 * e2; &#125; /** * 左手坐标系&lt;br/&gt; * 左手坐标系&lt;br/&gt; * 左手坐标系&lt;br/&gt; * 经纬度坐标转高斯投影坐标, 输出单位是厘米 */ public Pos gpsToGauss(Gps gps) &#123; double[] xy = gpsToGauss(gps.longitude, gps.latitude); return new Pos(xy[1] * 100, xy[0] * 100, gps.altitude * 100); &#125; /** * 左手坐标系&lt;br/&gt; * 左手坐标系&lt;br/&gt; * 左手坐标系&lt;br/&gt; * 高斯投影坐标 转为 经纬度坐标, pos的单位是厘米 */ public Gps gaussToGps(Pos pos) &#123; double[] gps = gaussToGps(pos.y * 0.01, pos.x * 0.01); return new Gps(gps[1], gps[0], pos.z * 0.01); &#125; /** * 经纬度坐标转高斯投影坐标,单位是米 * * @param longitude 经度 * @param latitude 纬度 * 把x的方向设置成和经度一致 */ public double[] gpsToGauss(double longitude, double latitude) &#123; //&#x27;给出经纬度坐标，转换为高克投影坐标 double[] resultP = new double[2]; final double BR = (latitude - W0) * Math.PI / 180;//纬度弧长 final double lo = (longitude - L0) * Math.PI / 180; //经差弧度 double sinBR = Math.sin(BR); double cosBR = Math.cos(BR); double eSinBr = e * sinBR; double N = a / Math.sqrt(1 - eSinBr * eSinBr); //卯酉圈曲率半径 //求解参数s double B0; double B2; double B4; double B6; double B8; double C = a * a / b; B0 = 1 - 3 * e12 / 4 + 45 * e14 / 64 - 175 * e16 / 256 + 11025 * e18 / 16384; B2 = B0 - 1; B4 = 15. / 32 * e14 - 175. / 384 * e16 + 3675. / 8192 * e18; B6 = 0 - 35. / 96 * e16 + 735. / 2048 * e18; B8 = 315. / 1024 * e18; double cos2 = cosBR * cosBR; double cos3 = cos2 * cosBR; double cos5 = cos2 * cos3; double cos7 = cos2 * cos5; double s = C * (B0 * BR + sinBR * (B2 * cosBR + B4 * cos3 + B6 * cos5 + B8 * cos7)); double t = Math.tan(BR); double g = e1 * cosBR; double lo2 = lo * lo; double lo3 = lo2 * lo; double lo4 = lo2 * lo2; double lo5 = lo4 * lo; double lo6 = lo2 * lo4; double t2 = t * t; double t4 = t2 * t2; double g2 = g * g; double g4 = g2 * g2; final double x = s + lo2 / 2 * N * sinBR * cosBR + lo4 * N * sinBR * cos3 / 24 * (5 - t2 + 9 * g2 + 4 * g4) + lo6 * N * sinBR * cos5 * (61 - 58 * t2 + t4) / 720; final double y = lo * N * cosBR + lo3 * N / 6 * cos3 * (1 - t2 + g2) + lo5 * N / 120 * cos5 * (5 - 18 * t2 + t4 + 14 * g2 - 58 * g2 * t2); resultP[0] = y + FE; resultP[1] = x + FN; return resultP; &#125; /** * 高斯投影坐标 转为 经纬度坐标，单位是度 * * @param X 高斯投影坐标X，单位是米 * @param Y 高斯投影坐标Y，单位是米 * @return 第一个是经度，第二个是纬度 */ public double[] gaussToGps(double X, double Y) &#123; //&#x27;给出高克投影坐标，转换为经纬度坐标 double[] resultP = new double[2]; double e_1_2 = Math.sqrt(1 - e2); double El1 = (1 - e_1_2) / (1 + e_1_2); double Mf = (Y - FN) / k0;//真实坐标值 double Q = Mf / (a * (1 - e2 / 4 - 3 * e4 / 64 - 5 * e6 / 256));//角度 double el2 = El1 * El1; double el3 = el2 * El1; double el4 = el3 * El1; double Bf = Q + (3 * El1 / 2 - 27 * el3 / 32) * Math.sin(2 * Q) + (21 * el2 / 16 - 55 * el4 / 32) * Math.sin(4 * Q) + (151 * el3 / 96) * Math .sin(6 * Q) + 1097. / 512 * el4 * Math.sin(8 * Q); double sinBf = Math.sin(Bf); double cosBf = Math.cos(Bf); double eSinBf = e * sinBf; double eSinBf2 = eSinBf * eSinBf; double _eSinBf2 = 1 - eSinBf2; double _eSinBf2_3 = _eSinBf2 * _eSinBf2 * _eSinBf2; double Rf = a * (1 - e2) / Math.sqrt(_eSinBf2_3); double Nf = a / Math.sqrt(1 - eSinBf2);//卯酉圈曲率半径 double tanBf = Math.tan(Bf); double Tf = tanBf * tanBf; double D = (X - FE) / (k0 * Nf); double Cf = e12 * cosBf * cosBf; double D2 = D * D; double D3 = D2 * D; double D4 = D2 * D2; double D5 = D4 * D; double D6 = D4 * D2; double Tf2 = Tf * Tf; double Cf2 = Cf * Cf; double B = Bf - Nf * tanBf / Rf * ( D2 / 2 - (5 + 3 * Tf + 10 * Cf - 9 * Tf * Cf - 4 * Cf2 - 9 * e12) * D4 / 24 + (61 + 90 * Tf + 45 * Tf2 - 256 * e12 - 3 * Cf2) * D6 / 720); double L = L0 * Math.PI / 180 + 1 / cosBf * (D - (1 + 2 * Tf + Cf) * D3 / 6 + (5 - 2 * Cf + 28 * Tf - 3 * Cf2 + 8 * e12 + 24 * Tf2) * D5 / 120); double Bangle = B * 180 / Math.PI; double Langle = L * 180 / Math.PI; resultP[0] = Langle;//RW * 180 / Math.PI; resultP[1] = Bangle + W0;//RJ * 180 / Math.PI; return resultP; &#125;&#125; 需要一个测试方法，验证数据转换的准确性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 标准测试&lt;br/&gt; * 测试方式：先定义一系列随机gps点，然后将gps点转到xy点，然后在xy平面绕中心点旋转给定角度 * 然后再把旋转后的xy平面点转换到gps点，遍历每，计算所有点相关之间的距离关系 */public static void standardTest() &#123; //首先给一个中心点 Gps center = new Gps(36, 111); List&lt;Gps&gt; srcGpsList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; srcGpsList.add( new Gps(center.latitude + 0.03 * (Math.random() * 0.7 + 0.3) * (Math.random() &gt; 0.5 ? 1 : -1), center.longitude + 0.03 * (Math.random() * 0.7 + 0.3) * (Math.random() &gt; 0.5 ? 1 : -1))); &#125; double longitude = 0; for (Gps g : srcGpsList) &#123; longitude += g.longitude; &#125; longitude /= srcGpsList.size(); ProjectConverter converter = createWgs84(longitude); List&lt;Pos&gt; srcPosList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; srcGpsList.size(); i++) &#123; srcPosList.add(converter.gpsToGauss(srcGpsList.get(i))); &#125; double x = 0; double y = 0; for (Pos p : srcPosList) &#123; x += p.x; y += p.y; &#125; Pos c = new Pos(x / srcPosList.size(), y / srcPosList.size()); List&lt;Pos&gt; rotatePosList = new ArrayList&lt;&gt;(); final double angle = 37; double sinA = Math.sin(Math.toRadians(angle)); double cosA = Math.cos(Math.toRadians(angle)); for (Pos p : srcPosList) &#123; Pos pos = new Pos(p.x, p.y); pos.rotate(c, cosA, sinA); rotatePosList.add(pos); &#125; List&lt;Gps&gt; rotateGpsList = new ArrayList&lt;&gt;(); for (Pos p : rotatePosList) &#123; rotateGpsList.add(converter.gaussToGps(p)); &#125; for (int i = 0; i &lt; srcGpsList.size(); i++) &#123; for (int j = 0; j &lt; srcGpsList.size(); j++) &#123; if (i == j) &#123; continue; &#125; Log.e(TAG, &quot;-----------&quot;); double disijGps = srcGpsList.get(i).distanceTo(srcGpsList.get(j)); double disijGauss = srcPosList.get(i).distanceTo(srcPosList.get(j)) * 0.01;//厘米转为米 double disijGaussR = rotatePosList.get(i).distanceTo(rotatePosList.get(j)) * 0.01;//厘米转为米 double disijGpsR = rotateGpsList.get(i).distanceTo(rotateGpsList.get(j)); Log.e(TAG, &quot;差值(毫米) : &quot; + ((int) ((disijGps - disijGauss) * 100000)) / 100f + &quot; : &quot; + ((int) ((disijGps - disijGaussR) * 100000)) / 100.f + &quot; , &quot; + ((int) ((disijGps - disijGpsR) * 100000)) / 100.f + &quot; , &quot; + ((int) ((disijGauss - disijGaussR) * 100000)) / 100.f + &quot; , &quot; + ((int) ((disijGauss - disijGpsR) * 100000)) / 100.f + &quot; , &quot; + ((int) ((disijGaussR - disijGpsR) * 100000)) / 100.f); Log.e(TAG, &quot;原GPS距离 = &quot; + disijGps + &quot; , 原高斯距离 = &quot; + disijGauss + &quot; , 旋转后GPS距离 = &quot; + disijGpsR + &quot; , 旋转后高斯距离 = &quot; + disijGaussR); &#125; &#125;&#125; 设置一个经度子午线，后面计算出来的平面坐标误差会非常低，完全可以接受。结果乘以 100，将米转成厘米，同时转到左手坐标系。得到坐标之后，相对原点做一个偏移，就能得到这个「世界坐标系」中每个点的坐标了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DefaultConverter implements Converter &#123; /** * 投影 */ private final ProjectConverter converter; /** * 原点 */ private final Pos zero; private final Gps zeroGps; public Gps getZeroGps() &#123; return zeroGps; &#125; public DefaultConverter(Gps gps) &#123; zeroGps = new Gps(gps); converter = ProjectConverter.createWgs84(gps.longitude); zero = converter.gpsToGauss(gps); &#125; /** * 经过原点的平移 * * @param gps gps坐标 * @return */ @Override public Pos gpsToGauss(Gps gps) &#123; return converter.gpsToGauss(gps).translate(-zero.x, -zero.y); &#125; /** * 经过原点平移回去 * * @param pos 平面坐标 * @return */ @Override public Gps gaussToGps(Pos pos) &#123; return converter.gaussToGps(new Pos(pos).translate(zero)); &#125;&#125; 左右手坐标系这个概念我琢磨了好久，到现在也还没有彻底搞清楚。参考左手坐标系 vs 右手坐标系，假设 Z 轴是屏幕往内，X 轴方向保持一致时，可以看到 Y 轴是相反的。所以左右手坐标系，在相对 2D 的 场景里，会影响 Y 轴的值，右手坐标系需要取反。在科二里，某些评判是需要方向的，比如直角转弯分左直角和右直角，我们通过「世界坐标系」中直角项目的的 3 个点（3 个点，指定一个原点，剩下 2 个点分别代表 X、Y 轴的方向）建立「我的坐标系」，就有可能是左手，也有可能是右手。所以在整个场景中，尽量以左手坐标系为默认坐标系，某些特殊情况需要右手坐标系时，需要将 y 值取反。「我的坐标系」建立之后，需要将「世界坐标系」中其他的点通过矩阵变换，也转换到这个坐标系内。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 左手坐标系 */public class Coordinate &#123; /** * 原点 */ private final Pos zero; private final double sin; private final double cos; /** * 缩放系数。默认会进行归一化处理，然后调整到0-1000的范围 */ private final double scale; /** * 是不是左手坐标系，如果是左手坐标系，转成世界坐标系的坐标，y要取反 */ private final boolean isLeftHand; /** * 由起点到终点决定了x轴方向，zero是坐标原点 * * @param start * @param end * @param zero */ public Coordinate(Pos start, Pos end, Pos zero) &#123; this(start, end, zero, 1000 / start.distanceTo(end), true); &#125; public Coordinate(Pos start, Pos end, Pos zero, double scale, boolean isLeftHand) &#123; this.zero = zero; this.scale = scale; this.isLeftHand = isLeftHand; double theta = start.angleTo(end); sin = Math.sin(theta); cos = Math.cos(theta); &#125; /** * 世界坐标系中的点在我的坐标系中的位置。 * &lt;p&gt; * 变换矩阵是 : * &lt;p&gt; * cos sin * -sin cos * * @param pos * @return */ public Pos toLocal(Pos pos) &#123; double x = (pos.x - zero.x) * scale; double y = (pos.y - zero.y) * scale; Pos p = new Pos(x * cos + y * sin, -x * sin + y * cos, pos.z); //如果我是右手坐标系，则把y值取反，最后统一输出左手坐标系的值 if (!isLeftHand) &#123; p.y = -p.y; &#125; return p; &#125; /** * 我的坐标系中的点，转化为世界坐标系中的点 * * @param pos * @return */ public Pos toWorld(Pos pos) &#123; //如果当前坐标系是右手坐标系，由于输入都是左手坐标系的，所以要取反 double y = isLeftHand ? pos.y : -pos.y; return new Pos(pos.x * cos - y * sin, pos.x * sin + y * cos, pos.z).scale(1 / scale).translate(zero); &#125;&#125; 渲染「世界坐标系」的点要渲染到界面上，需要映射成屏幕坐标。以直角转弯为例： 123456789101112131415161718192021222324252627282930313233public class ZhiJiaoSrcData implements Serializable &#123; public Gps gps1; public Gps gps2; public Gps gps3; public Gps gps4; public Gps gps5; public Gps gps6; /** * 创建碰撞数据. 这个时候数据都是完备的，不缺失的 */ public ZhiJiaoCollision createCollision(Converter converter, String mapName) &#123; Pos p1 = converter.gpsToGauss(gps1); Pos p2 = converter.gpsToGauss(gps2); Pos p3 = converter.gpsToGauss(gps3); Pos p4 = converter.gpsToGauss(gps4); Pos p5 = converter.gpsToGauss(gps5); Pos p6 = converter.gpsToGauss(gps6); ZhiJiaoCollision collision = new ZhiJiaoCollision(); collision.startLine = new Line(p1, p2); collision.line23 = new Line(p2, p3); collision.line34 = new Line(p3, p4); collision.endLine = new Line(p4, p5); collision.line56 = new Line(p5, p6); collision.line61 = new Line(p6, p1); //左手坐标系 collision.turnLeft = p2.vectorTo(p3).cross(p3.vectorTo(p4)) &lt; 0; return collision; &#125;&#125; 这是直角转弯的 6 个点，必须严格按照示意图进行采集。转成世界坐标系中的模型主要以线为单位： 123456789101112131415161718192021public class ZhiJiaoCollision &#123; /** * 开始控制线 */ public Line startLine; /** * 结束控制线 */ public Line endLine; /************ 控制线 *************/ public Line line23; public Line line34; public Line line56; public Line line61; /** * 默认左转弯 */ public boolean turnLeft;&#125; 然后再将 Collision 转换成渲染到界面的 Model： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ZhiJiaoRenderModel implements Serializable &#123; public Line line12; public Line line23; public Line line34; public Line line45; public Line line56; public Line line61; public boolean turnLeft; /** * 从解析好的碰撞数据中得到渲染数据 */ public static ZhiJiaoRenderModel from(ZhiJiaoCollision collision) &#123; ZhiJiaoRenderModel model = new ZhiJiaoRenderModel(); double lineWidth = 15; model.turnLeft = collision.turnLeft; Pos s1 = collision.line61.end; Pos s2 = collision.line23.start; Pos s3 = collision.line23.end; Pos s4 = collision.line34.end; Pos s5 = collision.line56.start; Pos s6 = collision.line56.end; double distance = lineWidth * 0.5; Pos p1 = LineUtils.getTrimPos(s6, s2, s1, distance); Pos p2 = LineUtils.getTrimPos(s3, s1, s2, distance); Pos p3 = LineUtils.getTrimPos(s2, s4, s3, -distance); Pos p4 = LineUtils.getTrimPos(s5, s3, s4, distance); Pos p5 = LineUtils.getTrimPos(s4, s6, s5, distance); Pos p6 = LineUtils.getTrimPos(s1, s5, s6, distance); model.line12 = new Line(p1, p2, lineWidth); model.line23 = new Line(p2, p3, lineWidth); model.line34 = new Line(p3, p4, lineWidth); model.line45 = new Line(p4, p5, lineWidth); model.line56 = new Line(p5, p6, lineWidth); model.line61 = new Line(p6, p1, lineWidth); return model; &#125;&#125; 因为绘制线是有宽度的，限定线宽为 15cm，采点全部采集的是内点，安卓绘制一条带宽度的线，大多都是使用 Paint 的 strokeWidth，而这个宽度，是向内外各辐射一半：所以我们需要根据采的内点，计算我们真实划线的点。 123456789101112131415161718192021222324252627282930313233/** * 根据两条直线，获取调整的点 */public static Pos getTrimPos(Pos p1, Pos p2, Pos target, double dis) &#123; return getPosFromThreePos(getPointOnExtend(p1, target, dis), target, getPointOnExtend(p2, target, dis));&#125;/** * 在线段的延长线上根据给定距离取一个点。这个距离可以是负值，这样就是在线段内部取一点了 */public static Pos getPointOnExtend(Pos start, Pos end, double dis) &#123; double dx = end.x - start.x; double dy = end.y - start.y; double dz = end.z - start.z; double a = Math.sqrt(dx * dx + dy * dy + dz * dz + 1e-100); double x = dis * dx / a + end.x; double y = dis * dy / a + end.y; double z = dis * dz / a + end.z; return new Pos(x, y, z);&#125;/** * 根据矩形的3个点，求第四个点.这三个点是顺序的,p2是中间点 */public static Pos getPosFromThreePos(Pos p1, Pos p2, Pos p3) &#123; double angle = p2.angleTo(p1); double cos = Math.cos(-angle); double sin = Math.sin(-angle); Pos p11 = new Pos(p1).rotate(p2, cos, sin); Pos p31 = new Pos(p3).rotate(p2, cos, sin); Pos pos = new Pos(p11.x, p31.y, (p11.z + p3.z) * 0.5); return pos.rotate(p2, cos, -sin);&#125; 这样计算后，我们得到的 6 个点如图标记所示：然后进行绘制： 123456789101112131415161718192021222324252627282930313233343536373839/** * 绘制直角项目，6条线 */public List&lt;MapBaseLayer&gt; createMapLayers(MapView mapView, boolean isSelect) &#123; List&lt;MapBaseLayer&gt; layers = new ArrayList&lt;&gt;(); addLine(line12, layers, mapView, Consts.Start_Color, null, true); addLine(line45, layers, mapView, Consts.End_Color, null, true); int sideColor = isSelect ? Color.GREEN : Consts.Side_Color; addLine(line23, layers, mapView, sideColor, null, false); addLine(line34, layers, mapView, sideColor, null, false); addLine(line56, layers, mapView, sideColor, null, false); addLine(line61, layers, mapView, sideColor, null, false); return layers;&#125;private void addLine(Line line, List&lt;MapBaseLayer&gt; lines, MapView mapView, int lineColor, String desc, boolean isDot) &#123; Line l; if (turnLeft) &#123; l = LineUtils.getLineAtLeft(line.start, line.end, Consts.Distance * 1.2f); &#125; else &#123; l = LineUtils.getLineAtRight(line.start, line.end, Consts.Distance * 1.2f); &#125; if (isDot) &#123; lines.add(new DotLineLayer(mapView, line.start, line.end, new DotLineLayer.Config((float) line.lineWidth, lineColor) .desc(desc) .dashGap(30) .dashWidth(30) .descPos(l.start.meanWith(l.end)))); &#125; else &#123; lines.add(new LineLayer(mapView, line.start, line.end, new BaseLineLayer.Config((float) line.lineWidth, lineColor) .desc(desc) .descPos(l.start.meanWith(l.end)))); &#125;&#125; getLineAtRight 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 在两点的右边构建一条平行线，给定距离 */public static Line getLineAtRight(Pos start, Pos end, double distance) &#123; if (HardCode) &#123; return getLine(start, end, distance, false); &#125; double dx = end.x - start.x; double dy = end.y - start.y; double angle = Math.atan2(dy, dx) + Math.PI * 0.5; double x2 = start.x + distance * Math.cos(angle); double y2 = start.y + distance * Math.sin(angle); double x3 = x2 + dx; double y3 = y2 + dy; return new Line(new Pos(x2, y2), new Pos(x3, y3));&#125;/** * 采用解方程的方式求平行线，时间比夹角的方式快一倍 */public static Line getLine(Pos start, Pos end, double distance, boolean atLeft) &#123; double a = end.x - start.x; double b = end.y - start.y; double ab = Math.sqrt(a * a + b * b + 1e-100); double distanceAB = distance / ab; double y1 = start.y + a * distanceAB; double x1 = start.x - b * distanceAB; double y4 = start.y - a * distanceAB; double x4 = start.x + b * distanceAB; double x, y; // 根据向量叉乘检测哪一个在左边 double cross = (end.x - start.x) * (y1 - start.y) - (end.y - start.y) * (x1 - start.x); if (atLeft) &#123; if (cross &lt; 0) &#123; x = x1; y = y1; &#125; else &#123; x = x4; y = y4; &#125; &#125; else &#123; if (cross &gt; 0) &#123; x = x1; y = y1; &#125; else &#123; x = x4; y = y4; &#125; &#125; return new Line( new Pos(x, y, start.z), new Pos(x + a, y + b, end.z));&#125; 直角转弯就是要画 2 条虚线，4 条实线，直接看看实线的绘制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void draw(Canvas canvas, Matrix currentMatrix) &#123; canvas.save(); float[] start = new float[]&#123;Scale.t(pos1.x), Scale.t(pos1.y)&#125;; float[] end = new float[]&#123;Scale.t(pos2.x), Scale.t(pos2.y)&#125;; currentMatrix.mapPoints(start); currentMatrix.mapPoints(end); paint.setColor(config.color); float strokeWidth = calculateValue(config.width, currentMatrix); paint.setStrokeWidth(strokeWidth); paint.setStyle(Paint.Style.STROKE); //给一个机会自己设置画笔 setPaint(paint, currentMatrix); //画直线 canvas.drawLine(start[0], start[1], end[0], end[1], paint); //画描述 if (config.desc != null) &#123; Pos descPos = config.descPos; if (descPos == null) &#123; descPos = new Pos((start[0] + end[0]) * 0.5, (start[1] + end[1]) * 0.5); &#125; else &#123; descPos = transform(descPos, currentMatrix); &#125; paint.setPathEffect(null); paint.setStyle(Paint.Style.FILL_AND_STROKE); paint.setTextSize(config.textSize); paint.setStrokeWidth(1); Rect rect = new Rect(); paint.getTextBounds(config.desc, 0, config.desc.length(), rect); canvas.drawText(config.desc, (float) descPos.x - rect.width() * 0.5f, (float) descPos.y + rect.height() * 0.5f, paint); &#125; //画选中 if (isSelect) &#123; paint.setPathEffect(null); paint.setStrokeWidth(2); paint.setStyle(Paint.Style.STROKE); canvas.drawCircle(start[0], start[1], config.width * 2, paint); canvas.drawCircle(end[0], end[1], config.width * 2, paint); if (isValid(target)) &#123; paint.setColor(COLOR_POS); Pos pt = transform(new Pos(target).scale(1 / Scale.SCALE), currentMatrix); canvas.drawCircle((float) pt.x, (float) pt.y, config.width * 2f, paint); &#125; &#125; canvas.restore();&#125; 通过 canvas、paint 进行绘制，就是普通的安卓知识了。但是还剩下一个疑问：这个时候的线，传入的坐标都是世界坐标系里的坐标，假设 Pos(1000,1000) 这个点即是相对原点往北 10 米，往东 10 米的一个点，而安卓原点在左上角，如何映射的呢？再听下回分解吧~","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"科二考试系统","date":"2021-07-08T06:04:59.000Z","path":"2021/07/08/gps/","text":"这是一个系列文章的开篇，尝试理解项目中用到的知识与结构，许多代码都是上级编写，我只能以我的能力尽量把东西说清楚，讲明白。 目标首选抛出一个目标，实现一个「科二考试系统」。这是一个 App，可以借助各种手段来评判这个学员是否按照考试规则进行考试，如果有错误的地方，需要扣分，扣分达到一定程度则考试不合格，下次再来。怎么来实现这样的目标呢？首先得有具体的考试规则。比如直角转弯需要打转向灯，在哪个地方如果没打灯就需要扣分。比如行驶中开车门，解安全带，曲线行驶压线了，这些都是需要扣分的。考试规则是最顶层的功能，为了实现这些规则，我们需要车辆信号（车速、挡位、灯信号等等）。信号可以通过车辆自身的 OBD，或者外接很多传感器来实现，比如挡位传感器，比如拓展口（外接一根线，连接到左转灯的灯泡里，就可以拿到左转灯亮、灭的信号了）等。那么还有一个难以解决的问题：如何判断车辆压线？以我个人的经验，我可能想到的就是通过摄像头拍照，然后结合图像识别技术来评判是否压线。但是这种必须得有真实的线，拍出的照片里得有「线」才能判断得出吧。那假设有一些「不存在的线」（比如电子栅栏）也需要进行判断呢？那就没辙了。所以有另外一种方案：基于「高精度定位」，将所有现实中的物体，映射到一个坐标系中，粗略将车子抽象成一个矩形，那么车辆压线就可以认作是：在一个坐标系中，矩形与线段是否触碰，这就可以理解为是个数学题了。 高精度定位那么这个高精度定位，一定得是「高精度」。普通的地图 App 比如高德、百度，定位精度相信大家都知道，差不多有好几米的误差，这种精度肯定是无法使用的。那么如何实现高精度定位呢？其实已经有很成熟的方案了：差分定位技术。在网上找到一篇大概能看得懂的文章：GNSS原理及技术（三）——差分定位技术。基于此我的理解就是：A（基站）获取到经纬度（正常的 GPS 定位系统，误差较大）之后，把一些数据发送给 B（流动站），B 结合这些数据，以及自身获取到的经纬度，进行差分运算，可以消除很多导致定位不准确的外届因素（比如卫星钟钟差，电离层延迟等等），从而实现可达 1~3 厘米的高精度定位。只要基站不动，那么所有与这个基站连接的流动站都能获取到「相对于这个基站的高精度坐标」。使用高精度定位之后，需要将基站固定在某个位置，然后车辆基于这个位置的基站进行定位。同时将考场范围内所有项目需要的线、曲线，甚至是「不存在的线」，也都可以映射成高精度坐标点。这个时候就可以脑补了：一张地图上，画了许多的点、线，然后将车辆抽象成一个矩形，在这个地图上进行移动，来做各种评判。 坐标系转换那么如何构建这样的地图呢？我们需要将高精度定位拿到的经纬度，转化成设备屏幕上的像素点，从而画出相应的点、线。假设车辆刚进入直角转弯，地图应该是这样的：如果车辆准备离开直角转弯，地图应该是这样的：科二考试是以考场为单位，一个考场里画几个项目，然后学员在里面练车，所以一个考场可以理解为就是一堆经纬度点的集合。采用高斯投影算法，将经纬度转化成平面坐标。由于安卓系统界面展示是左手坐标系，所以我们也将其转化成左手坐标系，将安卓界面往左旋转 90 度，以正北为 X 轴，正东为 Y 轴，然后选取一个基准点作为原点 Pos(0,0)，其他所有的点，也就都可以转化成 Pos(x,y) 了，给这个坐标系取名为「世界坐标系」。仅考虑北半球，纬度越大，x 越大。经度越大，y 越大。接下来，安卓界面左上角是原点，那么只需要将这个界面原点，与我们的地图原点，做个映射矩阵，后续所有的 Pos 便都可以映射成为界面上的像素点了，如此就可以将地图绘制在屏幕之上了。 碰撞检测有了坐标系转化之后，安卓界面坐标仅仅用于绘制到屏幕上，所有的检测数据来源都依赖于高斯投影转化的平面坐标。基于平面坐标，我们可以建立点、线段、直线、向量、三角形、矩形等数学概念。利用向量的点乘、叉乘，三角形的三角函数，勾股定理等等，我们可以计算出很多我们需要的数据，进行碰撞检测自然不在话下了。 大体的知识体系便是如此了，欲知后事如何，且听下回分解~","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"关于「引擎」设计的小结","date":"2021-05-14T09:05:53.000Z","path":"2021/05/14/engine/","text":"一个业务场景：科二学员考试系统，当学员做了错误的操作之后，会扣分。那么如何实现这样的一个扣分引擎呢？ 检测时机：很显然的我们需要一个定时检测的时机，比如每隔 100 毫秒，或者 1 秒，执行一次检测。这样的话，可以理解为，有一个死循环，持续进行检测。 检测事项：每一次检测需要检测哪些数据，当数据不符合条件，就扣这个分。 引擎状态：当开始考试时，需要启动引擎，进行检测。结束考试时，就停止检测。 基于这样的一个大体思路，实现一个引擎。根据具体的业务功能，先抽象出一个接口（仅仅为了展示思路，所有代码全部简化，接口只抽取信号检测）： 123456789101112/** * 考试处理器 */public interface ExamHandler &#123; /** * 信号处理 * * @param signal 信号 */ void onSignal(SignalGetter signal);&#125; 为了避免检测耗时，导致 App 卡顿，所以我们的引擎需要运行在子线程，而子线程可以接受各种消息，执行相应的任务，理所当然地使用到了 HandlerThread。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 考试执行器 */public class ExamScheduler &#123; private static final int SIGNAL = 520; /** * 真正执行检测的线程 */ private volatile HandlerThread thread; private volatile Handler checkerHandler; /** * 真正执行检测的类 */ private volatile ExamHandler examHandler; public ExamScheduler(ExamHandler examHandler) &#123; this.examHandler = examHandler; thread = new HandlerThread(&quot;EventCheckerThread&quot;); thread.start(); &#125; /** * 设置真实处理器 */ public void setExamHandler(ExamHandler examHandler) &#123; this.examHandler = examHandler; &#125; private Handler createCheckerHandler() &#123; final HandlerThread t = thread; if (t == null) &#123; return null; &#125; return new Handler(t.getLooper()) &#123; @Override public void handleMessage(@NonNull Message msg) &#123; dispatchAction(msg); &#125; &#125;; &#125; /** * 开始 */ public boolean start() &#123; if (checkerHandler == null) &#123; checkerHandler = createCheckerHandler(); &#125; if (checkerHandler == null) &#123; return false; &#125; return true; &#125; /** * 事件分发 */ private void dispatchAction(Message msg) &#123; final ExamHandler eh = ExamScheduler.this.examHandler; if (eh == null) &#123; return; &#125; final int action = msg.arg1; if (action == SIGNAL) &#123; if (isPause) &#123; return; &#125; SignalGetter signal = (SignalGetter) msg.obj; eh.onSignal(signal); &#125; &#125; /** * 执行事件检测 * * @param signal 周期信号 */ public void check(SignalGetter signal) &#123; if (isStop || checkerHandler == null) &#123; return; &#125; Message msg = Message.obtain(); msg.arg1 = SIGNAL; msg.obj = signal; sendMessage(msg); &#125; /** * 销毁 */ public void destroy() &#123; isStop = true; final Handler handler = checkerHandler; checkerHandler = null; if (handler != null) &#123; handler.removeCallbacksAndMessages(null); &#125; final HandlerThread ht = thread; thread = null; if (ht != null) &#123; ht.quit(); &#125; &#125; /** * 发送消息 */ private void sendMessage(Message message) &#123; final Handler h = checkerHandler; if (h != null) &#123; h.sendMessage(message); &#125; &#125;&#125; 通过 ExamScheduler 发送消息，来执行具体的 ExamHandler 的动作。然后提供一个 ExamEngine，来持有 ExamScheduler。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 考试引擎 */public class ExamEngine &#123; /** * 信号更改回调 */ private final SignalCallback callback = this::doOneCheck; /** * 实际处理器 */ private final ExamScheduler examScheduler; private final ExamConfig config; private final ExamResultCallback examResultCallback; private final ExamEventCallback examEventCallback; private final ExamEndInterceptor endInterceptor; /** * 当前的考试数据以及相关配置数据 */ private ExamData currentData; public ExamEngine(ExamConfig config, ExamResultCallback examResultCallback, ExamEventCallback examEventCallback, ExamEndInterceptor endInterceptor) &#123; this.config = config; this.examResultCallback = examResultCallback; this.examEventCallback = examEventCallback; currentData = config.create(null); this.endInterceptor = endInterceptor; examScheduler = new ExamScheduler(new ExamProcessor(currentData, examResultCallback, examEventCallback, this, config.continueIfError, endInterceptor)); &#125; /** * 开始考试 */ public boolean start() &#123; SignalCenter.instance.addSignalCallback(callback); return examScheduler.start(); &#125; /** * 获取当前的考试配置和数据 */ public ExamData getExamData() &#123; return currentData; &#125; /** * 根据当前信号和当前步骤，做一次检测 */ public synchronized void doOneCheck(SignalGetter signalGetter) &#123; examScheduler.check(signalGetter); &#125;&#125; 然后 ExamEngine 的创建需要 ExamConfig，即考试配置。为了兼容科二、科三，这个配置还是很有必要的（科二、科三的配置不一样，但是检测逻辑一致）。 1234567891011121314151617/** * 考试配置 */public class ExamConfig &#123; /** * 科目 */ private final KeMu keMu; /** * 事件创建 */ private final ExamEventCreator eventCreator; public ExamData create(RouteConfig routeConfig) &#123; return new ExamData(keMu, routeConfig); &#125;&#125; 这个类只是一些配置，重点在于 create 方法以及 ExamEventCreator 实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 考试事件创建器 */public interface ExamEventCreator &#123; /** * 创建各个步骤事件，比如直线行驶，加减挡 */ StepCreator stepCreator(); /** * 路线配置，包括路线步骤、每个步骤里的规则、每个规则的配置三部分。这个是根据场地id或者路线id，去Configs里获取的，考试中这个是不能修改的 */ RouteConfig getRouteConfig(); /** * 是否可以同时执行多个项目 */ default boolean canExeMoreThanOneStep(RouteConfig config) &#123; return true; &#125; /** * 创建全局事件，比如科三的安全带是否佩戴等。全局事件有个地方需要注意， * 是在步骤事件执行结束之后再执行的，所以要自己判断当前步骤是否全部执行完了。 * 这是因为有的事件是在全部执行完之后还要做一次检测的，但是大部分事件是不需要的。 */ StepHandler createGlobalEvents(StepConfig config); /** * 一共有哪些步骤 * * @return 需要检测的步骤 */ List&lt;StepInfo&gt; stepList(); /** * 每一步的事件创建器 */ interface StepCreator &#123; /** * 根据每一步，创建一个处理器 * * @param step 根据每一个step，提供一个step handler * @param stepConfig 每一步的配置 * @param allowNoStartPos 可不可以允许没有起始点 * @return 步骤事件处理器 */ StepHandler createStep(StepInfo step, StepConfig stepConfig, boolean allowNoStartPos); &#125; class StepInfo &#123; /** * 开始点 */ public Location location; /** * 刹车点 */ public Location brakePoint; /** * 刹车距离 */ public double brakeDistance; public Step step; &#125;&#125; 这个 ExamEventCreator 来负责检测事项的生成，科二、科三是不一致的。检测事项，需要按照考试项目来，根据不同的项目，生成对应的 StepHandler。 12345678910111213141516171819202122232425/** * 项目检测处理器 */public class StepHandler &#123; /** * 开始事件 */ private final SubStepHandler startEvent; /** * 结束事件,这个可以为空 */ private final SubStepHandler endEvent; /** * 顺序执行事件 */ private final List&lt;SubStepHandler&gt; orderEvents; /** * 固定检测执行事件 */ private final List&lt;SubStepHandler&gt; fixedEvents; /** * 是哪一步 */ public final Step examStep;&#125; 一个项目可能会有很多个检测事项，所以定义了 SubStepHandler，代表这个项目真正需要检测的子项。 12345678910111213141516171819202122/** * 项目子项处理器 */public interface SubStepHandler &#123; /** * 给这个步骤评分，检测，看是不是满足条件，满足规则 */ SubStepResult handle(SignalGetter signal, ExamProcessor processor, StepHandler stepEvent); /** * 主动检测的方式，是否触发了这个步骤 * * @param forceStartTrigger 强制开始，每个步骤都要考虑这种情况，即这一步被强制开始了，不需要达到原先的条件。 * 这个参数只在start事件中才有用，当强制开始的时候，不会用到这个结果，但是方法依然执行 */ boolean isTrigger(SignalGetter signal, ExamProcessor processor, StepHandler stepEvent, boolean forceStartTrigger); /** * 这一步的名称 */ String stepName();&#125; 具体的检测，则是执行到 SubStepHandler handle 方法，结合当前车辆信号，ExamProcessor(ExamHandler 接口实现类)，以及所处的项目 StepHandler，来进行相应的评判，来返回 SubStepResult。 12345678910public class SubStepResult &#123; /** * 累计扣分 */ public int deductScore; /** * 扣分条目 */ public final List&lt;DeductInfo&gt; deductList = new ArrayList&lt;&gt;();&#125; 就是累计扣的分，和需要回调出去的具体的扣分信息 DeductInfo。大多数情况下，list 的 size &#x3D; 1。因为分科二、科三，所以还需要再抽像一个 EngineManager，由它来持有 ExamEngine。这个 Manager 就只负责包装 ExamEngine 的一些方法，同时提供一些回调。科二、科三分别继承这个类，传入自身的 config，来创建相应的 ExamEngine 即可。至此，大体的引擎设计便差不多了。 题外话科三有几百个扣分项，理论上我们需要生成几百个 SubStepHandler，如果手动创建则会十分繁杂，所以使用了反射： 12345678910111213141516171819202122232425262728293031323334private List&lt;SubStepHandler&gt; fixedEvents(Step step, StepConfig config) &#123; Set&lt;Integer&gt; deducts = config.deductConfig.keySet(); List&lt;SubStepHandler&gt; fixed = new ArrayList&lt;&gt;(); String stepName = step.name(); String pureStepName = stepName.replace(&quot;K2_&quot;, &quot;&quot;); String dir = pureStepName.toLowerCase(); for (Integer i : deducts) &#123; Deduct deduct = config.deductConfig.get(i); if (deduct == null || deduct.judgeType.notAuto()) &#123; continue; &#125; String className = &quot;cn.xxxxxx.android.yyyyyy.examk2.rule.&quot; + dir + &quot;.&quot; + stepName + &quot;_&quot; + i + &quot;_Event&quot;; try &#123; Class&lt;?&gt; clazz = Class.forName(className); Constructor&lt;?&gt;[] cs = clazz.getConstructors(); Constructor&lt;?&gt; target = null; for (Constructor&lt;?&gt; c : cs) &#123; Class&lt;?&gt;[] pt = c.getParameterTypes(); if (pt != null &amp;&amp; pt.length == 2) &#123; target = c; break; &#125; &#125; if (target != null) &#123; fixed.add((SubStepHandler) target.newInstance(config.stepConfig, deduct)); &#125; else &#123; LogUtils.e(&quot;TAG&quot;, &quot;扣分项构造失败:deduct = &quot; + deduct + &quot; , Constructor = &quot; + target); &#125; &#125; catch (Exception e) &#123; LogUtils.e(&quot;TAG&quot;, &quot;固定事件扣分项构造失败:&quot; + e.getLocalizedMessage()); &#125; &#125; return fixed;&#125; 拿到具体的项目和项目的配置，通过反射生成所有的扣分项，那么这些扣分项必然需要满足同一个路径，以及命名规范了。举个例子： 123package cn.xxxxxx.android.yyyyyy.examk2.rule.cefangtingche;public class K2_CeFangTingChe_304100_Event extends OneDeductEvent&lt;K2CeFangTingCheConfig&gt; 可能存在性能损耗，但好在方便，使用之后发现性能影响甚微，便持续使用了。","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"一个关于“唯一 ID”的问题","date":"2021-04-09T08:03:03.000Z","path":"2021/04/09/unique-id/","text":"一般涉及到硬件出厂的，都会有一个唯一 ID 来标记这个硬件，最近项目也涉及到了这块。硬件的同事会通过串口，给我们一串字节（12 个 byte），他们可以保证这 12 个 byte 的序列是唯一的，所以在 App 层面，我们使用这串字节，转成相应的十六进制的字符串，作为业务层的唯一 ID。转换代码如下： 123456StringBuilder builder = new StringBuilder();for (int i = 0; i &lt; 12; i++) &#123; int a = data.readUnsignedByte(); builder.append(Integer.toHexString(a));&#125;sn = builder.toString(); data 就是 byte 数组，readUnsignedByte 就是将 byte 转成对应的 int： 123public final int readUnsignedByte() throws IndexOutOfBoundsException &#123; return read() &amp; 0xff;&#125; 就是 &amp; 一下 0xff，然后通过 Integer.toHexString 转成相应的十六进制字符串，最后拼接起来。如果不 &amp; 0xff，那么 byte 直接转 int，会出现负数，当出现负数时，得到的结果会多很多位： 120xff -&gt; ffffffff0xd8 -&gt; ffffffd8 然后…问题就来了。 即使是 &amp; 0xff 的 int 值，Integer.toHexString 返回的值，并不是固定的 2 位数，若是小于 10 的值，前面的 0 会被省略。比如 0x08，会返回 8。 那么就会导致 12 个 byte 输出的十六进制字符串，不一定是固定的 24 位了。比如： 12333 ff d8 55 64 23 63 54 42 71 00 4333 ff d8 55 64 23 63 54 42 07 10 4333 ff d8 55 64 23 63 54 04 27 10 43 这 3 个硬件层的唯一 ID 通过转化，都会映射到同一个业务 ID： 133ffd855642363544271043 导致的后果显而易见：多台设备映射到了同一个业务 ID，这多台设备会共用数据，导致数据混乱。并且随着硬件出厂的数量越来越多，导致多台设备映射到同一个 ID 的几率会越来越大。那么如何在兼容已有旧数据的前提下，来解决这个问题呢？通过讨论，再生成一个固定 24 位的新 ID，连同之前的旧 ID，一同传到服务器（数据尽可能详细，区域、登录的用户等等），由服务器建表进行关联映射。当这个表出现了一个旧 ID 对应到了多个新 ID 的时候，说明有设备重复了。这个时候，只能由人工介入，结合一些基本信息，对这多台新 ID 的设备进行确认，然后手动修复 ID。当迭代几个版本，没有少于 24 位的 ID 生成时，即可将所有数据进行清洗了。新 ID 的生成方式就是手动补“0”，确保一定会是 24 位的串： 1234567for (int i = 0; i &lt; 12; i++) &#123; String hex = sn24[i]; if (hex.length() == 1) &#123; hex = &quot;0&quot; + hex; &#125; builder.append(hex);&#125; 好了，下面就是研究 Integer.toHexString 这个方法了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"语音机器人交互实现","date":"2021-03-24T07:18:52.000Z","path":"2021/03/24/robot/","text":"概述嗯，先看需求：Your browser does not support the video tag. 整体需求是：监听麦克风，等待语音唤醒。唤醒成功后，展示弹窗，然后变成“我在听”的状态。当识别到用户说出的内容时，从服务器获取结果，并展示。整体包含了很多的动画效果，实现与之前写的 Android 动画序列的实现 类似，但还是写篇博客记录一下吧。 动画拆分将视频看个好几遍，可以拆分出一些动画元素： 粒子大圆环效果； “我在听”文案的抖动效果； 听到内容后，文字变眼睛的效果； 机器人与眼睛一起缩放的效果； 语音文案与答案的展示效果； 底部原型按钮的效果；拆分得差不多了，那么逐步实现即可。 动画 11 和 6 涉及到粒子效果，用原生 Android 来实现显然费时费力，而且效果不可预估，且具备很大的技术难度，基于我自身当前的技术深度，我只能先用 webp 或 gif 来实现了，让设计尽可能压缩，直接使用 Glide 加载即可。 动画 2从视频中可以看出文案的抖动效果是平移，x、y 同时平移一个量，但是不能超出一个边界： 1234567891011121314151617181920212223242526272829303132/** * &quot;我在听&quot;抖动动画，平移范围 [-5,5] */private fun shake() &#123; var random = ((Math.random() * 10) - 5).toFloat() var translationX = viewBinding.listenTv.translationX translationX += random if (translationX &gt; 5) &#123; translationX = 5f &#125; if (translationX &lt; -5) &#123; translationX = -5f &#125; random = ((Math.random() * 10) - 5).toFloat() var translationY = viewBinding.listenTv.translationY translationY += random if (translationY &gt; 5) &#123; translationY = 5f &#125; if (translationY &lt; -5) &#123; translationY = -5f &#125; viewBinding.listenTv.animate() .translationX(translationX) .translationY(translationY) .setInterpolator(LinearInterpolator()) .setDuration(300L) .withEndAction &#123; shake() &#125; .start()&#125; 动画 3文字变眼睛效果，也就是 2 个 View 的 alpha 渐变联合起来： 12345678910111213viewBinding.listenTv.animate().cancel()viewBinding.listenTv.animate() .alphaBy(1f) .alpha(0f) .setDuration(alphaDuration) .withEndAction &#123; viewBinding.eyeIv.animate() .alphaBy(0f) .alpha(1f) .setDuration(alphaDuration) .start() &#125; .start() 动画 4机器人的图片与眼睛要达到一个一起缩放的效果，可以考虑当成一个 View，但是视频中显然这 2 个是不同的元素，因为眼睛有单独的动画效果，所以只能当成 2 个 View。那么要实现这样的一起缩放的效果，只能设置相同的缩放点： 1234viewBinding.robotIv.pivotX = 140fviewBinding.robotIv.pivotY = -160fviewBinding.eyeIv.pivotX = 28fviewBinding.eyeIv.pivotY = -250f robotIv 宽度为 280，取一半为中心点，140。eyeIv 宽度为 56，取一半为 28，这样设置的 pivotX 在屏幕上是一个同一个 X，Y 同理，如此可以实现一起缩放的效果。 1234567891011121314viewBinding.robotIv.animate() .scaleXBy(1f) .scaleX(0.5f) .scaleYBy(1f) .scaleY(0.5f) .setDuration(scaleDuration) .start()viewBinding.eyeIv.animate() .scaleXBy(1f) .scaleX(0.5f) .scaleYBy(1f) .scaleY(0.5f) .setDuration(scaleDuration) .start() 动画 5语音文案与答案的动画效果就是个简单的 alpha 渐变： 123456789101112131415161718192021private fun showSpeak(speak: String) &#123; viewBinding.replyTv.text = context.resources.getString(R.string.panel__wait_reply) viewBinding.replyTv.alpha = 0f viewBinding.speakTv.text = &quot;\\&quot;$speak\\&quot;&quot; viewBinding.speakTv.animate() .alphaBy(0f) .alpha(1f) .setDuration(alphaDuration) .withEndAction &#123; viewBinding.replyTv.animate() .alphaBy(0f) .alpha(1f) .setDuration(alphaDuration) .withEndAction &#123; showReply = true showReply(reply) &#125; .start() &#125; .start()&#125; tip 切换动画“我在听”状态时，下面有提示语，有几条特定的提示语，有一个上下切换的效果，考虑使用 TextSwitcher 实现： 12345678viewBinding.tipTv.setFactory &#123; TextView(context).apply &#123; setTextColor(Color.parseColor(&quot;#CDE5FF&quot;)) textSize = 28f &#125;&#125;viewBinding.tipTv.setInAnimation(context, R.anim.voice__robot_tip_in)viewBinding.tipTv.setOutAnimation(context, R.anim.voice__robot_tip_out) 设置好 Factory，以及出入的动画，调用 setText 方法即可有相应的上下切换效果： 123456789/** * 2s 改变一次提示文案 */private val changeRunnable = object : Runnable &#123; override fun run() &#123; viewBinding.tipTv.setText(nextTip()) handler.postDelayed(this, 2000L) &#125;&#125; 至此，所有的动画效果实现得差不多了，稍微调下优即可。 SDK 设计公司内部希望将此功能作为一个单独的 Lib，那么有语音交互需求的 App 可单独集成。目前采用的是讯飞的 SDK，涉及到语音唤醒，语音听写，以及离线语音合成。讯飞 SDK 在内部是有根据 appId 来绑定 SDK 的，所以这个 Lib 无法提供具体的 SDK，SDK 必须由集成方自己去提供。所以这个 Lib 只能 compileOnly 讯飞的 SDK，以此来通过编译。 12// 编译依赖，具体的 SDK 由集成方提供compileOnly project(&#x27;:sdkLib&#x27;) 后续将讯飞 SDK 切换成其他的 SDK 也不是不可能，所以需要做个 SDK 隔离： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 语音交互接口，隔离 SDK 实现 */interface VoiceInteractor &#123; /** * 只做根据 appId 的初始化操作 */ fun init(context: Context) /** * 可能需要针对初始化做一些额外的参数设置 */ fun setParam(param: String, value: String) /** * 开始监听唤醒 */ fun startWakeListen() /** * 停止监听唤醒 */ fun stopWakeListen() /** * 开始监听语音，转文本 */ fun startAsrListen() /** * 停止监听语音 */ fun stopAsrListen() /** * 把文本读出来 */ fun startSpeak(text: String?, listener: TtsSpeakListener?) /** * 停止读文本 */ fun stopSpeak() /** * 释放资源 */ fun release()&#125; 然后提供一个讯飞 SDK 的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 讯飞实现交互 */class IflytekInteractor(val callback: InteractorCallback?) : VoiceInteractor &#123; private val TAG = &quot;IflytekInteractor&quot; override fun init(context: Context) &#123; SpeechUtility.createUtility( context, SpeechConstant.APPID + &quot;=&quot; + getAppId() ) &#125; override fun setParam(param: String, value: String) &#123; SpeechUtility.getUtility().setParameter(param, value) &#125; override fun startWakeListen() &#123; if (ivw == null) &#123; ivw = VoiceWakeuper.createWakeuper(MucangConfig.getContext(), null) // 清空参数 ivw?.setParameter(SpeechConstant.PARAMS, null) // 唤醒门限值，根据资源携带的唤醒词个数按照“id:门限;id:门限”的格式传入 ivw?.setParameter(SpeechConstant.IVW_THRESHOLD, &quot;0:1450&quot;) // 设置唤醒模式，wakeup 为单次唤醒 ivw?.setParameter(SpeechConstant.IVW_SST, &quot;wakeup&quot;) // 设置持续进行唤醒 ivw?.setParameter(SpeechConstant.KEEP_ALIVE, &quot;1&quot;) // 设置闭环优化网络模式 ivw?.setParameter(SpeechConstant.IVW_NET_MODE, &quot;0&quot;) // 设置唤醒资源路径 ivw?.setParameter(SpeechConstant.IVW_RES_PATH, getResource()) // 设置唤醒录音保存路径，保存最近一分钟的音频 ivw?.setParameter( SpeechConstant.IVW_AUDIO_PATH, Environment.getExternalStorageDirectory().path + &quot;/msc/ivw.wav&quot; ) ivw?.setParameter(SpeechConstant.AUDIO_FORMAT, &quot;wav&quot;) &#125; ivw!!.startListening(wakeListener) &#125; override fun stopWakeListen() &#123; ivw?.stopListening() &#125; override fun startAsrListen() &#123; if (asr == null) &#123; // 初始化识别无UI识别对象 asr = SpeechRecognizer.createRecognizer(MucangConfig.getContext(), null) // 清空参数 asr?.setParameter(SpeechConstant.PARAMS, null) // 设置引擎，此处engineType为“cloud”，使用云听写 asr?.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD) // 设置返回结果格式，目前支持json,xml以及plain三种格式，其中plain为纯听写文本内容 asr?.setParameter(SpeechConstant.RESULT_TYPE, &quot;plain&quot;) // 设置语音输入语言，zh_cn为简体中文 asr?.setParameter(SpeechConstant.LANGUAGE, &quot;zh_cn&quot;); // 设置结果返回语言 asr?.setParameter(SpeechConstant.ACCENT, &quot;mandarin&quot;); // 设置语音前端点:静音超时时间，即用户多长时间不说话则当做超时处理 asr?.setParameter(SpeechConstant.VAD_BOS, &quot;5000&quot;) // 设置语音后端点:后端点静音检测时间，即用户停止说话多长时间内即认为不再输入，自动停止录音 asr?.setParameter(SpeechConstant.VAD_EOS, &quot;2000&quot;) // 设置标点符号,设置为&quot;0&quot;返回结果无标点，设置为&quot;1&quot;返回结果有标点 asr?.setParameter(SpeechConstant.ASR_PTT, &quot;0&quot;) // 设置音频保存路径，保存音频格式支持pcm、wav，设置路径为sd卡请注意WRITE_EXTERNAL_STORAGE权限 asr?.setParameter(SpeechConstant.AUDIO_FORMAT, &quot;wav&quot;) asr?.setParameter( SpeechConstant.ASR_AUDIO_PATH, Environment.getExternalStorageDirectory().toString() + &quot;/msc/iat.wav&quot; ) &#125; asr!!.startListening(recognizerListener) &#125; override fun stopAsrListen() &#123; asr?.stopListening() &#125; override fun startSpeak(text: String?, listener: TtsSpeakListener?) &#123; SpeechSynthesizer.getSynthesizer()?.startSpeaking(text, DefaultSpeakListener(listener)) &#125; override fun stopSpeak() &#123; SpeechSynthesizer.getSynthesizer()?.stopSpeaking() &#125; override fun release() &#123; ivw?.destroy() asr?.destroy() ivw = null asr = null &#125;&#125; 再提供一个 Manager 管理 Interactor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108object VoiceInteractionManager &#123; val replyWords: Array&lt;String&gt; = MucangConfig.getContext().resources.getStringArray(R.array.voice__wake_up_words) // 语音事件回调 var callback: VoiceInteractionCallback? = null private set // 一次会话 private var sessionId: String? = null private val api = VoiceInteractionApi() private val innerCallback = object : InteractorCallback &#123; override fun onWakeSuccess() &#123; callback?.onWakeSuccess() // 每次唤醒，生成一次 sessionId sessionId = UUID.randomUUID().toString() &#125; override fun onSpeakReturn(result: String) &#123; callback?.onSpeakReturn(result) getReply(result) stopAsrListen() &#125; override fun onTimeOut() &#123; callback?.onTimeOut() &#125; &#125; private val interactor = IflytekInteractor(innerCallback) @JvmStatic fun init(context: Context, callback: VoiceInteractionCallback?) &#123; interactor.init(context) this.callback = callback &#125; @JvmStatic fun startWakeListen() &#123; PermissionUtils.requestPermissions( Config.getCurrentActivity(), PermissionsCallback &#123; permissions: PermissionsResult -&gt; if (permissions.grantedAll) &#123; interactor.startWakeListen() &#125; else &#123; MainThreadUtils.toast(&quot;需要权限&quot;) &#125; &#125;, Manifest.permission.RECORD_AUDIO, Manifest.permission.WRITE_EXTERNAL_STORAGE ) &#125; @JvmStatic fun stopWakeListen() &#123; interactor.stopWakeListen() &#125; @JvmStatic fun startAsrListen() &#123; PermissionUtils.requestPermissions( Config.getCurrentActivity(), PermissionsCallback &#123; permissions: PermissionsResult -&gt; if (permissions.grantedAll) &#123; interactor.startAsrListen() &#125; else &#123; MainThreadUtils.toast(&quot;需要权限&quot;) &#125; &#125;, Manifest.permission.RECORD_AUDIO, Manifest.permission.WRITE_EXTERNAL_STORAGE ) &#125; @JvmStatic fun stopAsrListen() &#123; interactor.stopAsrListen() &#125; @JvmStatic fun startSpeak(text: String?, listener: TtsSpeakListener?) &#123; interactor.startSpeak(text, listener) &#125; @JvmStatic fun stopSpeak() &#123; interactor.stopSpeak() &#125; @JvmStatic fun release() &#123; interactor.release() &#125; /** * 获取结果 */ private fun getReply(result: String) &#123; if (callback == null) &#123; return &#125; // 获取 reply，然后回调 var reply: VoiceInteractionReply callback?.onReplyReturn(reply) &#125;&#125; 可以看到 interactor 直接是一个 IflytekInteractor 的对象，任何对 SDK 的调用统一由这个 manager 来做。这样即使后面切换 SDK，只需要将 IflytekInteractor 切换成另外一个 Interactor 即可。另外 2 个封装的回调： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 外层使用，语音交互回调 */interface VoiceInteractionCallback &#123; /** * 唤醒成功 */ fun onWakeSuccess() /** * 识别到文本 */ fun onSpeakReturn(result: String) /** * 服务器返回答案 */ fun onReplyReturn(reply: VoiceInteractionReply) /** * 超时了还没识别到文本 */ fun onTimeOut()&#125;/** * 内部 SDK 的回调 */interface InteractorCallback &#123; /** * 唤醒成功 */ fun onWakeSuccess() /** * 识别到文本 */ fun onSpeakReturn(result: String) /** * 超时了还没识别到文本 */ fun onTimeOut()&#125; 另外，Lib 也会有部分资源文件，全部使用 voice__ 作为前缀开头，避免被集成方同名覆盖掉，产生不可预期的影响。至此，一个相对独立的 Lib 库设计基本完成，后续看需求进行迭代了。 后续Lib 库提供 SNAPSHOT 版本时，集成方若要及时拉取，可以如此设置： 123456configurations.all &#123; // 动态版本 resolutionStrategy.cacheDynamicVersionsFor 10, &#x27;minutes&#x27; // 变化模块 resolutionStrategy.cacheChangingModulesFor 0, &#x27;minutes&#x27;&#125; 动态版本即为 lastest 或者 + 表达式的版本，变化模块即为 SNAPSHOT。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"记一次《春游》","date":"2021-02-27T11:52:39.000Z","path":"2021/02/27/outing/","text":"今天是老婆难得的双休，正好周末这两天的天气，在最近半个月算是好的了，于是决定出游一波，姑且称之为《春游》吧。这次出游，我们没有做详细的规划，只设置了一个目的地：东湖之眼。出行方法我们也采用了更原生态的方式，共享单车加上步行，前往目的地。出门首先骑单车，经雄庄路转民族大道，然后来到光谷大转盘，再进入鲁磨路，一直前行就能到达东湖了，这就是整趟行程的规划了。顺着鲁磨路骑行，勾起了我很多关于这条路的回忆。我大学毕业于中国地质大学，就在这条鲁磨路上。骑车经过学校门口时，便想着进入瞧瞧。 可能是因为疫情的原因，门口出入的管理比较严格，需要刷脸或者一卡通等渠道证明自己与学校的联系，才能进入。比较麻烦，就没进去了，就在外面转转吧。顺着鲁磨路走，发现学校的变化不算太大，当年的大江南网吧升级为网咖了。学校对面多了栋珠宝大厦，地大的珠宝还是厉害的：再接着往前面走就到地大北街了，俗称“堕落街”。想着当年经常在北区健身，然后来到北街吃一顿自助餐，管饱，十分满足。走入街中，还是那种熟悉的感觉，见到了印象深刻的南望山，街中店面都十分紧凑，主要服务人群就是地大的学生了，节约成本嘛。好像也是刚开学，很多店面并没有开始营业，我走到最里面，也发现北门紧闭着，几乎没什么人。当下已然快正午了，先填饱肚子吧。在大众点评找到一家店“韩味屋”，评价十分不错，走吧！店面比较小巧，堂食的位置并不算多，简单的装修，墙上贴了一张大大的韩式美女的图片。没等一会，就上菜了：烤五花肉的肉感很不错，多余的油脂早已被炸干，十分美味！年糕配上独特的酱料，吃起来甜而不腻。部队火锅的这个分量我是没想到的，里面有很多的配菜，摆盘也很漂亮。再加上这个蛋包饭，吃到最后，我们的胃是着实装不下了。嗯，吃饱了，再出发！我俩就边走边聊天，偶然发现路边淡粉色的花儿，还挺好看：经过了小李村，大李村，就和老家村庄的感觉差不多。再走着没一会，就到东湖了。原来是新开了一个游乐场，记得早些时候来的时候还没有的，时代在发展啊，得跟上脚步。娱乐项目没什么适合我俩玩的，弹射蹦极有点刺激，小心脏受不了。东湖之眼摩天轮排队堪比欢乐谷，而且一个车舱必须坐满 4 人，这多没情调啊，作罢，就看看吧。其实也没什么好看的，比较适合小孩来玩，等以后有娃了再带过来玩儿吧。东湖绿道之前走过，靠走实在太远了，得 2、3 个小时，不太合适。骑车吹着湖风又有点冷，索性作罢，就围着湖边转转吧。围着湖边骑了下自行车，感受了下人流，就就是户外的感觉啊。差不多有点累就准备回家了，走不动，也骑不动，滴滴走起。 写在最后这就是一篇流水式的日记，发现很久不写东西了，写起来很费劲，以后有事没事还是多动动笔。发现这样不做详细规划的出行，还挺好的。一切随心，想干嘛就干嘛，走在这座城市里，用心去感受。经过鲁磨路上的小村庄，转瞬便是人流中心的大东湖，现在很难在武汉这种城市里感受到小村庄的那份惬意了。一路上和老婆瞎聊，这也聊，那也聊，十分自在畅快。原生态出行，既少排放二氧化碳，也加强了身体的锻炼。最近我俩都在朝着婚前的体重前进，嗯，晚上也不用吃了，加油吧！很多东西都在变，当然也有不变的，这就是最好的时代了。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"2020 年度总结","date":"2021-02-07T05:37:34.000Z","path":"2021/02/07/2020/","text":"嗯，今天是 2020 年的最后一天班了（农历），明天就要回家过年了。每年总还是喜欢做一下总结，回顾一下时光。 新冠疫情中国的 2020 年注定是不平凡的一年，也必是载入史册的一年。不知不觉，已经戴口罩生活一年了。整个的 2020 年，全球被新冠病毒肆虐。年初最早在中国武汉爆发，后面随着春运爆发至全国各地，随即美国、英国等等，几乎没有一个国家能够幸免于难。病毒已然来了，我们只能思考如何应对。在这场看不见硝烟的战争中，自认为国家已经做得足够好了。在最喜欢“热闹”的中国，在理应最“热闹”的春节，国家的一篇通告，让数以亿计的人们，真的就在家足不出户，将新冠传染的可能性降低到最低。每一个人用切身的行动来证明，中国是强大的！这样的一件事情，最早发生在中国是非常不可思议的。相信越来越多的中国人，乃至一些国外的友人，会相信我们这样一个越来越强大的国家。 婚礼也是由于疫情的原因，原本 3 月份就计划举行的婚礼，被延迟到了 6 月份。我与老婆在 2019 年 7 月 28 日 初始，同年 9 月 16 日便初步确立关系，2020 年 3 月份就已然在计划结婚了。事情发展之迅速令人咋舌，包括我自己。为什么会这么快呢？其实我也不知道。就是感觉来了，她就应该是我下半辈子的伴侣。我老婆人很不错，心里善良，温柔体贴。尽管我们在某些方面会有些争执，但这是生活中不可或缺的部分。目前来看，已经结婚生活了大半年，没什么大问题。未来我依然会与我老婆携手共进，我们一定会幸福。 《诗经·卫风·木瓜》投我以木瓜，报之以琼琚。匪报也，永以为好也！投我以木桃，报之以琼瑶。匪报也，永以为好也！投我以木李，报之以琼玖。匪报也，永以为好也！ 工作今年的工作算是比较有进步的一年，在结婚之后没多久，我便调到了现在的项目组。项目的最终目标是机器人教练：替代教练教学，智能防碰撞，智能评判。这样的一个项目起初再刚接触的时候，我是非常迷茫的，因为它和我之前做的项目都不太一样。它需要硬件的支持，这就涉及到了 Android 与硬件的通信。同时呢，硬件很难保持一致性。同样的一套软硬件设备，在这台车上可以正常表现，换台车可能就不正常了。有一些问题发现后，硬件那边是可以解决的，有一些是解决不了的，所以需要针对具体的情况，在 App 层做各种兼容。然后也需要一些碰撞检测，就又涉及到了很多数学知识。是的，数学！向量呀，坐标系呀，已然全都忘了。所以在碰到的时候，需要先补补数学知识，太难了~项目从我加入的 6 月一直持续到现在，跨越武汉的夏季与冬季，代码很多情况下需要在车里进行调试，在外面的考场实地调试，夏热冬冷，大家确实是都很辛苦。好算今年的结果还可以，基本达标。项目也因此发放了一些奖金，同时收获了「年度优秀员工」的奖励，今年的目标基本达成！明年继续加油干~ 旅行嗯，2020 年的旅行计划是空白的，一半是因为疫情的原因，一半是因为结婚的原因。结婚后，大节小节都是在老家来回走动了。加上后面换项目组，平时加班也比较多，老婆后面也换工作，大小周，能在一起的时间就更少了。但是这块还是要写出来了，争取在明年计划一次旅行。旅行这个事情怎么说呢，一年总还是要来这么一遭的，不然在一个地方呆久了，呼吸不到外面的空气，很容易就陷进去了，至少对我来说是这样。所以明年，一定要计划一次旅行！ 其他剩下的就没什么要写的了。就是感慨一下自己的体重：从认识老婆到结婚，再到婚后，从 140 斤涨到现在差不多 160 斤，净重！我滴个妈呀~所以过年来了之后，还有一个目标：减肥！减肥！减肥！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"LiveBus 之思考","date":"2021-01-28T09:15:41.000Z","path":"2021/01/28/livebus/","text":"在项目中使用到 LiveBus 时，还是挺好用的，各方面的需求也都能满足。碰到的问题也能一一解决，这篇文章就稍微总结一下： observeForever当调用 observeForever 时，发现 remove 会失效，这个是代码问题导致的，在那篇文章中已经修复，这里再啰嗦一下： 1234567891011121314151617private val wrappers = mutableMapOf&lt;Observer&lt;in T&gt;, BusWrapper&gt;()override fun observeForever(observer: Observer&lt;in T&gt;) &#123; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observeForever(wrapper)&#125;override fun removeObserver(observer: Observer&lt;in T&gt;) &#123; val wrapper = wrappers[observer] if (wrapper != null) &#123; super.removeObserver(wrapper) wrappers.remove(observer) &#125; else &#123; super.removeObserver(observer) &#125;&#125; 然后就会出现另外一个问题：假设我现在有一个 observer，在 observe 之后，当收到回调时，想手动 remove 掉，发现也 remove 不掉。因为在 observe 时没有把外面传入的 observer 给保存起来，那么在手动 remove 的时候就会发现 remove 不掉了，解决方案也简单：再加入到 wrappers 里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667open class BusLiveData&lt;T&gt; : MutableLiveData&lt;T&gt;() &#123; private val wrappers = mutableMapOf&lt;Observer&lt;in T&gt;, BusWrapper&gt;() override fun observe(owner: LifecycleOwner, observer: Observer&lt;in T&gt;) &#123; // 不重复注册 if (wrappers[observer] != null) &#123; return &#125; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observe(owner, wrapper) &#125; open fun observeSticky(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; super.observe(owner, observer) &#125; override fun observeForever(observer: Observer&lt;in T&gt;) &#123; // 不重复注册 if (wrappers[observer] != null) &#123; return &#125; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observeForever(wrapper) &#125; fun observeStickyForever(observer: Observer&lt;T&gt;) &#123; super.observeForever(observer) &#125; override fun removeObserver(observer: Observer&lt;in T&gt;) &#123; val wrapper = wrappers[observer] if (wrapper != null) &#123; super.removeObserver(wrapper) wrappers.remove(observer) &#125; else &#123; val iterator = wrappers.iterator() run find@&#123; while (iterator.hasNext()) &#123; val data = iterator.next() if (data.value == observer) &#123; wrappers.remove(data.key) return@find &#125; &#125; &#125; super.removeObserver(observer) &#125; &#125; inner class DefaultWrapper(observer: Observer&lt;in T&gt;) : BusWrapper(observer) &#123; override fun onChanged(t: T?) &#123; if (lastVersion &gt;= version) &#123; return &#125; lastVersion = version observer.onChanged(t) &#125; &#125; abstract inner class BusWrapper(val observer: Observer&lt;in T&gt;) : Observer&lt;T&gt; &#123; var lastVersion = version &#125;&#125; 不论是 observe 或者 observeForever 都会加入到 wrappers 里进行管理，然后在 remove 时通过遍历，找到对应 observer 的 wrapper，再进行移除，如此一来，问题也都解决了。同时也处理了同一个 observer 不重复 observe 的问题。 思考在这样进行修改的时候，我就发现有点麻烦了，外部传入的 observer 都要经过 LiveBus 进行转换，转换成相应的 wrapper 才调用 LiveData 的 observe 方法，其实 LiveData 内部就已经针对 observer 进行管理了。而现在的 LiveBus 为了实现 LiveData notSticky 的效果，把每一个 observer 都做了 wrapper 转换，导致外部的 observer 在 LiveBus 内部都需要再管理一遍。那么能不能直接就调用 LiveData.observe 方法，传入一个 observer，是否粘性由 observer 自身决定。按照这个思路，我重写了 BusLiveData 类： 1234567891011121314151617open class BusLiveData&lt;T&gt; : MutableLiveData&lt;T&gt;() &#123; abstract inner class NotStickyObserver : Observer&lt;T&gt; &#123; private var observerVersion: Int = version override fun onChanged(t: T) &#123; if (observerVersion &gt;= version ) &#123; return &#125; onRealChanged(t) observerVersion = version &#125; abstract fun onRealChanged(t: T) &#125;&#125; 为了获取 version，必须要把包名命名为 androidx.lifecycle，同时 NotStickyObserver 必须为 BusLiveData 的内部类，并且是 inner 的。那这样的话，就导致外面的类就无法使用 NotStickyObserver了，所以需要 BusLiveData 自身来生成 Observer： 1234567891011121314151617181920212223242526272829open class BusLiveData&lt;T&gt; : MutableLiveData&lt;T&gt;() &#123; fun getNotStickyObserver(onChanged: (T) -&gt; Unit): NotStickyObserver &#123; return object : NotStickyObserver() &#123; override fun onRealChanged(t: T) &#123; onChanged(t) &#125; &#125; &#125; fun observeNotSticky(owner: LifecycleOwner, onChanged: (T) -&gt; Unit) &#123; observe(owner, getNotStickyObserver(onChanged)) &#125; abstract inner class NotStickyObserver : Observer&lt;T&gt; &#123; private var observerVersion: Int = version override fun onChanged(t: T) &#123; if (observerVersion &gt;= version ) &#123; return &#125; onRealChanged(t) observerVersion = version &#125; abstract fun onRealChanged(t: T) &#125;&#125; 添加一个 getNotStickyObserver 方法，返回非粘性的 observer，如有需要可以接收，方便后续手动 remove。结合 LiveData 自身的使用方式，添加一个 observeNotSticky，自动生成一个 NotStickyObserver 并 observe。现在就只有这样的一个初步方案，不知使用起来是否可行，有待验证。 调试通过 LiveBus 监听，很难调试相应的代码：监听的地方可以通过事件类名找到相应的代码，但是无法得知是哪里 post 出这个事件的。所以打算直接把 LiveBus 里的 post 方法去掉： 12345678910object LiveBus &#123; private val busMap by lazy &#123; ConcurrentHashMap&lt;Class&lt;*&gt;, BusLiveData&lt;*&gt;&gt;() &#125; private fun &lt;T&gt; bus(clazz: Class&lt;T&gt;) = busMap.getOrPut(clazz) &#123; BusLiveData&lt;T&gt;() &#125; @Suppress(&quot;UNCHECKED_CAST&quot;) @JvmStatic fun &lt;T&gt; with(clazz: Class&lt;T&gt;) = bus(clazz) as BusLiveData&lt;T&gt;&#125; 只提供 with 方法，返回 BusLiveData，然后手动 postValue。 1LiveBus.with(String.class).postValue(&quot;Hello world&quot;); 这样的话就比较方便调试了，但是代码会多一些，具体哪种方式好，还得依赖具体的场景吧。同时无法限制 postValue 的使用了，由外部自己调用的，那么就又可能就会出现在子线程调用 setValue 的场景了。想来想去，貌似也没有十全十美的方案，只能说针对自己的场景选取最合适的方式，头发又少了","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android 连接 USB 设备","date":"2020-11-27T06:38:15.000Z","path":"2020/11/27/usb/","text":"最近项目中有需要连接 USB 设备，App 运行在平板之上，只有一个 type-c 接口，只能通过 type-c 转串口进行连接，所以 App 直接接触的是 USB 设备。使用 USB 设备遵照Google 官方文档开发即可。 配置清单12345678910111213141516&lt;manifest ...&gt; &lt;uses-feature android:name=&quot;android.hardware.usb.host&quot; /&gt; &lt;uses-sdk android:minSdkVersion=&quot;12&quot; /&gt; ... &lt;application&gt; &lt;activity ...&gt; ... &lt;intent-filter&gt; &lt;action android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot; android:resource=&quot;@xml/device_filter&quot; /&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; device_filter 可过滤具有指定属性的所有 USB 设备： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;usb-device vendor-id=&quot;1234&quot; product-id=&quot;5678&quot; class=&quot;255&quot; subclass=&quot;66&quot; protocol=&quot;1&quot; /&gt;&lt;/resources&gt; 使用设备 发现连接的 USB 设备，具体方法是使用 Intent 过滤器在用户连接 USB 设备时接收通知，或者枚举已连接的 USB 设备。 请求用户授予连接到 USB 设备的权限（如果尚未获得权限）。 通过在适当的接口端点读取和写入数据来与 USB 设备通信。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566object UsbDeviceManager &#123; private const val ACTION_USB_PERMISSION = &quot;com.android.example.USB_PERMISSION&quot; private var usbManager: UsbManager? = null private var serial: UsbSerialDevice? = null private var listener: OnDeviceConnectListener? = null @JvmStatic fun open(context: Context, listener: OnDeviceConnectListener) &#123; this.listener = listener usbManager = context.getSystemService(USB_SERVICE) as? UsbManager usbManager?.let &#123; for (device in it.deviceList.values) &#123; if (UsbSerialDevice.isSupported(device)) &#123; if (it.hasPermission(device)) &#123; connect(device) &#125; else &#123; val filter = IntentFilter(ACTION_USB_PERMISSION) context.registerReceiver(usbReceiver, filter) val permissionIntent = PendingIntent.getBroadcast( context, 0, Intent(ACTION_USB_PERMISSION), 0 ) it.requestPermission(device, permissionIntent) &#125; &#125; &#125; &#125; &#125; private fun connect(device: UsbDevice?) &#123; device?.let &#123; val connect = usbManager?.openDevice(device) serial = UsbSerialDevice.createUsbSerialDevice(device, connect) serial?.syncOpen() serial?.setBaudRate(115200) serial?.let &#123; listener?.onDeviceConnect(it) &#125; &#125; &#125; private val usbReceiver: BroadcastReceiver = object : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; val action = intent.action if (ACTION_USB_PERMISSION == action) &#123; val device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE) as? UsbDevice if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) &#123; connect(device) &#125; else &#123; LogUtils.e( &quot;UsbDeviceManager&quot;, &quot;permission denied for device $device&quot; ) &#125; &#125; &#125; &#125; interface OnDeviceConnectListener &#123; fun onDeviceConnect(serial: UsbSerialDevice) &#125;&#125; 封装USB 有多种芯片，针对不同的芯片可能需要做识别，在 Github 上找到一个库UsbSerial，针对 USB 设备做了许多的封装，硬件同事提供的转串口工具为 CH34X 系列，该库也支持。参照文档使用起来很方便。 12345678910111213141516171819202122232425262728public class UsbDeviceCommunicator extends BaseCommunicator &#123; private static final int BufferSize = 32; private UsbSerialDevice usbDevice; @Override public void open() &#123; UsbDeviceManager.open(MucangConfig.getContext(), new UsbDeviceManager.OnDeviceConnectListener() &#123; @Override public void onDeviceConnect(@NotNull UsbSerialDevice serial) &#123; usbDevice = serial; // Usb 串口读取 byte[] 是读满才返回，把 bufferSize 搞小点 mInputStream = new BufferedInputStream(serial.getInputStream(), BufferSize); mOutputStream = new BufferedOutputStream(serial.getOutputStream()); startReadThread(); &#125; &#125;); &#125; @Override public void close() &#123; super.close(); if (usbDevice != null) &#123; usbDevice.syncClose(); &#125; &#125;&#125; 抽象因为串口的不一致性，项目中有 3 中流传输方式：蓝牙、串口、USB。数据读取解析方式完全一致，所以抽象出 Communicator： 123456789101112131415161718192021222324252627282930313233343536373839404142public interface Communicator &#123; /** * 打开串口 */ void open() throws Exception; /** * 发送数据 */ @WorkerThread void send(SendData sendData); /** * 处理接收的数据 * * @param readBytes 只包含数据域数据 */ void parseData(ReadBytes readBytes); /** * 关闭串口 */ void close(); /** * 释放资源 */ void release(); /** * 大小端 * * @return */ boolean littleEndian(); /** * 串口是否可用 */ boolean isAvailable();&#125; BaseCommunicator： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238public abstract class BaseCommunicator implements Communicator &#123; private static final String TAG = &quot;BaseCommunicator&quot;; private static final long SEND_INTERVAL = 10; // 避免多线程发送粘包，添加延时 protected BufferedInputStream mInputStream; // 输入流，子类进行初始化 protected BufferedOutputStream mOutputStream; // 输出流，子类进行初始化 private DefaultReadThread mReadThread; // 读线程 private final SignalHandler signalHandler; // 消息分发 handler private long lastSendTime; // 上一次发包的时间 public BaseCommunicator() &#123; this.signalHandler = new SignalHandler(); &#125; @WorkerThread @Override public synchronized void send(SendData sendData) &#123; if (!isAvailable()) &#123; return; &#125; if (interceptMessage(sendData.toBytes())) &#123; return; &#125; try &#123; byte[] finalData = SerialProtocol.createProtocol(sendData.toBytes()); if (mOutputStream != null) &#123; long curTime = SystemClock.elapsedRealtime(); if (curTime - lastSendTime &gt;= SEND_INTERVAL) &#123; lastSendTime = curTime; &#125; else &#123; long delta = SEND_INTERVAL - (curTime - lastSendTime); SystemClock.sleep(delta); lastSendTime = SystemClock.elapsedRealtime(); &#125; mOutputStream.write(finalData, 0, finalData.length); mOutputStream.flush(); &#125; &#125; catch (Throwable e) &#123; LogUtils.e(TAG, &quot;sendData() error&quot;, e); &#125; &#125; @Override public void parseData(ReadBytes readBytes) &#123; readBytes.reset(); int msgType = readBytes.readUnsignedByte(); signalHandler.dispatchHandler(msgType, readBytes); &#125; /** * 当ota正在升级的时候不下发其他业务消息,ota升级优先级最高 */ private boolean interceptMessage(byte[] bytes) &#123; // 升级过程中 if (CommunicateManager.getInstance().isNeedInterceptor()) &#123; // 解析指令类型 int order = bytes[0] &amp; 0xff; // 只放行 ota 指令 boolean isOtaOrder = SingleFirmwareUpgradeProcessor.isOtaOrder(order); return !isOtaOrder; &#125; return false; &#125; @Override public synchronized void close() &#123; if (mReadThread != null &amp;&amp; mReadThread.isAlive()) &#123; mReadThread.close(); mReadThread = null; &#125; IOUtils.close(mInputStream); IOUtils.close(mOutputStream); lastSendTime = 0; &#125; @Override public synchronized void release() &#123; close(); &#125; @Override public boolean isAvailable() &#123; if (mReadThread == null || !mReadThread.isAlive()) &#123; return false; &#125; return true; &#125; @Override public boolean littleEndian() &#123; return true; &#125; /** * 启动串口读线程 */ protected void startReadThread() &#123; mReadThread = new DefaultReadThread(); mReadThread.start(); LiveBus.post(new CommunicatorOpenSuccess()); &#125; /** * 读满一个数组 */ private static void readFully(InputStream in, byte[] array, int off, int len) throws IOException &#123; if (len &lt; 0) throw new IndexOutOfBoundsException(); int n = 0; while (n &lt; len) &#123; int count = in.read(array, off + n, len - n); if (count &lt; 0) throw new EOFException(); n += count; &#125; &#125; private static void readFully(InputStream in, byte[] array) throws IOException &#123; readFully(in, array, 0, array.length); &#125; private static long crc(byte[] data) &#123; CRC32 crc = new CRC32(); crc.update(data); return crc.getValue(); &#125; /** * 默认读线程 */ private class DefaultReadThread extends Thread &#123; private volatile boolean mRunning = true; DefaultReadThread() &#123; &#125; /** * 读取一帧数据 */ private byte[] readFrame() throws IOException &#123; //header识别，一直识别到一帧为止，否则一直等待 byte h1, h2 = 0; while (mRunning) &#123; h1 = (byte) mInputStream.read(); if (h2 == SerialProtocol.HEAD1 &amp;&amp; h1 == SerialProtocol.HEAD2) &#123; break; &#125; h2 = (byte) mInputStream.read(); if (h1 == SerialProtocol.HEAD1 &amp;&amp; h2 == SerialProtocol.HEAD2) &#123; break; &#125; &#125; //帧长 int length = mInputStream.read(); //数据 byte[] data = new byte[length - 5]; readFully(mInputStream, data); //校验数据 byte[] crcArray = new byte[4]; readFully(mInputStream, crcArray); ReadBytes readCrc = new ReadBytes(crcArray, littleEndian()); int crc = readCrc.readInt(); //结束数据 byte[] eof = new byte[2]; readFully(mInputStream, eof); //crc校验 if (!(true || crc(data) == crc)) &#123; return null; &#125; //结束符校验,其实这个要不要都无所谓,双重校验了 if (!(eof[0] == SerialProtocol.END &amp;&amp; eof[1] == SerialProtocol.END)) &#123; return null; &#125; return data; &#125; @Override public void run() &#123; while (mRunning) &#123; try &#123; if (mInputStream == null) &#123; // 暂停一点时间，免得一直循环造成CPU占用率过高 Thread.sleep(10); continue; &#125; byte[] data = readFrame(); if (data != null) &#123; parseData(new ReadBytes(data, littleEndian())); &#125; &#125; catch (Exception e) &#123; LogUtils.e(TAG, &quot;DefaultReadThread exception: &quot;, e); if (e instanceof IOException) &#123; mRunning = false; reconnect(); LiveBus.post(new CommunicatorError()); break; &#125; &#125; &#125; &#125; /** * 重连 */ private void reconnect() &#123; CommunicateManager.getInstance().release(); MainThreadUtils.postDelayed(new Runnable() &#123; @Override public void run() &#123; CommunicateManager.getInstance().start(); &#125; &#125;, 1500); &#125; /** * 关闭读线程 */ void close() &#123; mRunning = false; try &#123; this.interrupt(); &#125; catch (Exception e) &#123; LogUtils.e(TAG, &quot;DefaultReadThread close: &quot;, e); &#125; &#125; &#125;&#125; 另外 2 个子类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class SerialBoxCommunicator extends BaseCommunicator &#123; private int mBaudRate; // 串口波特率 private String mDevicePath; // 串口地址 private SerialPort mSerialPort; // 串口 public SerialBoxCommunicator(String devicePath, int baudRate) &#123; this.mDevicePath = devicePath; this.mBaudRate = baudRate; &#125; @Override public void open() throws OpenSerialPortException &#123; if (mSerialPort != null) &#123; close(); &#125; try &#123; if (TextUtils.isEmpty(mDevicePath) || mBaudRate == 0) &#123; throw new RuntimeException(&quot;SerialPort hasn&#x27;t been configured! (device=&quot; + mDevicePath + &quot;,baudRate=&quot; + mBaudRate); &#125; mSerialPort = SerialPort.newBuilder(mDevicePath, mBaudRate).build(); SystemClock.sleep(100); mInputStream = new BufferedInputStream(mSerialPort.getInputStream()); mOutputStream = new BufferedOutputStream(mSerialPort.getOutputStream()); startReadThread(); &#125; catch (Exception e) &#123; // 清理数据 close(); // 抛出异常 throw new OpenSerialPortException(e); &#125; &#125; @Override public boolean isAvailable() &#123; if (mSerialPort == null) &#123; return false; &#125; return super.isAvailable(); &#125;&#125;class BluetoothCommunicator extends BaseCommunicator implements BTDataReceiver.InputStreamChangedListener &#123; private final BTDataReceiver receiver = new BTDataReceiver(MucangConfig.getContext(), this); @Override public void open() &#123; receiver.start(); startReadThread(); &#125; @Override public void send(SendData sendData) &#123; // 蓝牙模拟，只接收数据，不发送 &#125; @Override public void close() &#123; super.close(); receiver.destroy(); &#125; @Override public void onInputStreamChanged(InputStream inputStream) &#123; this.mInputStream = new BufferedInputStream(inputStream); &#125;&#125; 小坑UsbDeviceCommunicator 中，获取 mInputStream 时，包装 BufferedInputStream 使用的 bufferSize 设置为 32。三方库封装的 SerialInputStream 读取数据都是通过 usbConnection.bulkTransfer 来实现的： 123456789101112131415161718192021222324/** * Performs a bulk transaction on the given endpoint. * The direction of the transfer is determined by the direction of the endpoint. * * @param endpoint the endpoint for this transaction * @param buffer buffer for data to send or receive * @param offset the index of the first byte in the buffer to send or receive * @param length the length of the data to send or receive. Before * &#123;@value Build.VERSION_CODES#P&#125;, a value larger than 16384 bytes * would be truncated down to 16384. In API &#123;@value Build.VERSION_CODES#P&#125; * and after, any value of length is valid. * @param timeout in milliseconds, 0 is infinite * @return length of data transferred (or zero) for success, * or negative value for failure */public int bulkTransfer(UsbEndpoint endpoint, byte[] buffer, int offset, int length, int timeout) &#123; checkBounds(buffer, offset, length); if (mContext.getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.P &amp;&amp; length &gt; UsbRequest.MAX_USBFS_BUFFER_SIZE) &#123; length = UsbRequest.MAX_USBFS_BUFFER_SIZE; &#125; return native_bulk_request(endpoint.getAddress(), buffer, offset, length, timeout);&#125; length 代表的读取数据的长度，会堵塞，直到读满 buffer。而 FileInputStream 的 read 方法为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * @param b the buffer into which the data is read. * @param off the start offset in array &lt;code&gt;b&lt;/code&gt; * at which the data is written. * @param len the maximum number of bytes to read. * @return the total number of bytes read into the buffer, or * &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of * the stream has been reached. * @exception IOException If the first byte cannot be read for any reason * other than end of file, or if the input stream has been closed, or if * some other I/O error occurs. * @exception NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. * @exception IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative, * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than * &lt;code&gt;b.length - off&lt;/code&gt; * @see java.io.InputStream#read() */public int read(byte b[], int off, int len) throws IOException &#123; if (b == null) &#123; throw new NullPointerException(); &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return 0; &#125; int c = read(); if (c == -1) &#123; return -1; &#125; b[off] = (byte)c; int i = 1; try &#123; for (; i &lt; len ; i++) &#123; c = read(); if (c == -1) &#123; break; &#125; b[off + i] = (byte)c; &#125; &#125; catch (IOException ee) &#123; &#125; return i;&#125; len 代表最大可读取的字节数，不会一直堵塞，直到读满 buffer。 所以需要将 BufferedInputStream 的 bufferSize 设置小一点（默认8192），否则使用默认值一直读满 8192 个字节会等待较久的时间，不符合每 200ms 发送一次 64 byte 的实际场景。另外，当没有 DevicePermission 时会弹窗，如果一直弹不太合适，所以有一个绕过弹窗验证的思路，可以参考一下，待验证。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 打包动态修改变量","date":"2020-10-28T08:47:52.000Z","path":"2020/10/28/gradle-variable/","text":"在项目中经常有这种需求：在打包时指定某些变量的值，比如渠道号、应用名称等。我们采用 Jenkins 进行打包构建，可以添加相应的参数，参数可以直接在打包脚本中使用，也可以在项目的 gradle 文件中使用。下面以动态改变端口号，举例进行说明。 Jenkins 添加变量在 Jenkins 构建的设置中，添加变量PORT_NAME，做成选择项（固定的变量尽量避免人为错误），然后添加一下说明。这个变量可以在 Build 配置中的 Execute shell 中使用，当前场景不需要，只需要配置即可。 gradle 获取在项目的 gradle 文件的 android 路径下，使用System.getenv(&quot;PORT_NAME&quot;)便可以获取到 Jenkins 上配置的值了。 12345// 默认 MT1 端口def portName = &quot;/dev/ttyMT1&quot;if (System.getenv(&quot;PORT_NAME&quot;)) &#123; portName = System.getenv(&quot;PORT_NAME&quot;)&#125; 设置使用现在在 gradle 代码中已经获取到配置的变量了，那么就有几种方式将它写入到我们的 android 代码中。 resValue：1resValue(&quot;string&quot;, &quot;port_name&quot;, &quot;/dev/ttyMT1&quot;) 此种方式，是添加一个 string 的 resource 到我们的代码中，编译打包最终生成的 resource.arsc 中便会包含这个 port_name 值，但是在引用时，会提示找不到变量，从而标红，但是运行没问题。（运行后代码便会写入，就能找到了）同时，我们的 res 文件夹下面不能添加 port_name 的 res，否则会报错：duplicate string resources。 manifestPlaceholders：123456789101112&lt;meta-data android:name=&quot;port_name&quot; android:value=&quot;$&#123;port_name&#125;&quot;/&gt;buildTypes &#123; debug &#123; manifestPlaceholders = [port_name: &quot;/dev/ttyMT1&quot;] &#125; release &#123; manifestPlaceholders = [port_name: &quot;/dev/ttyMT1&quot;] &#125;&#125; 然后获取 meta 值：12ActivityInfo info = getPackageManager().getActivityInfo(getComponentName(), PackageManager.GET_META_DATA);String msg = info.metaData.getString(&quot;port_name&quot;); buildConfigField：123456789buildTypes &#123; release &#123; buildConfigField(&quot;String&quot;, &quot;PORT_NAME&quot;, &quot;\\&quot;$portName\\&quot;&quot;) &#125; &#125; debug &#123; buildConfigField(&quot;String&quot;, &quot;PORT_NAME&quot;, &quot;\\&quot;$portName\\&quot;&quot;) &#125;&#125; 这种方式要注意2点：String 开头 S 必须大写；双引号必须要转义。获取：1private static final String PortName = BuildConfig.PORT_NAME; 小结：方式 1 会变红；方式 2 获取比较麻烦；所以最后采用方式 3。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"混淆小记","date":"2020-09-24T11:17:51.000Z","path":"2020/09/24/proguard/","text":"最近做的项目是个新项目，早期为了快速迭代实现需求，在混淆这块没做过处理。最近打算上 release 包，混淆这块肯定还是需要的。 开启混淆在 App Module 的 build.gradle 文件中配置开启混淆： 1234567release &#123; signingConfig signingConfigs.release minifyEnabled true multiDexEnabled = true proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27; resValue(&quot;string&quot;, &quot;build_type&quot;, &quot;debug&quot;)&#125; minifyEnabled 开启为 true 则开启混淆，混淆规则为 proguard-rules.pro 中配置。proguardFiles getDefaultProguardFile(‘proguard-android.txt’) 会包含一份 Android 默认的混淆规则，比如四大组件的混淆等等。proguard-android-optimize.txt 也是默认的混淆规则，但是相比于 proguard-android.txt，它包含更“严格”的优化项，可能会出现某些预料之外的表现，比如连包名都给混淆了，视情况是否需要采用 optimize 吧。 混淆继承作为 lib 库，最好是能实现自身的混淆规则，通过 consumerProguardFiles 指定自身混淆规则，这样第三方在依赖 lib 时便可以不用手动配混淆规则了： 1234release &#123; minifyEnabled false consumerProguardFiles &#x27;proguard-rules.pro&#x27;&#125; 混淆文件合并有些时候可能需要获取全量的混淆规则，来排查一些问题，可以在 App 层的混淆文件中加入这句： 1-printconfiguration &quot;build/outputs/mapping/configuration.txt&quot; 这样再成功 build 完之后，就能在相应路径下面看到 configuration.txt，它包含了全部的混淆规则（Android 默认的也能看得到）。 常用混淆 开启 ViewBinding 使用反射调用 inflate 实现基类，需要 keep ViewBinging：12345678910111213141516private fun initViewBinding(inflater: LayoutInflater, container: ViewGroup?): View &#123; val type = javaClass.genericSuperclass val clazz = (type as ParameterizedType).actualTypeArguments[0] as Class&lt;VB&gt; val method = clazz.getMethod( &quot;inflate&quot;, LayoutInflater::class.java, ViewGroup::class.java, Boolean::class.java ) viewBinding = method.invoke(null, inflater, container, false) as VB return viewBinding.root&#125;-keep class * implements androidx.viewbinding.ViewBinding &#123; *;&#125; 自定义 ViewModelProvider.Factory，会反射调用构造方法，也需要 keep：12345678override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123; val examSite = intent.getSerializableExtra(KEY_EXAM_SITE) as ExamSite return modelClass.getConstructor(ExamSite::class.java).newInstance(examSite)&#125;-keepclassmembers public class * extends androidx.lifecycle.ViewModel &#123; public &lt;init&gt;(...);&#125; kotlin 写的这个 ViewModelProvider.Factory 在添加混淆之后，依然报错： kotlin.jvm.KotlinReflectionNotSupportedError: Kotlin reflection implementation is not found at runtime. Make sure you have kotlin-reflect.jar in the classpath. 所以解决方法便是添加 kotlin-reflect.jar： 1implementation &quot;org.jetbrains.kotlin:kotlin-reflect:$project.thirdparty.kotlinVersion&quot; 其他用到反射的地方，以及各类 SDK 的混淆，需要注意。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"一次 Python 工具编写的经历《三》","date":"2020-09-19T09:55:59.000Z","path":"2020/09/19/python-3/","text":"将整个 python 工具写好之后，最后一步便是生成 exe 文件提供给 Windows 电脑使用了，可以使用 pyinstaller 生成。这里需要注意个坑：MacOS 只能生成 MacOS 对应的可执行文件，所以若要生成 exe，需要切换到 Windows 平台。安装 PyInstaller，然后进入到需要打包的 .py 文件所在文件夹，执行 cmd 指令：pyinstaller -F -w xx.py。打包是很容易了，但是能正常运行则需要运气。使用 pyCharm 可以正常运行 py 文件，但是打成 exe 后运行直接崩溃。所以第一步：接入异常提示。 异常提示123456try: # do somethingexcept Exception as e: self.box = QMessageBox(QMessageBox.Warning, &#x27;提示&#x27;, &quot;出错了!&quot; + traceback.format_exc()) self.box.exec() 获取到提示后，下一个错误就来了。 WindowsError:[Error 6]运行 exe 报错：WindowsError:[Error 6]，报错文件为 imgkit&#x2F;config.py，里面用到了 subprocess。网上查阅相关文章，需要添加全量的参数设置。修改前： 1subprocess.Popen([&#x27;where&#x27;, &#x27;xvfb-run&#x27;],stdout=subprocess.PIPE).communicate()[0].strip() 修改后： 1subprocess.Popen([&#x27;where&#x27;, &#x27;xvfb-run&#x27;],shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE,stdout=subprocess.PIPE).communicate()[0].strip() 然后重新打包，运行成功。PS：python 修改三方库文件，直接 pyCharm 修改保存即可，十分方便了~ Windows 兼容在 Windows 7 上运行 exe，报如下的错： 1Python.exe cannot run for missing api-ms-win-core-path-l1-1.0.dll 后面搜了一下： 1Sorry, Windows 7 is no longer supported in Python 3.9. You&#x27;ll need to update, ideally to Windows 10, but if you want to stay on Windows 8.1 then I believe that one&#x27;s supported until Python 3.10. 意思是 Windows 7 只能使用 3.9 版本一下的 python，恰巧运行报错的电脑就是 Windows 7。所以需要兼容一下，使用 3.9 以下版本的 python。 打包指令-F, –onefile Py代码只有一个文件-D, –onedir Py代码放在一个目录中（默认是这个）-K, –tk 包含TCL&#x2F;TK-d, –debug 生成debug模式的exe文件-w, –windowed, –noconsole 窗体exe文件(WindowsOnly)-c, –nowindowed, –console 控制台exe文件(WindowsOnly)-X, –upx 使用upx压缩exe文件-o DIR, –out&#x3D;DIR 设置spec文件输出的目录，默认在PyInstaller同目录-v FILE, –version&#x3D;FILE 加入版本信息文件 python 工具之旅到此结束。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"一次 Python 工具编写的经历《二》","date":"2020-09-19T08:40:33.000Z","path":"2020/09/19/python-2/","text":"继上篇文章，获取到序列号后，接下来就是得打印了。python 里使用打印，可以直接使用PyQt5.QtPrintSupport。 打印获取打印机列表： 12345678def printerList(): printer = [] printerInfo = QPrinterInfo() print(&#x27;availablePrinterNames&#x27;, printerInfo.availablePrinterNames()) print(&#x27;defaultPrinterName&#x27;, printerInfo.defaultPrinterName()) for item in printerInfo.availablePrinters(): printer.append(item.printerName()) return printer 打印一个文档： 1234567891011def printing(printer, content): printerInfo = QPrinterInfo() p = QPrinter() for item in printerInfo.availablePrinters(): if printer == item.printerName(): p = QPrinter(item) doc = QTextDocument() doc.setHtml(content) # doc.setPageSize(QSizeF(p.logicalDpiX() * (80 / 25.4),p.logicalDpiY() * (297 / 25.4))) p.setOutputFormat(QPrinter.NativeFormat) doc.print_(p) doc.setHtml 设置一个 Html 进行打印。使用此种方法，发现一个问题：html 左右布局，但是打出来的标签是上下布局的，找了多种方法没找到解决方案，寻到一个曲线救国的方案：先转成图片，然后再打印。 Html 转图片在网上找到的是使用imgkit 库。安装有两步： pip install imgkit brew install wkhtmltopdf(Mac OS) 若使用 Windows，前往wkhtmltopdf 官网下载安装。运行后依然报错： Can’t create pdf using python PDFKIT Error : “ No wkhtmltopdf executable found:” 在 stactoverflow 上找到相应解决方案(Windows)： 1234import pdfkitpath_wkhtmltopdf = r&#x27;C:\\Program Files (x86)\\wkhtmltopdf\\bin\\wkhtmltopdf.exe&#x27;config = pdfkit.configuration(wkhtmltopdf=path_wkhtmltopdf)pdfkit.from_url(&quot;http://google.com&quot;, &quot;out.pdf&quot;, configuration=config) 然后就可以转成图片了。 1234567891011def do_print(self, num, qrCode): # 生成图片再打印 html = &#x27;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=&quot;&gt;&lt;style&gt; html, body, div &#123; margin: 0; padding: 0; &#125; table &#123; &#125; table td &#123; padding: 12px; vertical-align: middle; text-align: center; &#125; p &#123; margin: 8px 0; font-size: 24px; font-weight: bold; &#125;&lt;/style&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table &gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;&#x27; + qrCode + &#x27;&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;序列号&lt;/p&gt;&lt;p&gt;&#x27; + num + &#x27;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&#x27; path = r&#x27;C:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltoimage.exe&#x27; config = Config(wkhtmltoimage=path) options = &#123; &#x27;width&#x27;: 350, &#x27;height&#x27;: 140, &#x27;encoding&#x27;: &#x27;UTF-8&#x27; &#125; imgkit.from_string(html, &#x27;print.png&#x27;, config=config, options=options) options 是生成图片的宽高，看打印需求进行调整。代码成功执行后，本地就会生成一个 print.png 的图片了。 打印图片打印图片使用 QPainter： 1234567891011121314151617printer = &quot;defaultPrinter&quot;printerInfo = QPrinterInfo()p = QPrinter()# p.setPaperSize(QSizeF(50,20),QPrinter.Millimeter)# p.setPageSize(QPageSize.LetterExtra)for item in printerInfo.availablePrinters(): if printer == item.printerName(): p = QPrinter(item)img = QImage(&#x27;print.png&#x27;)painter = QPainter(p)# rect = painter.viewport()# size = img.size()# size.scale(rect.size(), Qt.KeepAspectRatio)# painter.setViewport(rect.x(), rect.y(), size.width(), size.height())# painter.setWindow(img.rect())painter.drawImage(0, 0, img)painter.end() 图片打印成功，后续要需要根据纸张大小进行调整，以达到最佳的打印效果。 打印多列项目中用到的打印机是标签打印机，一行有 2 个标签纸，所以需要做特殊适配： 123456789101112painter.setRenderHint(QPainter.HighQualityAntialiasing, True)count = self.print_count.value()for i in range(0, count): # 打第奇数张图片 painter.drawImage(10, 0, img) if 1 == i % 2: # 打第偶数张图片 painter.drawImage(440, 0, img) if i != count - 1: # 如果还有下一个，就新建下一页 p.newPage()painter.end() print_count 为一个数量选择器，目前暂定只能打 2 张或者 4 张： 1234self.print_count = QSpinBox(Form)self.print_count.setRange(2, 4)self.print_count.setSingleStep(2)self.print_count.setValue(2) 图片模糊通过此种方法打印出来的标签，总感觉比较模糊。即使我把生成图片的宽高调成与打印机的一致，也还是会模糊。寻找了很多方法，无果。后面在QT 官网看到打印机的 PrinterMode 设置。默认是 ScreenResolution，改成 HighResolution 之后打印出来就很清晰了，然后打第二张图的间距也需要适当调整（painter.drawImage(440, 0, img)）。 This enum describes the mode the printer should work in. It basically presets a certain resolution and working mode.QPrinter::ScreenResolution：Sets the resolution of the print device to the screen resolution. This has the big advantage that the results obtained when painting on the printer will match more or less exactly the visible output on the screen. It is the easiest to use, as font metrics on the screen and on the printer are the same. This is the default value. ScreenResolution will produce a lower quality output than HighResolution and should only be used for drafts.QPrinter::PrinterResolution：This value is deprecated. It is equivalent to ScreenResolution on Unix and HighResolution on Windows and Mac. Due to the difference between ScreenResolution and HighResolution, use of this value may lead to non-portable printer code.QPrinter::HighResolution：On Windows, sets the printer resolution to that defined for the printer in use. For PDF printing, sets the resolution of the PDF driver to 1200 dpi. 下一步便是生成 Windows 可运行工具了，欲知后事如何，且听下回分解。 参考Can’t create pdf using python PDFKIT Error : “ No wkhtmltopdf executable found:”pythonhtml2image: imgkit 和 wkhtmltoimage的坑QPainter绘制图片填充方式（正常大小、剪切大小、自适应大小、平铺） Qt中的打印操作Qt打印详解Qt实现 二维码打印功能Python调用打印机参考例子","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"一次 Python 工具编写的经历《一》","date":"2020-09-15T11:32:30.000Z","path":"2020/09/15/python-1/","text":"背景最近的项目涉及到硬件，硬件由工厂生产，生产之后需要连接到电脑，然后执行检测程序。检测程序需要做两件事： 检测硬件的可用性； 从硬件获取到硬件编号，拿到编号后去服务器请求一个序列号； 拿到序列号后告知标签打印机进行打印。 后面硬件装箱时，贴上此标签，通过服务器就可以知道一个序列号对应的具体硬件是哪一个了（排除人为标签贴错的情况）。那么，现在就是需要做这样的一个检测工具，运行在 windows 平台。 准备工具的第一部分，已经由另一个同事做得差不多了，我只需要在基础上进行拓展就行。同事选用的语言是 python，我也是好久没碰过了，这次完善工具，浪费了颇多时间，必须记录一下。我选用的 IDE 是 PyCharm，也是由 JetBrains 出品的，与 Android Studio 一套风格，上手容易。py 文件拷入到工程，然后 import 一大堆的三方库，完毕后工程如期跑起来了。与硬件的通信也是基于串口的，采用的库是 serial。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import serialimport serial.tools.list_ports# 列出所有的串口port_list = list(serial.tools.list_ports.comports())if len(port_list) &lt;= 0: print(&quot;未发现串口&quot;) QMessageBox.warning(self, &#x27;警告&#x27;, &#x27;未发现串口&#x27;, QMessageBox.Yes) returnself.cb_comname.clear()for port in port_list: self.com_dict[&quot;%s&quot; % port[0]] = &quot;%s&quot; % port[1] # 添加到下拉选择框中 self.cb_comname.addItem(port[0])# 打开串口serialPort = self.cb_comname.currentText()baudRate = 115200self.port_open(serialPort, baudRate)self.timer_rec.start(10)# 定义 timer_rec，每 10 毫秒读取一次数据self.timer_rec = QTimer(self)self.timer_rec.timeout.connect(self.read_data)# 解析数据def read_data(self): if self.openFlag == True: n = self.port.inWaiting() if n &gt; 0: data1 = self.port.read(1) if self.bytes2hex(data1) == &#x27;0xa5&#x27;: data2 = self.port.read(1) if self.bytes2hex(data2) == &#x27;0x5a&#x27;: zhenlength = self.port.read(1) zhenType = self.port.read(1) if zhenType == b&#x27;\\x10&#x27; or zhenType == b&#x27;\\x11&#x27;: data = data1 + data2 + zhenlength + zhenType + self.port.read(60) if zhenType == b&#x27;\\x08&#x27;: data = data1 + data2 + zhenlength + zhenType + self.port.read(44) if self.saveFlag == True: if (self.f.closed == False): self.f.write(self.bytestohex(data) + &#x27;\\n&#x27;) head = None if zhenType == b&#x27;\\x10&#x27;: head = StructConverter.encoding(data, Signal1) if zhenType == b&#x27;\\x11&#x27;: head = StructConverter.encoding(data, Signal2) self.txt_show.setText(self.bytestohex(data)) if zhenType == b&#x27;\\x08&#x27;: head = StructConverter.encoding(data, Signal3) # 解析数据搞事情 ... 获取硬件编号现在需要从硬件获取到编码，通过 serial 打开的串口发送一个指令到硬件即可，指令是个 byte 数组，在 python 中可以这样写： 12data = bytearray(b&#x27;\\xff\\xff\\xff\\xff&#x27;)self.port.write(data) b 代表是 byte，后面的 \\xff 是字节，根据已经定制好的协议，写入相应的数据即可。然后收到的数据进行解析得到硬件编号。 123# 获取设备号data = &quot;&quot;.join([&#x27;&#123;:x&#125;&#x27;.format(int(i)) for i in head.carSn])self.txt_sn.setText(data) head.carSn 是个 byte 数组，通过** ‘{:x}’.format 转换成 hex string 进行输出 **。eg：0x33 0xff 0xda 0x5 0x52 0x53 0x36 0x35 0x43 0x39 0x10 0x43 -&gt; 33ffda55253363543391043。因为 App 也是需要拿到这个硬件号去做唯一匹配的，所以 App 和这个 python 工具的转换公式必须是一样，贴下 App 中如何转换： 12345StringBuilder builder = new StringBuilder();for (int i = 0; i &lt; 12; i++) &#123; int a = data.readUnsignedByte(); builder.append(Integer.toHexString(a));&#125; 注意 Java byte 是有符号的，需要转成无符号进行 hex 转换： 123public final int readUnsignedByte() throws IndexOutOfBoundsException &#123; return read() &amp; 0xff;&#125; 进过测试，双端通过同一硬件转换出来的 hex string 是一致的，达到目标。 获取序列号拿到硬件编号需要获取序列号，走网络请求，引入 requests 库。 12345678910111213import requests# 发送请求获取序列号url = &quot;http://request.url.html&quot;d = &#123;&#x27;paramA&#x27;: A, &#x27;paramB&#x27;: B, &#x27;paramC&#x27;: C&#125;response = requests.post(url, data=d)if response.status_code == requests.codes.ok: # 解析序列号 result = response.json().get(&#x27;data&#x27;) num = result.get(&#x27;serialNum&#x27;) qrCode = result.get(&#x27;qrCode&#x27;) self.txt_number.setText(num) self.do_print(num, qrCode) 通过 post 请求，指定 data 参数，便可发送请求了。利用 .json() 便可将结果转成 json 串，然后 get 到相应的数据。 检测逻辑在获取序列号之前，还需要先检测数据项是否可用，通过 key value 形式定义一个如下结构： 1234567# 检查项列表checkList = &#123;&#x27;检测项1&#x27;: 0, &#x27;检测项2&#x27;: 0, &#x27;检测项3&#x27;: 0, ... &#125; 每次开始检测时，把数据全部置为 0，然后数据每变化一次，加1，最终只有变化次数 &gt;&#x3D; 2 的才有效。 1234567891011121314151617181920212223# global 关键字，可在函数中改变全局变量的值global checkList# 检测项1old = self.check1.toPlainText()new = hex(head.check1)if new != old: checkList[&#x27;check1&#x27;] = checkList[&#x27;check1&#x27;] + 1self.check1.setText(new)# 遍历找到不符合的值，提醒for key in checkList: if checkList[key] &lt; 2: self.box = QMessageBox(QMessageBox.Information, &#x27;提示&#x27;, key + &quot;未通过检测&quot;) jump = self.box.addButton(&quot;跳过检测&quot;, QMessageBox.YesRole) self.box.addButton(&quot;确定&quot;, QMessageBox.NoRole) self.box.exec() # 点击的是 jump 按钮 if self.box.clickedButton() == jump: # 强制跳过检测 checkList[key] = 2 print(key + &quot;未通过检测&quot;) return 下一步便是打印了，欲知后事如何，且听下回分解。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"viewBinding 使用小结","date":"2020-07-21T08:28:57.000Z","path":"2020/07/21/viewbinding/","text":"通过视图绑定功能，您可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。在大多数情况下，视图绑定会替代 findViewById。 启用只能在 Android Studio 3.6 Canary 11 及更高版本中使用。 123456android &#123; ... viewBinding &#123; enabled = true &#125;&#125; 启用后，会根据 xml 名称生成一个驼峰命名，结尾带上 Binding 的绑定类。例如：result_profile.xml，会生成 ResultProfileBinding 的绑定类，这个绑定类 getRoot 方法返回根布局，xml 中所有有 id 的 View 也能通过此类直接获取。相比于 kotlin-android-extensions，它不会空指针，并且 id 唯一。kotlin-android-extensions 直接获取对应 id 的 view 有可能导致空指针。另一点，如果我们很多 xml 里的 id 有一样的命名，会很难区分。且如果一个页面引用了 2 个 xml，这 2 个 xml 里是不能使用同样的 id 的，编译器会不知道要去找哪个 id 从而报错，而使用 viewBinding 这些便都解决了。 当然，或许某些时候，我们不需要生成绑定类，那么可以在布局根节点，添加tools:viewBindingIgnore=&quot;true&quot;即可： 12345&lt;LinearLayout ... tools:viewBindingIgnore=&quot;true&quot; &gt; ...&lt;/LinearLayout&gt; 在 Activity 中可以这样使用 viewBinding： 12345678private lateinit var binding: ResultProfileBindingoverride fun onCreate(savedInstanceState: Bundle) &#123; super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) val view = binding.root setContentView(view)&#125; 封装 Base那么基于 viewBinding 如何封装 Base 呢？写一下封装高德地图 RouteBaseMapFragment： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130abstract class RouteBaseMapFragment&lt;VB : ViewBinding&gt; : BaseFragment(), DefaultLocationListener &#123; protected lateinit var viewBinding: VB protected var needLocate = false private lateinit var map: AMap private var polyline: Polyline? = null private var myLocationMark: MyLocationMark? = null private var markerList = mutableListOf&lt;Marker&gt;() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? &#123; val view = initViewBinding(inflater, container) initViewModel() initView() myLocationMark = MyLocationMark(map) return view &#125; @Suppress(&quot;UNCHECKED_CAST&quot;) private fun initViewBinding(inflater: LayoutInflater, container: ViewGroup?): View &#123; val type = javaClass.genericSuperclass val clazz = (type as ParameterizedType).actualTypeArguments[0] as Class&lt;VB&gt; val method = clazz.getMethod( &quot;inflate&quot;, LayoutInflater::class.java, ViewGroup::class.java, Boolean::class.java ) viewBinding = method.invoke(null, inflater, container, false) as VB return viewBinding.root &#125; abstract fun getMap(): AMap open fun getMapView(): MapView? &#123; return null &#125; open fun getTextureMapView(): TextureMapView? &#123; return null &#125; open fun initViewModel() &#123;&#125; open fun initView() &#123; getMapView()?.onCreate(null) getTextureMapView()?.onCreate(null) map = getMap() map.showBuildings(false) map.showIndoorMap(false) map.showMapText(false) val uiSettings = map.uiSettings uiSettings.isTiltGesturesEnabled = false uiSettings.isScaleControlsEnabled = true uiSettings.isGestureScaleByMapCenter = true uiSettings.isZoomControlsEnabled = false map.animateCamera(CameraUpdateFactory.zoomTo(18f)) &#125; protected fun drawRouteLine(nodeList: List&lt;RouteNode&gt;, animate: Boolean = false) &#123; polyline?.remove() val latLngList: MutableList&lt;LatLng&gt; = ArrayList() nodeList.forEach &#123; latLngList.add(LatLng(it.lat, it.lon).toGCJPoint()) &#125; polyline = map.addPolyline( PolylineOptions().addAll(latLngList).width(10f).color(Color.parseColor(&quot;#FF7D3C&quot;)) ) if (animate) &#123; val boundsBuilder = LatLngBounds.Builder() latLngList.forEach &#123; boundsBuilder.include(it) &#125; val cameraUpdate = CameraUpdateFactory.newLatLngBoundsRect( boundsBuilder.build(), 50, 20, 50, 20 ) map.animateCamera(cameraUpdate) &#125; &#125; protected fun clearMarker() &#123; markerList.forEach &#123; it.remove() &#125; markerList.clear() &#125; protected fun drawMark(node: RouteNode) &#123; val view = PointMarkView(context, null) view.setData(node) val markerOptions = MarkerOptions() markerOptions.anchor(0.5f, 0.8f) markerOptions.position(LatLng(node.lat, node.lon).toGCJPoint()) markerOptions.icon(BitmapDescriptorFactory.fromView(view)) markerList.add(map.addMarker(markerOptions)) &#125; private fun drawMyLocation(location: Location) &#123; if (needLocate) &#123; myLocationMark?.onLocationChange(location) &#125; &#125; override fun onLocationChanged(location: Location) &#123; drawMyLocation(location) &#125; override fun onResume() &#123; super.onResume() JLocationManager.addListener(this) getMapView()?.onResume() getTextureMapView()?.onResume() &#125; override fun onPause() &#123; super.onPause() JLocationManager.removeListener(this) getMapView()?.onPause() getTextureMapView()?.onPause() &#125; override fun onDestroyView() &#123; super.onDestroyView() getMapView()?.onDestroy() getTextureMapView()?.onDestroy() myLocationMark?.onDestroy() &#125;&#125; viewBinding 生成绑定类对应的基类是 ViewBinding，所以以此写相应的泛型即可。 封装 Multi-Type ItemBinder项目中使用了 Multi-Type，每实现一个 ItemBinder，都需要实现 2 个方法：onCreateViewHolder、onBindViewHolder。那么结合 ViewBinding 就可以考虑将 onCreateViewHolder 给抽掉： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@RestrictTo(RestrictTo.Scope.LIBRARY)abstract class ViewBindingBinder&lt;T, VB : ViewBinding&gt; : ItemViewBinder&lt;T, ViewBindingHolder&lt;VB&gt;&gt;(), WithViewBinding&lt;VB&gt; &#123; @NonNull override fun onCreateViewHolder( @NonNull inflater: LayoutInflater, @NonNull parent: ViewGroup ): ViewBindingHolder&lt;VB&gt; &#123; val viewBinding: VB = onCreateViewBinding(javaClass, inflater, parent) return ViewBindingHolder(viewBinding) &#125;&#125;@RestrictTo(RestrictTo.Scope.LIBRARY)class ViewBindingHolder&lt;T : ViewBinding?&gt;(val viewBinding: T) : RecyclerView.ViewHolder(viewBinding!!.root)@RestrictTo(RestrictTo.Scope.LIBRARY)interface WithViewBinding&lt;VB : ViewBinding?&gt; &#123; fun onCreateViewBinding( clz: Class&lt;*&gt;, inflater: LayoutInflater, @Nullable container: ViewGroup? ): VB &#123; return ViewBindingCreator&lt;VB&gt;().onCreateView(clz, inflater, container) &#125;&#125;@Suppress(&quot;UNCHECKED_CAST&quot;)@RestrictTo(RestrictTo.Scope.LIBRARY)class ViewBindingCreator&lt;VB : ViewBinding?&gt; &#123; fun onCreateView(clz: Class&lt;*&gt;, inflater: LayoutInflater, container: ViewGroup?): VB &#123; return try &#123; val viewBindingType = getViewBindingType(clz) val inflateMethod: Method = viewBindingType .getDeclaredMethod( &quot;inflate&quot;, LayoutInflater::class.java, ViewGroup::class.java, Boolean::class.javaPrimitiveType ) inflateMethod.invoke(null, inflater, container, false) as VB &#125; catch (e: Exception) &#123; throw IllegalStateException(&quot;创建ViewBinding失败&quot;, e) &#125; &#125; private fun getViewBindingType(clzParam: Class&lt;*&gt;): Class&lt;*&gt; &#123; var clz = clzParam var genericType: Type? = clz.genericSuperclass while (genericType !is ParameterizedType) &#123; clz = clz.superclass if (clz == null) &#123; genericType = null break &#125; genericType = clz.genericSuperclass &#125; checkNotNull(genericType) &#123; &quot;找不到ViewBinding Type&quot; &#125; val actualTypeArguments: Array&lt;Type&gt; = (genericType as ParameterizedType).actualTypeArguments if (actualTypeArguments.isNotEmpty()) &#123; for (type in actualTypeArguments) &#123; if (type is Class&lt;*&gt;) &#123; if (ViewBinding::class.java.isAssignableFrom(type)) &#123; return type &#125; &#125; &#125; &#125; throw IllegalStateException(&quot;找不到ViewBinding Type&quot;) &#125;&#125; 看一下 2 个 Base 封装，都是用 VB : ViewBinding 通过反射来找到相应的类，手动调用 inflate 方法即可。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android 串口通信小记","date":"2020-07-15T07:40:19.000Z","path":"2020/07/15/serial-port/","text":"最近项目有需要用到串口通信，硬件同事通过串口给应用层发送数据，稍微记录一下。 串口串口通信（Serial Communications）是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。串口通信是计算机中非常常见的通信方式，比如一些有线鼠标、键盘、打印机等都是通过串口进行通信的。串口的通信一般使用3根线完成，分别是地线、发送线（tx）、接收线（rx）。串口中有五个重要的参数：串口设备名、波特率、奇偶校验位、数据位、停止位。 设备名称：串口的名称。 波特率：传输速率的参数，波特率和传输距离成反比。 校验位：在串口通信中一种简单的检错方式，有四种检错方式：偶、奇、高和低，允许无校验位。 数据位：通信中实际数据位的参数 停止位：用于表示单个包的最后一位。 接入Google 官方有基于串口通信的 demo，部分代码可以用以借鉴。在 github 上有几个三方库，封装了串口通信，项目决定采用的是Android-SerialPort-API。打开串口： 12345678910111213141516171819private synchronized void doOpenSerial() throws OpenSerialPortException &#123; if (mSerialPort != null) &#123; close(); &#125; try &#123; mSerialPort = SerialPort.newBuilder(&quot;/dev/ttyMT1&quot;, 115200).build(); mInputStream = new BufferedInputStream(mSerialPort.getInputStream()); mOutputStream = new BufferedOutputStream(mSerialPort.getOutputStream()); startReadThread(); &#125; catch (Exception e) &#123; // 清理数据 close(); // 抛出异常 throw new OpenSerialPortException(e); &#125;&#125; 在打开串口后，开启一个线程循环读取数据。 读取与解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 默认读线程 */private class DefaultReadThread extends Thread &#123; private final byte[] mReceiveBuffer; private boolean mRunning = true; private final byte[] buffer; private int index; DefaultReadThread() &#123; // 接收收据缓存 mReceiveBuffer = new byte[16]; //多缓存一点，以防万一 buffer = new byte[256]; index = 0; &#125; @Override public void run() &#123; while (mRunning) &#123; try &#123; if (mInputStream.available() &gt; 0) &#123; int len = mInputStream.read(mReceiveBuffer); if (len &gt; 0) &#123; System.arraycopy(mReceiveBuffer, 0, buffer, index, len); index += len; Arrays.fill(mReceiveBuffer, (byte) 0); while (true) &#123; //查找数据头和数据尾 int start = -1; int end = -1; for (int i = 0; i &lt; index; i++) &#123; if (buffer[i] == SerialProtocol.HEAD1 &amp;&amp; i + 1 &lt; index &amp;&amp; buffer[i + 1] == SerialProtocol.HEAD2) &#123; start = i; &#125; if (start != -1 &amp;&amp; buffer[i] == SerialProtocol.END &amp;&amp; i + 1 &lt; index &amp;&amp; buffer[i + 1] == SerialProtocol.END)&#123; end = i + 1; &#125; if (end != -1) &#123; break; &#125; &#125; //说明前面有脏数据，把数据前移start位 if (start &gt; 0) &#123; for (int i = 0; i &lt; buffer.length &amp;&amp; i + start &lt; buffer.length; i++) &#123; buffer[i] = buffer[i + start]; &#125; start = 0; end = end - start; index -= start; &#125; //如果找到了 if (start == 0 &amp;&amp; end &gt; start) &#123; //先把数据写入真实数据区域 byte[] data = new byte[end - start + 1]; System.arraycopy(buffer, start, data, 0, data.length); //然后向左移动数据 for (int i = start; i &lt; buffer.length; i++) &#123; if (i + data.length &lt; buffer.length) &#123; buffer[i] = buffer[i + data.length]; &#125; else &#123; buffer[i] = 0; &#125; &#125; //把index前移 index -= data.length; //这个其实应该不会发生 index = Math.max(0, index); ReadBytes readBytes = new ReadBytes(data, bigEndian()); //将数据交给处理器来处理 SerialProtocol protocol = new SerialProtocol(readBytes); if (protocol.isValid()) &#123; // 解析协议数据 parseData(new ReadBytes(protocol.data, bigEndian())); &#125; &#125; else &#123; break; &#125; &#125; &#125; &#125; else &#123; // 暂停一点时间，免得一直循环造成CPU占用率过高 Thread.sleep(10); &#125; &#125; catch (Exception e) &#123; LogUtils.e(TAG, &quot;DefaultReadThread exception: &quot;, e); &#125; &#125; &#125; /** * 关闭读线程 */ void close() &#123; mRunning = false; try &#123; this.interrupt(); &#125; catch (Exception e) &#123; LogUtils.e(TAG, &quot;DefaultReadThread close: &quot;, e); &#125; &#125;&#125; 一般会制定通讯协议，一个有效包需要完整包含起始、终止、以及校验位等，通过 InputStream 读取到字节数组后按照协议进行解析数据。读取有几个注意点： 数据包可能有多个类型，有的包 x 个字节，有的包 y 个字节，如果底层硬件都是往一个串口发送数据，那么就要做好解析的流程。每次读取应该是 x、y 的最大公约数，这样不管是 x 包还是 y 包发过来，我读取 n 次之后都能组装成一个完整的包，进行解析。例如：x &#x3D; 30，y &#x3D; 40，那么最好就是每次读取 10 个字节，这样读3次能组装成一个 x 的包，读 4 次组装成一个 y 的包。当然也可以直接一口气读取最大的值，40。但是这样就会导致一个问题：如果我发的是 x 包，只有 30 个字节，mInputStream.read(mReceiveBuffer) 会一直读满 40 个字节才返回，那么就会出现前 30 个字节是 x 包，后 10 个字节是 y 包的一部分，这样在解析的时候反而增加了成本。所以，目前项目中采用的就是 16 作为最大公约数，依此定义最小的包 16 个字节，其他的包必须是 16 的倍数，例如 32、64、128 等等。 所有的数据会先读取到一个 buffer 中，通过解析起始、结束标记位，来取出一个完整的包，再将 buffer 的剩余位左移此包的长度。例如我读取一个 64 字节的包，在读取多次后，buffer 长度正好为 70（可能有脏数据导致 buffer 长度不为 16 的倍数），假设解析到 start &#x3D; 2,end &#x3D; 66，start 之前的 2 个字节应该作为脏数据被抛弃掉，先将 2-&gt;66 位置的字节组装成 byte 数组抛到上层去解析。同时 buffer 左移 66 位，buffer 中就会只剩下 3 个字节了。 如何从 buffer 里解析出一个完整的包呢？通过协议，找到起始的 start index，找到终止的 end index，然后就可以确定一个完成的包了。但是如果内容是不确定的，那么就有可能导致找到的 end index 会提前。例如，结束字节为固定的 OxFF，但是内容很有可能就包含了 OxFF 这个字节，所以 end index 就会小于实际值，那么取出来的包就不完整，如此便会导致后面的包持续错位，一直解析错误。现在我采取的做法很“古板”，制定的结束字节为 2 个 OxFF，那么我便会一直找连续的 OxFF，代码可以简单一点，找连续的 3 个、4 个、5 个，然后取最后一个 OxFF 的 index 作为 end index。 byte 数组作为通用结构，硬件层一般是 c、c++，写入的字节一般是小端序，而 Java 一般是大端序，所以需要进行转换。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class ReadBytes &#123; // 是否需要高低位转换 private final boolean needHighLowCovert; private final byte[] data; private final int len; private int position = 0; public ReadBytes(byte[] data) &#123; this(data, false); &#125; public ReadBytes(byte[] data, boolean needHighLowCovert) &#123; this.data = data; this.len = data.length; this.needHighLowCovert = needHighLowCovert; &#125; public final byte read() throws IndexOutOfBoundsException &#123; return data[position++]; &#125; public void reset() &#123; position = 0; &#125; /** * 读取无符号byte * * @return * @throws IndexOutOfBoundsException */ public final int readUnsignedByte() throws IndexOutOfBoundsException &#123; return read() &amp; 0xff; &#125; public final byte[] readBytes(int len) throws IndexOutOfBoundsException &#123; byte[] value = Arrays.copyOfRange(data, position, position + len); position += len; return value; &#125; public final boolean readBoolean() throws IndexOutOfBoundsException &#123; byte value = read(); return value == 1; &#125; public final int readShort() throws IndexOutOfBoundsException &#123; int value; if (needHighLowCovert) &#123; value = (data[position++] &amp; 0xff) | ((data[position++] &amp; 0xff) &lt;&lt; 8); &#125; else &#123; value = ((data[position++] &amp; 0xff) &lt;&lt; 8) | data[position++]; &#125; return value; &#125; public final int readInt() throws IndexOutOfBoundsException &#123; int value; if (needHighLowCovert) &#123; value = ((data[position++] &amp; 0xFF) | ((data[position++] &amp; 0xFF) &lt;&lt; 8) | ((data[position++] &amp; 0xFF) &lt;&lt; 16) | ((data[position++] &amp; 0xFF) &lt;&lt; 24)); &#125; else &#123; value = ((data[position++] &amp; 0xFF) &lt;&lt; 24) | ((data[position++] &amp; 0xFF) &lt;&lt; 16) | ((data[position++] &amp; 0xFF) &lt;&lt; 8) | (data[position++] &amp; 0xFF); &#125; return value; &#125; public final long readLong() throws IndexOutOfBoundsException &#123; if (needHighLowCovert) &#123; return (((long) (data[position++]) &amp; 0xFF) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 8) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 16) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 24) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 32) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 40) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 48) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 56) ); &#125; else &#123; return (((long) (data[position++] &amp; 0xFF) &lt;&lt; 56) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 48) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 40) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 32) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 24) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 16) | ((long) (data[position++] &amp; 0xFF) &lt;&lt; 8) | ((long) (data[position++] &amp; 0xFF))); &#125; &#125; public final float readFloat() throws IndexOutOfBoundsException &#123; return Float.intBitsToFloat(readInt()); &#125; public final double readDouble() throws IndexOutOfBoundsException &#123; return Double.longBitsToDouble(readLong()); &#125;&#125; 串口在进行调试时不太方便，需要设备连接硬件，有时候在项目初始阶段，硬件采买十分有限。串口无非是不停写入数据然后应用层解析，所以为了方便调试，可以采用 Socket 方式（例如蓝牙）连接另一个客户端（手机人人都有），进行模拟写入数据。Java 在写入数据时，可以使用buffer.order(ByteOrder.LITTLE_ENDIAN) 来模拟底层硬件的小端序写入，这样解析端无需进行修改。123456789101112131415161718192021222324252627282930313233343536373839404142private BluetoothSocket createSocket() throws IOException &#123; BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(macAddress); BluetoothSocket socket = device.createRfcommSocketToServiceRecord(uuid); socket.connect(); return socket;&#125;public OutputStream connect() throws IOException &#123; socket = createSocket(); os = socket.getOutputStream(); return os;&#125;@Overridepublic void encode(OutputStream os) throws IOException &#123; byte[] bytes = toBytes(); os.write(bytes);&#125;/** * 按照协议组装模拟数据 */public byte[] toBytes() &#123; byte[] data = toData(); ByteBuffer buffer = ByteBuffer.allocate(data.length + 9); buffer.order(ByteOrder.LITTLE_ENDIAN); // 帧头，两字节 0xA5 0x5A buffer.put((byte) 0xA5); buffer.put((byte) 0x5A); int length = data.length + 5; // 帧长 帧长不包括帧（起始+EOF） // len=1（帧长）+数据长度+4（校验） // 所以=1 + 43 + 4 buffer.put((byte) length); buffer.put(data); // 校验4 CRC-32数据域校验结果，CRC参数见* buffer.putInt(0xFFFFFFFF); // EOF2 0xC3 0xC3 buffer.put((byte) 0xC3); buffer.put((byte) 0xC3); return buffer.array();&#125;","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"ViewPager 左右突出","date":"2020-05-09T08:29:19.000Z","path":"2020/05/09/viewpager-1/","text":"日常开发中经常会有如下需求： ViewPager 左右突出，实现起来非常简单： 123456&lt;android.support.v4.view.ViewPager android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clipToPadding=&quot;false&quot; android:paddingLeft=&quot;48dp&quot; android:paddingRight=&quot;48dp&quot; /&gt; 添加 padding、clipToPadding 即可。现在还有几个需求： 两边的 item 小一点，并且有透明度 item 之间的间距固定 滑动有动画效果 第 1点使用 scale 进行缩放即可，但是左边需要向右缩放，右边需要向左缩放，才能保证第 2 点。第 2 点使用 setPageMargin。第 3 点使用 setPageTransformer。 transformPage 有 2 个参数： page，View: Apply the transformation to this page position，float: Position of page relative to the current front-and-center position of the pager. 0 is front and center. 1 is one full page position to the right, and -1 is one page position to the left. 也就是左边的 View -10 变化，右边的 View 01 变化。下面问题来了，显示的页面并非在中间的时候缩放到最大，而是要滑动到左边的边缘才是最大。通过断点调试，发现 postion 值就没有出现过0，也就是从来没有滑到“正中间”。看到代码调用 transformPage 的地方： 123456789101112131415161718protected void onPageScrolled(int position, float offset, int offsetPixels) &#123; ... if (mPageTransformer != null) &#123; final int scrollX = getScrollX(); final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = getChildAt(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (lp.isDecor) continue; final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth(); mPageTransformer.transformPage(child, transformPos); &#125; &#125; ...&#125; 传回来的 transformPos 在进行计算时，没有考虑 ViewPager 的 padding，一切似乎都对应上了。自己计算位置，最终代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647viewPager.pageMargin = DimenUtils.dp2px(10f)viewPager.setPageTransformer(false) &#123; page: View, _: Float -&gt; var position = getPositionConsiderPadding(view.itemView.schoolViewPager, page) if (position &lt; -1) &#123; position = -1f &#125; if (position &gt; 1) &#123; position = 1f &#125; val scale: Float val alpha: Float val pivotX: Float val pivotY: Float when &#123; position &lt; 0 -&gt; &#123; scale = 1f + position * (1 - ORIGIN_SCALE) alpha = (0.5f + 0.5f * (1 + position)) pivotX = width.toFloat() pivotY = height / 2f &#125; position &gt; 0 -&gt; &#123; scale = 1f - position * (1 - ORIGIN_SCALE) alpha = (0.5f + 0.5f * (1 - position)) pivotX = 0f pivotY = height / 2f &#125; else -&gt; &#123; scale = 1f alpha = 1f pivotX = width / 2f pivotY = height / 2f &#125; &#125; page.alpha = alpha page.pivotX = pivotX page.pivotY = pivotY page.scaleX = scale page.scaleY = scale&#125;/** * 根据 padding 计算真实的 position */private fun getPositionConsiderPadding(viewPager: ViewPager, page: View): Float &#123; val clientWidth = (viewPager.measuredWidth - viewPager.paddingLeft - viewPager.paddingRight).toFloat() return ((page.left - viewPager.scrollX - viewPager.paddingLeft) / clientWidth)&#125; 注：scale 动画可以设置 x、y 的参照点，代码设置为相对值，不是百分比，所以需要根据百分比映射到真实的位置。 参考：解决几个ViewPager 异常问题 | 深入剖析","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"记一次电信一键登录的“BUG”","date":"2020-01-22T08:34:56.000Z","path":"2020/01/22/telecom/","text":"马上就要过年了，这几天公司的人越来越少，而我打算坚守到最后一天，虽然事情比较少，但也能稍微自己看点东西，充充电。然而，项目发布的 App 在华为渠道被拒了，原因是：在登录页的隐私协议，不能默认勾选上。然后我看到了这样的代码： 123456789101112&lt;CheckBox android:id=&quot;@+id/check_box&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:button=&quot;@null&quot; android:checked=&quot;true&quot; android:drawableLeft=&quot;@drawable/account__protocol_agree&quot; android:drawablePadding=&quot;7dp&quot; android:enabled=&quot;false&quot; android:text=&quot;同意&quot; android:textColor=&quot;#333333&quot; android:textSize=&quot;12dp&quot; /&gt; 登录页的 CheckBox 被禁用了，肯定也是点不了的。然后改一下，默认不选中，并添加相应的逻辑判断。 1234567891011121314&lt;CheckBox android:id=&quot;@+id/check_box&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:button=&quot;@drawable/account__login_protocol_agree_bg&quot; android:text=&quot; 同意&quot; android:textColor=&quot;#333333&quot; android:textSize=&quot;12dp&quot; /&gt;final boolean isChecked = protocolCb.isChecked();if (!isChecked) &#123; MainThreadUtils.toast(&quot;请先勾选同意《用户使用协议》和《隐私协议》&quot;); return;&#125; 一切都很顺利，直到电信一键登录。电信一键登录调起的页面是由 sdk 提供的，但是开发者可以提供布局，项目中的如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginBottom=&quot;35dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;CheckBox android:id=&quot;@+id/check_box&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:button=&quot;@null&quot; android:checked=&quot;true&quot; android:drawableLeft=&quot;@drawable/account__protocol_agree&quot; android:drawablePadding=&quot;7dp&quot; android:enabled=&quot;false&quot; android:text=&quot;&quot; android:textColor=&quot;#333333&quot; android:textSize=&quot;12dp&quot; /&gt; &lt;!-- 底部隐私协议文本配置说明： 1、SDK默认配置： a、文案的前面部分&quot;登录即同意《天翼账号服务与隐私协议》&quot;不可修改， b、《天翼账号服务与隐私协议》的色值通过android:tag属性设置，点击事件由SDK处理 --&gt; &lt;TextView android:id=&quot;@+id/reg_china_mobile_agreement&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;登录即同意《天翼账号服务与隐私协议》&quot; android:textSize=&quot;12dp&quot; android:textColor=&quot;#333333&quot; android:tag=&quot;#1DACF9&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;和&quot; android:textColor=&quot;#333333&quot; android:textSize=&quot;12dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/reg_user_agreement&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;《用户使用协议》&quot; android:textColor=&quot;#1DACF9&quot; android:textSize=&quot;12dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/reg_user_privacy_agreement&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;《隐私协议》&quot; android:textColor=&quot;#1DACF9&quot; android:textSize=&quot;12dp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 调用代码如下： 12345678910111213141516171819202122232425262728293031323334public void openQuickLoginActivity(Context context, QuickLoginModel quickLoginModel) &#123; AccountAssistUtils.onEvent(&quot;电信sdk-一键登录页&quot;); AuthPageConfig.Builder configBuilder = new AuthPageConfig.Builder() //设置“登录界面”的布局文件ID .setAuthActivityLayoutId(R.layout.account__activity_quick_login_china_telecom) //设置“登录界面”的控件ID .setAuthActivityViewIds(R.id.title_bar_left, //导航栏返回按钮ID R.id.phone_number, //脱敏号码文本控件ID R.id.ct_account_brand_view, //品牌标识文本控件ID R.id.ct_account_login_btn, //登录按钮控件ID R.id.ct_account_login_loading, //登录加载中控件ID（必须为ImageView控件） R.id.btn_one_key_login, //登录按钮文本控件ID R.id.btn_normal_login, //其他登录方式控件ID R.id.check_box, //隐私协议勾选框控件ID R.id.reg_china_mobile_agreement) //“服务与隐私协议”文本控件ID; //设置隐私协议WebviewActivity的布局文件ID .setWebviewActivityLayoutId(R.layout.account__activity_quick_login_china_telecom_argument) //设置隐私协议界面的控件ID .setWebviewActivityViewIds(R.id.ct_account_webview_goback, //导航栏返回按钮ID R.id.ct_account_progressbar_gradient, //进度条控件ID（ProgressBar控件） R.id.ct_account_webview) //协议内容WebView控件ID .setExtendView1(R.id.reg_user_agreement, v -&gt; AccountAssistUtils.toUserAgreement(MucangConfig.getCurrentActivity())) .setExtendView2(R.id.reg_user_privacy_agreement, v -&gt; &#123; AccountAssistUtils.toUserPrivacyAgreement(MucangConfig.getCurrentActivity()); &#125;); AuthPageConfig authPageConfig = configBuilder.build(); CtAuth.getInstance().openAuthActivity(context, authPageConfig, new ResultListener() &#123; @Override public void onResult(String json) &#123; onGetResult(context, json, quickLoginModel); &#125; &#125;);&#125; 然后我将 CheckBox 也类似的改了一下，结果崩溃了： 123456789101112131415161718192021222324252627282020-01-21 16:49:13.087 32472-32472/? E/AndroidRuntime: FATAL EXCEPTION: main Process: com.xxx.xxx.android, PID: 32472 android.content.res.Resources$NotFoundException: Resource ID #0x0 at android.content.res.ResourcesImpl.getValue(ResourcesImpl.java:299) at android.content.res.Resources.loadXmlResourceParser(Resources.java:2398) at android.content.res.Resources.getLayout(Resources.java:1292) at android.view.LayoutInflater.inflate(LayoutInflater.java:534) at android.view.LayoutInflater.inflate(LayoutInflater.java:483) at com.android.internal.policy.PhoneWindow.setContentView(PhoneWindow.java:520) at com.android.internal.policy.HwPhoneWindow.setContentView(HwPhoneWindow.java:328) at android.app.Dialog.setContentView(Dialog.java:735) at cn.com.chinatelecom.account.sdk.ui.a.onCreate(Unknown Source:29) at android.app.Dialog.dispatchOnCreate(Dialog.java:579) at android.app.Dialog.show(Dialog.java:397) at cn.com.chinatelecom.account.sdk.ui.a.a(Unknown Source:2) at cn.com.chinatelecom.account.sdk.ui.b.b(Unknown Source:14) at cn.com.chinatelecom.account.sdk.ui.b.onClick(Unknown Source:18) at android.view.View.performClick(View.java:7192) at android.view.View.performClickInternal(View.java:7166) at android.view.View.access$3500(View.java:824) at android.view.View$PerformClick.run(View.java:27592) at android.os.Handler.handleCallback(Handler.java:888) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:213) at android.app.ActivityThread.main(ActivityThread.java:8169) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1101) 说找不到资源文件，很懵逼，然后去查看 demo、相关文档，也没找到详细的说明。来来回回试了很多次，浪费了很多时间，也没找到问题所在，只要一改 CheckBox，必然崩溃。然后临近下班了，同事说帮我看看。然后定位异常，看到： 1cn.com.chinatelecom.account.sdk.ui.a.onCreate 于是找到相关的包，尽管混淆了，但是也能看。 12345678910111213141516171819202122232425262728293031package cn.com.chinatelecom.account.sdk.ui;public class a extends Dialog &#123; private cn.com.chinatelecom.account.sdk.ui.a.a a; private Context b; private AuthPageConfig c; private AuthViewConfig d; private TextView e; private View f; private View g; public a(Context var1, int var2) &#123; super(var1, var2); this.b = var1; &#125; protected void onCreate(Bundle var1) &#123; super.onCreate(var1); this.c = cn.com.chinatelecom.account.sdk.a.d.a().b(); this.d = cn.com.chinatelecom.account.sdk.a.d.a().c(); this.setContentView(this.c.k()); this.setCanceledOnTouchOutside(false); this.a(); if (this.d != null) &#123; this.c(); &#125; &#125; ...&#125; 然后异常报的找不到资源文件，那么可以合理猜测为 setContentView 时传入的参数无效，然后看到参数为 c.k。c 是 AuthPageConfig。然后再来看到 AuthPageConfig 的 k 参数是什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static class Builder &#123; private int a; private int b; private int c; private int d; private int e; private int f; private int g; private int h; private int i; private int j; private int k; private int l; private int m; private int n; private int o; private int p; private int q; private int r; private int s; private int t; private int u; private OnClickListener v; private OnClickListener w; private OnClickListener x; private boolean y; private boolean z; private int A; private int B; private int C; private int D; public AuthPageConfig.Builder setAuthActivityLayoutId(int var1) &#123; this.a = var1; return this; &#125; public AuthPageConfig.Builder setAuthActivityViewIds(int var1, int var2, int var3, int var4, int var5, int var6, int var7, int var8, int var9) &#123; this.b = var1; this.c = var2; this.d = var3; this.e = var4; this.f = var5; this.g = var6; this.h = var7; this.i = var8; this.j = var9; return this; &#125; public AuthPageConfig.Builder setPrivacyDialogLayoutId(int var1) &#123; this.k = var1; return this; &#125; ...&#125; 即通过setPrivacyDialogLayoutId方法来设置一个 Dialog 的布局。那么为什么会需要一个 Dialog 呢？而且是在改过 CheckBox 之后才会蹦。这个时候合理猜测：CheckBox 默认不勾选之后，登录需要提醒用户，sdk 内部则是使用 Dialog 来提醒用户。感觉完全说得通啊！于是再详细看 demo、文档： 123456789101112131415161718192021222324252627282930313233343536373839private AuthPageConfig getAuthPageConfig()&#123; AuthPageConfig.Builder configBuilder = new AuthPageConfig.Builder() //设置“登录界面”的布局文件ID .setAuthActivityLayoutId(R.layout.ct_account_auth_activity) //设置“登录界面”的控件ID .setAuthActivityViewIds(R.id.ct_account_nav_goback , //导航栏返回按钮ID R.id.ct_account_desensphone , //脱敏号码文本控件ID R.id.ct_account_brand_view, //品牌标识文本控件ID R.id.ct_account_login_btn , //登录按钮控件ID R.id.ct_account_login_loading , //登录加载中控件ID（必须为ImageView控件） R.id.ct_account_login_text , //登录按钮文本控件ID R.id.ct_account_other_login_way , //其他登录方式控件ID R.id.ct_auth_privacy_checkbox , //隐私协议勾选框控件ID R.id.ct_auth_privacy_text //“服务与隐私协议”文本控件ID ) //设置隐私协议对话框的布局文件ID .setPrivacyDialogLayoutId(R.layout.ct_account_privacy_dialog) //设置隐私协议对话框的控件ID .setPrivacyDialogViewIds(R.id.ct_account_dialog_privacy , //“服务与隐私协议”文本控件ID R.id.ct_account_dialog_cancel , // 返回按钮控件ID R.id.ct_account_dialog_confirm) //确认按钮控件ID //设置隐私协议WebviewActivity的布局文件ID .setWebviewActivityLayoutId(R.layout.ct_account_privacy_webview_activity) //设置隐私协议界面的控件ID .setWebviewActivityViewIds(R.id.ct_account_webview_goback , //导航栏返回按钮ID R.id.ct_account_progressbar_gradient , //进度条控件ID（ProgressBar控件） R.id.ct_account_webview); //协议内容WebView控件ID //扩展一：添加View及点击事件 （可选） //.setExtendView1(view1 ,onClickListener1) //.setExtendView1(view2 ,onClickListener2) //.setExtendView1(view2 ,onClickListener2) //扩展二：配置登录Activity进入动画和退出动画 （可选） //.setStartActivityTransition(enterAnim ,exitAnim) //.setFinishActivityTransition(enterAnim ,exitAnim) AuthPageConfig authPageConfig = configBuilder.build(); return authPageConfig;&#125; 也看到了 setPrivacyDialogLayoutId、setPrivacyDialogViewIds 方法的调用，感觉猜测很合理，于是在调用的地方也加入了相应的代码： 123456//设置隐私协议对话框的布局文件ID.setPrivacyDialogLayoutId(R.layout.account__dialog_privacy_agree)//设置隐私协议对话框的控件ID.setPrivacyDialogViewIds(R.id.account_dialog_privacy, R.id.account_dialog_cancel, R.id.account_dialog_confirm) 然后果然没蹦了，当不勾选 CheckBox 的时候，会弹出 Dialog 来提醒用户。至此，问题解决。 反思很尴尬，反过头来看问题其实很简单，但是自己却没有找出来，同事耐着性子查看混淆的代码，顺藤摸瓜找到根源，也就不到一小时时间。而我却花费大量时间在表面上，完全瞎猜，觉得没道理。在编译、打包的期间也没有做更多的思考，看到混淆的代码也没跟进去，十分肤浅！写下这边文章倒不是真的因为这个 BUG 有多么难解，而是记录下自己的“狼狈”状态，以后一定要改进，凡事多跟进，多思考，耐着性子解决问题。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"2019 年终总结","date":"2020-01-15T06:25:39.000Z","path":"2020/01/15/summary-2019/","text":"还有八天便是除夕了，又到了年终总结的时候了。2019 的总结，一个字：「难」。诉乐不诉苦，不管多难自己承受，「任何杀不死的，都会使我变得更为强大」。2019 还是有一些好事的。 电子锁我思想比较传统，网上能看到各种关于电子锁的负面评价，各种担忧，一直止步不前。2019 年我想通了，任何事情都有两面，自己权衡即可。索性换了电子锁，从此出门不用再带钥匙，出门忘带钥匙的尴尬再也不会发生（之前忘带钥匙让家人帮忙送钥匙的记忆依然铭记于心）。用到现在也没出现盗窃现象，也确实方便了很多，尤其是手里拿着快递的时候，极大提升了生活的幸福指数。 土豆2019 做了许多之前想做，但没做的事情。养猫算是 Top 1。6月份开始将土豆带回家，到现在也有半年多了，不知不觉每天铲屎的操作竟然持续了这么久，要是减肥能如此就好了。看着初来乍到的土豆慢慢成长成现在的样子，我只想感叹一句：岁月是把杀猪刀，猫也适用。现在变肥了，也没以前萌了，但我依然爱他。半年多的时间，土豆得了一次肠胃炎，打了几针后慢慢恢复了。前不久带他去做了绝育，现在正在恢复中，希望后面复查没什么大问题。他就像我的孩子，希望能一直健康快乐的成长。 国庆自驾游一直想去祖国的大西北，因为从没有去过，见过，所以内心的欲望非常强烈。和朋友一次偶然的对话，彻底地将内心的火苗点燃。从初步确定到最终出行，中间隔了 5 个月，能够出游真是十分难得。8 天的行程，5000 多公里，一路上经历许多平常体验不到的景色和危险。每隔一段时间，内心便会很失落，平凡的生活一点点磨平自己的棱角，需要这样的一趟旅程来缓解，来赋予生活新的意义。 女朋友是的，2019 我认识了将会和我携手一生的伴侣，实现了三年前定的目标。和她相处，让我感觉在「做自己」，我不用装模作样，让我很舒服。也正是这种感觉，让我们的感情迅速升温，婚纱照也拍了。现在我已然半只脚踩在了婚姻的“坟墓”中，但在我看来，这不算“坟墓”，任何问题都是可以解决的，我的下一段生活也一定会幸福美满。 工作最后来聊聊工作，年前最后一个季度加入到新的项目组，由于是公司最重要的项目，也是公司最直接的经济来源，项目成员都变忙了许多。大家忙前忙后，总算在过年前给公司交了一份满意的答卷，项目团队获得了年度最佳团队，奖励 20 万元。本以为自己也能获得表彰，拿一份奖项，然而并没有，就连绩效都是史上最低，有点失落。但也思考了这一年自己的工作成长，发现还是有一些事情是可以进步的，新的一年新的目标，奥里给！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"TextView 自定义“ellipsize”","date":"2019-12-24T03:23:43.000Z","path":"2019/12/24/textview-suffix/","text":"日常开发中，经常有 TextView 最多显示 3 行，超出了就显示“…查看更多”，在网上找到一个十分方便使用的类，原理也很简单，摘录一下，以后开发类似需求再也不愁了~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442private const val logTag = &quot;TextViewLayout&quot;private val enableDebugLog = BuildConfig.DEBUGprivate fun log(any: Any?) &#123; if (enableDebugLog) &#123; LogUtils.d(logTag, any.toString()) &#125;&#125;/** * TextViewBuilder * ellipsize textView with custom suffix. * link: https://juejin.im/post/5d4a5fb66fb9a06b0517d7eb */class TextViewSuffixWrapper(val textView: TextView) &#123; private data class SuffixColor(val fromIndex: Int, val toIndex: Int, val color: Int?, val listener: View.OnClickListener? = null) var mainContent: CharSequence = textView.text set(value) &#123; collapseCache = null field = value &#125; var suffix: CharSequence? = null set(value) &#123; collapseCache = null field = value &#125; private var collapseCache: CharSequence? = null private var collapseLayoutCache: Layout? = null var isCollapsed: Boolean = false private set var enableCache = false var enableMaxLinesCheck = true var targetLineCount: Int = 2 var transition: Transition? = AutoTransition() var sceneRoot: ViewGroup = textView.parent as ViewGroup private val textWrapper: (text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence = &#123; text, suffix, suffixIndex -&gt; SpannableStringBuilder(text).apply &#123; suffixColorList.forEach &#123; val start = suffixIndex + it.fromIndex val end = suffixIndex + it.toIndex it.listener?.also &#123; listener -&gt; setSpan(object : ClickableSpan() &#123; override fun onClick(widget: View) &#123; listener.onClick(widget) &#125; &#125;, start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) textView.movementMethod = LinkMovementMethod.getInstance() &#125; it.color?.also &#123; color -&gt; setSpan(ForegroundColorSpan(color), start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) &#125; &#125; &#125; &#125; private val suffixColorList by lazy &#123; mutableListOf&lt;SuffixColor&gt;() &#125; init &#123; if (textView.layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; throw RuntimeException(&quot;textView&#x27;s width can&#x27;t be wrap_content. Only support match_parent or specified size&quot;) &#125; &#125; fun suffixColor(fromIndex: Int, toIndex: Int, @ColorRes colorRes: Int) &#123; val color = ResourcesCompat.getColor(textView.resources, colorRes, textView.context.theme) suffixColorList.add(SuffixColor(fromIndex, toIndex, color, null)) &#125; fun suffixColor(fromIndex: Int, toIndex: Int, listener: View.OnClickListener) &#123; suffixColorList.add(SuffixColor(fromIndex, toIndex, null, listener)) &#125; fun suffixColor(fromIndex: Int, toIndex: Int, @ColorRes colorRes: Int, listener: View.OnClickListener) &#123; val color = ResourcesCompat.getColor(textView.resources, colorRes, textView.context.theme) suffixColorList.add(SuffixColor(fromIndex, toIndex, color, listener)) &#125; @JvmOverloads fun collapse(animation: Boolean = true) &#123; performCollapse( if (animation) &#123; transition &#125; else &#123; null &#125; ) &#125; @JvmOverloads fun toggle(animation: Boolean = true) &#123; if (isCollapsed) &#123; expand(animation) &#125; else &#123; collapse(animation) &#125; &#125; @JvmOverloads fun expand(animation: Boolean = true) &#123; performExpand( if (animation) &#123; this.transition &#125; else &#123; null &#125; ) &#125; private fun performExpand(transition: Transition?) &#123; isCollapsed = false textView.expand(mainContent = mainContent, transition = transition, sceneRoot = sceneRoot) &#125; private fun performCollapse(transition: Transition?) &#123; require(!(enableMaxLinesCheck &amp;&amp; textView.maxLines &lt; targetLineCount)) &#123; &quot;textView.maxLines($&#123;textView.maxLines&#125;) &lt; targetLineCount($targetLineCount)&quot; &#125; isCollapsed = true fun defaultCollapse() &#123; textView.maxLines = targetLineCount textView.ellipsize = TextUtils.TruncateAt.END val originText = textView.text textView.text = mainContent if (transition != null) &#123; textView.apply &#123; val layout = this.layout if (layout != null) &#123; val targetHeight = layout.height + paddingTop + paddingBottom text = originText maxLines = Int.MAX_VALUE layoutParams.height = targetHeight layoutParams = layoutParams transition.addListener(object : TransitionListenerAdapter() &#123; override fun onTransitionEnd(transition: Transition) &#123; transition.removeListener(this) layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT layoutParams = layoutParams maxLines = targetLineCount text = mainContent &#125; override fun onTransitionCancel(transition: Transition) &#123; transition.removeListener(this) &#125; &#125;) &#125; TransitionManager.beginDelayedTransition(sceneRoot, transition) &#125; &#125; &#125; if (suffix == null) &#123; defaultCollapse() &#125; else &#123; if (enableCache &amp;&amp; collapseCache != null &amp;&amp; collapseLayoutCache == textView.layout) &#123; if (collapseCache == mainContent) &#123; return &#125; if (transition != null) &#123; textView.setTextWithAnimator(content = collapseCache!!, transition = transition, sceneRoot = sceneRoot) &#125; else &#123; textView.maxLines = targetLineCount textView.ellipsize = TextUtils.TruncateAt.END textView.text = collapseCache &#125; &#125; else &#123; textView.collapse( mainContent = mainContent, suffix = suffix!!, targetLineCount = targetLineCount, transition = transition, sceneRoot = sceneRoot, onSuccess = &#123; text -&gt; collapseCache = text collapseLayoutCache = textView.layout &#125;, onFailed = &#123; defaultCollapse() &#125;, textWrapper = textWrapper ) &#125; &#125; &#125;&#125;@JvmOverloadsfun TextView.setTextWithAnimator( content: CharSequence, transition: Transition = AutoTransition(), sceneRoot: ViewGroup = this.parent as ViewGroup) &#123; val originText = this.text this.text = content val layout = this.layout if (layout != null) &#123; val targetHeight = layout.height + paddingTop + paddingBottom text = originText layoutParams.height = targetHeight layoutParams = layoutParams transition.addListener(object : TransitionListenerAdapter() &#123; override fun onTransitionEnd(transition: Transition) &#123; transition.removeListener(this) layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT layoutParams = layoutParams text = content &#125; override fun onTransitionCancel(transition: Transition) &#123; transition.removeListener(this) &#125; &#125;) &#125; TransitionManager.beginDelayedTransition(sceneRoot, transition)&#125;/** * collapse TextView * @param mainContent text * @param suffix suffix * @param targetLineCount targetLineCount * @param transition for animation. If is null, there will be no animation and it will take effect immediately. * @param onSuccess There may be asynchronous operations here, You can listen to the end event via onSuccess. * @param textWrapper You can wrap the text, such as changing the color through a SpannableString. */fun TextView.collapse( mainContent: CharSequence, suffix: CharSequence, targetLineCount: Int, transition: Transition? = AutoTransition(), sceneRoot: ViewGroup = this.parent as ViewGroup, onSuccess: ((text: CharSequence) -&gt; Unit)? = null, onFailed: ((text: CharSequence) -&gt; Unit)? = null, textWrapper: ((text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence)?) &#123; val originText = text setTextWithSuffix( mainContent = mainContent, suffix = suffix, targetLineCount = targetLineCount, onSuccess = &#123; result -&gt; if (transition == null) &#123; onSuccess?.invoke(result) &#125; else &#123; val targetText = text val targetHeight = layout.height + paddingTop + paddingBottom text = originText layoutParams.height = targetHeight layoutParams = layoutParams transition.addListener(object : TransitionListenerAdapter() &#123; override fun onTransitionEnd(transition: Transition) &#123; transition.removeListener(this) layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT layoutParams = layoutParams text = targetText onSuccess?.invoke(result) &#125; override fun onTransitionCancel(transition: Transition) &#123; transition.removeListener(this) &#125; &#125;) TransitionManager.beginDelayedTransition(sceneRoot, transition) &#125; &#125;, onFailed = &#123; this.text = mainContent this.maxLines = targetLineCount onFailed?.invoke(mainContent) &#125;, textWrapper = textWrapper )&#125;/** * expand TextView * @param mainContent text * @param transition for animation. If is null, there will be no animation and it will take effect immediately. */fun TextView.expand( mainContent: CharSequence, transition: Transition? = AutoTransition(), sceneRoot: ViewGroup = this.parent as ViewGroup) &#123; this.maxLines = Int.MAX_VALUE this.text = mainContent transition?.also &#123; TransitionManager.beginDelayedTransition(sceneRoot, it) &#125;&#125;fun TextView.setTextWithSuffix( mainContent: CharSequence, suffix: CharSequence, targetLineCount: Int, onSuccess: (text: CharSequence) -&gt; Unit = &#123;&#125;, onFailed: (text: CharSequence) -&gt; Unit = &#123; text -&gt; this.text = text maxLines = targetLineCount ellipsize = TextUtils.TruncateAt.END &#125;, textWrapper: ((text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence)?) &#123; val originText = text fun autoSet(index: Int) &#123; if (index &lt; 0) &#123; onFailed(originText) &#125; else &#123; text = if (index &gt;= mainContent.length) &#123; mainContent &#125; else &#123; val msg = &quot;$&#123;mainContent.substring(0, index)&#125;$suffix&quot; textWrapper?.invoke(msg, suffix, index) ?: msg &#125; onSuccess(text) &#125; &#125; if (layout == null) &#123; val listener = object : View.OnLayoutChangeListener &#123; override fun onLayoutChange( v: View?, left: Int, top: Int, right: Int, bottom: Int, oldLeft: Int, oldTop: Int, oldRight: Int, oldBottom: Int ) &#123; removeOnLayoutChangeListener(this) if (layout == null) &#123; onFailed(text) &#125; else &#123; post &#123; val start = System.currentTimeMillis() autoSet(binarySearch(mainContent, suffix, targetLineCount, textWrapper)) val end = System.currentTimeMillis() log(&quot;&gt;&gt;&gt;&gt;&gt;performance: $&#123;end - start&#125;ms&quot;) &#125; &#125; &#125; &#125; addOnLayoutChangeListener(listener) requestLayout() &#125; else &#123; val start = System.currentTimeMillis() autoSet(binarySearch(mainContent, suffix, targetLineCount, textWrapper)) val end = System.currentTimeMillis() log(&quot;&gt;&gt;&gt;&gt;&gt;performance: $&#123;end - start&#125;ms&quot;) &#125;&#125;/** * Note: binary search will change the text, so be sure to remember the case where the search failed. */private fun TextView.binarySearch( mainContent: CharSequence, suffix: CharSequence, targetLineCount: Int, textWrapper: ((text: String, suffix: CharSequence, suffixIndex: Int) -&gt; CharSequence)?): Int &#123; var verifyCount = 0 val verifyCache = mutableMapOf&lt;Int, Int&gt;() fun verify(start: Int, end: Int): Int &#123; val key = (start shl 16) or end val hit = verifyCache[key] if (hit != null) &#123; log(&quot;verify: $end cached&quot;) return hit &#125; verifyCount++ val tmp = mainContent.substring(start, end) val context = &quot;$tmp$suffix&quot; text = textWrapper?.invoke(context, suffix, end) ?: context val lineCount = this.lineCount log(&quot;verify: $end, lineCount = $lineCount&quot;) verifyCache[key] = lineCount return lineCount &#125; if (layout == null) &#123; log(&quot;layout is null&quot;) return -1 &#125; val verify = verify(0, mainContent.length) if (verify &lt;= targetLineCount) &#123; log(&quot;verify &lt;= targetLineCount, verify = $verify, targetLineCount = $targetLineCount&quot;) text = mainContent return mainContent.length &#125; // Remove optimization. Some special characters will cause bug. // var left = this.layout.getLineEnd(targetLineCount - 2) // var right = this.layout.getLineEnd(targetLineCount - 1) var left = 0 var right = mainContent.length log(&quot;left = $left, right = $right&quot;) while (left &lt;= right) &#123; val mid = (left + right) / 2 val pLineCount = verify(0, mid) var s = &quot;binarySearch: ($left, $mid, $right), pLineCount = $pLineCount&quot; if (pLineCount &lt; targetLineCount) &#123; s += &quot;, targetLineCount = $targetLineCount, pLineCount &lt; targetLineCount&quot; left = mid + 1 &#125; else if (pLineCount == targetLineCount) &#123; val nLineCount = verify(0, mid + 1) s += &quot;, nLineCount = $nLineCount&quot; if (nLineCount &lt; targetLineCount + 1) &#123; left = mid + 1 &#125; else if (nLineCount == targetLineCount + 1) &#123; log(&quot;success = $mid, verifyCount = $verifyCount&quot;) return mid &#125; else &#123; // error impossible log(&quot;impossible&quot;) break &#125; &#125; else &#123; right = mid - 1 &#125; log(&quot;$s, text = $&#123;mainContent.substring(0, mid) + suffix&#125;&quot;) &#125; log(&quot;failed, verifyCount = $verifyCount&quot;) return -1&#125; 使用： 12345678TextViewSuffixWrapper(topicView.descTv).apply &#123; targetLineCount = 3 suffix = &quot;...查看全部&quot; suffix?.apply &#123; suffixColor(&quot;...&quot;.length, length, R.color.main_title_text_color_checked) &#125; collapse(false)&#125; 还可以添加点击事件，点击后撑开，着实方便~ 参考：Android TextView用”查看更多”替代自带ellipsize","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"土豆历险记","date":"2019-12-18T06:58:46.000Z","path":"2019/12/18/cat-1/","text":"上上周末，带土豆去洗了一次澡。从领回家到现在，就洗过一次澡…洗完澡之后，在烘干机里瑟瑟发抖。 后面回到家，可神气了。嗯，然后没过几天，早晨起来铲屎的时候，土豆在我旁边颤抖，痉挛，然后吐了几口“水”出来了。当时赶着要上班，没办法，只把呕吐物处理了一下就出门了。然后下班回去后，又看到吐了一次。顿时心里发凉，从来没有给猫看病的经验，也不知道土豆现在是个什么样的情况，土豆要是能说话就好了。没有办法，当即地图查询附近的宠物医院，然后找了一家最近的，把土豆送过去。话不多说，检查先来一套，花费 280 块。根据检查结果，排除猫瘟的可能性，初步判断为肠胃炎。起初我还以为是洗澡给搞感冒了，但是隔了三天之久，可能性不大。土豆精神萎靡不振，也不进食，非常担心。根据检测结果，后面听医生的，给打了 3 针小针，合计 120 块，然后带回家观察。好运的是，土豆没有再吐了，但是仍然不进食，以前一天的量现在放几天都没怎么吃，水也喝得很少，无奈只能不停得给他喂营养膏。以前看到这玩意，土豆都是箭步冲过来，然后扒拉我，不停得叫，吃得贼香。现在给他送到嘴边，也只是非常淑女地吃几口。前后巨大的落差让我越发地担心土豆的病情。看到没吐之后，就没送到医院去看了。结果有一天，他拉完屎蹦到我桌上，屁股对着我，我一瞅：哎哟卧槽，怎么还有血！然后就又慌了，连忙送到医院。当时都过了晚上 8.30 了，医院还说过了下班的点，看病得加 120 块钱。好歹我嘴皮子能磨：这我是今天才知道，要不今天就算了吧？我后面肯定尽量早些送过来。医生：好吧。省了 120 块，嘿嘿嘿…嗯，送到医院后，医生：需要再做个检查，但是还是看你。前几天做得检查只能说明当时情况正常，不代表这几天有没有恶化。这话意思很明显，就是不给我明确的病情解析，让我瞎担心，然后掏钱给土豆做检查。但是我一个理科生，怎么能被如此忽悠！我：看情况应该是拉屎有问题，就做个便检吧，这几天土豆没怎么吃喝，也没去过外面，应该不会出现新的病情。然后就只做了一个便检，说情况正常，没有检测到寄生虫、病菌之类的，符合肠胃炎的特征，听完我就稍微放心了些。然后又和我说：土豆现在的情况还是不容乐观，建议打针或者输液，但是具体选择还是在你，我们只提供建议。mmp，听完这句话我内心就炸了：你作为一个医生，不为我提供专业的诊断，尽在这忽悠我，这有可能，那有可能，让我瞎操心，然后就好掉进你们的陷阱，你们说啥就是啥了吧。随便检查一下，打个针，400 块没了，你们就只能赚这种钱？虽然我是这样想，但是我并没有明说，我只是淡淡地说，今天太晚了，就不打针了，明天早上（周末了）我再送过来打针吧，然后就溜了。然后观察了一晚，突然发现土豆有进食的欲望了！诶(二声)，这是有慢慢恢复的趋势啊！然后第二天观察土豆精神还不错，略有进食，结合我们人生病的情况来看，我觉得应该是慢慢恢复了，索性就没送去输液了。然后下午医生联系我：土豆今天情况怎么样？我：看着还不错，我再观察观察。然后这医生就没叼我了。呵呵哒…还好这几天土豆恢复得不错，胃口越来越好，食量慢慢恢复到之前得水准，也越来越有精神了。截至今日，应该算恢复得差不多了。这次给猫治病的经历，给我上了一堂课，以前以为养猫很简单，就每天喂喂食物和水，然后铲铲屎就行了，但是给猫看病才是真正麻烦的问题，也是消费最贵的。给猫看病，需要有自己的判断力，不能被不良医院忽悠。就像人得了个感冒，医院却把你当癌症来治。同时，自己日常需要多补充些猫相关的知识，这样才能更好的照顾他们。后面再也不能喂他吃人吃的食物了，早晨在家吃个馒头、包子、火腿肠啊，就跑过来大眼睛瞪着你，然后不停的叫，就会弄一丢丢给他吃，这也许就是土豆得肠胃炎的根本原因，还是只喂猫粮、营养膏，不然生病了就得不偿失。再贴几张土豆这几天的照片： 参考对于患肠胃炎的猫咪应该如何调理？89%铲屎官都不知道的养猫知识！记录猫咪急性肠胃炎的诊断和治疗方法","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"记一次动画实践-续","date":"2019-12-18T03:28:39.000Z","path":"2019/12/18/anim-continue/","text":"嗯，这篇文章是接着上一篇的，因为需求“变”了。上一篇文章中已经实现了滑动动画效果，现在需求变为：当停止滑动时，判断当前状态，若满足一个阈值就直接展开或者收起，也就是动画进度为 0 或 1 的状态。如果只是单纯这种展开或者收起的效果，使用 layout_scrollFlags 的 snap 效果即可实现。layout_scrollFlags 有 5 种效果，摘录一片博客中的内容： scroll The view will be scroll in direct relation to scroll events. This flag needs to be set for any of the other flags to take effect. If any sibling views before this one do not have this flag, then this value has no effect. Child View 伴随着滚动事件而滚出或滚进屏幕。注意两点：第一点，如果使用了其他值，必定要使用这个值才能起作用；第二点：如果在这个 Child View 前面的任何其他 Child View 没有设置这个值，那么这个 Child View 的设置将失去作用。 enterAlways When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling. This is commonly referred to as the ‘quick return’ pattern. 快速返回模式。其实就是向下滚动时 Scrolling View 和 Child View 之间的滚动优先级问题。对比 scroll 和 scroll | enterAlways 设置，发生向下滚动事件时，前者优先滚动 Scrolling View，后者优先滚动 Child View，当优先滚动的一方已经全部滚进屏幕之后，另一方才开始滚动。 enterAlwaysCollapsed An additional flag for ‘enterAlways’ which modifies the returning view to only initially scroll back to it’s collapsed height. Once the scrolling view has reached the end of it’s scroll range, the remainder of this view will be scrolled into view. The collapsed height is defined by the view’s minimum height. enterAlways的附加值。这里涉及到 Child View 的高度和最小高度，向下滚动时，Child View 先向下滚动最小高度值，然后 Scrolling View 开始滚动，到达边界时，Child View 再向下滚动，直至显示完全。 exitUntilCollapsed When exiting (scrolling off screen) the view will be scrolled until it is ‘collapsed’. The collapsed height is defined by the view’s minimum height. 这里也涉及到最小高度。发生向上滚动事件时，Child View 向上滚动退出直至最小高度，然后 Scrolling View 开始滚动。也就是，Child View 不会完全退出屏幕。 snap Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it’s closest edge. For example, if the view only has it’s bottom 25% displayed, it will be scrolled off screen completely. Conversely, if it’s bottom 75% is visible then it will be scrolled fully into view. 简单理解，就是 Child View 滚动比例的一个吸附效果。也就是说，Child View 不会存在局部显示的情况，滚动 Child View 的部分高度，当我们松开手指时，Child View 要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似 ViewPager 的左右滑动。 给 bgView 添加使用 snap 效果： 12345678&lt;ImageView android:id=&quot;@+id/bgView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;375dp&quot; android:layout_marginBottom=&quot;-217dp&quot; android:scaleType=&quot;fitXY&quot; android:src=&quot;@drawable/jiakao_ke3_exam_route_unbuy_banner&quot; app:layout_scrollFlags=&quot;scroll|snap&quot; /&gt; 运行后 bgView 一直是张开状态，收不起来。如果把 marginBottom 去掉则可以收起了。目测是必须要滑到 一半的距离 才可以收起。于是跑到源码里去看，研究了一阵没发现修改这个距离的办法。由于是原生提供，所以我更倾向这个方案。无奈界面的覆盖效果，必须使用 marginBottom 设置负值，所以只能另寻他法了。那么便只能自己监听事件，来做滑动了。自定义 CoordinatorLayout 判断上滑、下滑： 12345678910111213141516171819202122232425262728293031323334class ExamVideoCoordinatorLayout(context: Context, attr: AttributeSet) : CoordinatorLayout(context, attr) &#123; var listener: ExamVideoScrollListener? = null private var originY = 0F private val scrollHandler = Handler() @SuppressLint(&quot;ClickableViewAccessibility&quot;) override fun dispatchTouchEvent(event: MotionEvent): Boolean &#123; if (event.action == MotionEvent.ACTION_DOWN) &#123; originY = event.y scrollHandler.removeCallbacksAndMessages(null) &#125; else if (event.action == MotionEvent.ACTION_UP) &#123; val y = event.y if (y &gt; originY) &#123; scrollHandler.postDelayed(&#123; listener?.scrollDown() &#125;, 100L) &#125; else &#123; scrollHandler.postDelayed(&#123; listener?.scrollUp() &#125;, 100L) &#125; &#125; return super.dispatchTouchEvent(event) &#125;&#125;interface ExamVideoScrollListener &#123; fun scrollUp() fun scrollDown()&#125; 然后设置 listener： 123456789101112131415161718192021222324252627282930coordinator.listener = object : ExamVideoScrollListener &#123; override fun scrollUp() &#123; appBarLayout.post &#123; val behavior = (appBarLayout?.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior if (behavior is AppBarLayout.Behavior) &#123; val topAndBottomOffset = behavior.topAndBottomOffset if (Math.abs(topAndBottomOffset) &gt; DimenUtils.dp2px(150F) * 0.2) &#123; appBarLayout.setExpanded(false, true) &#125; else &#123; appBarLayout.setExpanded(true, true) &#125; &#125; &#125; &#125; override fun scrollDown() &#123; appBarLayout.post &#123; val behavior = (appBarLayout?.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior if (behavior is AppBarLayout.Behavior) &#123; val topAndBottomOffset = behavior.topAndBottomOffset if (Math.abs(topAndBottomOffset) &lt; DimenUtils.dp2px(150F) * 0.8) &#123; appBarLayout.setExpanded(true, true) &#125; else &#123; appBarLayout.setExpanded(false, true) &#125; &#125; &#125; &#125;&#125; 通过判断 AppBarLayout 的 topAndBottomOffset 值，来执行 appBarLayout.setExpanded() 方法，第一个参数为 appBarLayout 是否打开，第二个参数为是否使用动画。使用此种方式，基本能实现效果，但是有小概率操作（手指 fling），会导致 AppBarLayout 处于中间态，目前还没发现好的解决办法，只能先妥协了~ 参考：Android 详细分析AppBarLayout的五种ScrollFlags","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"记一次动画实践","date":"2019-12-12T03:48:19.000Z","path":"2019/12/12/anim/","text":"废话少说，先上效果图：Your browser does not support the video tag.得如何实现这样的效果呢？ 首先，将动画拆分几个独立的部分： 「芳草地考场」横轴从左侧移动到中间，纵轴移动到标题栏，字体同时变小； 「切换考场」纵轴移动到标题栏，距离右侧边距变斤，字体同时变小； 「标题栏」背景渐变，图标颜色变化； 「考场横向列表」缩小，左移靠边，同时能吸顶； 现在来考虑具体要怎么做。做开始想到的就是 CoordinatorLayout + CollapsingToolbarLayout 来实现，Google 后发现实现的效果与预期不同，又没有足够的时间去研究，所以抛弃了此方案，打算直接自己写。那么要如何写呢？动画无非是由一系列的状态组合起来的，当滑动 100dp 时，界面这样展示；当滑动 200dp 时，界面那样展示。思路就很明确了：直接监听页面滑动，根据滑动的距离，来展示界面所有的元素。那么剩下的，便是根据滑动距离，来做 4 个部分动画元素的展示了。最终实现的 xml 布局如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#F7FBFF&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appBarLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:elevation=&quot;0dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/bgView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;375dp&quot; android:layout_marginBottom=&quot;-217dp&quot; android:scaleType=&quot;fitXY&quot; android:src=&quot;@drawable/jiakao_ke3_exam_route_unbuy_banner&quot; app:layout_scrollFlags=&quot;scroll&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/videoLl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;12dp&quot; android:layout_marginTop=&quot;68dp&quot; android:layout_marginRight=&quot;-12dp&quot; android:background=&quot;@drawable/bg_white_corner_5dp&quot; android:orientation=&quot;vertical&quot; android:paddingBottom=&quot;12dp&quot; tools:ignore=&quot;MissingPrefix&quot;&gt; &lt;include android:id=&quot;@+id/tipView&quot; layout=&quot;@layout/exam_route_line_top_tip&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;36dp&quot; android:layout_marginRight=&quot;12dp&quot; android:visibility=&quot;invisible&quot; /&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/placeRv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot; android:clipToPadding=&quot;false&quot; android:paddingRight=&quot;27dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:clipToPadding=&quot;false&quot; android:paddingBottom=&quot;80dp&quot; android:scrollbars=&quot;none&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;include layout=&quot;@layout/layout_exam_video_unbuy_bottom&quot; /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;RelativeLayout android:id=&quot;@+id/titleRl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;68dp&quot; android:fitsSystemWindows=&quot;true&quot; app:layout_behavior=&quot;.paid_video.behavior.ExamTitleBehavior&quot;&gt; &lt;ImageView android:id=&quot;@+id/backIv&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;1dp&quot; android:layout_marginTop=&quot;20dp&quot; android:scaleType=&quot;centerInside&quot; android:src=&quot;@drawable/core__title_bar_back_icon&quot; android:tint=&quot;#FFFFFFFF&quot; /&gt; &lt;TextView android:id=&quot;@+id/locationTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_marginRight=&quot;22dp&quot; android:gravity=&quot;center_vertical&quot; android:includeFontPadding=&quot;false&quot; android:text=&quot;北京&quot; android:textColor=&quot;#FFFFFFFF&quot; android:textSize=&quot;14dp&quot; /&gt; &lt;ImageView android:id=&quot;@+id/locationIv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_marginRight=&quot;5dp&quot; android:layout_toLeftOf=&quot;@id/locationTv&quot; android:src=&quot;@drawable/jiakao__ic_exam_route_video_dizhi&quot; android:tint=&quot;#FFFFFFFF&quot; /&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=&quot;@+id/titleTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;28dp&quot; android:layout_marginTop=&quot;230dp&quot; android:ellipsize=&quot;marquee&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; android:gravity=&quot;center&quot; android:marqueeRepeatLimit=&quot;marquee_forever&quot; android:maxWidth=&quot;200dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000&quot; android:textSize=&quot;21sp&quot; android:textStyle=&quot;bold&quot; app:layout_behavior=&quot;.paid_video.behavior.ExamPlaceNameBehavior&quot; tools:text=&quot;芳草地考场&quot; /&gt; &lt;TextView android:id=&quot;@+id/switchPlaceTv&quot; android:layout_width=&quot;106dp&quot; android:layout_height=&quot;32dp&quot; android:layout_gravity=&quot;right&quot; android:layout_marginTop=&quot;238dp&quot; android:layout_marginRight=&quot;15dp&quot; android:background=&quot;@drawable/bg_shape_ff8149_ff2803_r100&quot; android:gravity=&quot;center&quot; android:text=&quot;切换考场 &gt;&quot; android:textColor=&quot;#ffffff&quot; android:textSize=&quot;16sp&quot; app:layout_behavior=&quot;.paid_video.behavior.SwitchPlaceBehavior&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 下面逐一来解析。 bgView 是最上面的背景图，高度 375dp，「考场横向列表」卡片需要覆盖一部分在上面，AppBarLayout 是继承自 LinearLayout 的，所以加了个 android:layout_marginBottom&#x3D;”-217dp” 以此来实现覆盖效果。 当滑到最大值时，顶部的 tipView 与 placeRv 需要吸顶，所以二者组合为一个 LinearLayout，同时只给 bgView 设置 **app:layout_scrollFlags&#x3D;”scroll”**，便可实现吸顶。因为整个界面是通栏，所以在动画结束状态，videoLl 需要设置一个 **android:layout_marginTop&#x3D;”68dp”**，使其正好处于标题栏之下。参考Android 滑动吸顶效果。 「芳草地考场」、「切换考场」、「标题栏」需要在页面最上层展示，所以直接写到 CoordinatorLayout 最外层。 「芳草地考场」、「切换考场」 的 marginTop 都是依据设计稿写死的值，使其正好处于 AppBarLayout 的某个位置，不能轻易改。 NestedScrollView include 底部的列表布局，进行嵌套滑动。 ok，现在静态界面写好了，下面就是要根据页面滑动来进行元素展示了。CoordinatorLayout 直接子孩子可以直接使用 Behavior，这样可以将 4 个动画块分开，非直接子孩子则使用监听的方式。「芳草地考场」Behavior： 1234567891011121314151617181920212223242526272829303132class ExamPlaceNameBehavior(context: Context, attr: AttributeSet) : CoordinatorLayout.Behavior&lt;TextView&gt;(context, attr) &#123; private val dp230 = DimenUtils.dp2px(230F) private val startLeftMargin = DimenUtils.dp2px(28F) private val topMarginGap = dp230 - DimenUtils.dp2px(20F) override fun layoutDependsOn(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; return dependency is AppBarLayout &#125; override fun onDependentViewChanged(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; if (dependency is AppBarLayout) &#123; val offset = abs(dependency.top) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; val maxMargin = (DimenUtils.getScreenWidth() - child.width) / 2 (child.layoutParams as CoordinatorLayout.LayoutParams).leftMargin = (startLeftMargin + (maxMargin - startLeftMargin) * progress).toInt() (child.layoutParams as CoordinatorLayout.LayoutParams).topMargin = (dp230 - topMarginGap * progress).toInt() child.isSelected = progress == 0F child.textSize = 21 - 4 * progress child.requestLayout() return true &#125; return false &#125;&#125; 「切换考场」Behavior： 12345678910111213141516171819202122232425262728293031323334353637class SwitchPlaceBehavior(context: Context, attr: AttributeSet) : CoordinatorLayout.Behavior&lt;TextView&gt;(context, attr) &#123; private val dp15 = DimenUtils.dp2px(15F) private val dp32 = DimenUtils.dp2px(32F) private val dp106 = DimenUtils.dp2px(106F) private val dp238 = DimenUtils.dp2px(238F) private val widthGap = DimenUtils.dp2px(106F - 86F) private val heightGap = DimenUtils.dp2px(32F - 28F) private val rightMarginGap = DimenUtils.dp2px(15F - 12F) private val topMarginGap = DimenUtils.dp2px(238F - 30F) override fun layoutDependsOn(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; return dependency is AppBarLayout &#125; override fun onDependentViewChanged(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; if (dependency is AppBarLayout) &#123; val offset = abs(dependency.top) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; (child.layoutParams as ViewGroup.MarginLayoutParams).width = (dp106 - widthGap * progress).toInt() (child.layoutParams as ViewGroup.MarginLayoutParams).height = (dp32 - heightGap * progress).toInt() (child.layoutParams as ViewGroup.MarginLayoutParams).rightMargin = (dp15 - rightMarginGap * progress).toInt() (child.layoutParams as ViewGroup.MarginLayoutParams).topMargin = (dp238 - topMarginGap * progress).toInt() child.textSize = 16 - 2 * progress child.requestLayout() return true &#125; return false &#125;&#125; 「标题栏」Behavior： 123456789101112131415161718192021222324252627282930class ExamTitleBehavior(context: Context, attr: AttributeSet) : CoordinatorLayout.Behavior&lt;RelativeLayout&gt;(context, attr) &#123; override fun layoutDependsOn(parent: CoordinatorLayout, child: RelativeLayout, dependency: View): Boolean &#123; return dependency is AppBarLayout &#125; override fun onDependentViewChanged(parent: CoordinatorLayout, child: RelativeLayout, dependency: View): Boolean &#123; if (dependency is AppBarLayout) &#123; val offset = abs(dependency.top) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; val activity = ActivityUtils.findActivity(child) child.setBackgroundColor(Color.argb((progress * 255).toInt(), 255, 255, 255)) if (progress &gt; 0.5) &#123; StatusBarUtils.setStatusBarTransparentBg(activity, true) child.backIv.setColorFilter(Color.parseColor(&quot;#333333&quot;)) &#125; else &#123; child.backIv.setColorFilter(Color.parseColor(&quot;#ffffff&quot;)) StatusBarUtils.setStatusBarTransparentBg(activity, false) &#125; return true &#125; return false &#125;&#125; 「考场横向列表」监听： 1234567891011121314151617181920212223242526272829303132333435appBarLayout.addOnOffsetChangedListener(AppBarLayout.OnOffsetChangedListener &#123; _, y -&gt; val offset = abs(y) var progress = offset / MAX_OFFSET if (progress &gt; 1) &#123; progress = 1F &#125; if (progress &lt; 0) &#123; progress = 0F &#125; if ((placeRv.tag as? Float) != progress) &#123; if (ExamRouteLineTopTipModel.needClose()) &#123; (placeRv.layoutParams as ViewGroup.MarginLayoutParams).topMargin = (DimenUtils.dp2px(20F) - DimenUtils.dp2px(8F) * progress).toInt() &#125; else &#123; (placeRv.layoutParams as ViewGroup.MarginLayoutParams).topMargin = (DimenUtils.dp2px(56F) - DimenUtils.dp2px(48F) * progress).toInt() &#125; (videoLl.layoutParams as ViewGroup.MarginLayoutParams).leftMargin = (DimenUtils.dp2px(12F) * (1 - progress)).toInt() if (progress == 1F) &#123; if (tipView.visibility == View.INVISIBLE) &#123; tipView.visibility = View.VISIBLE &#125; videoLl.setBackgroundResource(R.drawable.white) &#125; else &#123; if (tipView.visibility == View.VISIBLE) &#123; tipView.visibility = View.INVISIBLE &#125; videoLl.setBackgroundResource(R.drawable.bg_white_corner_5dp) &#125; placeRv.tag = progress (placeRv.adapter as? ExamVideoUnbuyAdapter)?.setProgress(progress) &#125;&#125;) tipView 通过 ExamRouteLineTopTipModel.needClose() 判断是否需要展示，两种状态的 margin 不一致，需要区分开。另外，CoordinatorLayout 有子孩子变化，都会回调到 OnOffsetChangedListener，所以需要保存 progress，避免一直调用方法。因为需求太具体，文章写起来不宜碎碎念，就只帖了代码，记录一下，以后碰到类似需求，有思路去做。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"问题集锦","date":"2019-11-29T10:18:21.000Z","path":"2019/11/29/tips/","text":"换了个项目组，最近忙了很多，没空写什么东西，碎碎念贴点碰到的小问题。 文件校验应用内部有本地数据库，有版本校验，会不定时更新，在使用的时候会使用 md5 进行校验。当更新版本后，发现数据库更新一直失败，调试后发现是 md5 值不一致，一脸懵逼的状态。数据库文件由服务端下发，然后复制移动到目标工程，并没有改任何东西，为何会造成 md5 值不一致呢？最后定位问题：同事拿到数据库文件，为了确定版本是对的，打开 db 文件看了一眼，然后 SQLite 就会自动写入一些东西，导致 md5 值改变。 涨点姿势，以后应当注意。 移除权限现在项目中难免会集成某些三方库，基础库，这些库有些时候大而全的会申明许多并未用到的权限，项目在集成时需要移除这些权限。如何在不修改三方库、基础库的基础上移除呢？以蓝牙权限为例，在 AndroidManifest.xml 中声明： 12&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; tools:node=&quot;remove&quot;/&gt; webp 加载为了达到某些页面效果，设计师会设计一些动态图，有时是 gif，有时是 webp。碰到的问题是 webp 的文件放到 xhdpi 文件夹会一直报错：unsolved reference，也不知道是什么原因。放到其他分辨率的文件夹下 就好了，暂时还不知道原因。 恢复“误删”的本地文件项目中有 Java、Kotlin 文件，当把 Java 文件转成 Kotlin 文件时，会生成新的 Git 记录，无法查看 .java 文件的历史提交记录。可以右键项目根目录，然后选择 Local History，然后可以搜索出 .java 文件对照着看。 Android Studio 代码错位莫名其妙 .java 文件展示了 .xml 的内容，文件全部错乱展示，为 Android Studio 编译错误导致。删除所有的编译文件：.idea、.gradle、build 文件夹，以及 &#x2F;user&#x2F;AndroidStudio3.5&#x2F;system&#x2F;caches 文件夹，然后重启。 View 设置背景当有这样一个 selector： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:color=&quot;#4A5356&quot; android:state_selected=&quot;true&quot; /&gt; &lt;item android:color=&quot;@android:color/transparent&quot; /&gt;&lt;/selector&gt; 调用 view.setBackgroundResource 时会失败，可以使用 StateListDrawable，手动 addState。或者使用 shape： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;#333333&quot; /&gt; &lt;corners android:bottomLeftRadius=&quot;4dp&quot; android:topLeftRadius=&quot;4dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item android:right=&quot;-2dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#333333&quot; /&gt; &lt;corners android:bottomLeftRadius=&quot;4dp&quot; android:topLeftRadius=&quot;4dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;#333333&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#333333&quot; /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;#333333&quot; /&gt; &lt;corners android:bottomRightRadius=&quot;4dp&quot; android:topRightRadius=&quot;4dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item android:left=&quot;-2dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#333333&quot; /&gt; &lt;corners android:bottomRightRadius=&quot;4dp&quot; android:topRightRadius=&quot;4dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; selector 可以添加各种 item 实现不用的效果，item 内部可以使用 layer-list 来达到不同的效果覆盖。 TextView 走马灯123456789101112131415161718&lt;TextView android:id=&quot;@+id/titleTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;28dp&quot; android:layout_marginTop=&quot;230dp&quot; android:ellipsize=&quot;marquee&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; android:gravity=&quot;center&quot; android:marqueeRepeatLimit=&quot;marquee_forever&quot; android:maxWidth=&quot;200dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000&quot; android:textSize=&quot;21sp&quot; android:textStyle=&quot;bold&quot; app:layout_behavior=&quot;.paid_video.behavior.ExamPlaceNameBehavior&quot; tools:text=&quot;芳草地考场&quot; /&gt; 可以使用 titleTv.isSelected &#x3D; true 来开启走马灯效果。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"十月","date":"2019-10-31T01:59:40.000Z","path":"2019/10/31/october/","text":"银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星。 十月，秋高气爽，中秋国庆，适合出游。一直没空写点东西，在十月的尾巴，还是写点东西吧。 早在 6、7 月份，便有了想去「西北大环线」的冲动。大学伊始到现在的几年里，去的地方也有一些了，山呀，水呀，都见过很多了，唯独大西北那种戈壁、荒漠的自然风光却只存在于想象里。在基友群里吹牛，说想去大西北，吹着吹着发现就这样组起队来了：去啊，去他妈的！老康、斌哥还是给力呀，行动力 Max。人员定了之后，初步聊了一下，后面就没怎么聊了，直到出发的前一天，感觉很梦幻：就这样出发了吗？总有种感觉会鸽掉。所幸没有。 Your browser does not support the video tag. 这一路，我们的所见所闻，都深刻的印在了脑子里。经历了一些没有经历过的事情，平淡的人生在这一刻变得有意义。于我而言，如果每天都处于同样的生活环境里，迟早会崩坏掉，这趟旅行对我来说意义非凡，是我永远的瑰宝。 这一趟来回有 5000 多公里，第一次连续驾驶这么长的时间，尽管很累，但却不敢闭眼睡觉的感觉还真是不好受呢![](https://images-1258496336.cos.ap-chengdu.myqcloud.com/mh121.gif)； 塔尔寺的藏传佛教貌似与我认知中的佛教不同，但是咱身上没那文化细胞，也就随便逛逛，不过来这边玩的妹纸还真是多啊![](https://images-1258496336.cos.ap-chengdu.myqcloud.com/mh109.gif)； 塔尔寺开往青海湖的路途真是美极了。行驶在蜿蜒的盘山公路上，映入眼帘的是电影里的画面，山路十八弯，山峰矗立，感觉很刺激。下山后一眼看不到尽头的笔直的公路，“一路向西”，放飞自我。碰到拦路的牛呀、羊呀，有种说不出的俏皮，青海湖就像海一样，看不到边际； 日出见过好多次，在黑马河看日出倒显得比较平常了； 在天空之境的映射下，一切都变得干净。网红打卡的圣地，妹纸披着大红色披风拍起照来真是好看，可惜同行的都是几个糙汉子，略微显得有些无趣了； 连夜赶往敦煌的路上，国内排行第九的危险公路 215 国道，连续下坡 42 公里，一路上超级多的刹车印记触目惊心，好算夜幕遮住了我们的眼睛，让我们没有过于紧张。高速上的逆行车辆，后面回忆起也是一阵后怕。出门在外，安全第一； 在鸣沙山，骑着骆驼，漫天黄沙，此情此景，必须来一首《沙漠骆驼》。激情滑沙，清澈月牙泉，感觉还不错； 莫高窟应该是此行最无趣的景点了，体内确实没那种历史文化细胞，品位不来； 后面几天玩的嘉峪关、张掖七彩丹霞、祁连草原，可能是累了的原因，大家玩的兴致都不是很高，审美疲劳了![](https://images-1258496336.cos.ap-chengdu.myqcloud.com/mh124.gif)，不过《回道张掖》沙秀是真的不错，头一次看这样的表演艺术，感觉很震撼。祁连草原的星空也是令人向往，只是太特么冷了。 最后出发返程，回家后看到新闻，就在祁连草原，我们走后几个小时，就开始下大雪了，和基友们越聊越怕，咱这一程还是比较幸运的~![](https://images-1258496336.cos.ap-chengdu.myqcloud.com/mh118.gif) 经过这次旅行，上半年的颓势一扫而净，这就是旅行的意义吧。后面要撸起袖子加油干咯~","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"无声视频合成音频（续）","date":"2019-09-19T08:30:39.000Z","path":"2019/09/19/media-mix2/","text":"之前有一个音视频合成的需求，还写了一篇文章无声视频合成音频。之前的需求是，视频整体时间控制在 10s（便于发布到朋友圈），现在朋友圈的限制改为 15s 了，所以产品决定不再限制视频的时长为 10s 了，改为最长 40s，若有发布到朋友圈的需求，则自己裁剪。大部分情况下，生成的视频长度会小于 15s，也不需要裁剪。需求调整后，之前文章里的音视频合成的方案就需要略作修改了。 说下之前的方案：利用录屏生成 10s 的无声视频，与正好 10s 的音频 aac 文件进行合成。之前的代码最终生成的文件长度为音视频文件的最大值（若视频为 10s，音频为 15s，则会生成 15s 的视频，视频最后 5s 一直展示视频的最后一帧，同时播放音乐）。现在调整视频时长后，产品定的需求是视频时长增加，然后音频循环播放。所以可能就是 24s 的无声视频合成 10s 的音频。所以之前的代码就得调整了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/** * 无声视频添加音频 * 参考代码：https://stackoverflow.com/questions/31572067/android-how-to-mux-audio-file-and-video-file * * audioTrack 的 mime type 只支持： * MediaFormat.MIMETYPE_AUDIO_AMR_NB, * MediaFormat.MIMETYPE_AUDIO_AMR_WB, * MediaFormat.MIMETYPE_AUDIO_AAC */private fun muxing(musicName: String, showToast: Boolean = true) &#123; val saveFile = File(DirUtils.getPublicMediaPath(), &quot;$saveName.mp4&quot;) if (saveFile.exists()) &#123; saveFile.delete() PhotoHelper.sendMediaScannerBroadcast(saveFile) &#125; try &#123; val duration = getVideoDuration(mSaveFile!!.absolutePath) saveFile.createNewFile() val videoExtractor = MediaExtractor() videoExtractor.setDataSource(mSaveFile!!.absolutePath) val audioExtractor = MediaExtractor() val afdd = MucangConfig.getContext().assets.openFd(musicName) audioExtractor.setDataSource(afdd.fileDescriptor, afdd.startOffset, afdd.length) val muxer = MediaMuxer(saveFile.absolutePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4) videoExtractor.selectTrack(0) val videoFormat = videoExtractor.getTrackFormat(0) val videoTrack = muxer.addTrack(videoFormat) audioExtractor.selectTrack(0) val audioFormat = audioExtractor.getTrackFormat(0) val audioTrack = muxer.addTrack(audioFormat) var sawEOS = false val offset = 100 val sampleSize = 1000 * 1024 val videoBuf = ByteBuffer.allocate(sampleSize) val audioBuf = ByteBuffer.allocate(sampleSize) val videoBufferInfo = MediaCodec.BufferInfo() val audioBufferInfo = MediaCodec.BufferInfo() videoExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) muxer.start() // 每秒多少帧 val frameRate = videoFormat.getInteger(MediaFormat.KEY_FRAME_RATE) // 得出平均每一帧间隔多少微妙 val videoSampleTime = 1000 * 1000 / frameRate while (!sawEOS) &#123; videoBufferInfo.offset = offset videoBufferInfo.size = videoExtractor.readSampleData(videoBuf, offset) if (videoBufferInfo.size &lt; 0) &#123; sawEOS = true videoBufferInfo.size = 0 &#125; else &#123; videoBufferInfo.presentationTimeUs += videoSampleTime videoBufferInfo.flags = videoExtractor.sampleFlags muxer.writeSampleData(videoTrack, videoBuf, videoBufferInfo) videoExtractor.advance() &#125; &#125; var sawEOS2 = false var sampleTime = 0L while (!sawEOS2) &#123; audioBufferInfo.offset = offset audioBufferInfo.size = audioExtractor.readSampleData(audioBuf, offset) // 判断如果写满时长，则直接返回 if (audioBufferInfo.presentationTimeUs &gt;= duration) &#123; sawEOS2 = true audioBufferInfo.size = 0 &#125; else &#123; // 判断没有写满时长，且已经写完当前 Track，则重置到开始状态，同时累加 presentationTimeUs if (audioBufferInfo.size &lt; 0) &#123; sampleTime = audioBufferInfo.presentationTimeUs audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) continue &#125; &#125; audioBufferInfo.presentationTimeUs = audioExtractor.sampleTime + sampleTime audioBufferInfo.flags = audioExtractor.sampleFlags muxer.writeSampleData(audioTrack, audioBuf, audioBufferInfo) audioExtractor.advance() &#125; muxer.stop() muxer.release() videoExtractor.release() audioExtractor.release() afdd.close() // 删除无声视频文件 mSaveFile?.delete() &#125; catch (e: Exception) &#123; LogUtils.e(TAG, &quot;Mixer Error:&quot; + e.message) // 视频添加音频合成失败，直接保存视频 mSaveFile?.renameTo(saveFile) &#125; finally &#123; MainThreadUtils.post &#123; if (activity.isDestroyed) &#123; return@post &#125; if (mSaveFile != null) &#123; if (needInsertMediaDB) &#123; PhotoHelper.sendMediaScannerBroadcast(saveFile) &#125; if (showToast) &#123; ToastUtils.toast(&quot;已保存到相册&quot;) &#125; &#125; listener?.finishRecord(saveFile.absolutePath) mSaveFile = null &#125; &#125;&#125;/** * 获取视频的时长，微秒 */private fun getVideoDuration(videoPath: String): Long &#123; val mmr = MediaMetadataRetriever() try &#123; mmr.setDataSource(videoPath) return java.lang.Long.parseLong(mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)) * 1000L &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; try &#123; mmr.release() &#125; catch (e: Throwable) &#123; LogUtils.e(TAG, e.toString()) &#125; &#125; return 0L&#125; 整体思路是这样的：先获取无声视频的长度，假设为 24s，然后 muxer.writeSampleData 写入所有的 videoTrack 数据，然后开始写入 audioTrack 的数据。当写完 10s 后，audioTrack 便结束了，但是此时才写入 10s，不足 24s，所以重新 seek 到初始位置，再继续写入。写到 20s 后，再写入 4s，判断满足视频时长 24s 了，则直接退出。需要多说一下的是：生成视频的音频轨道 audioExtractor 获取到的 presentationTimeUs 正好就是音频播放的长度，而视频轨道由于有关键帧、非关键帧导致 videoExtractor presentationTimeUs 只能是递增，但却不能保证是播放长度。所以在写入音频数据时，可以根据 presentationTimeUs 来判断当前写入了多少秒，若已经达到视频长度，则可以直接退出，从而保证写入音频的时长与视频的时长是一致的。另外，当 audioExtractor 读完后，返回的 size 为 -1，判断此时时长不足，则直接 seek 到初始位置，同时需要累加 presentationTimeUs，所以代码里用到了 sampleTime 来记录 presentationTimeUs 的值。muxer.writeSampleData 时 presentationTimeUs 必须是递增的。 在 stackoverflow 上也搜到了同样的问题 How to mux (merge) video&amp;audio, so that the audio will loop in the output video in case it’s too short in duration?，但是没有回答，于是舔着脸强行回答了一波，欢迎来点赞~","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"博客图片迁移","date":"2019-09-12T08:05:05.000Z","path":"2019/09/12/adjust/","text":"早期博客图床使用的七牛图床，七牛图床被黄图给搞了，所以现在测试域名都只有一个月的使用期限，早些阵子就已经过期回收了，所以之前的测试域名绑定的图片全部失效了，2018-10-10 之前的博客图片全部看不了了，阿西吧~若要继续使用七牛图床，需要自己绑定加速域名，重新迁移才行。而绑定加速域名是需要已经备案过的，备案又需要实名制，而我的域名还没有实名制QAQ，不巧的是阿里域名根据工信部的条款，关闭了 .win 域名后缀的实名制认证，这就很尴尬了。然后一直等阿里云开放域名实名认证，等到现在也还没开放，今天下定决心把图片都迁移一下，不用七牛了。图片所在的旧 Bucket 测试域名被回收之后，就彻底看不到图片资源了，也下载不了，只能借助七牛官方工具 qshell 来进行相关操作。 qshell下载好相应平台的 qshell 工具，所用电脑为 Win7，所以以下示例均为 Windows 平台。设置用户名及 key： 1qshell account &lt;AK&gt; &lt;SK&gt; &lt;Name&gt; 获取所有图片的文件名要从旧的的 Bucket 获取所有的文件名： 1qshell listbucket blog-images -o list.txt blog-images 为 Bucket 的名称，list.txt 为输出文件。list.txt 内容是个表格，具有多列属性，第一列为名称，是我需要的，其他所有列都不需要，需要删除。因为 Windows 命令行很不好用，我的文件数量也比较少，就直接用的很傻的办法，Android Studio 多行编辑手动删除了，然后得到一个只包含文件名的文件：name.txt。 迁移到新的 Bucket新建一个 Bucket（last-backup） 会有一个月限期的测试域名，所以这一步，需要将测试域名过期的旧 Bucket 里的所有文件迁移到新的 Bucket（所属区域需要一致，华东、华南等）。 1qshell batchcopy blog-images last-backup -i name.txt -s success.txt -e fail.txt 使用 batchcopy 指令，将旧 Bucket 的文件复制到新的 Bucket，-s 指定复制成功的输出文件，-e 指定复制失败的输出文件。最好指定一下，方便后面看哪些文件有问题，需要手动调整的。 从新 Bucket 下载文件此时，新的 Bucket 已经有了所有的资源了（可能会有少许文件复制失败，只能手动校对了），并且有可用的域名，所以此时所有的资源都是可以访问到的。将所有文件下载下来： 1qshell qdownload -c 10 config.txt -c 指定同时下载的文件个数，config.txt 为下载的设置： 12345&#123; &quot;dest_dir&quot;: &quot;D:\\\\blog_images&quot;, // 下载文件到哪里 &quot;bucket&quot;: &quot;last-backup&quot;, // bucket 名称 &quot;cdn_domain&quot;: &quot;pxp8xxx5.bkt.clouddn.com&quot; // bucket 域名&#125; 上传到新的图床一般的图床都会保留文件上传时的文件名，对于带路径的也是一样，我这里选择的是腾讯云。从七牛下载下来的文件，会按照上传时添加的前缀，生成对应的文件夹，好在腾讯也是支持文件夹的，将所有的文件按照对应的路径上传到腾讯云这步就 ok 了。 替换域名之前 md 文件里写的旧的七牛的域名，替换成新的腾讯云的域名。直接 Sublime Text 全局搜索，替换就行。因为腾讯云支持文件夹上传，所以域名之后的路径其实都是一致的，只需要替换下域名即可，后面图片的路径保持不动即可，可以节约不少时间。部分图片会有问题，把所有文章过一遍，找到有问题的，手动修复一下就行了。 博客所有的图片终于都能看见了，虽然现在来看，早期的文章写得不怎么样，但这也是我成长的痕迹了。心里的一块石头终于落地了。","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Android 保活设置适配","date":"2019-09-06T06:39:09.000Z","path":"2019/09/06/keepalive/","text":"随着 Android 开发的越来越规范，那些“黑科技”的保活手段基本没什么用了，所以只能通过引导，让用户自己去设置相关保活的选项，就像 Rom 的白名单。只不过白名单是系统帮你设置，没有白名单就得自己去引导了。保活相关的一般包含自启动和防睡眠，当然功能在各个 Rom 的描述不尽相同，不用纠结于此。针对各大厂商，做了一些准备工作，如下。 三星 Galaxy S10+：SM-G9750，Android 9 Galaxy Note8：SM-N9500，Android 8.0.0 Galaxy Note9：SM-N9600，Android 8.1.0 C7：Android 8，Sumsang Experience 版本 S8：Android 8，Sumsang Experience 版本（没有自启动） 智能管理器-&gt;电池-&gt;未监视的应用程序-&gt;添加应用程序：添加后，应用处于后台时系统不会休眠应用智能管理器-&gt;自动运行应用程序：打开允许后，若应用后台一段时间未使用，仍有可能自动停止 三星云测平台 小米 小米 MIX2：Android 9，MIUI 10.4.2 红米 NOTE7 Pro：Android 9 设置-&gt;授权管理-&gt;自启动管理-&gt;运行应用自启动设置-&gt;电量和性能-&gt;应用配置-&gt;设置应用的省电策略为无限制 小米云测平台 vivo X9：Android 6.0.1，Funtouch OS_3.0 Y75A：Android 7.1.1，Funtouch OS_3.2 X21：Android 8.1.0，Funtouch OS_4.0 iQOO：Android 9，Funtouch OS_9 NEXS：Android 10，Funtouch OS_10 开发板 设置-&gt;更多设置-&gt;权限管理-&gt;权限Tab-&gt;自启动设置-&gt;电池-&gt;后台高耗电-&gt;打开开关允许应用高耗电时继续允许 X6A：Android 5.0.2，Funtouch OS_2.5 i 管家-&gt;软件管理-&gt;权限管理-&gt;自启动管理i 管家-&gt;省电管理-&gt;后台高耗电-&gt;打开开关允许应用高耗电时继续允许 vivo 云测平台 oppo A73：Android 7.1.1，ColorOS v5.2.1 手机管家-&gt;权限隐私-&gt;自启动管理设置-&gt;电池-&gt;应用速冻-&gt;关闭速冻开关 oppo 云测平台需要开发者账号，还要银行卡、手持身份证等玩意，太麻烦，就没申请了，所以 oppo 看的比较少。 华为 Mate 9：Android 9，EMUI 9.1.0 P10：Android 9，EMUI 9.1.0 设置-&gt;应用-&gt;应用启动管理-&gt;关闭自动管理，允许自启动，后台活动设置-&gt;电池-&gt;更多电池设置-&gt;？（云真机显示的没有应用，不确定是否有开关） P10 Plus：Android 8.0，EMUI 8.0 手机管家-&gt;自启管理-&gt;允许自启动设置-&gt;电池-&gt;耗电排行-&gt;选中应用进入耗电详情-&gt;关闭高耗电提醒 Mate 9：Android 7.0，EMUI 5.0 手机管家-&gt;自启管理-&gt;允许自启动设置-&gt;电池-&gt;设置(右上角图标)-&gt;锁屏应用清理-&gt;关闭清理选项 华为云测平台 代码只看了几个主流平台，其实还想看看一加的，但是一加没找到云测平台，也没有一加真机，无奈作罢。下面上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222object KeepCompactUtil &#123; private val AUTO_START_INTENTS = arrayOf( // 小米 Intent().setComponent(ComponentName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.autostart.AutoStartManagementActivity&quot;)), // 华为 Intent().setComponent(ComponentName .unflattenFromString(&quot;com.huawei.systemmanager/.startupmgr.ui.StartupNormalAppListActivity&quot;)), Intent().setComponent(ComponentName .unflattenFromString(&quot;com.huawei.systemmanager/.appcontrol.activity.StartupAppControlActivity&quot;)), // 魅族 Intent().setComponent(ComponentName.unflattenFromString(&quot;com.meizu.safe/.SecurityCenterActivity&quot;)), // 三星 Intent().setComponent(ComponentName(&quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm.autorun.ui.AutoRunActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm.ui.ram.AutoRunActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm.ui.appmanagement.AppManagementActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm&quot;, &quot;com.samsung.android.sm.autorun.ui.AutoRunActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm&quot;, &quot;com.samsung.android.sm.ui.ram.AutoRunActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm&quot;, &quot;com.samsung.android.sm.ui.appmanagement.AppManagementActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm&quot;, &quot;com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity&quot;)), Intent().setComponent(ComponentName.unflattenFromString( &quot;com.samsung.android.sm_cn/.app.dashboard.SmartManagerDashBoardActivity&quot;)), Intent().setComponent(ComponentName.unflattenFromString( &quot;com.samsung.android.sm/.app.dashboard.SmartManagerDashBoardActivity&quot;)), // oppo Intent().setComponent(ComponentName .unflattenFromString(&quot;com.coloros.safecenter/.startupapp.StartupAppListActivity&quot;)), Intent().setComponent(ComponentName .unflattenFromString(&quot;com.coloros.safecenter/.permission.startupapp.StartupAppListActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.coloros.safecenter&quot;, &quot;com.coloros.privacypermissionsentry.PermissionTopActivity&quot;)), Intent().setComponent( ComponentName.unflattenFromString(&quot;com.oppo.safe/.permission.startup.StartupAppListActivity&quot;)), // vivo Intent().setComponent(ComponentName .unflattenFromString(&quot;com.vivo.permissionmanager/.activity.BgStartUpManagerActivity&quot;)), Intent().setComponent(ComponentName .unflattenFromString(&quot;com.iqoo.secure/.phoneoptimize.BgStartUpManager&quot;)), Intent().setComponent(ComponentName .unflattenFromString(&quot;com.vivo.permissionmanager/.activity.PurviewTabActivity&quot;)), Intent().setComponent(ComponentName .unflattenFromString(&quot;com.iqoo.secure/.ui.phoneoptimize.SoftwareManagerActivity&quot;)), // 一加 Intent().setComponent(ComponentName .unflattenFromString(&quot;com.oneplus.security/.chainlaunch.view.ChainLaunchAppListActivity&quot;)), // 乐视 Intent().setComponent( ComponentName.unflattenFromString(&quot;com.letv.android.letvsafe/.AutobootManageActivity&quot;)), // HTC Intent().setComponent( ComponentName.unflattenFromString(&quot;com.htc.pitroad/.landingpage.activity.LandingPageActivity&quot;)) ) private val BATTERY_INTENTS = arrayOf( // 小米 Intent().setComponent(ComponentName .unflattenFromString(&quot;com.miui.powerkeeper/.ui.HiddenAppsContainerManagementActivity&quot;)), // 华为 Intent().setComponent(ComponentName .unflattenFromString(&quot;com.huawei.systemmanager/.power.ui.HwPowerManagerActivity&quot;)), // 魅族 Intent().setComponent(ComponentName .unflattenFromString(&quot;com.meizu.safe/.SecurityCenterActivity&quot;)), // 三星 Intent().setComponent(ComponentName(&quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm.ui.battery.AppSleepListActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm.ui.battery.BatteryActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm&quot;, &quot;com.samsung.android.sm.ui.battery.AppSleepListActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm&quot;, &quot;com.samsung.android.sm.ui.battery.BatteryActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.lool&quot;, &quot;com.samsung.android.sm.battery.ui.BatteryActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.lool&quot;, &quot;com.samsung.android.sm.ui.battery.BatteryActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm&quot;, &quot;com.samsung.android.sm.ui.battery.BatteryActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity&quot;)), // oppo Intent().setComponent(ComponentName .unflattenFromString(&quot;com.coloros.safecenter/.appfrozen.activity.AppFrozenSettingsActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.coloros.oppoguardelf&quot;, &quot;com.coloros.powermanager.fuelgaue.PowerUsageModelActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.coloros.oppoguardelf&quot;, &quot;com.coloros.powermanager.fuelgaue.PowerSaverModeActivity&quot;)), Intent().setComponent(ComponentName(&quot;com.coloros.oppoguardelf&quot;, &quot;com.coloros.powermanager.fuelgaue.PowerConsumptionActivity&quot;)), Intent().setComponent(ComponentName .unflattenFromString(&quot;com.oppo.safe/.SecureSafeMainActivity&quot;)), // vivo Intent().setComponent(ComponentName(&quot;com.vivo.abe&quot;, &quot;com.vivo.applicationbehaviorengine.ui.ExcessivePowerManagerActivity&quot;)), Intent().setComponent(ComponentName.unflattenFromString(&quot;com.iqoo.powersaving/.PowerSavingManagerActivity&quot;)) ) var brandAliveEnumList: List&lt;BrandAliveEnum&gt; = object : ArrayList&lt;BrandAliveEnum&gt;() &#123; init &#123; add(BrandAliveEnum.Huawei) add(BrandAliveEnum.Xiaomi) add(BrandAliveEnum.Oppo) add(BrandAliveEnum.Vivo) add(BrandAliveEnum.Samsung) add(BrandAliveEnum.Meizu) add(BrandAliveEnum.LeEco) add(BrandAliveEnum.Smartisan) add(BrandAliveEnum.Lenovo) add(BrandAliveEnum.NONE) &#125; &#125; /** * @return 是否为三星s9 型号的手机 */ val isSamsungS9: Boolean get() = (&quot;samsung&quot;.equals(Build.BRAND, ignoreCase = true) &amp;&amp; StringUtils.isNotEmpty(Build.MODEL) &amp;&amp; Build.MODEL.startsWith(&quot;SM-G9&quot;)) val deviceEnum: BrandAliveEnum get() &#123; if (&quot;Huawei&quot;.equals(Build.BRAND, ignoreCase = true) || &quot;HONOR&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Huawei &#125; if (&quot;vivo&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Vivo &#125; if (&quot;OPPO&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Oppo &#125; if (&quot;Xiaomi&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Xiaomi &#125; if (&quot;Meizu&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Meizu &#125; if (&quot;samsung&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Samsung &#125; if (&quot;smartisan&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Smartisan &#125; if (&quot;LeEco&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.LeEco &#125; if (&quot;Lenovo&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Lenovo &#125; if (&quot;oneplus&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.Yijia &#125; if (&quot;Sony&quot;.equals(Build.MANUFACTURER, ignoreCase = true)) &#123; return BrandAliveEnum.Sony &#125; if (&quot;LG&quot;.equals(Build.MANUFACTURER, ignoreCase = true)) &#123; return BrandAliveEnum.LG &#125; if (&quot;Coolpad&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; return BrandAliveEnum.NONE &#125; return if (&quot;ZTE&quot;.equals(Build.BRAND, ignoreCase = true)) &#123; BrandAliveEnum.NONE &#125; else BrandAliveEnum.NONE &#125; // 自启动 fun daemonSet(activity: Activity): Boolean &#123; for (intent in AUTO_START_INTENTS) &#123; if (activity.packageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123; intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK try &#123; activity.startActivity(intent) return true &#125; catch (e: Exception) &#123; LogUtils.e(&quot;KeepCompactUtil&quot;, e.toString()) continue &#125; &#125; &#125; return false &#125; // 防睡眠 fun noSleepSet(activity: Activity): Boolean &#123; for (intent in BATTERY_INTENTS) &#123; if (activity.packageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123; intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK try &#123; activity.startActivity(intent) return true &#125; catch (e: Exception) &#123; LogUtils.e(&quot;KeepCompactUtil&quot;, e.toString()) continue &#125; &#125; &#125; return false &#125;&#125; 直接罗列所有的 Intent，按页面相关性从大到小排列。比如，A-&gt;B-&gt;C，设置页面在 C，但是有的手机不支持打开 C 和 B，Intent 排序为 C&gt;B&gt;A。通过 resolveActivity 判断系统是否能处理此 Intent，跳转成功则 ok，若跳转失败则继续遍历，找到能跳转的 Intent，如果遍历完也没有找到，则返回 false 给出相应提示。 小结oppo vivo 的手机有点恶心，每次安装 debug 包还要弹窗让输密码，然后还自己捣鼓了权限啥的，限制三方应用进行跳转。vivo： 1Permission Denial: starting Intent &#123; flg=0x10000000 cmp=com.vivo.abe/com.vivo.applicationbehaviorengine.ui.ExcessivePowerManagerActivity &#125; from ProcessRecord&#123;306679b 16047:cn.xxx.android.xxx/u0a605&#125; (pid=16047, uid=10605) requires com.vivo.abe.permission.action.openhpactivity oppo： 1java.lang.SecurityException: Permission Denial: starting Intent &#123; flg=0x10000000 cmp=com.coloros.safecenter/.startupapp.StartupAppListActivity &#125; from ProcessRecord&#123;2255367 30192:cn.xxx.android.xxx/u0a697&#125; (pid=30192, uid=10697) requires oppo.permission.OPPO_COMPONENT_SAFE 然后在 AndroidManifest 中添加相关的权限也无效的，因为只能系统应用申请，三方应用申请没用（oppo 同学内部询问大佬给出的回答）。针对 vivo，我选择跳到上一级页面，也可以跳，只不过需要用户手动再点一下。针对 oppo，我佛了，上一级页面也跳不了，只能到最初的设置页面，这跳到设置页面大多数用户都会一脸懵逼，所以干脆不跳了，直接返回 false，同时给好相应的引导。同时，申请了权限之后，好像 apk 安装会出问题（部分机型），反正没用，所以权限就不要加了。三星也值得说一下，一会是 sm，一会是 sm_cn，我也是佛了。一会是 ui.battery，一会是 battery.ui，索性直接进行排列组合搞了一波，所以三星的 Intent 就很多了。另外三星 S9 貌似是没有自启动的，所以可以考虑进行屏蔽。其实不屏蔽影响也不大，返回 false 给出提示即可，无奈老板的手机是 S9… 经过这次云测平台的使用，发现华为还是牛逼啊，三星也还不错，还支持 adb 命令（点个赞）。oppo vivo 就差太远了，小米更不用谈了，连可用的机型都没有。腾讯的 WeTest 机型倒是都有，但是要收费，这很腾讯。送的 30 分钟完全不够用好吗，而且每用一个机型至少 15 分钟，我的免费额度剩下 10 分钟就已经用不了了，无力吐槽。 参考 Intent跳转到[自启动]页面全网最全适配机型解决方案(持续更新) Denial permission OPPO_COMPONENT_SAFE backgroundable-android How to start Power Manager of all android manufactures to enable background and push notification? [WeTest]（https://wetest.qq.com/cloud/n/remotedevicelist?test=remote）","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"使用 LiveData 实现消息总线","date":"2019-09-02T05:46:54.000Z","path":"2019/09/02/livedata/","text":"作为 Android 开发，对消息总线总不会陌生，当需要告知某些界面进行一些操作的时候，都会通过发送消息来做。早期的可以有广播，或者回调的方式，但是写起来都会比较麻烦，所以才会出现 EventBus 这种三方库，它使用起来非常方便，极大的解耦了我们的代码，所以当它一出现就受到了广大开发者的青睐。那用了这么久的 EventBus，香确实是很香，但是感觉还可以有优化的地方： 只在界面可见的时候进行处理（生命周期感知功能）； 每次都得显式 register，unregister； 回调方法名称固定为 onEventMainThread 等等几个规定的名称，在 Android Studio 里会显示成 xxx is never used，警告也是很烦人的； 多个同类型消息不能只处理一次，这其实也和第 1 点呼应； 不同类型的消息，但是导致的业务操作其实是一致的，这种情景其实只需要处理一次即可，但 EventBus 做不到； 所以，在新出了 LiveData 之后，基于它的特性，是否可以进行改造呢？当然是可以的。 改造第一步基于 EventBus 的使用习惯，很容易改造出第一版： 12345678910111213object LiveBus &#123; private val busMap by lazy &#123; ConcurrentHashMap&lt;Class&lt;*&gt;, MutableLiveData&lt;*&gt;&gt;() &#125; private fun &lt;T&gt; bus(clazz: Class&lt;T&gt;) = busMap.getOrPut(clazz) &#123; MutableLiveData&lt;T&gt;() &#125; @Suppress(&quot;UNCHECKED_CAST&quot;) fun &lt;T&gt; with(clazz: Class&lt;T&gt;) = bus(clazz) as MutableLiveData&lt;T&gt; fun post(event: Any) &#123; with(event.javaClass).value = event &#125;&#125; 发送消息只需要： 1LiveBus.post(&quot;Hello world!&quot;) 接收消息： 123LiveBus.with(String::class.java).observe(this, Observer &#123; // do something&#125;) 只需要 observe，不再需要注销，下面的代码再也不会出现了： 12345@Overridepublic void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this);&#125; 写个 onDestroy 纯粹为了注销 EventBus。可以看到，基于 LiveData，第一版这样很简短的写法，已经就可以解决我上面的 4 个问题了！我可以在一个界面重复发送消息，但是只有在界面展示的时候，处理一次。在某些场景下，这种优化还是很有必要的，不然每次都在不可见的状态下还刷新数据，如果消息发送非常频繁，那就可能导致很大的性能问题了。 Sticky 改造使用第一版的代码，很容易就发现一个问题：订阅者会收到订阅之前发布的消息。这其实类似于 EventBus 提供的 Sticky 功能。这种默认功能，在大多数下情况下，是不适用的，所以也需要改造。导致这个问题的原因在 LiveData 的源码是有体现的： 1234567891011121314151617181920private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we&#x27;ve not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData);&#125; 在 LiveData 的 considerNotify 方法中，如果 ObserverWrapper 的 mLastVersion 小于 LiveData 的 mVersion，就会去回调 mObserver 的 onChanged 方法。而每个新的订阅者，其 version 都是 -1，LiveData 一旦设置过其 version 是大于 -1 的（每次 LiveData 设置值都会使其 version 加 1），这样就会导致 LiveBus 每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。知道问题所在之后，便可以进行解决了：提供相同包名的 BusLiveData，进行改造。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package android.arch.lifecycleopen class BusLiveData&lt;T&gt; : MutableLiveData&lt;T&gt;() &#123; private val wrappers = mutableMapOf&lt;Observer&lt;T&gt;, BusWrapper&gt;() override fun observe(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observe(owner, wrapper) &#125; open fun observeSticky(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; super.observe(owner, observer) &#125; override fun observeForever(observer: Observer&lt;T&gt;) &#123; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observeForever(wrapper) &#125; fun observeStickyForever(observer: Observer&lt;T&gt;) &#123; super.observeForever(observer) &#125; override fun removeObserver(observer: Observer&lt;T&gt;) &#123; val key = if (observer is BusWrapper) &#123; super.removeObserver(observer) super.removeObserver(observer.observer) observer.observer &#125; else &#123; super.removeObserver(observer) observer &#125; wrappers.remove(key) &#125; inner class DefaultWrapper(observer: Observer&lt;T&gt;): BusWrapper(observer) &#123; override fun onChanged(t: T?) &#123; if (lastVersion &gt;= version) &#123; return &#125; lastVersion = version observer.onChanged(t) &#125; &#125; abstract inner class BusWrapper(val observer: Observer&lt;T&gt;): Observer&lt;T&gt; &#123; var lastVersion = version &#125;&#125; 注意包名为 android.arch.lifecycle。因为用到了 getVersion 方法，这个在 LiveData 里是包可见： 123int getVersion() &#123; return mVersion;&#125; 在每次 observe 的时候，使用 LiveData 的 version 赋值一次，就可以解决问题了。同理，MediatorLiveData 的改造如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192@SuppressLint(&quot;RestrictedApi&quot;)class BusMediatorLiveData&lt;T&gt; : BusLiveData&lt;T&gt;() &#123; private val mSources = SafeIterableMap&lt;BusLiveData&lt;*&gt;, Source&lt;*&gt;&gt;() /** * Starts to listen the given `source` LiveData, `onChanged` observer will be called * when `source` value was changed. * * * `onChanged` callback will be called only when this `MediatorLiveData` is active. * * If the given LiveData is already added as a source but with a different Observer, * [IllegalArgumentException] will be thrown. * * @param source the `LiveData` to listen to * @param onChanged The observer that will receive the events * @param &lt;S&gt; The type of data hold by `source` LiveData &lt;/S&gt; */ @MainThread fun &lt;S&gt; addSource(source: BusLiveData&lt;S&gt;, onChanged: Observer&lt;S&gt;) &#123; val e = Source(source, onChanged) val existing = mSources.putIfAbsent(source, e) if (existing != null &amp;&amp; existing.mObserver !== onChanged) &#123; throw IllegalArgumentException( &quot;This source was already added with the different observer&quot; ) &#125; if (existing != null) &#123; return &#125; if (hasActiveObservers()) &#123; e.plug() &#125; &#125; override fun observe(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; onActive() ArchTaskExecutor.getInstance().postToMainThread &#123; super.observe(owner, observer) &#125; &#125; /** * Stops to listen the given `LiveData`. * * @param source `LiveData` to stop to listen * @param &lt;S&gt; the type of data hold by `source` LiveData &lt;/S&gt; */ @MainThread fun &lt;S&gt; removeSource(source: BusLiveData&lt;S&gt;) &#123; @Suppress(&quot;NAME_SHADOWING&quot;) val source = mSources.remove(source) source?.unplug() &#125; @CallSuper override fun onActive() &#123; for ((_, value) in mSources) &#123; value.plug() &#125; &#125; @CallSuper override fun onInactive() &#123; for ((_, value) in mSources) &#123; value.unplug() &#125; &#125; private class Source&lt;V&gt; internal constructor( internal val mLiveData: BusLiveData&lt;V&gt;, internal val mObserver: Observer&lt;V&gt; ) : Observer&lt;V&gt; &#123; internal var mVersion = mLiveData.version internal fun plug() &#123; mLiveData.observeStickyForever(this) &#125; internal fun unplug() &#123; mLiveData.removeObserver(this) &#125; override fun onChanged(v: V?) &#123; if (mVersion != mLiveData.version) &#123; mVersion = mLiveData.version mObserver.onChanged(v) &#125; &#125; &#125;&#125; 这个后面会用到。嗯，改造完成之后，将 LiveBus 里的 MutableLiveData 替换成 BusLiveData 就可以解决问题了。那么想要实现 EventBus 的 Sticky 效果便非常简单了： 123open fun observeSticky(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; super.observe(owner, observer)&#125; 消息合并针对第 5 条，使用 EventBus 很容易出现如下代码： 1234567891011121314//增加路线public void onEventMainThread(RouteCreateEvent event) &#123; onLoadFirst(false);&#125;//删除路线public void onEventMainThread(RouteDeleteEvent event) &#123; onLoadFirst(false);&#125;//更新路线public void onEventMainThread(RouteUpdateEvent event) &#123; onLoadFirst(false);&#125; 这在列表界面处理相关刷新的操作太常见了，感觉很恶心。所以，使用 LiveBus 如何改造呢？这就要用到上面说 MediatorLiveData 了。MediatorLiveData 类就是个自定义 LiveData，可以观察其他 LiveData 对象并且回调。使用 addSource 可以添加一个 LiveData，当任何一个 LiveData 发生改变时都能进行回调。所以当多个类型的消息界面都是统样的处理时，便可以使用 MediatorLiveData 了。稍微封装一下： 123456789101112131415161718class SameActionMediator &#123; private val mediatorLiveData = BusMediatorLiveData&lt;Boolean&gt;() fun addSource(vararg source: BusLiveData&lt;*&gt;) &#123; source.forEach &#123; mediatorLiveData.addSource(it, Observer &#123; mediatorLiveData.postValue(true) &#125;) &#125; &#125; fun observe(owner: LifecycleOwner, onChange: (Boolean?) -&gt; Unit) &#123; mediatorLiveData.observe(owner, Observer &#123; onChange(it) &#125;) &#125;&#125; 使用时： 12345val mediatorLiveData = SameActionMediator()mediatorLiveData.addSource(LiveBus.with(String::class.java), LiveBus.with(Int::class.java))mediatorLiveData.observe(this) &#123; // do something&#125; 注意 mediatorLiveData 必须使用 postValue，使用 setValue 导致 onChange 回调多次。看下 postValue 的实现： 123456789101112131415161718192021222324protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125;private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125;&#125;; 可以看到，当连续多次调用 postValue 时，LiveData 只会更新 mPendingData 为最新的值，如果 postTask 为 true，就直接返回，所以 mPostValueRunnable 只会发送一次，从而避免 onChange 的多次调用。同时当 mPostValueRunnable 执行时，又会将 mPendingData 赋值为 NOT_SET，用于下次消息发送。 observeForever补充一下一个不常用的场景：常驻后台，当界面不可见也需要接受消息。 123LiveBus.with(Float::class.java).observeForever &#123; // do something&#125; 这种就是消息只要一发送，就可以接受到了，可用于某些特殊场景。但是这种就有了内存泄漏的风险，当不需要时记得手动移除。 小结使用上述 4 个类：BusLiveData、BusMediatorLiveData、LiveBus、SameActionMediator，便可实现消息总线的整体功能了，同时有所优化。嗯，JetPack 真香啊~ 更新在项目使用过程中，当用到 observeForever 时，即使 removeObserver 了还是会收到回调，导致内存泄露。查看代码，发现是 BusLiveData 代码有问题，更新一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748open class BusLiveData&lt;T&gt; : MutableLiveData&lt;T&gt;() &#123; private val wrappers = mutableMapOf&lt;Observer&lt;in T&gt;, BusWrapper&gt;() override fun observe(owner: LifecycleOwner, observer: Observer&lt;in T&gt;) &#123; val wrapper = DefaultWrapper(observer) super.observe(owner, wrapper) &#125; open fun observeSticky(owner: LifecycleOwner, observer: Observer&lt;T&gt;) &#123; super.observe(owner, observer) &#125; override fun observeForever(observer: Observer&lt;in T&gt;) &#123; val wrapper = DefaultWrapper(observer) wrappers[observer] = wrapper super.observeForever(wrapper) &#125; fun observeStickyForever(observer: Observer&lt;T&gt;) &#123; super.observeForever(observer) &#125; override fun removeObserver(observer: Observer&lt;in T&gt;) &#123; val wrapper = wrappers[observer] if (wrapper != null) &#123; super.removeObserver(wrapper) wrappers.remove(observer) &#125; else &#123; super.removeObserver(observer) &#125; &#125; inner class DefaultWrapper(observer: Observer&lt;in T&gt;) : BusWrapper(observer) &#123; override fun onChanged(t: T?) &#123; if (lastVersion &gt;= version) &#123; return &#125; lastVersion = version observer.onChanged(t) &#125; &#125; abstract inner class BusWrapper(val observer: Observer&lt;in T&gt;) : Observer&lt;T&gt; &#123; var lastVersion = version &#125;&#125; 调用 observe 的绑定了生命周期的，会在 destroy 的时候自动移除掉，wrappers 不需要持有。调用 observeForever 的 wrappers 需要持有，以便在 remove 时，找到对应的 Observer 去 remove。 参考 Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus 【译】LiveData 使用详解 LiveBus","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"MotionLayout 使用介绍","date":"2019-08-13T08:18:16.000Z","path":"2019/08/13/cl-2/","text":"MotionLayout 是 ConstraintLayout 2.0 版本引入进来的，目前还在测试版本中，但感觉还挺有意思的，就写一篇记录一下。 MotionLayout 类继承自 ConstraintLayout 类，允许你为各种状态之间的布局设置过渡动画。由于 MotionLayout 继承了 ConstraintLayout，因此可以直接在 XML 布局文件中使用 MotionLayout 替换 ConstraintLayout。MotionLayout 是完全声明式的，你可以完全在 XML 文件中描述一个复杂的过渡动画而无需任何代码。 MotionLayout 与 ConstraintLayout 不同的是 MotionLayout 需要链接到一个 MotionScene 文件。使用 MotionLayout 的 app:layoutDescription 属性将 MotionLayout 链接到一个 MotionScene 文件。另外，MotionLayout 所有的直接子 View 需要指定 id，不然会报错： 1All children of ConstraintLayout must have ids to use ConstraintSet. 简单使用 起始状态：12345678910111213141516171819202122232425262728293031323334&lt;android.support.constraint.motion.MotionLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/motionLayout&quot; app:layoutDescription=&quot;@xml/activity_main_motion_scene&quot;&gt; &lt;TextView android:id=&quot;@+id/button&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;56dp&quot; android:text=&quot;这个View不动&quot; android:textColor=&quot;#fff&quot; android:gravity=&quot;center&quot; android:background=&quot;#f00&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;56dp&quot; android:layout_height=&quot;56dp&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:background=&quot;@color/colorPrimary&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;1&quot;/&gt;&lt;/android.support.constraint.motion.MotionLayout&gt; 结束状态:123456789101112131415161718&lt;android.support.constraint.motion.MotionLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/motionLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layoutDescription=&quot;@xml/activity_main_motion_scene&quot;&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; android:layout_marginTop=&quot;100dp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;&lt;/android.support.constraint.motion.MotionLayout&gt; MotionScene：文件名 activity_main_motion_scene.xml，存放在 res&#x2F;xml 目录下。12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;MotionScene xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;Transition app:constraintSetStart=&quot;@layout/activity_main_scene1&quot; app:constraintSetEnd=&quot;@layout/activity_main_scene2&quot; app:duration=&quot;1000&quot;&gt; &lt;OnClick app:clickAction=&quot;toggle&quot; app:targetId=&quot;@id/image&quot; /&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 看下效果： 属性讲解MotionLayout 会自动检测这两个场景中具有相同 id 的 View 的属性差别，然后针对这些差别属性应用过渡动画。MotionLayout 除了支持一下的标准属性外，还支持全部的 ConstraintLayout 属性。 android:visibility android:alpha android:elevation android:rotation android:rotationX android:rotationY android:scaleX android:scaleY android:translationX android:translationY android:translationZ MotionScene 文件的根元素是 MotionScene。在 MotionScene 元素中使用 Transition 子元素来描述一个过渡，使用 Transition 元素的 app:constraintSetStart 属性指定起始场景的布局文件，使用 app:constraintSetEnd 指定结束场景的布局文件。在 Transition 元素中使用 OnClick 或者 OnSwip 子元素来描述过渡的触发条件。使用 app:duration 指定动画时间，app:motionInterpolator 指定差值器，取值有 linear、bounce 等等。 OnClick 元素的属性： app:targetId：Id 值，设置用来触发过渡的那个 View 的 Id，例如：@id&#x2F;image。 app:clickAction：设置点击时执行的动作，有 5 个可选项： toggle：在 Start 场景和 End 场景之间循环的切换。 transitionToEnd：过渡到 End 场景。 transitionToStart：过渡到 Start 场景。 jumpToEnd：跳到 End 场景（不执行过渡动画）。 jumpToStart：跳到 Start 场景（不执行过渡动画）。 OnSwip 拖动操作，由于拖动操作涉及的交互较为复杂，这里就不讲述了，有兴趣的同学可以自己了解。 代码控制代码开启动画，切换到起始状态： 1motionLayout.transitionToStart(); 同样，切换到终止状态： 1motionLayout.transitionToEnd() 设置动画进度： 1motionLayout.setProgress(progress) // 取值 0 ~ 1 监听动画： 123456789101112131415161718motionLayout.setTransitionListener(object : MotionLayout.TransitionListener &#123; override fun onTransitionTrigger(p0: MotionLayout?, p1: Int, p2: Boolean, p3: Float) &#123; // Call when a trigger is fired &#125; override fun onTransitionStarted(p0: MotionLayout?, p1: Int, p2: Int) &#123; // Called when a drawer is about to start a transition. &#125; override fun onTransitionChange(p0: MotionLayout?, p1: Int, p2: Int, p3: Float) &#123; // Called when a drawer&#x27;s position changes. &#125; override fun onTransitionCompleted(p0: MotionLayout?, p1: Int) &#123; // Called when a drawer has settled completely a state. &#125;&#125;) 在 MotionScene 文件中定义约束我们可以在 MotionScene 元素中使用 ConstraintSet 子元素定义一个场景约束集，并在 ConstraintSet 元素中使用 Constraint 元素定义单个 View 的属性约束。将 activity_main_motion_scene.xml 改成如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;MotionScene xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 定义 Start 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=&quot;@+id/activity_main_start&quot;&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=&quot;@id/image&quot; android:layout_width=&quot;56dp&quot; android:layout_height=&quot;56dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;1.0&quot;/&gt; &lt;/ConstraintSet&gt; &lt;!-- 定义 End 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=&quot;@+id/activity_main_end&quot;&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=&quot;@id/image&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.0&quot;/&gt; &lt;/ConstraintSet&gt; &lt;!-- Start 场景与 End 场景都是定义在 MotionScene 文件中的约束集 --&gt; &lt;Transition app:constraintSetStart=&quot;@id/activity_main_start&quot; app:constraintSetEnd=&quot;@id/activity_main_end&quot; app:duration=&quot;1000&quot;&gt; &lt;OnClick app:clickAction=&quot;toggle&quot; app:targetId=&quot;@id/image&quot;/&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 效果如下： 这种写法还支持自定义属性：在 Constraint 元素中使用 CustomAttribute 子元素来指定自定义属性。改成如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;MotionScene xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 定义 Start 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=&quot;@+id/activity_main_start&quot;&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=&quot;@id/image&quot; android:layout_width=&quot;56dp&quot; android:layout_height=&quot;56dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;1.0&quot;&gt; &lt;!-- 使用自定义属性 --&gt; &lt;CustomAttribute app:attributeName=&quot;backgroundColor&quot; app:customColorValue=&quot;@color/colorPrimary&quot;/&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;!-- 定义 End 场景的属性约束集 --&gt; &lt;ConstraintSet android:id=&quot;@+id/activity_main_end&quot;&gt; &lt;!-- 定义布局中 id 为 image 的 View 的属性约束 --&gt; &lt;Constraint android:id=&quot;@id/image&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.0&quot;&gt; &lt;!-- 使用自定义属性 --&gt; &lt;CustomAttribute app:attributeName=&quot;backgroundColor&quot; app:customColorValue=&quot;@color/colorAccent&quot;/&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;!-- Start 场景与 End 场景都是定义在 MotionScene 文件中的约束集 --&gt; &lt;Transition app:constraintSetStart=&quot;@id/activity_main_start&quot; app:constraintSetEnd=&quot;@id/activity_main_end&quot; app:duration=&quot;1000&quot;&gt; &lt;OnClick app:clickAction=&quot;toggle&quot; app:targetId=&quot;@id/image&quot;/&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 效果如下： 所以如果有使用到 CustomAttribute，则最好将约束变化定义在 MotionScene xml 中。 小结利用 MotionLayout 实现了一个普遍的按钮点击动画：效果还不错，只是如果前后动画的插值器不一致，或有其他定制的需求时，MotionLayout 是否能满足呢？ 本文只是简单介绍了一下 MotionLayout 的使用，它其实还有很多东西，比如 OnSwipe，以及 app:transitionEasing、app:transitionPathRotate、app:drawPath 等一些比较有意思的属性，有空的时候可以再多看看。MotionLayout 当前还只是测试版，期待正式版本出来的那一天！","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"高德地图 Marker 聚合","date":"2019-08-05T06:36:57.000Z","path":"2019/08/05/handlerthread/","text":"高德地图有个官方 Demo用来实现 Marker 聚合，但不是在 SDK 里。项目里也有这个需求，但是比较简单，不用做到数量计算，只需要当 Marker 数量很多的的时候，只展示部分 Marker，显示了会覆盖的 Marker 则直接不显示。每次移动地图都会请求新的数据，然后来进行展示，为了避免移动地图导致频繁请求数据，可以做个简单的优化：移动后延迟一定时间再去请求数据，在延迟时间内再次移动地图，则取消上次请求的动作，重新请求。综合考虑，使用 HandlerThread 便是不二之选了，在这里记录一下，以后或许用得到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264class MarkerClusterController&lt;T : MarkerItem&gt;(val mapController: MapController, val adapter: MarkerDataAdapter&lt;T&gt;) : AMap.OnCameraChangeListener, AMap.OnMarkerClickListener &#123; companion object &#123; private const val TAG = &quot;MarkerClusterController&quot; private const val UPDATE_INTERVAL_TIME = 500L // 更新数据 private const val MSG_CLUSTER_DATA_UPDATE = 1 // 清空数据 private const val MSG_CLUSTER_MARKER_CLEAR = 2 &#125; private val amap = mapController.amap private val clusterHandlerThread: HandlerThread = HandlerThread(&quot;MarkerClusterThread&quot;) private var clusterHandler: ClusterHandler // 更新过程中是否取消更新 var isCanceled = false private val makerUpdateManger = MarkerUpdateManger() init &#123; clusterHandlerThread.start() clusterHandler = ClusterHandler(clusterHandlerThread.looper) mapController.addCameraChangeListener(this) mapController.addOnMarkerClickListener(this) &#125; override fun onCameraChangeFinish(p0: CameraPosition) &#123; // 地图移动或者层级变化时更新数据 clusterHandler.sendDataUpdateMsg() &#125; override fun onCameraChange(p0: CameraPosition?) &#123; &#125; @Suppress(&quot;UNCHECKED_CAST&quot;) override fun onMarkerClick(marker: Marker): Boolean &#123; val markerItem = marker.`object` as? MarkerItem return if (markerItem == null) &#123; false &#125; else &#123; adapter.onMarkerClick(markerItem, marker) &#125; &#125; fun initData() &#123; clusterHandler.sendEmptyMessage(MSG_CLUSTER_DATA_UPDATE) &#125; /** * 销毁数据，移除监听 */ fun onDestroy() &#123; isCanceled = true mapController.removeCameraChangeListener(this) mapController.removeMarkClickListener(this) clusterHandler.removeCallbacksAndMessages(null) clusterHandlerThread.quit() makerUpdateManger.clearMarker() &#125; /** * 清除某个类型的 Marker 集合 */ fun clearMarkers(type: MarkType) &#123; val iterator = makerUpdateManger.markerList.iterator() iterator.forEach &#123; val markerItem = it.`object` as? MarkerItem if (markerItem?.type == type) &#123; it.remove() makerUpdateManger.markerList.remove(it) &#125; &#125; &#125; /** * 移除某个 Marker * 高亮的 Marker 先移除再绘制 */ fun removeMarker(t: T?) &#123; if (t == null) &#123; return &#125; val iterator = makerUpdateManger.markerList.iterator() iterator.forEach &#123; if (it.`object` == t) &#123; it.remove() makerUpdateManger.markerList.remove(it) &#125; &#125; &#125; fun getMarkerList(): List&lt;Marker&gt; &#123; return makerUpdateManger.markerList &#125; fun updateMarkerList(tempList: MutableList&lt;T&gt;?) &#123; clusterHandler.post &#123; makerUpdateManger.updateMarkerList(tempList) &#125; &#125; /** * Marker 更新管理 */ inner class MarkerUpdateManger &#123; // 两个marker之间的最小距离阈值 private val defaultDistance = DimenUtils.dp2px(40f) val markerList = CopyOnWriteArrayList&lt;Marker&gt;() /** * 获取数据计算聚合 */ internal fun updateClustersData() &#123; isCanceled = false val visibleBounds = amap.projection.visibleRegion.latLngBounds val markerItemList = adapter.getMarkerData(visibleBounds) updateMarkerList(markerItemList) &#125; /** * 显示 MarkerList，先清空已显示的 */ fun updateMarkerList(tempList: MutableList&lt;T&gt;?) &#123; if (isCanceled) &#123; return &#125; // 还需要显示的不用移除 val showMarkerList = mutableListOf&lt;Marker&gt;() val newDrawList = mutableListOf&lt;MarkerItem&gt;() tempList?.sortByDescending &#123; it.zIndex &#125; tempList?.let &#123; list -&gt; if (isCanceled) &#123; return &#125; list.forEach &#123; item -&gt; if (getCluster(item.latLng, newDrawList)) &#123; newDrawList.add(item) &#125; &#125; &#125; val repeatList = mutableListOf&lt;MarkerItem&gt;() // 循环匹配保留还需要显示的，移除不需要显示的 markerList.forEach &#123; marker -&gt; val objectData = marker.`object` as MarkerItem if (newDrawList.contains(objectData)) &#123; repeatList.add(objectData) showMarkerList.add(marker) &#125; else &#123; marker.remove() &#125; &#125; // 剔除已绘制过的 newDrawList.removeAll(repeatList) markerList.clear() markerList.addAll(showMarkerList) addMarkerList(newDrawList) &#125; /** * 增加 MarkerList */ private fun addMarkerList(newList: List&lt;MarkerItem&gt;) &#123; newList.forEach &#123; addMarker(it) &#125; &#125; /** * 增加一个 Marker */ private fun addMarker(markerItem: MarkerItem) &#123; val marker = markerItem.createMarker(mapController.mapView) marker.`object` = markerItem markerList.add(marker) &#125; /** * 清除 Marker */ internal fun clearMarker() &#123; markerList.forEach &#123; it.remove() &#125; markerList.clear() &#125; /** * 当前点是否会被覆盖 * * @param latLng * @return */ private fun getCluster(latLng: LatLng, markerItem: List&lt;MarkerItem&gt;): Boolean &#123; for (item in markerItem) &#123; val clusterCenterPoint = item.latLng val distance = AMapUtils.calculateLineDistance(latLng, clusterCenterPoint).toDouble() val clusterDistance = defaultDistance * amap.scalePerPixel if (distance &lt; clusterDistance) &#123; return false &#125; &#125; return true &#125; &#125; /** * 集合Handler，保证 Marker 集合处理在同一子线程 */ private inner class ClusterHandler(looper: Looper) : Handler(looper) &#123; private var lastUpdateTime = 0L override fun handleMessage(msg: Message) &#123; when (msg.what) &#123; MSG_CLUSTER_DATA_UPDATE -&gt; &#123; makerUpdateManger.updateClustersData() &#125; MSG_CLUSTER_MARKER_CLEAR -&gt; &#123; makerUpdateManger.clearMarker() &#125; &#125; &#125; fun sendDataUpdateMsg() &#123; val currentTime = System.currentTimeMillis() if (currentTime - lastUpdateTime &lt; UPDATE_INTERVAL_TIME) &#123; return &#125; lastUpdateTime = currentTime isCanceled = true removeCallbacksAndMessages(null) sendEmptyMessageDelayed(MSG_CLUSTER_DATA_UPDATE, UPDATE_INTERVAL_TIME) &#125; &#125;&#125;/** * Marker 数据获取适配器 */interface MarkerDataAdapter&lt;T : MarkerItem&gt; &#123; fun getMarkerData(visibleBounds: LatLngBounds): MutableList&lt;T&gt;? fun onMarkerClick(markerItem: MarkerItem, marker: Marker): Boolean&#125;abstract class MarkerItem(val type: MarkType, val latLng: LatLng, var zIndex: Float = -1F) &#123; /** * 生成 Marker */ abstract fun createMarker(mapView: MapView): Marker&#125;","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android 实现大文件分片上传","date":"2019-07-12T07:57:19.000Z","path":"2019/07/12/multi-form/","text":"项目中有视频上传的功能，但一直没做断点续传，针对大视频上传不友好，最近的版本需求将断点续传加上了，服务端采用的是 multipart&#x2F;form-data 编码方式来实现，那么客户端也依照这个方式来做就好了。 multipart&#x2F;form-datamultipart&#x2F;form-data 方式用于大数据 Post 请求，用做分片正好合适。它对数据有一定的格式，参照示例： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 每部分都是以--boundary开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以--boundary--标示结束。 原生实现如果使用 Android 原生 HttpUrlConnection 来拼接数据，参照从原理角度解析Android （Java） http 文件上传贴出部分代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private static final String BOUNDARY = &quot;----WebKitFormBoundaryT1HoybnYeFOGFlBR&quot;; /** * * @param params * 传递的普通参数 * @param uploadFile * 需要上传的文件名 * @param fileFormName * 需要上传文件表单中的名字 * @param newFileName * 上传的文件名称，不填写将为uploadFile的名称 * @param urlStr * 上传的服务器的路径 * @throws IOException */public void uploadForm(Map&lt;String, String&gt; params, String fileFormName, File uploadFile, String newFileName, String urlStr) throws IOException &#123; if (newFileName == null || newFileName.trim().equals(&quot;&quot;)) &#123; newFileName = uploadFile.getName(); &#125; StringBuilder sb = new StringBuilder(); /** * 普通的表单数据 */ for (String key : params.keySet()) &#123; sb.append(&quot;--&quot; + BOUNDARY + &quot;\\r\\n&quot;); sb.append(&quot;Content-Disposition: form-data; name=\\&quot;&quot; + key + &quot;\\&quot;&quot; + &quot;\\r\\n&quot;); sb.append(&quot;\\r\\n&quot;); sb.append(params.get(key) + &quot;\\r\\n&quot;); &#125; /** * 上传文件的头 */ sb.append(&quot;--&quot; + BOUNDARY + &quot;\\r\\n&quot;); sb.append(&quot;Content-Disposition: form-data; name=\\&quot;&quot; + fileFormName + &quot;\\&quot;; filename=\\&quot;&quot; + newFileName + &quot;\\&quot;&quot; + &quot;\\r\\n&quot;); sb.append(&quot;Content-Type: image/jpeg&quot; + &quot;\\r\\n&quot;);// 如果服务器端有文件类型的校验，必须明确指定ContentType sb.append(&quot;\\r\\n&quot;); byte[] headerInfo = sb.toString().getBytes(&quot;UTF-8&quot;); byte[] endInfo = (&quot;\\r\\n--&quot; + BOUNDARY + &quot;--\\r\\n&quot;).getBytes(&quot;UTF-8&quot;); System.out.println(sb.toString()); URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;POST&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + BOUNDARY); conn.setRequestProperty(&quot;Content-Length&quot;, String .valueOf(headerInfo.length + uploadFile.length() + endInfo.length)); conn.setDoOutput(true); OutputStream out = conn.getOutputStream(); InputStream in = new FileInputStream(uploadFile); out.write(headerInfo); byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) != -1) out.write(buf, 0, len); out.write(endInfo); in.close(); out.close(); if (conn.getResponseCode() == 200) &#123; System.out.println(&quot;上传成功&quot;); &#125;&#125; 拼接好字符串之后，转成 byte 数组，然后写入到 http connection 中即可。 OkHttp 实现项目中有基于 OkHttp 封装网络请求，但是不支持 multipart&#x2F;form-data，那么便根据 OkHttp 自己实现一个吧。 12345678910111213141516171819202122232425262728293031// Http 请求 Clientprivate val client: OkHttpClient = OkHttpClient().newBuilder() .connectTimeout(0, TimeUnit.MILLISECONDS) .writeTimeout(60 * 1000, TimeUnit.MILLISECONDS) .readTimeout(60 * 1000, TimeUnit.MILLISECONDS) .build()/** * 分片上传，采用 OkHttp MultipartBody */fun uploadPart(data: ByteArray, uploadId: String, key: String, partNumber: Int, progressListener: ProgressListener?): String? &#123; val requestBody = VideoUploadRequestBody.create(MediaType.parse(&quot;video/mp4&quot;), data, progressListener) val multipartBody = MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(&quot;filename&quot;, key, requestBody) .addFormDataPart(&quot;uploadId&quot;, uploadId) .addFormDataPart(&quot;key&quot;, key) .addFormDataPart(&quot;partNumber&quot;, partNumber.toString()) .addFormDataPart(&quot;partSize&quot;, data.size.toString()) .build() val url = RequestUtils.buildFullUrl(apiHost, &quot;/api/open/upload/part.htm&quot;, signKey, extraParams) val request = Request.Builder() .url(url) .post(multipartBody) .build() val response = client.newCall(request).execute() return response.body()?.string()&#125; 利用 MultipartBody.addFormDataPart 可以很方便的添加参数，而不用自己拼接了。MultipartBody.FORM即对应multipart/form-data： 1public static final MediaType FORM = MediaType.get(&quot;multipart/form-data&quot;) 针对 client 返回的 response，想要获取数据只需要调用： 1response.body()?.string() 但是此方法只能调用一次，调用之后 client 会关闭通道，这让我在调试返回结果的时候浪费不少时间。data 作为数据来源，可以从 File 中读取： 12345678910111213141516171819202122232425262728293031/** * 获取某一片对应的二进制数据 * PART_SIZE：每一片的大小 * * @param partSize 当前第几片 * @param file 文件对象 * * @return 对应片段的二进制数据流 */private fun getPartData(partSize: Int, file: File): ByteArray? &#123; val result = ByteArray(PART_SIZE) var accessFile: RandomAccessFile? = null try &#123; accessFile = RandomAccessFile(file, &quot;r&quot;) accessFile.seek((partSize - 1L) * PART_SIZE) return when (val readSize = accessFile.read(result)) &#123; -1 -&gt; null PART_SIZE -&gt; result else -&gt; &#123; val tempArray = ByteArray(readSize) System.arraycopy(result, 0, tempArray, 0, readSize) tempArray &#125; &#125; &#125; catch (e: IOException) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; IOUtils.close(accessFile) &#125; return null&#125; 至此，数据便能使用 multipart&#x2F;form-data Post 到服务器了。 进度监听看到上述示例中的 VideoUploadRequestBody： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class VideoUploadRequestBody(val contentType: MediaType?, val data: ByteArray, val listener: ProgressListener?) : RequestBody() &#123; companion object &#123; @JvmStatic fun create(contentType: MediaType?, data: ByteArray, listener: ProgressListener?): RequestBody &#123; return VideoUploadRequestBody(contentType, data, listener) &#125; &#125; override fun contentType(): MediaType? &#123; return contentType &#125; @Throws(IOException::class) override fun contentLength(): Long &#123; return data.size.toLong() &#125; @Throws(IOException::class) override fun writeTo(sink: BufferedSink) &#123; var localSink = sink if (listener != null) &#123; localSink = Okio.buffer(CountSink(localSink)) &#125; localSink.writeAll(Okio.source(ByteArrayInputStream(data))) // 必须添加 flush，不然最后一片会上传失败 localSink.flush() &#125; private inner class CountSink(delegate: Sink) : ForwardingSink(delegate) &#123; internal var bytesWritten = 0L internal var contentLength = 0L @Throws(IOException::class) override fun write(source: Buffer, byteCount: Long) &#123; super.write(source, byteCount) if (contentLength == 0L) &#123; contentLength = contentLength() &#125; bytesWritten += byteCount listener?.onProgress(bytesWritten, contentLength, bytesWritten == contentLength) &#125; &#125;&#125; 继承 RequestBody，在每一次 write 的时候回调一下，BufferedSink writeAll 方法内部会每次写入 8192 字节。 123456789101112131415@Overridepublic long writeAll(Source source) throws IOException &#123; if (source == null) &#123; throw new IllegalArgumentException(&quot;source == null&quot;); &#125; long totalBytesRead = 0; for (long readCount; (readCount = source.read(buffer, Segment.SIZE)) != -1; ) &#123; totalBytesRead += readCount; emitCompleteSegments(); &#125; return totalBytesRead;&#125;final class Segment &#123; /** The size of all segments in bytes. */ static final int SIZE = 8192;&#125; 所以每写入 8192 字节会回调一次，对于进度监听有特殊需求的，可自行修改 writeTo 方法。这个回调只是针对单片的，还需要一个针对整个文件的回调： 123456789// 当前上传的是第几片private var currentPart = 0// 上传文件的 sizeprivate var size = 0Loverride fun onProgress(currentLength: Long, contentLength: Long, complete: Boolean) &#123; val progress = (currentPart - 1) * PART_SIZE + currentLength listener?.onProgress(progress, size, progress == size)&#125; 如此，整个文件上传的进度监听即实现了。注：要实现断点续传，则需要在每个分片上传完之后保存到本地数据库，然后续传的时候根据数据库保存的最新片段取出数据进行上传。 参考四种常见的 POST 提交数据方式从原理角度解析Android （Java） http 文件上传OkHttp踩坑记：为何 response.body().string() 只能调用一次？","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"记一次 ANR 寻根之旅","date":"2019-07-04T07:12:38.000Z","path":"2019/07/04/anr/","text":"最近项目升大版本，targetSdkVersion 从 Android 6.0（version 21） 直接升到 Adnroid 9.0（version 28），跨度有点大，但是没有像升到 Android 6.0 那样工作量大。升完之后，在小米5、小米4C 2款测试机上 App 启动直接无响应了，在我的小米 MIX 上没问题。于是测试机调试之旅开始了。。。在 SplashActivity onCreate 的方法里打断点进都进不去，有点懵，所以将目标定位到 Application 初始化了。看着 Application 相关初始化的代码，没发现什么大问题。打断点逐步调试，运行到某一行时直接就无响应了，后面的代码也不执行了，logcat 也看不到有用的信息，有点摸不着头脑。后面 Google 发现可以直接看到手机 ANR 的日志，路径为：&#x2F;data&#x2F;anr&#x2F;traces.txt，于是很欢快的将日志导出到电脑： 1adb pull /data/anr/traces.txt d:/test 然后看到 traces.txt： 12345678910111213141516171819202122232425262728293031323334353637383940----- pid 1928 at 2019-07-03 17:42:50 -----Cmd line: cn.xxx.xxx.xxxBuild fingerprint: &#x27;Xiaomi/gemini/gemini:6.0.1/MXB48T/V8.0.10.0.MAACNDH:user/release-keys&#x27;ABI: &#x27;arm&#x27;Build type: optimizedZygote loaded classes=4121 post zygote classes=1287Intern table: 54279 strong; 161 weakJNI: CheckJNI is on; globals=322 (plus 266 weak)Libraries: /data/app/cn.xxx.xxx.xxx-1/lib/arm/libBDSpeechDecoder_V1.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libbd_etts.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libbdtts.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libgnustl_shared.so /data/app/cn.xxx.xxx.xxx-1/lib/arm/libtnpn.so /system/app/WebViewGoogle/WebViewGoogle.apk!/lib/armeabi-v7a/libwebviewchromium.so /system/lib/libandroid.so /system/lib/libcompiler_rt.so /system/lib/libjavacrypto.so /system/lib/libjnigraphics.so /system/lib/libmedia_jni.so /system/lib/libmiuinative.so /system/lib/libqti_performance.so /system/lib/libsechook.so /system/lib/libwebviewchromium_loader.so /system/lib/libwebviewchromium_plat_support.so libjavacore.so (17)Heap: 24% free， 21MB/28MB; 47008 objects...&quot;main&quot; prio=5 tid=1 Waiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x744885e0 self=0xf4f76500 | sysTid=1928 nice=-1 cgrp=bg_non_interactive sched=0/0 handle=0xf7194b34 | state=S schedstat=( 236711085 326769009 310 ) utm=17 stm=6 core=0 HZ=100 | stack=0xff4ef000-0xff4f1000 stackSize=8MB | held mutexes= at cn.xxx.android.core.glide.GlideProgressManager.getOkHttpClient(GlideProgressManager.java:36) - waiting on &lt;0x08da7fbe&gt; (a java.lang.Class&lt;cn.xxx.android.core.http.XXXHttpClient&gt;) at cn.xxx.android.core.glide.XXXAppGlideModule.registerComponents(XXXAppGlideModule.java:44) at com.bumptech.glide.GeneratedAppGlideModuleImpl.registerComponents(GeneratedAppGlideModuleImpl.java:38) at com.bumptech.glide.Glide.initializeGlide(Glide.java:273) at com.bumptech.glide.Glide.initializeGlide(Glide.java:223) at com.bumptech.glide.Glide.checkAndInitializeGlide(Glide.java:184) at com.bumptech.glide.Glide.get(Glide.java:168) - locked &lt;0x02e8781f&gt; (a java.lang.Class&lt;com.bumptech.glide.Glide&gt;) at cn.xxx.xxx.xxx.VygApplication.onTrimMemory(VygApplication.java:93) at android.app.ActivityThread.handleTrimMemory(ActivityThread.java:4420) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1548) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5458) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)... 日志很多，Cmd line 就是当前 ANR 应用的包名，通过日志，可以得到一些有效信息： 123456789101112131415161718main：main标识是主线程，如果是线程，那么命名成“Thread-X”的格式，x 表示线程 id，逐步递增prio：线程优先级，默认是 5tid：tid 不是线程的 id，是线程唯一标识 IDgroup：是线程组名称sCount：该线程被挂起的次数dsCount：是线程被调试器挂起的次数obj：对象地址self：该线程 Native 的地址sysTid：是线程号(主线程的线程号和进程号相同)nice：是线程的调度优先级sched：分别标志了线程的调度策略和优先级cgrp：调度归属组handle：线程处理函数的地址state：是调度状态schedstat：从 /proc/[pid]/task/[tid]/schedstat 读出，三个值分别表示线程在 cpu 上执行的时间、线程的等待时间和线程执行的时间片长度，不支持这项信息的三个值都是 0utm：是线程用户态下使用的时间值(单位是 jiffies）stm：是内核态下的调度时间值core：是最后执行这个线程的 cpu 核的序号 找到 “main”，可以看到，在 Application 的 onTrimMemory 时调用了 Glide 的 get 方法，后面一系列操作导致的主线程变成 Waiting 状态了。 12345678910@Overridepublic void onTrimMemory(int level) &#123; super.onTrimMemory(level); if (level == TRIM_MEMORY_UI_HIDDEN) &#123; Glide.get(this).clearMemory(); &#125; Glide.get(this).trimMemory(level);&#125; 最终会调用到 GlideAppModule 的 registerComponents 方法： 123456789101112@Overridepublic void registerComponents(Context context， Glide glide， Registry registry) &#123; registry.replace(GlideUrl.class， InputStream.class， new OkHttpUrlLoader.Factory(GlideProgressManager.getOkHttpClient())); if (CollectionUtils.isNotEmpty(libraryGlideModuleList)) &#123; int size = libraryGlideModuleList.size(); for (int i = 0; i &lt; size; i++) &#123; libraryGlideModuleList.get(i).registerComponents(context， glide， registry); &#125; &#125;&#125; 然后看到 GlideProgressManager： 12345678910111213141516static OkHttpClient getOkHttpClient() &#123; if (okHttpClient == null) &#123; okHttpClient = XXXHttpClient.getDefaultHttpClient().newBuilder() .addNetworkInterceptor(new Interceptor() &#123; @Override public Response intercept(@NonNull Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); return response.newBuilder() .body(new ProgressResponseBody(request.url().toString()， response.body()， LISTENER)) .build(); &#125; &#125;).build(); &#125; return okHttpClient;&#125; XXXHttpClient： 123456789101112private static volatile OkHttpClient defaultHttpClient;public static OkHttpClient getDefaultHttpClient() &#123; if (defaultHttpClient == null) &#123; synchronized (MucangHttpClient.class) &#123; if (defaultHttpClient == null) &#123; defaultHttpClient = new OkHttpClient(); &#125; &#125; &#125; return defaultHttpClient;&#125; 很标准的 Double-Check 单例模式，感觉没啥大问题，但是为啥会导致 ANR 呢？因为升大版本，将绝大多数注意力都放到升级注意项了，比如 FileProvider 等等，但是正好基础库在大版本升级时，将 OkHttp 从 2.x 升到 3.x，上面的代码正时此时添加进来的，所以没升大版本一切正常。解决问题的话，将 Application 中 Glide 相关操作直接干掉就好了，Glide 内部有自己的内存控制策略，无需开发者关心了吧。写这篇文章主要是记录一下可以通过拉取 traces.text 日志来分析 ANR，但是为什么这样的代码导致了 ANR 还没研究透，待我研究好了再来更新此文。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"养猫一个星期后","date":"2019-06-28T08:40:21.000Z","path":"2019/06/28/cat/","text":"我有一个梦想：养一只二哈，或者柴犬、金毛也可以，哈哈。但是狗的话，天性好动，需要每天带出去溜溜（或许是狗溜我）。我现在一个人住，普遍情况下家里是没人的，养一只狗确实没太多的时间和精力。退而求其次，养只猫或许可行？猫的话，比较爱干净，也能一整天待在家里不需要你带出去溜，只要我在家的时间能陪陪他便好了。也做了很久的思想斗争，养不好怎么办，这不是耽误猫生吗？最后还是开悟了，人生不就是这样吗？要多多体验没经历过的事情，之前没养过猫，现在养一只，也是一种经历，会养慢慢学习总能变好的。早些日子就找过一家猫舍看过猫，也加了微信，总能在朋友圈看到各种各样的小猫咪，内心总是蠢蠢欲动。心动不如行动，就在上周日，我去猫舍买了一只美短虎斑，很调皮的一个小家伙，我给他取名「土豆」。 你看我，萌不萌？ 第一天刚到家的时候，这家伙很怂，就躲在沙发下面。 后面慢慢熟悉了，可以用逗猫棒把他吸引过来了。 被逗起来的猫还是很过瘾的。Your browser does not support the video tag. 再然后他都敢往我电脑桌上爬了，“快来撸我，别玩电脑了！”。 胆子越来越大，才两个月大点的小猫咪，直接爬上了我近一米高的凳子。后面直接往下跳，估计是把腿摔疼了，破天荒的在我怀里安静了小半天，果然是初生牛犊不怕虎。 有一天竟然还爬到我的床上了，但是我现在还没能接受和猫咪一起睡，直接就把他丢下床去。 最近莫名喜欢玩我的拖鞋，让我很无语。 这几天，小猫咪适应的很好，现在吃喝拉撒都挺正常，一天喂两次猫粮，早晚各一次，水就看情况加。猫舍管家说，猫不喜欢吃隔夜的食物，所以我尽量都是每天都喂，一次少喂点。营养膏应该是猫最喜欢吃的实物了吧，吃营养膏的时候是他最乖的时候。Your browser does not support the video tag. 最后上个撸猫视频，撸猫一时爽，一直撸一直爽。Your browser does not support the video tag.","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"ConstraintLayout 真香","date":"2019-06-13T02:37:26.000Z","path":"2019/06/13/cl/","text":"ConstraintLayout 出来蛮久了，但是一直没怎么用，说是可以直接进行拖拽来实现布局，但是 xml 里全是写死的 dp，不实用。然后用代码吧，属性都贼长贼多，有些难记。最近同学强力安利，说多写写就熟悉了，于是项目新的布局基本都用 ConstraintLayout 来写了，刚开始写的时候确实比较慢，很多属性不知道，有些属性有什么用也不晓得，但是用了几天后，发现真好用！人类的本质啊，真香怪！ 基本属性 layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf 见名思意，都很直接明了，还是很方便使用的。和 RelativeLayout 很相似，但是还有着 LinearLayout 的特性，可以说是结合了两大布局的特性，用起来爽歪歪。用这些基础属性已经可以实现大部分的布局了，而且布局嵌套层级就一级。举个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;44dp&quot; android:paddingLeft=&quot;14dp&quot; android:paddingRight=&quot;4dp&quot; tools:background=&quot;#f00&quot;&gt; &lt;ImageView android:id=&quot;@+id/backIv&quot; android:layout_width=&quot;32dp&quot; android:layout_height=&quot;32dp&quot; android:paddingLeft=&quot;6dp&quot; android:src=&quot;@drawable/vyg__icon_back_white&quot; android:tint=&quot;#fff&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/catalogTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:paddingLeft=&quot;16dp&quot; android:paddingRight=&quot;16dp&quot; android:text=&quot;目录&quot; android:textColor=&quot;@color/vyg__white&quot; android:textSize=&quot;14sp&quot; android:visibility=&quot;gone&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; tools:visibility=&quot;gone&quot;/&gt; &lt;ImageView android:id=&quot;@+id/avatarIv&quot; android:layout_width=&quot;32dp&quot; android:layout_height=&quot;32dp&quot; android:layout_marginLeft=&quot;12dp&quot; android:src=&quot;@drawable/vyg__user_avatar_default&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toRightOf=&quot;@id/backIv&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/nameTv&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;16dp&quot; android:ellipsize=&quot;end&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;@color/vyg__363A3E&quot; android:textSize=&quot;13sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/timeTv&quot; app:layout_constraintHorizontal_bias=&quot;0&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/avatarIv&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/followTv&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_chainStyle=&quot;packed&quot; tools:text=&quot;小孩子的故事小孩子的故事小孩子的故事小孩子的故事&quot;/&gt; &lt;TextView android:id=&quot;@+id/timeTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/vyg__A0A9B9&quot; android:textSize=&quot;11sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/nameTv&quot; app:layout_constraintTop_toBottomOf=&quot;@id/nameTv&quot; tools:text=&quot;2012-11-12&quot;/&gt; &lt;TextView android:id=&quot;@+id/followTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/vyg__shape_f8e71c_r100&quot; android:drawablePadding=&quot;4dp&quot; android:gravity=&quot;center&quot; android:paddingBottom=&quot;6dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:paddingTop=&quot;6dp&quot; android:text=&quot;关注&quot; android:textColor=&quot;@color/vyg__font_363a3e&quot; android:textSize=&quot;14sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@id/catalogTv&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_goneMarginRight=&quot;16dp&quot;/&gt; &lt;android.support.constraint.Group android:id=&quot;@+id/group&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; app:constraint_referenced_ids=&quot;avatarIv,nameTv,timeTv,followTv&quot; tools:visibility=&quot;visible&quot;/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 界面效果如下： goneMargin如上图的界面中，为了加大「目录」两字的点击相应区域，给它设置了左右 16dp 的 padding，但是某些情况下，这个「目录」不需要展示，设置为 GONE 之后「关注」按钮距离右边的距离就只剩 4dp 了，需要手动改为 16dp，这样就得写一句很蛋疼的代码： 1(followTv.layoutParams as ViewGroup.MarginLayoutParams).rightMargin = DimenUtils.dp2px(16F) 但是利用 ConstraintLayout 之后，你会发现一句 xml 代码即可搞定，给「关注」设置如下属性 1app:layout_goneMarginRight=&quot;16dp&quot; 当它依赖的 View 变为 GONE 时，仍然能保留 margin，ConstraintLayout 流弊！ chainStyle上述代码中有一个属性： 1app:layout_constraintVertical_chainStyle=&quot;packed&quot; 可以将约束元素组成一个链，chainStyle 用来设置元素之间的效果。 weight经常有这种布局： 12345678910111213141516171819202122&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;View android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;View android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;View android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;/&gt;&lt;/LinearLayout&gt; ConstraintLayout 利用 layout_constraintHorizontal_weight 或 layout_constraintVertical_weight 也可以轻而易举的实现。只有一个 View 占据宽度的 1&#x2F;3，利用 LinearLayout 可以将 View 换成 Space： 12345678910111213141516171819202122&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Space android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;View android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;Space android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;/&gt;&lt;/LinearLayout&gt; 利用 ConstraintLayout 实现将会更简单： 1234567891011121314151617&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;View android:layout_width=&quot;0dp&quot; android:layout_height=&quot;100dp&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_weight=&quot;&quot; app:layout_constraintWidth_percent=&quot;0.33&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 忽略除不断的小数- -。 Group经常会有这种需求：在某个场景下，展示哪些 View，在其他场景要隐藏这些 View，它们是同显示同隐藏的，一个两个 View 还好，如果 View 很多，写起来就很蛋疼了。用 Group 则会很简单。 1234567&lt;android.support.constraint.Group android:id=&quot;@+id/group&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; app:constraint_referenced_ids=&quot;avatarIv,nameTv,timeTv,followTv&quot; tools:visibility=&quot;visible&quot;/&gt; 然后使用 group.visibility 即可设置 ids 里面所有 id 对应的 View 了。注：Group 只有在 1.1 及以上的版本才添加进来。再注：Group 添加后的 id 再针对子 View 单独操作 visibility 是无效的。代码： 12345678910111213141516171819public void updatePreLayout(ConstraintLayout container) &#123; int visibility = this.getVisibility(); float elevation = 0.0F; if (VERSION.SDK_INT &gt;= 21) &#123; elevation = this.getElevation(); &#125; for(int i = 0; i &lt; this.mCount; ++i) &#123; int id = this.mIds[i]; View view = container.getViewById(id); if (view != null) &#123; view.setVisibility(visibility); if (elevation &gt; 0.0F &amp;&amp; VERSION.SDK_INT &gt;= 21) &#123; view.setElevation(elevation); &#125; &#125; &#125;&#125; 界面绘制时，Group 关联的所有 View 的 visibility 只会根据 Group 来，要么全看得见，要么全看不见。 constrainedWidth先看两张图： 文章 RecyclerView 处于微信图标的左侧，且从右边开始布局，嵌套布局很容易实现，看下约束布局如何实现： 1234567891011121314151617181920212223242526272829303132333435&lt;android.support.constraint.ConstraintLayout android:id=&quot;@+id/articleRoot&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom&quot; android:layout_marginBottom=&quot;112dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/wxIconIv&quot; android:layout_width=&quot;62dp&quot; android:layout_height=&quot;57dp&quot; android:layout_marginLeft=&quot;6dp&quot; android:paddingRight=&quot;8dp&quot; android:src=&quot;@drawable/vyg__article_icon_wx&quot; android:visibility=&quot;gone&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot;/&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/articleRv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;12dp&quot; android:layout_marginLeft=&quot;12dp&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;1&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/wxIconIv&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 将控件的尺寸设置为 wrap_content，那么对控件设置的 maxWidth、minHeight 这些约束是不起作用的，而强制约束就用于使控件在设置 wrap_content 的情况下约束依然生效。 小结ConstraintLayout 还有很多我没用到特性，目前为止，我：真香！已经不想再用原始的三大布局了，嘿嘿嘿。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"RecyclerView 滑动小记","date":"2019-05-17T07:58:19.000Z","path":"2019/05/17/scroll-1/","text":"关于 RecyclerView 的滑动方法有很多： scrollToPosition scrollTo scrollBy smoothScrollBy smoothScrollToPosition 针对 LineaderLayoutManager 还有一个很重要的方法：scrollToPositionWithOffset，下面逐一进行说明。 scrollTo1234public void scrollTo(int x, int y) &#123; Log.w(TAG, &quot;RecyclerView does not support scrolling to an absolute position. &quot; + &quot;Use scrollToPosition instead&quot;);&#125; 滑动到绝对位置，直接不支持。很皮~ scrollBy &amp; smoothScrollBy基于当前位置进行相对滑动。 123456789101112131415public void scrollBy(int x, int y) &#123; if (mLayout == null) &#123; Log.e(TAG, &quot;Cannot scroll without a LayoutManager set. &quot; + &quot;Call setLayoutManager with a non-null argument.&quot;); return; &#125; if (mLayoutFrozen) &#123; return; &#125; final boolean canScrollHorizontal = mLayout.canScrollHorizontally(); final boolean canScrollVertical = mLayout.canScrollVertically(); if (canScrollHorizontal || canScrollVertical) &#123; scrollByInternal(canScrollHorizontal ? x : 0, canScrollVertical ? y : 0, null); &#125;&#125; 根据布局的方向进行滑动。scrollByInternal 为具体处理滑动的方法，这里不贴了，它会调用 dispatchOnScrolled： 1234567891011121314151617181920212223void dispatchOnScrolled(int hresult, int vresult) &#123; mDispatchScrollCounter++; // Pass the current scrollX/scrollY values; no actual change in these properties occurred // but some general-purpose code may choose to respond to changes this way. final int scrollX = getScrollX(); final int scrollY = getScrollY(); onScrollChanged(scrollX, scrollY, scrollX, scrollY); // Pass the real deltas to onScrolled, the RecyclerView-specific method. onScrolled(hresult, vresult); // Invoke listeners last. Subclassed view methods always handle the event first. // All internal state is consistent by the time listeners are invoked. if (mScrollListener != null) &#123; mScrollListener.onScrolled(this, hresult, vresult); &#125; if (mScrollListeners != null) &#123; for (int i = mScrollListeners.size() - 1; i &gt;= 0; i--) &#123; mScrollListeners.get(i).onScrolled(this, hresult, vresult); &#125; &#125; mDispatchScrollCounter--;&#125; 会调用到 mScrollListener.onScrolled，也就是说可以与 ScrollListener 共同作用。这里先提一下，后面做详细说明。 12345678910111213141516171819public void smoothScrollBy(int dx, int dy, Interpolator interpolator) &#123; if (mLayout == null) &#123; Log.e(TAG, &quot;Cannot smooth scroll without a LayoutManager set. &quot; + &quot;Call setLayoutManager with a non-null argument.&quot;); return; &#125; if (mLayoutFrozen) &#123; return; &#125; if (!mLayout.canScrollHorizontally()) &#123; dx = 0; &#125; if (!mLayout.canScrollVertically()) &#123; dy = 0; &#125; if (dx != 0 || dy != 0) &#123; mViewFlinger.smoothScrollBy(dx, dy, interpolator); &#125;&#125; 最终调用的是 mViewFlinger.smoothScrollBy，mViewFlinger 是 RecyclerView 内部的一个 Runnable，通过不停执行 postOnAnimation 来实现平滑滑动。 scrollToPosition &amp; smoothScrollToPosition滑动到指定 position，也是可以直接或者平滑滑动。最后调用到的还是 LayoutManager 中的方法： 12345678public void scrollToPosition(int position) &#123; mPendingScrollPosition = position; mPendingScrollPositionOffset = INVALID_OFFSET; if (mPendingSavedState != null) &#123; mPendingSavedState.invalidateAnchor(); &#125; requestLayout();&#125; 改了属性直接 requestLayout。看下：smoothScrollToPosition 1234567public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) &#123; LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()); linearSmoothScroller.setTargetPosition(position); startSmoothScroll(linearSmoothScroller);&#125; 创建了一个 LinearSmoothScroller 来进行滑动，滑动也是调用的 RecyclerView 内部的 ViewFlinger 来实现的，它也会调用到 dispatchOnScrolled 方法，所以也可以与 ScrollListener 共用。 scrollToPositionWithOffset12345678public void scrollToPositionWithOffset(int position, int offset) &#123; mPendingScrollPosition = position; mPendingScrollPositionOffset = offset; if (mPendingSavedState != null) &#123; mPendingSavedState.invalidateAnchor(); &#125; requestLayout();&#125; 与 scrollToPosition 几无二致，只不过带上了 offset。当 offset &gt; 0，目标元素会距离顶部多出 offset 的距离，小于 0 则会被盖住 offset 的距离。注意：当 mPendingScrollPositionOffset 为 INVALID_OFFSET 时，滑动表现是 SNAP_TO_ANY，否则为 SNAP_TO_START，下面来具体说说。 LinearSmoothScroller SNAP1234567891011121314151617181920212223242526272829/** * Align child view&#x27;s left or top with parent view&#x27;s left or top * * @see #calculateDtToFit(int, int, int, int, int) * @see #calculateDxToMakeVisible(android.view.View, int) * @see #calculateDyToMakeVisible(android.view.View, int) */public static final int SNAP_TO_START = -1;/** * Align child view&#x27;s right or bottom with parent view&#x27;s right or bottom * * @see #calculateDtToFit(int, int, int, int, int) * @see #calculateDxToMakeVisible(android.view.View, int) * @see #calculateDyToMakeVisible(android.view.View, int) */public static final int SNAP_TO_END = 1;/** * &lt;p&gt;Decides if the child should be snapped from start or end, depending on where it * currently is in relation to its parent.&lt;/p&gt; * &lt;p&gt;For instance, if the view is virtually on the left of RecyclerView, using * &#123;@code SNAP_TO_ANY&#125; is the same as using &#123;@code SNAP_TO_START&#125;&lt;/p&gt; * * @see #calculateDtToFit(int, int, int, int, int) * @see #calculateDxToMakeVisible(android.view.View, int) * @see #calculateDyToMakeVisible(android.view.View, int) */public static final int SNAP_TO_ANY = 0; 根据注释很清晰了，SNAP_TO_START 为左上角对齐，SNAP_TO_END 为 右下角对齐，SNAP_TO_ANY 则是不限制，只要显示完对应 postion 的 Item 即可。举个栗子：当前有 10个 Item。 处于列表顶部，调用 scrollToPosition(5)，列表会从顶部定位到第 6 个 Item，且第 6 个 Item 位于屏幕最下方。 处于列表底部，调用 scrollToPosition(5)，列表会从底部定位到第 6 个 Item，且第 6 个 Item 位于屏幕最上方。 处于列表中部，第 6 个 Item 可见时调用 scrollToPosition(5)，界面不会发生任何改变。 这也就是网上众多文章吐槽 RecycleView 定位不准的原因了。因为默认是 SNAP_TO_ANY，RecycleView 处理起来就是让目标 position 的 Item 在列表中完全可见。如果目标是从底部滑上来，那么当目标完全可见时，滑动就会终止了，所以目标处理可见列表的最底端，反之亦然。当目标本身就是完全可见的，便不会做任何处理。所以，如若有定位目标必须处于列表顶端的需求，则可以这样： 12345678RecyclerView.SmoothScroller smoothScroller = new LinearSmoothScroller(context) &#123; @Override protected int getVerticalSnapPreference() &#123; return LinearSmoothScroller.SNAP_TO_START; &#125;&#125;;smoothScroller.setTargetPosition(position);layoutManager.startSmoothScroll(smoothScroller); 如果是底端则可以使用 SNAP_TO_END。 addOnScrollListener通常会有这种需求，监听 RecyclerView 滑动多少了，来改变标题栏的表现等需求。所以会有这样的代码： 12345678910111213private val onScrollListener = object : RecyclerView.OnScrollListener() &#123; // 滑动的距离 private var offsetY = 0 override fun onScrolled(recyclerView: RecyclerView?, dx: Int, dy: Int) &#123; super.onScrolled(recyclerView, dx, dy) offsetY += dy if (offsetY &gt; DimenUtils.dp2px(100F)) &#123; // do something &#125; &#125;&#125; 当滑动距离超过 100dp 则进行某些处理。上文有可以与 ScrollListener 共同作用这一说法，下面进行说明。当设置了 onScrollListener 了之后，现在假设每个 Item 高度为 100， 现在处于第 2个 Item，那么 offsetY 的值为 100。现在分别执行下面几个操作： scrollBy(200)：基于当前位置直接滑动 200 单位，会回调 onScrolled，dy 为 200，所以 offsetY 为 300，符合预期。 smoothScrollBy(200)：大体与 scrollBy 一直，只不过是平滑滑动，会多几个中间值，但最终结果是一样的。 scrollToPosition(3)：直接定位到 position 为 3 的位置，最终会调用 onScrolled（重新 layout 调用，而不是滑动操作调用），dy 为 0，offsetY 仍然为 100，即当前已经显示在第 4 个 Item 了，结果 offsetY 仍然为 100，这是有问题的。 smoothScrollToPosition(3)：会平滑定位到 position 为 3 的位置，与 smoothScrollBy 表现类似，最终结果与 1、2 一致。 scrollToPositionWithOffset(3)：与 3 表现一致，只不过允许 offset。 鉴于文章长度，没有粘贴测试代码及 Log，只是把现象描述出来，需要细心看看。综上所述：平滑滑动或相对滑动的方法可以与 onScrollListener 结合使用，scrollToPosition 和 scrollToPositionWithOffset 则不能与 onScrollListener 结合使用。 scrollToPositionWithOffset &amp; onScrollListener如上图，是一个文章详情页。 需要监听 onScrollListener 来改变标题栏。 文章是个列表，文章详情为一个 Item，每一条评论为一个 Item，新增一条评论时需要定位到这条评论。 标题栏覆盖在列表之上。 直接使用 smoothScrollToPosition 会导致标题栏覆盖一部分评论，所以需要加上偏移。可惜上文得出的结论 scrollToPositionWithOffset 与 onScrollListener 无法结合使用。所以如何处理呢？这里我保持 onScrollListener 不变，针对偏移采用曲线救国的方法：给详情 Item 添加一个 layout_marginBottom&#x3D;”-60dp”，给新增的一条评论添加 layout_marginBottom&#x3D;”60dp”，这样当使用 smoothScrollToPosition 定位到最新一条评论时，它距离顶部有 60 dp 的距离，如此便不会被覆盖了。这个想法与Android 滑动吸顶效果是一致的，发现这个做法还真挺有用，哈哈~","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android H5 与原生交互那点事","date":"2019-05-16T07:19:05.000Z","path":"2019/05/16/h5/","text":"鉴于 H5 丰富的表现力，产品决定将项目中的某个详情页改为 H5 展示，评论、点赞仍由原生实现，于是便需要原生与 H5 交互。之前对于这块少有涉及，恰巧合作的前端同事对于这块也不太熟悉，所以耗时良久。现在功能做得差不多了，稍微记录一下。 原生先看下 WebView 的设置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class VygWebView(context: Context, attr: AttributeSet) : BaseWebView(context, attr) &#123; private var callback: JSCallback? = null private var isDestroyed: Boolean = false init &#123; addJavascriptInterface(VygJavaScriptInterface(), &quot;voyagerApp&quot;) setWebContentsDebuggingEnabled(true) settings.allowFileAccess = true settings.allowFileAccessFromFileURLs = true settings.allowUniversalAccessFromFileURLs = true &#125; /** * 注册js回调监听器 */ fun registerJSCallback(callback: JSCallback) &#123; this.callback = callback &#125; /** * 将消息发送给 WebView 来处理 */ fun sendMessageToWeb(message: String) &#123; if (isDestroyed) &#123; return &#125; if (Config.isDebug()) &#123; LogUtils.e(&quot;MessageParser&quot;, &quot;sendMessageToWeb:$message&quot;) &#125; val function = &quot;javascript:window.receiveMessage($message)&quot; if (MainThreadUtils.isMainThread()) &#123; loadUrl(function) &#125; else &#123; MainThreadUtils.post(Runnable &#123; if (isDestroyed) &#123; return@Runnable &#125; loadUrl(function) &#125;) &#125; &#125; override fun destroy() &#123; super.destroy() isDestroyed = true callback = null &#125; inner class VygJavaScriptInterface &#123; @JavascriptInterface fun sendMessage(message: String) &#123; if (isDestroyed) &#123; return &#125; callback?.onReceiveWebMessage(message) &#125; &#125; interface JSCallback &#123; fun onReceiveWebMessage(message: String) &#125;&#125; 所有的交互全部通过 Json 字符串来进行，双端协定对 Json 的解析规则。本地通过添加 VygJavaScriptInterface 实现 sendMessage 方法，来接受 H5 传递过来的消息，通过 sendMessageToWeb 向 H5 发送消息。定义消息体如下： 12345678910111213141516171819202122232425262728class MessageEntity : Serializable &#123; /** * 消息id */ var id: String? = null /** * 消息类型 */ var type: String? = null /** * 版本号 */ var version: Int? = null /** * 消息内容 */ var content: Any? = null /** * 额外透传信息 */ var extraData: String? = null fun toJSONString(): String &#123; return JSON.toJSONString(this) &#125;&#125; 下面来看消息解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116abstract class MessageParser(private val activity: VygBaseActivity, private val webView: VygWebView, private val listener: MessageParser.MessageHandedListener?) : VygWebView.JSCallback &#123; private val TAG = &quot;MessageParser&quot; override fun onReceiveWebMessage(message: String) &#123; if (StringUtils.isEmpty(message)) &#123; return &#125; if (Config.isDebug()) &#123; LogUtils.e(TAG, message) &#125; parse(message) &#125; private fun parse(message: String) &#123; Config.execute &#123; try &#123; doParse(message) &#125; catch (t: Throwable) &#123; LogUtils.e(TAG, t.localizedMessage) &#125; &#125; &#125; /** * 这个json可能很大，放到异步去处理 */ @Throws(JSONException::class) private fun doParse(message: String) &#123; val obj = JSON.parseObject(message) val type = obj.getString(&quot;type&quot;) if (StringUtils.isEmpty(type)) &#123; return &#125; val version = try &#123; obj.getInteger(&quot;version&quot;) &#125; catch (t: Throwable) &#123; 1 &#125; val e = getEvents(type) if (e == null) &#123; MainThreadUtils.post(Runnable &#123; if (activity.hasDestroyed()) &#123; return@Runnable &#125; if (version != null &amp;&amp; version &gt; NATIVE_WEB_VERSION) &#123; // 提示更新 notifyUpdateApp() &#125; else &#123; // 什么也不做 &#125; &#125;) return &#125; val entity = MessageEntity() entity.type = type try &#123; entity.id = obj.getString(&quot;id&quot;) &#125; catch (t: Throwable) &#123; &#125; entity.version = version try &#123; entity.extraData = obj.getString(&quot;extraData&quot;) &#125; catch (t: Throwable) &#123; &#125; var content: String? = null try &#123; content = obj.getString(&quot;content&quot;) &#125; catch (t: Throwable) &#123; &#125; if (StringUtils.isEmpty(content) || e.clazz == null) &#123; entity.content = null &#125; else &#123; // Content 为字符串类型直接赋值 if (String::class.java.isAssignableFrom(e.clazz)) &#123; entity.content = content &#125; else &#123; try &#123; entity.content = JSON.parseObject(content, e.clazz) &#125; catch (t: Throwable) &#123; LogUtils.e(TAG, t.localizedMessage) &#125; &#125; &#125; if (activity.hasDestroyed()) &#123; return &#125; MainThreadUtils.post(Runnable &#123; if (activity.hasDestroyed()) &#123; return@Runnable &#125; MessageHandler(e, entity, activity, webView).handle() listener?.onMessageHanded(entity) &#125;) &#125; protected abstract fun getEvents(type: String): Events? /** * 提示更新app */ private fun notifyUpdateApp() &#123; &#125; interface MessageHandedListener &#123; fun onMessageHanded(message: MessageEntity) &#125;&#125; getEvents 为根据消息 type 来取得具体的消息体 Content 类型及处理消息的类： 12345678910111213public final class Events &#123; public final String eventName; public final Class&lt;?&gt; clazz; public final Class&lt;? extends MessageHandler.HandleCallback&gt; callback; public Events(String name, Class&lt;?&gt; clazz, Class&lt;? extends MessageHandler.HandleCallback&gt; callback) &#123; this.eventName = name; this.clazz = clazz; this.callback = callback; &#125;&#125; 看到消息处理类： 12345678910111213141516class MessageHandler(private val events: Events, private val entity: MessageEntity, private val activity: VygBaseActivity, private val webView: VygWebView) &#123; private val TAG = &quot;MessageHandler&quot; fun handle() &#123; try &#123; events.callback?.newInstance()?.handleMessage(entity, entity.content, activity, webView) &#125; catch (t: Throwable) &#123; LogUtils.e(TAG, t.localizedMessage) &#125; &#125; interface HandleCallback &#123; fun handleMessage(entity: MessageEntity, obj: Any?, activity: VygBaseActivity, webView: VygWebView) &#125;&#125; 举例一个具体的消息处理类： 1234567891011121314151617181920212223242526272829class LoadImageHandler : MessageHandler.HandleCallback &#123; private val TAG = &quot;LoadImageHandler&quot; override fun handleMessage(entity: MessageEntity, obj: Any?, activity: VygBaseActivity, webView: VygWebView) &#123; if (obj != null &amp;&amp; obj is LoadImageEntity) &#123; if (UriUtils.isNetUrl(obj.url)) &#123; AsImage.downloadFile(obj.url).loadListener(object : ImageLoadListener&lt;File&gt; &#123; override fun onLoadingStarted(imageUri: String?, view: View?) &#123; LogUtils.e(TAG, &quot;onLoadingStarted:$imageUri&quot;) &#125; override fun onLoadingFailed(imageUri: String?, view: View?, t: Throwable?): Boolean &#123; LogUtils.e(TAG, &quot;onLoadingFailed:$imageUri&quot;) return true &#125; override fun onLoadingComplete(imageUri: String?, view: View?, loaded: File?): Boolean &#123; loaded?.let &#123; obj.uri = &quot;file://&quot; + it.absolutePath webView.sendMessageToWeb(entity.toJSONString()) &#125; return true &#125; &#125;).download() &#125; &#125; &#125;&#125; 根据修改页面的业务，定义所有的 Event： 123456789101112131415161718192021222324252627282930object ArticleEvents &#123; private val events = HashMap&lt;String, Events&gt;() operator fun get(eventName: String): Events? &#123; return events[eventName] &#125; init &#123; events[HTML_FINISH_LOAD] = Events(HTML_FINISH_LOAD, null, HtmlFinishLoadHandler::class.java) events[CONTENT_FINISH_LOAD] = Events(CONTENT_FINISH_LOAD, null, ContentFinishLoadHandler::class.java) events[PROTOCOL] = Events(PROTOCOL, String::class.java, ProtocolHandler::class.java) events[PLAY_VIDEO] = Events(PLAY_VIDEO, String::class.java, PlayVideoHandler::class.java) events[IMAGE_BROWSE] = Events(IMAGE_BROWSE, String::class.java, ImageBrowseHandler::class.java) events[LOAD_IMAGE] = Events(LOAD_IMAGE, LoadImageEntity::class.java, LoadImageHandler::class.java) &#125; object EventName &#123; const val HTML_FINISH_LOAD = &quot;htmlFinishLoad&quot; // H5 加载完 const val LOAD_ARTICLE_CONTENT = &quot;articleContent&quot; // 发送 Content 给 H5 填充 const val CONTENT_FINISH_LOAD = &quot;contentFinishLoad&quot; // Content 加载完 const val UPDATE_COMMENT_COUNT = &quot;updateCommentCount&quot; // 更新回复数 const val PROTOCOL = &quot;ProtocolPageJump&quot; // 协议 const val PLAY_VIDEO = &quot;playVideo&quot; // 播放视频 const val IMAGE_BROWSE = &quot;imgBrowse&quot; // 大图浏览 const val LOAD_IMAGE = &quot;loadImg&quot; // 加载图片 &#125;&#125; 消息解析这一套流程便完成了，根据 type 找到对应的消息处理类，然后传入 Content 进行处理。 H5H5 除了界面渲染之外，还需要根据约定实现相关的方法： 1234567891011121314151617getNativeData: function() &#123; var me = this; window.receiveMessage = function(data) &#123; var type = data.type; var content = data.content; if (type == &#x27;articleContent&#x27;) &#123; me.handleArticleData(content); &#125; else if (type == &#x27;loadImg&#x27;) &#123; me.handleImgData(content); &#125; else if (type == &#x27;updateCommentCount&#x27;) &#123; me.handleReplyCount(content); &#125;else if(type == &#x27;changeOffset&#x27;)&#123; me.handleUploadImg(content) &#125; &#125;&#125; 然后调用原生方法时，也是组装好 Message，然后调用 sendMessage 方法即可： 123456789// 个人中心$(&#x27;[data-type=&quot;user&quot;]&#x27;).click(function() &#123; var uid = $(this).attr(&#x27;data-uid&#x27;); var wxToken = $(this).attr(&#x27;data-wxToken&#x27;); var link = `https://voyager.nav.cn/user/homePage?id=$&#123;uid&#125;&amp;wxToken=$&#123;wxToken&#125;`; var params = JSON.stringify(&#123; id: 1, type: &#x27;ProtocolPageJump&#x27;, content: link &#125;); voyagerApp.sendMessage(params);&#125;) 至此两端的交互体系大体完成。 小坑 最好使用本地 html 文件来完成交互，可以比较方便的加载本地图片，前缀加上”file:&#x2F;&#x2F;“，同时 WebView 需要设置（具体效用尚未研究）：123settings.allowFileAccess = truesettings.allowFileAccessFromFileURLs = truesettings.allowUniversalAccessFromFileURLs = true H5 调用本地方法需要 voyager.sendMessage，iOS 则是 voyager_sendMessage。 参考 Android：最全面的 Webview 详解 Android：你要的WebView与 JS 交互方式 都在这里了 Android：你不知道的 WebView 使用漏洞","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 获取手机媒体数据那些事","date":"2019-05-09T11:06:56.000Z","path":"2019/05/09/media/","text":"在上一篇文章 ViewModel + LiveData 初探 中的场景中，有获取手机媒体数据的操作，界面上也要展示横竖屏，展示规则很简单：宽度不小于高度则定义为横屏，否则未竖屏。在我的小米 MIX2 上，不论手机如何拍照，返回的分辨率都是 4000:3000（根据相机设置中的画幅比例），不论你是横着拍还是竖着拍。所以当拿到 4000:3000 后就全部定义成横屏了，与实际不符。所以着手解决了一下，顺便整理下获取手机媒体数据的相关代码，方便日后使用。整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195object MediaDataUtils &#123; private const val TAG = &quot;MediaDataUtils&quot; private val QUERY_URI = MediaStore.Files.getContentUri(&quot;external&quot;) //=============================== 查询系统相册中的视频、图片 ================================ private const val ORDER_BY = MediaStore.MediaColumns.DATE_MODIFIED + &quot; DESC&quot; private const val SELECTION_MEDIA_TYPE_WITHOUT_FOLDER = ( MediaStore.Files.FileColumns.MEDIA_TYPE + &quot;=?&quot; + &quot; AND &quot; + MediaStore.MediaColumns.SIZE + &quot;&gt;0&quot;) private const val SELECTION_MEDIA_TYPE_WITH_FOLDER = ( MediaStore.Files.FileColumns.MEDIA_TYPE + &quot;=?&quot; + &quot; AND &quot; + &quot; bucket_id=?&quot; + &quot; AND &quot; + MediaStore.MediaColumns.SIZE + &quot;&gt;0&quot;) private val PROJECTION = arrayOf( MediaStore.MediaColumns._ID, MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DATE_MODIFIED, MediaStore.MediaColumns.SIZE, MediaStore.MediaColumns.WIDTH, MediaStore.MediaColumns.HEIGHT, &quot;duration&quot;) //=============================== 查询系统文件夹 ================================== private const val SELECTION_MEDIA_TYPE_FOLDER = ( MediaStore.Files.FileColumns.MEDIA_TYPE + &quot;=?&quot; + &quot; AND &quot; + MediaStore.MediaColumns.SIZE + &quot;&gt;0&quot; + &quot;) GROUP BY (bucket_id&quot;) private const val BUCKET_ORDER_BY = &quot;datetaken DESC&quot; private val FOLDER_PROJECTION = arrayOf( MediaStore.Files.FileColumns._ID, &quot;bucket_id&quot;, &quot;bucket_display_name&quot;, MediaStore.MediaColumns.DATA, &quot;COUNT(*) AS $COLUMN_COUNT&quot;) /** * 获取具体文件 */ @WorkerThread @JvmStatic fun getMediaData(isVideo: Boolean, folderItem: FolderItem? = null): List&lt;MediaDataItem&gt;? &#123; if (!PermissionUtils.checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; return null &#125; val data = mutableListOf&lt;MediaDataItem&gt;() val pair = getQueryArgs(false, isVideo, folderItem) val cursor = MucangConfig.getContext().contentResolver.query( QUERY_URI, PROJECTION, pair.first, pair.second, ORDER_BY) if (cursor != null) &#123; try &#123; if (cursor.moveToFirst()) &#123; val nameIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DISPLAY_NAME) val pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA) val modifyIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATE_MODIFIED) val sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE) val widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH) val heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT) val durationIndex = cursor.getColumnIndex(&quot;duration&quot;) do &#123; val file = MediaDataItem() file.isVideo = isVideo file.name = cursor.getString(nameIndex) file.path = cursor.getString(pathIndex) file.date = cursor.getLong(modifyIndex) file.size = cursor.getLong(sizeIndex) file.width = cursor.getInt(widthIndex) file.height = cursor.getInt(heightIndex) if (isVideo) &#123; if (file.width == 0 || file.height == 0) &#123; val widthHeight = readVideoPixel(file.path) if (widthHeight != null) &#123; file.width = widthHeight.first file.height = widthHeight.second &#125; &#125; &#125; else &#123; val widthHeight = readImagePixel(file.path) if (widthHeight != null) &#123; file.width = widthHeight.first file.height = widthHeight.second &#125; &#125; if (durationIndex &gt; -1) &#123; file.duration = (cursor.getLong(durationIndex) / 1000F + 0.5).toLong() &#125; data.add(file) &#125; while (cursor.moveToNext()) &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; cursor.close() &#125; &#125; return data &#125; /** * 获取文件夹 */ @WorkerThread @JvmStatic fun getFolderData(isVideo: Boolean): List&lt;FolderItem&gt;? &#123; if (!PermissionUtils.checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; return null &#125; val data = mutableListOf&lt;FolderItem&gt;() val pair = getQueryArgs(true, isVideo) val cursor = MucangConfig.getContext().contentResolver.query( QUERY_URI, FOLDER_PROJECTION, pair.first, pair.second, BUCKET_ORDER_BY) if (cursor != null) &#123; try &#123; if (cursor.moveToFirst()) &#123; // 全部文件夹 val allFolder = FolderItem() allFolder.id = ALL_FOLDER_ID if (isVideo) &#123; allFolder.name = &quot;全部视频&quot; &#125; else &#123; allFolder.name = &quot;全部照片&quot; &#125; allFolder.selected = true data.add(allFolder) var count = 0 val idIndex = cursor.getColumnIndex(&quot;bucket_id&quot;) val pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA) val nameIndex = cursor.getColumnIndex(&quot;bucket_display_name&quot;) val countIndex = cursor.getColumnIndex(AlbumLoader.COLUMN_COUNT) do &#123; val folder = FolderItem() folder.id = cursor.getString(idIndex) folder.path = cursor.getString(pathIndex) folder.name = cursor.getString(nameIndex) folder.count = cursor.getInt(countIndex) data.add(folder) count += folder.count if (StringUtils.isEmpty(allFolder.path)) &#123; allFolder.path = folder.path &#125; &#125; while (cursor.moveToNext()) data.first().count = count &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.toString()) &#125; finally &#123; cursor.close() &#125; &#125; return data &#125; /** * getMediaData 时调用，根据是否视频、是否查询文件夹返回查询参数 * * @return Pair：first-&gt;selection，second-&gt;args */ private fun getQueryArgs(isQueryFolder: Boolean, isVideo: Boolean, folderItem: FolderItem? = null): Pair&lt;String, Array&lt;String&gt;&gt; &#123; if (isQueryFolder) &#123; return if (isVideo) &#123; Pair(SELECTION_MEDIA_TYPE_FOLDER, arrayOf(MEDIA_TYPE_VIDEO.toString())) &#125; else &#123; Pair(SELECTION_MEDIA_TYPE_FOLDER, arrayOf(MEDIA_TYPE_IMAGE.toString())) &#125; &#125; if (folderItem?.id != null &amp;&amp; !folderItem.isAll()) &#123; return if (isVideo) &#123; Pair(SELECTION_MEDIA_TYPE_WITH_FOLDER, arrayOf(MEDIA_TYPE_VIDEO.toString(), folderItem.id!!)) &#125; else &#123; Pair(SELECTION_MEDIA_TYPE_WITH_FOLDER, arrayOf(MEDIA_TYPE_IMAGE.toString(), folderItem.id!!)) &#125; &#125; return if (isVideo) &#123; Pair(SELECTION_MEDIA_TYPE_WITHOUT_FOLDER, arrayOf(MEDIA_TYPE_VIDEO.toString())) &#125; else &#123; Pair(SELECTION_MEDIA_TYPE_WITHOUT_FOLDER, arrayOf(MEDIA_TYPE_IMAGE.toString())) &#125; &#125;&#125; 利用我的小米 MIX2 使用 18:9 画幅比例竖屏拍摄的一张照片，在我的 Rom 里显示的是 4000:2000，将这张照片放到同事的华为手机里，显示的分辨率则是另外一个数，但是华为 Rom 里获取的高宽比例是一致的，宽：高 &#x3D; 1 : 2，所以在我的手机里识别成横屏照片，在华为手机里识别为竖屏照片。所以仅仅使用 MediaStore.MediaColumns.WIDTH、MediaStore.MediaColumns.HEIGHT 获取的宽高是不准确的，需要一个更好的方案： 1234567891011121314151617181920212223242526272829303132/** * 读取图片的宽高信息，系统多媒体数据库保存的宽高信息是通过读取图片 ExifInterface 数据 * 某些手机拍照生成的 exif 数据不准，此处使用 BitmapDecode 的方式获取，经测试耗时可忽略不计 */@JvmStaticprivate fun readImagePixel(filePath: String?): Pair&lt;Int, Int&gt;? &#123; if (!FileUtils.exists(filePath)) &#123; return null &#125; try &#123; val options = BitmapFactory.Options() options.inJustDecodeBounds = true BitmapFactory.decodeFile(filePath, options) val width = options.outWidth val height = options.outHeight if (width &gt; 0 &amp;&amp; height &gt; 0) &#123; val exifInterface = ExifInterface(filePath) val orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL) // 如果图片的旋转角度为 90 或者 270，则宽高互换 if (orientation == ExifInterface.ORIENTATION_ROTATE_90 || orientation == ExifInterface.ORIENTATION_ROTATE_270) &#123; return Pair(height, width) &#125; return Pair(width, height) &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.message) &#125; return null&#125; 当照片数量很多（我的手机 2200+ 张照片）时，遍历完耗时大概在 3 ~ 4 秒，在接受范围内吧。另外对于小米 MIX2 拍摄的视频数据，获取的宽高会是 0，所以也需要一种方案获取比例： 12345678910111213141516171819202122232425262728293031323334/** * 读取视频的宽高数据 * 需要根据拍摄方向进行转换，有点耗时平均五六十毫秒 */@JvmStaticprivate fun readVideoPixel(filePath: String?): Pair&lt;Int, Int&gt;? &#123; if (!FileUtils.exists(filePath)) &#123; return null &#125; val mmr = MediaMetadataRetriever() try &#123; mmr.setDataSource(filePath) val width = mmr.extractMetadata(android.media.MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)?.toInt() ?: 0 val height = mmr.extractMetadata(android.media.MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)?.toInt() ?: 0 val orientation = mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION).toInt() if (width &gt; 0 &amp;&amp; height &gt; 0) &#123; if (orientation == 90 || orientation == 270) &#123; return Pair(height, width) &#125; return Pair(width, height) &#125; &#125; catch (e: Exception) &#123; LogUtils.e(TAG, e.message) &#125; finally &#123; try &#123; mmr.release() &#125; catch (e: Throwable) &#123; LogUtils.e(TAG, e.message) &#125; &#125; return null&#125; 视频数量一般比较少，耗时问题暂时可以不考虑。使用此种方案后，照片、视频的横竖问题基本准确。Over~ 题外话当手机视频、照片数量特别多了之后，一次加载全部就耗时有些久了，手机里 50 多个视频耗时 2 秒多，2000 多张照片耗时 5 秒左右，所以需要调整成为分页加载。利用 limit + offset 来实现： 1val order = ORDER_BY + &quot; limit &quot; + PAGE_SIZE + &quot; offset &quot; + (page - 1) * PAGE_SIZE 有了分页就可能出现重复数据了（第一页加载完后，又拍了 2 张照片，下一页加载的数据会有 2 条重复），所以要注意去重。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"ViewModel + LiveData 初探","date":"2019-04-24T09:29:38.000Z","path":"2019/04/24/jetpack/","text":"Google 已经推出 Lifecycle、ViewModel、LiveData 等一系列架构组件已经很久了，但是自己一直没尝试使用，仅仅就是了解一点点，没有紧跟技术潮流持续学习，说来十分羞愧了。最近接到一个需求，界面如下： 突发奇想：ViewModel 可以在一个界面共享数据，感觉是做这个需求的不二选择呀，于是乎便开始使用了。 添加依赖1implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot; sync 之后报错： 1Android dependency &#x27;android.arch.lifecycle:runtime&#x27; has different version for the compile (1.0.3) and runtime (1.1.1) classpath. You should manually set the same version via DependencyResolution 查看依赖，发现 support 库有依赖 runtime:1.0.3： 1234| | +--- com.android.support:support-v4:27.0.2| | | +--- com.android.support:support-compat:27.0.2| | | | +--- com.android.support:support-annotations:27.0.2| | | | \\--- android.arch.lifecycle:runtime:1.0.3 所以如果要使用 1.1.1 的 extensions 则需要将 runtime:1.0.3 升到 1.1.1，如果降版本使用低版本的 extensions 也是可以的，但是就无法使用最新的特性以及问题修复了。这里说下强升的几个方法： 根 build.gradle 添加：12345678910allprojects &#123; ... configurations &#123; all &#123; resolutionStrategy &#123; force &quot;android.arch.lifecycle:runtime:1.1.1&quot; &#125; &#125; &#125;&#125; exclude support 的依赖：12345implementation (&#x27;com.android.support:appcompat-v7:27.1.1&#x27;) &#123; exclude group: &#x27;android.arch.lifecycle&#x27;&#125;api &quot;android.arch.lifecycle:runtime:1.1.1&quot; implementation 改成 api：1api &quot;android.arch.lifecycle:extensions:1.1.1&quot; 注意：需要注意 runtime:1.1.1 不会与 support-v4:27.0.2 产生冲突。网上没看到有人说会不兼容，所以姑且先忽略。 Android Architecture Components: Gradle sync error for dependency version 实践注意到设计稿里，拆分一下页面结构： 顶部状态栏，可以切换视频文件夹、照片文件夹 ViewPager 切换视频或者照片 第 x 段 RecyclerView 这里可以分为三个 Fragment，主页面一个，视频、照片各位一个，所以需要在三个 Fragment 里共享数据，方便操作。这里主页面 Fragment 称为 MainFragment，素材 Fragemnt 称为 MaterialFragent。参照官网的例子，写出的 ViewModel 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MaterialViewModel : ViewModel() &#123; // 视频数据 val videoData: MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getMediaData(true)) &#125; &#125; &#125; // 视频文件夹 val videoFolder: MutableLiveData&lt;List&lt;FolderItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;FolderItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getFolderData(true)) &#125; &#125; &#125; // 照片数据 val pictureData: MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;MediaDataItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getMediaData(false)) &#125; &#125; &#125; // 照片文件夹 val pictureFolder: MutableLiveData&lt;List&lt;FolderItem&gt;&gt; by lazy &#123; MutableLiveData&lt;List&lt;FolderItem&gt;&gt;().also &#123; MucangConfig.execute &#123; it.postValue(MediaDataUtils.getFolderData(false)) &#125; &#125; &#125; /** * 获取文件夹下的视频 */ fun getFolderVideo(folderItem: FolderItem) &#123; MucangConfig.execute &#123; videoData.postValue(MediaDataUtils.getMediaData(true, folderItem)) &#125; &#125; /** * 获取文件夹下的照片 */ fun getFolderPicture(folderItem: FolderItem) &#123; MucangConfig.execute &#123; pictureData.postValue(MediaDataUtils.getMediaData(false, folderItem)) &#125; &#125;&#125; 在 MaterialFragent 里需要监听素材数据的改变，来填充列表： 123456789101112private fun initViewModel() &#123; // 因为要同页面共享数据，所以需要传 activity viewModel = ViewModelProviders.of(activity!!).get(MaterialViewModel::class.java) if (isVideo) &#123; viewModel.videoData &#125; else &#123; viewModel.pictureData &#125;.observe(this, Observer&lt;List&lt;MediaDataItem&gt;&gt; &#123; // 给 RecyclerView 的 adapter 设置数据 setData(it) &#125;)&#125; 根据是否是视频，来选择不同的 LiveData 来监听。注意到有几个操作： 底部的 Rv 默认选中第一个 Item，Item 可以点击切换选择状态。当前选择的 Item 可以匹配一个素材（视频或照片） 素材列表右上角的选择点击之后，则将素材与底部 Rv 当前选中的 Item 进行匹配，并且选中的素材下面出现红色条，代表当前素材已匹配到某一个 Item，若当前 Item 已匹配过素材，则进行替换，所以如果匹配过，则需要将旧的素材下面的红色条置为 GONE。同时 Rv 切换到下一个可选择素材的 Item（没有匹配过素材的 Item），最直观的感受就是绿色边框的切换。 当底部 Rv 所有素材全部匹配完之后，下面的选择完成按钮变成可点击。 针对以上几点，又新增了几个 LiveData： 1234567891011121314// 当前给哪个 Item 选择素材lateinit var currentSegment: Segment/** * 同一个 Item 有重复选择视频或者照片，需要记录上一次选择的位置，用于更新界面取消选中 * * Pair：first-&gt;上一次选择的是否是视频，second-&gt;上一次选中的位置 */val changePos: MutableLiveData&lt;Pair&lt;Boolean, Int&gt;&gt; = MutableLiveData()/** * 当前的 Item 选择素材之后，需要更新背景图 */var currentPos: MutableLiveData&lt;Int&gt; = MutableLiveData() 在匹配一个 Item 之后，ViewModel 更新数据： 12345678910111213141516171819202122232425/** * 填充模板 Item 选择的素材 */fun fillSegment(mediaDataItem: MediaDataItem) &#123; if (mediaDataItem == currentSegment.mediaDataItem) &#123; return &#125; if (currentSegment.mediaDataItem == null) &#123; currentSegment.mediaDataItem = mediaDataItem changePos.value = Pair(true, -1) &#125; else &#123; val currentMedia = currentSegment.mediaDataItem!! currentMedia.selected = false val index = if (currentMedia.isVideo) &#123; videoData.value?.indexOf(currentMedia) &#125; else &#123; pictureData.value?.indexOf(currentMedia) &#125; currentSegment.mediaDataItem = mediaDataItem changePos.value = Pair(currentMedia.isVideo, index ?: -1) &#125; currentPos.value = templateData.value?.video?.segments?.indexOf(currentSegment)&#125; 在 MainFragment 里监听 currentPos 数据的变化： 1234567891011121314viewModel.currentPos.observe(this, Observer &#123; if (it != null &amp;&amp; it &gt; -1) &#123; val index = (segmentRv.adapter as SegmentAdapter).cycleValidIndex(it) // 没有未完成的 Segment 时可点击完成 if (index == -1) &#123; chooseCompleteTv.alpha = 1F chooseCompleteTv.isClickable = true &#125; else &#123; segmentRv.smoothScrollToPosition(index) chooseCompleteTv.alpha = 0.3F chooseCompleteTv.isClickable = false &#125; &#125;&#125;) SegmentAdapter 的方法 cycleValidIndex 自动循环下一个需要匹配素材的的 Item，当返回 -1 时代表所有 Item 都已经匹配素材，这时可以针对单一 Item 进行素材调整，不用做 index 自动循环了。 1234567891011121314151617181920212223242526272829303132333435363738/** * 当前选中的 index，自动切换到下一个可用的 index */fun cycleValidIndex(pos: Int): Int &#123; var nextIndex = -1 run findIndex@&#123; val index = pos + 1 if (index &lt; dataList.lastIndex) &#123; for (i in index until dataList.size) &#123; if (dataList[i].mediaDataItem == null) &#123; nextIndex = i return@findIndex &#125; &#125; for (i in 0 until index) &#123; if (dataList[i].mediaDataItem == null) &#123; nextIndex = i return@findIndex &#125; &#125; &#125; else &#123; for (i in 0 until dataList.size) &#123; if (dataList[i].mediaDataItem == null) &#123; nextIndex = i return@findIndex &#125; &#125; &#125; &#125; if (nextIndex == -1) &#123; notifyItemChanged(pos) &#125; // 切换选择状态 chooseSegment(nextIndex) return nextIndex&#125; 在 MaterialFragment 监听上一个需要取消红色条的 LiveData： 12345viewModel.changePos.observe(this, Observer &#123; if (it != null &amp;&amp; it.first == isVideo &amp;&amp; it.second &gt; -1) &#123; materialRv.adapter?.notifyItemChanged(it.second) &#125;&#125;) ok，实践就说到这里，基本实现需求了。 ViewModel 原理ViewModel 不会随着 Activity 的屏幕旋转而销毁，减少了维护状态的代码成本。另外，它可以在多个 Fragment 维护相同的数据，极大的减少了组件之间数据传递的代码成本。那么它是如何实现的呢？在说原理之前，需要了解一个知识点： setRetainInstance(boolean) 是 Fragment 中的一个方法。将这个方法设置为 true 就可以使当前 Fragment 在 Activity 重建时存活下来。 现在相信已经对原理的实现有自己的思路了：让 Activity 持有一个不可见的 Fragment(HolderFragment)，并让这个 HolderFragment 调用 setRetainInstance(boolean) 方法并持有 ViewModel ——这样当 Activity 因为屏幕的旋转销毁并重建时，该 Fragment 存储的 ViewModel 自然不会被随之销毁回收了。另外一个 Fragment 或者 Activity 是有可能持有多个 ViewModel 的，所以内部需要一个 HashMap 进行存储所有的 ViewModel。 123456789101112131415161718192021@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public class HolderFragment extends Fragment implements ViewModelStoreOwner &#123; private ViewModelStore mViewModelStore = new ViewModelStore(); public HolderFragment() &#123; setRetainInstance(true); &#125;&#125;public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125;&#125; 看到相应的代码，是不是一目了然？然后看到 ViewModel 只会有一个实例的代码： 1234567891011121314151617181920@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 如果 mViewModelStore 里存有 ViewModel 实例则直接返回，没有则进行 create，然后 put 到 mViewModelStore 中，很直截了当了。 总结篇幅所限，关于 LiveData 这里就不写了，核心原理是 LifeCycleOwner，这个网上的相关文章也挺多的。 参考： ViewModel OverView LiveData Overview Android官方架构组件ViewModel:从前世今生到追本溯源 Android Architecture Component之LiveData原理解析","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"CoordinatorLayout 滑动再探","date":"2019-04-16T06:11:55.000Z","path":"2019/04/16/coordinator-1/","text":"嗯，还是之前的路线详情的页面，新增了需求，导致界面结构又发生变化了。添加了一个途经点的列表，与打点列表并列，可以和横向滑动切换 Tab。之前写过一篇文章CoordinatorLayout + RecyclerView 处理滑动说的也是这个页面，这里再贴一下当前的 xml 布局： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/vyg__route_detail_map_action&quot;/&gt; &lt;cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout android:id=&quot;@+id/unFullScreenRoot&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;50dp&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/barLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;330dp&quot; android:background=&quot;@color/vyg__transparent&quot; app:elevation=&quot;0dp&quot;&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_scrollFlags=&quot;scroll&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;cn.mucang.android.ui.widget.xrecyclerview.SafeRecyclerView android:id=&quot;@+id/detailRv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt; &lt;/cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout&gt; &lt;include layout=&quot;@layout/vyg__route_detail_fullscreen&quot;/&gt; &lt;include layout=&quot;@layout/vyg__route_detail_title&quot;/&gt; &lt;include layout=&quot;@layout/vyg__route_detail_bottom&quot;/&gt;&lt;/RelativeLayout&gt; 基于这个布局，为了实现新增需求，改成了如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/vyg__route_detail_map_action&quot;/&gt; &lt;cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout android:id=&quot;@+id/unFullScreenRoot&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;50dp&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/barLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/vyg__transparent&quot; app:elevation=&quot;0dp&quot;&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;330dp&quot; app:layout_scrollFlags=&quot;scroll&quot;/&gt; &lt;android.support.v4.widget.NestedScrollView android:id=&quot;@+id/headerContainer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_scrollFlags=&quot;scroll&quot;/&gt; &lt;cn.mucang.android.voyager.lib.framework.tab.CustomTabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;65dp&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.SafeViewPager android:id=&quot;@+id/viewPager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt; &lt;/cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout&gt; &lt;include layout=&quot;@layout/vyg__route_detail_fullscreen&quot;/&gt; &lt;include layout=&quot;@layout/vyg__route_detail_title&quot;/&gt; &lt;include layout=&quot;@layout/vyg__route_detail_bottom&quot;/&gt;&lt;/RelativeLayout&gt; 将旧布局中的路线详情 Header 单独抽出个布局，添加到 headerContainer 中。这里使用 NestedScrollView 进行包裹是因为 MyCoordinatorLayout 拦截了 onTouchEvent 始终返回 false，MyCoordinatorLayout 就只能处理自身实现了 NestedScrollingChild2 的 View 了，tabLayout 则是 Tab 栏。嗯，这样功能是能实现了，但是在这界面进行滑动的时候，总会感觉不流畅，而且在快速滑动的时候，还容易反弹。这是很好理解的，因为 MyCoordinatorLayout 重写 onTouchEvent 并且始终返回 false，可能就会导致事件的传递有问题，造成这种滑动不顺的感觉。那如果不使用 MyCoordinatorLayout，地图上按钮的点击事件如何传递下去呢？这就得想另外一个法子了。CoordinatorLayout 本身是一个增强型的 FrameLayout，增加了嵌套滑动的处理。所以另一种方式的布局就出来了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_above=&quot;@+id/bottomActionLl&quot;&gt; &lt;include layout=&quot;@layout/vyg__route_detail_map_action&quot;/&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout android:id=&quot;@+id/barLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/vyg__transparent&quot; app:elevation=&quot;0dp&quot; app:layout_behavior=&quot;cn.mucang.android.voyager.lib.framework.widget.SnapAppBarLayoutBehavior&quot;&gt; &lt;View android:id=&quot;@+id/mapFakeView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;330dp&quot; app:layout_scrollFlags=&quot;scroll&quot;/&gt; &lt;LinearLayout android:id=&quot;@+id/headerContainer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:clickable=&quot;true&quot; android:orientation=&quot;vertical&quot; app:layout_scrollFlags=&quot;scroll&quot;/&gt; &lt;cn.mucang.android.voyager.lib.framework.tab.CustomTabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;65dp&quot;/&gt; &lt;/cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.SafeViewPager android:id=&quot;@+id/viewPager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;include layout=&quot;@layout/vyg__route_detail_fullscreen&quot;/&gt; &lt;include layout=&quot;@layout/vyg__route_detail_title&quot;/&gt; &lt;include layout=&quot;@layout/vyg__route_detail_bottom&quot;/&gt;&lt;/RelativeLayout&gt; 将地图布局直接被 CoordinatorLayout 包裹，弃用 MyCoordinatorLayout。当页面处于非全屏时，设置 mapFakeView 的 isClickable 为 false。那么 AppBarLayout 便不会消费地图上按钮的点击事件，事件就会传递到地图那一层进行处理了。在使用 CoordinatorLayout + AppBarLayout 时，会有一些滑动抖动的问题，和 AppBarLayout 无法拖动的问题，这些在网上都有案例。所以会有自定义的 AppBarLayout、Behavior： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * 解决 AppBarLayout 滑动抖动问题 */public class SnapAppBarLayoutBehavior extends AppBarLayout.Behavior &#123; private boolean isNestedFlinging = true; private boolean isFlinging; private boolean shouldBlockNestedScroll; public SnapAppBarLayoutBehavior() &#123; &#125; public SnapAppBarLayoutBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull AppBarLayout child, @NonNull View target, float velocityX, float velocityY) &#123; return false; &#125; @Override public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, AppBarLayout abl, View target, int type) &#123; if (!isNestedFlinging) &#123; super.onStopNestedScroll(coordinatorLayout, abl, target, ViewCompat.TYPE_NON_TOUCH); &#125; else &#123; if (type == ViewCompat.TYPE_TOUCH) &#123; super.onStopNestedScroll(coordinatorLayout, abl, target, ViewCompat.TYPE_NON_TOUCH); &#125; else &#123; super.onStopNestedScroll(coordinatorLayout, abl, target, ViewCompat.TYPE_TOUCH); &#125; &#125; isFlinging = false; shouldBlockNestedScroll = false; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, int dx, int dy, int[] consumed, int type) &#123; if (type == ViewCompat.TYPE_TOUCH) &#123; isNestedFlinging = false; &#125; if (type == ViewCompat.TYPE_NON_TOUCH) &#123; isFlinging = true; &#125; if (!shouldBlockNestedScroll) &#123; super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type); &#125; &#125; @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type) &#123; if (!shouldBlockNestedScroll) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, type); &#125; &#125; @Override public boolean onNestedFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull AppBarLayout child, @NonNull View target, float velocityX, float velocityY, boolean consumed) &#123; isNestedFlinging = true; return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed); &#125; @Override public boolean onInterceptTouchEvent(CoordinatorLayout parent, AppBarLayout child, MotionEvent ev) &#123; shouldBlockNestedScroll = false; if (isFlinging) &#123; shouldBlockNestedScroll = true; &#125; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; Object scroller = getSuperSuperField(this, &quot;mScroller&quot;); if (scroller != null &amp;&amp; scroller instanceof OverScroller) &#123; OverScroller overScroller = (OverScroller) scroller; overScroller.abortAnimation(); &#125; &#125; return super.onInterceptTouchEvent(parent, child, ev); &#125; private Object getSuperSuperField(Object paramClass, String paramString) &#123; Field field = null; Object object = null; try &#123; field = paramClass.getClass().getSuperclass().getSuperclass().getDeclaredField(paramString); field.setAccessible(true); object = field.get(paramClass); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125;/** * 解决 AppBarLayout 无法滚动的问题 */ class NestAppBarLayout : AppBarLayout &#123; constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet) : super(context, attrs) override fun onAttachedToWindow() &#123; super.onAttachedToWindow() compactAppbarNestScroll() &#125; private fun compactAppbarNestScroll() &#123; try &#123; ((this.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior as? AppBarLayout.Behavior) ?.setDragCallback(object : AppBarLayout.Behavior.DragCallback() &#123; override fun canDrag(appBarLayout: AppBarLayout): Boolean &#123; return true &#125; &#125;) &#125; catch (e: Exception) &#123; LogUtils.d(&quot;NestAppBarLayout&quot;, e.message) &#125; &#125;&#125; 但是仍然有一个问题：当点击地图全屏按钮时，隐藏 barLayout 与 viewPager，只剩下 CoordinatorLayout 包裹一层地图。这个时候滑动地图下面可以滑动流畅，但是滑动上面被 AppBarLayout 盖住的一部分（即使不可见）则不流畅。然后监听 AppBarLayout 的 addOnOffsetChangedListener 方法会发现有回调。也就是说，即使 AppBarLayout 即使是 GONE，但是它仍然在消费触摸事件，这很令人费解。但是转念一想，好像也不无道理。CoordinatorLayout 是结合 Behavior 来进行处理嵌套滑动的，说明 Behavior 是具有事件处理能力的，在 Behavior 内没有对 View 是否可见进行控制则显得没那么重要了。这里看到 Behavior 中有一个是否可拖动的 Callback： 123456789101112131415/** * Callback to allow control over any &#123;@link AppBarLayout&#125; dragging. */public static abstract class DragCallback &#123; /** * Allows control over whether the given &#123;@link AppBarLayout&#125; can be dragged or not. * * &lt;p&gt;Dragging is defined as a direct touch on the AppBarLayout with movement. This * call does not affect any nested scrolling.&lt;/p&gt; * * @return true if we are in a position to scroll the AppBarLayout via a drag, false * if not. */ public abstract boolean canDrag(@NonNull AppBarLayout appBarLayout);&#125; 想来 NestAppBarLayout 里设置 canDrag 一直返回 true 是为了解决 AppBarLayout 无法拖动的问题了，所以要解决我现在的问题就很简单了： 123456789101112private fun compactAppbarNestScroll() &#123; try &#123; ((this.layoutParams as? CoordinatorLayout.LayoutParams)?.behavior as? AppBarLayout.Behavior) ?.setDragCallback(object : AppBarLayout.Behavior.DragCallback() &#123; override fun canDrag(appBarLayout: AppBarLayout): Boolean &#123; return appBarLayout.visibility == View.VISIBLE &#125; &#125;) &#125; catch (e: Exception) &#123; LogUtils.d(&quot;NestAppBarLayout&quot;, e.message) &#125;&#125; 当 AppBarLayout 不可见时，当然是不能拖动的了。至此，整个页面的滑动又如丝般顺滑了~","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android 滑动吸顶效果","date":"2019-03-12T06:06:58.000Z","path":"2019/03/12/scroll/","text":"啥也不说，先上个图：往上滑动的时候，有两点： 透明度渐变显示个人主页标题栏，这个是覆盖在最上层的标题栏 当 Tab 栏滑动到主页下面时，固定不动了，下面的布局继续滑动 看下布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clickable=&quot;true&quot; android:focusable=&quot;true&quot;&gt; &lt;cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout android:id=&quot;@+id/barLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:elevation=&quot;0dp&quot; app:layout_behavior=&quot;cn.mucang.android.voyager.lib.framework.widget.SnapAppBarLayoutBehavior&quot;&gt; &lt;!-- 用户头像、简介 --&gt; &lt;include layout=&quot;@layout/profile_fragment_header&quot;/&gt; &lt;!-- Tab 栏 --&gt; &lt;include layout=&quot;@layout/ucenter_fragment_tab&quot;/&gt; &lt;/cn.mucang.android.voyager.lib.framework.widget.NestAppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewPager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;LinearLayout android:id=&quot;@+id/titleLl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;72dp&quot; android:background=&quot;@color/vyg__transparent&quot; android:clickable=&quot;true&quot; android:gravity=&quot;center_vertical&quot; android:paddingTop=&quot;24dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/backIv&quot; android:layout_width=&quot;32dp&quot; android:layout_height=&quot;32dp&quot; android:layout_marginLeft=&quot;12dp&quot; android:paddingLeft=&quot;6dp&quot; android:src=&quot;@drawable/vyg__icon_back&quot;/&gt; &lt;TextView android:id=&quot;@+id/titleTv&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:layout_weight=&quot;1&quot; android:ellipsize=&quot;end&quot; android:gravity=&quot;center&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;@color/vyg__transparent&quot; android:textSize=&quot;18sp&quot;/&gt; &lt;Space android:layout_width=&quot;32dp&quot; android:layout_height=&quot;32dp&quot; android:layout_marginRight=&quot;12dp&quot;/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; profile layout 的根布局有设置： 1app:layout_scrollFlags=&quot;scroll&quot; 使其能跟着界面一起滑动，那下面的 Tab 栏需要在滑动到标题栏下面的时候停止滑动，吸附在上面。如果没有标题栏，就不会有这篇文章了。加上标题栏之后，相当于：往上滑动，scroll 的布局滑出界面，然后 Tab 栏滑动到距离顶部一个标题栏的高度后固定不动，如果拿去标题栏，应该是还能看到一部分 scroll 布局的内容的。也就是说需要固定的布局距离顶部有一段距离。起初想着这种需求能否利用 CoordinatorLayout、layout_scrollFlags 来实现，但是找了找，并没有发现类似功能的 Api。后面突发奇想：AppBarLayout 里面包裹了两个布局，给下面的 Tab 栏布局设置个 marginTop，这样应该就可以距离顶部一段距离了，然后给上面的距离设置个负数的 marginBottom，一正一负正好抵消，或许有作用？想没用，直接上代码： 1234// 距离顶部的高度为 状态栏的高度 + 标题栏的高度（固定 48dp）val titleHeight = statusBarHeight + DimenUtils.dp2px(48F)(profileHeaderRl.layoutParams as AppBarLayout.LayoutParams).bottomMargin = -titleHeight(userHomeTabScroll.layoutParams as AppBarLayout.LayoutParams).topMargin = titleHeight 然后试了一下效果，还真有用！因缺思厅！","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"记录微信分享的一个坑","date":"2019-03-05T09:47:01.000Z","path":"2019/03/05/wechat-tip/","text":"今天碰到一个问题，社区里帖子有的可以分享到微信，有的不行，单独调试获取分享的数据，发现并无不同。生成分享数据的代码如下： 1234567891011WXMediaMessage mediaMessage = new WXMediaMessage(programObject);mediaMessage.title = shareData.getTitle();mediaMessage.description = shareData.getContent();mediaMessage.thumbData = Utils.readMiniProgramThumbImageFileData(shareData.getShareImagePath());//发送请求SendMessageToWX.Req req = new SendMessageToWX.Req();req.transaction = String.valueOf(listenerId);req.message = mediaMessage;// 目前支持会话req.scene = SendMessageToWX.Req.WXSceneSession;doSendReq(req); shareData 是客户端单独组织的一个 Model。起初怀疑是 thumbData 太大导致的，结果后面可以分享的帖子生成的 thumbData 所占的字节还要大一些。。。然后试着分享到微博、QQ 等其他平台，发现也可以分享成功，唯独微信分享给朋友或朋友圈不行。偶然的发现一个帖子分享到微博也会失败，而微博客户端给出了“内容不符合规范”类似大意的提示，于是猜测可能是 description 导致。于是分别调试了不同帖子的数据，发现不能分享的帖子生成的 description length 都是 2000+，而可以分享的帖子生成的才 1000+，没有超过 2000，于是预测是 description 超长导致的。最后调试进行截取，超长的则取前 100 个字符，发现问题解决。问题比较简单，但是调试的时候很坑，因为分享失败的帖子竟然连 WxEntryActivity 里的 onResp 都不回调，所以压根无法知道失败的原因，只能对比数据靠猜测，于是便记录一下，以后碰到这类问题便知道如何解决了。总结一下：微信分享传的 description 参数不能过长（测试 1800 以下是可以分享的），否则会分享失败，而且回调里的 onResp 都不会调用。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"最近的几点感悟","date":"2019-02-27T02:14:14.000Z","path":"2019/02/27/feeling/","text":"一直有读公众号的习惯，关注了 MacTalk、Fenng、王信文等一些大咖，也读过不少文章，有一些还是蛮有感慨的，希望自己能每天变得更好一点。 抽纸办公桌上的抽纸用完了，打算自己再带一份来（公司发的会在瞬间被员工抢光，实在抢不过…）。但是我没有背包上班的需求，每天都是赤手空空的，单独拿一抽纸走在路上会感觉很奇怪。于是我下意识的是找我们的产品（和他关系还不错，他每天背包带电脑上下班）让他帮我带一份，钱微信转给他。当我准备这样做的时候，我发现我不知道怎么开口，“你家抽纸多少钱一份？”、“你帮我带一份抽纸吧？”，想想就感觉好智障啊，还好我没有这样做。没有背包上班的习惯，就挑一天背个包上班，带上抽纸，有什么难的吗？并不难。麻烦吗？也并不麻烦，背个包而已。可为什么我会下意识的先让别人来帮我，现在想想还挺可怕的。力所能及的事情就不要麻烦别人了，即使对别人来说就是举手之劳，但是这可能会消费你的「社会信用」。 任务分配项目组三个开发，需求下来时会评估需求及时间，然后分配任务。在之前我都是会选“知道怎么做的任务”，因为害怕完不成拖进度，拿 C 评级。但是这样久了连我自己都觉得厌烦了。“又要做xxx详情页，真没意思”，自己都厌烦了，都觉得无聊了，为什么还不愿意改变一下呢？每天重复同样的工作有什么意义呢？最近的几个版本迭代，我开始挑选自己没做过的，觉得有挑战性的任务了。对自己有信心，即使接到任务的时候无从下手，但是随着慢慢摸索，总能找到对的路。碰到问题就去解决，不知道怎么解决就 Google，你得相信你做的事情总会有人也在做。永远挑选高于自身水平一点的任务去做，这样才能进步。当然，不能太高，那会打击自己的自信心。 阅读理解和刚认识的朋友聊天，谈到自己的上班作息。聊天记录是这样： ：那早上一般几点上班？：8点半：我们9点到9点半，不过我下班肯定比你晚，你几点下班？：我们五点半，我们一天上7个小时：我们8个小时，吃饭加午休，一个半小时，一般都是7 8点才下班：你不是说到九点半 听到九点半后，我有点诧异，没有立即回复，于是我往上拉查看聊天记录，发现确实有一句话会产生这样的歧义：我们9点到9点半。正常来看本身就可以有两种理解： 上班的时间是9点到9点半，弹性半小时 上下班的时间是早上9点到晚上9点半 其实结合上下文可以理解为我表述的意思应该是第一种理解。可是，一万个读者有一万个哈姆雷特，你无法知道他人的想法是什么样的。即使是面对一部电梯，有的人也会认为按钮的功能是“让电梯上或者下”，而有的人会认为是表达“我想上或者我想下”。当然，这个电梯问题有正确答案：当你在电梯最底下一层时，是没有向下的按钮的。但是大多数情景都是没有正确答案的，因为每个人的经历不同，想法不同。最后我回复了两句： ：早上上班时间最晚是九点半，最早九点：不是早上9点到晚上9点半，我没说清楚 这放在之前，我可能就会觉得对方怎么这么“蠢”，哈哈哈有点自大。写到这里，我又想起来之前的一个事情。 人物：A 和他女朋友 A’，A 的同学 B。事情：A’ 对 A 说想和闺蜜一起看一部电影，叫啥来着忘了，然后 A 把这事告诉了 B，B 说：这个电影国外上映了的，网上有资源，不是什么大片，可以就网上看。然后 A 把 B 的话转述给了 A’，然后 A’ 表示可以，然后问 A 要电影。于是 B 给 A 发了一个电影的下载链接，A 转发给 A’，然后 A’ 就生气了。生气的理由就是：我要的是电影啊，你给我一个下载链接我怎么看？ 这个事情刚发生的时候我觉得很不可思议，但是现在我慢慢的接受并理解。每个人的生活轨迹不同，所受的教育也不同，每个人都是独特的，世上没有完全一样的树叶，你的想法在别人看来未必就是对的。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Android 动画序列的实现","date":"2019-02-02T06:19:14.000Z","path":"2019/02/02/animation/","text":"老规矩，上需求：这个 Gif 里有众多的动画效果，怎么实现呢？ 拆分效果整体的动画效果大致可以分为 3 个： 右上角小车移动的动画 图片缩放动画及文字展示的动画 左侧 Logo 及底部文字的动画 拆分完之后，依次来实现。 小车轨迹动画项目基于高德地图，小车绘制的路线必须是实际路线的样子，然后车头还要跟着路线进行旋转，里面的细节还是挺多的。 如何绘制路线？使用高德自带的 Api 很难实现这样的效果，所以采取的方案是：利用高德地图绘制出路线，然后将路线中的 GPS 点映射成为屏幕中的坐标点，这些坐标点是基于 Android 手机屏幕的，所以可以直接传入到 Path 中，然后利用 Path 进行绘制，这样绘制出来的图形遍与真实的路线一致了。 小车如何移动旋转？小车的移动显然与路线的绘制保持一致，小车的中心点即是路线最新画出来的点。至于角度，则是根据前面 N 个点的平均点，与后面 N 个点的平均点进行连线所形成的的夹角来得到。 1234567891011121314151617181920val pastCenter = Point() // 过去 N 个点的平均点var totalX = 0var totalY = 0for (index in startIndex..newIndex) &#123; totalX += traceDataList!![index].x totalY += traceDataList!![index].y&#125;pastCenter.x = totalX / (newIndex - startIndex + 1)pastCenter.y = totalY / (newIndex - startIndex + 1)val lastCenter = Point() // 未来 N 个点的平均点totalX = 0totalY = 0for (index in newIndex..endIndex) &#123; totalX += traceDataList!![index].x totalY += traceDataList!![index].y&#125;lastCenter.x = totalX / (endIndex - newIndex + 1)lastCenter.y = totalY / (endIndex - newIndex + 1)val angle = (lastCenter.y - pastCenter.y).toFloat() / (lastCenter.x - pastCenter.x) 求得角度之后，将其转化为 Canvas 使用的角度进行绘制小车 Bitmap 即可。 图片缩放动画，文字展示的动画Gif 演示图中有 5 张图片，对应了 5 个文字展示动画。 第一张图对应里程、时间动画。 第二张图对应速度、海拔动画。 第三、四张图对应描述文字动画。 第五张图对应推广文字动画。 将每张图的动画仔细拆分： 第一张图：里程文字 alpha 渐变 -&gt; 里程数据从右往左展示 -&gt; 时间文字 alpha 渐变 -&gt; 时间数据从右往左展示。 第二张图：速度文字从上往下展示 -&gt; 速度数据从左往右展示 -&gt; 海拔文字从上往下展示 -&gt; 海拔数据从左往右展示。 第三、四张图：整体从左往右逐渐揭露展示。 第五张图：整体 alpha 渐变。 那么如何将这么些动画组织起来呢？它就像事件流一样，1 执行完了执行 2，2 执行完了执行 3。。。Android View 提供一个 animate() 方法，它会返回一个 ViewPropertyAnimator 对象，它提供了很多动画方法进行调用，并且有点像建造者模式，可以链式调用，最后写起来就像这样： 12345678910111213141516171819202122232425262728293031323334/** * 展示里程、时间动画 */private fun startFirstPageAnimation() &#123; firstView.distanceLl.animate() .alphaBy(0F) .alpha(1F) .withEndAction &#123; firstView.distanceTv.animate() .translationXBy(firstView.distanceTv.measuredWidth.toFloat()) .translationX(0F) .withEndAction &#123; firstView.timeLl.animate() .alphaBy(0F) .alpha(1F) .withEndAction &#123; firstView.timeTv.animate() .translationXBy(firstView.timeTv.measuredWidth.toFloat()) .translationX(0F) .withEndAction &#123; hideView(firstView) &#125; .setDuration(240L) .start() &#125; .setDuration(240L) .start() &#125; .setDuration(240L) .start() &#125; .setDuration(240L) .start()&#125; 顺带贴一下 firstView 的布局： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:id=&quot;@+id/firstAnimationRoot&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;right|bottom&quot; android:layout_marginBottom=&quot;24dp&quot; android:layout_marginRight=&quot;24dp&quot; android:gravity=&quot;right&quot; android:orientation=&quot;vertical&quot; tools:background=&quot;#c000ffff&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/distanceLl&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;View android:layout_width=&quot;24dp&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;@color/vyg__white&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:text=&quot;总里程&quot; android:textColor=&quot;@color/vyg__white&quot; android:textSize=&quot;8sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/distanceTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/vyg__white&quot; android:textSize=&quot;22sp&quot; tools:text=&quot;8765KM&quot;/&gt; &lt;LinearLayout android:id=&quot;@+id/timeLl&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;14dp&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;View android:layout_width=&quot;24dp&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;@color/vyg__white&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:text=&quot;总时间&quot; android:textColor=&quot;@color/vyg__white&quot; android:textSize=&quot;8sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/timeTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/vyg__white&quot; android:textSize=&quot;12sp&quot; tools:text=&quot;01:23:89&quot;/&gt;&lt;/LinearLayout&gt; 利用 withEndAction 方法很方便的在动画结束后执行某个操作，而不用加监听。但是这样动画多了就会产生「回调地狱」，看起来不太舒服…但是也没想到其他好的方法，姑且只能这样了。第二张图动画代码也和这个类似就不帖了。看下第三张揭露动画： 12345678910111213141516171819202122232425/** * 展示文字描述动画 */private fun startDescPageAnimation(view: View) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; val animator = ViewAnimationUtils.createCircularReveal(view, 0, 0, 0F, DimenUtils.dp2px(240F).toFloat()) animator.duration = 160L animator.start() animator.removeAllListeners() animator.addListener(object : AnimatorListenerAdapter() &#123; override fun onAnimationEnd(animation: Animator?) &#123; hideView(view) &#125; &#125;) &#125; else &#123; view.animate() .alphaBy(0F) .alpha(1F) .withEndAction &#123; hideView(view) &#125; .setDuration(160L) .start() &#125;&#125; 直接使用的 createCircularReveal 来创建动画，若是在 5.0 以下，则直接展示个 alpha 渐变动画。最后一张图的动画就是 alpha 渐变，也没啥好说的。 ok，每一页的动画都准备好了，如何将他们组织起来呢？首先，需要将每一页元素添加到界面上进行展示。如果需求是固定的 5 组图文，可以直接将布局写死到代码里，可是数量不是固定的。图片是根据路线的数据来取的。 如果没有图片，则返回默认三张图，并展示 1、2、5 对应的文本动画。 如果只有一张或三张，则使用返回的图片，并展示 1、2、5 对应的文本动画。 如果只有两张，则使用返回的图片，并展示 1、2 对应的文本动画。 如果有大于三张，则使用返回的图片，固定展示 1、2、5 的文本动画，多的图片展示 3、4 的动画。 所以：图片的数量和下面展示的文本数量并不是一致的，要将图片动画和文本动画拆开。为了统一控制，最好保持一个动画触发入口。再看到 Gif 图，基本上文本动画执行完准备消失时，图片动画开始。所以我的做法是：统一一个入口，管理文本动画，当文本动画要消失时，触发图片动画。若数量不对应，则不执行图片动画。下面贴代码： 图片容器添加所有的图片12345678910111213141516/** * 填充图片内容 */private fun fillPicContent(picList: MutableList&lt;Any&gt;) &#123; picContainer.removeAllViews() picList.forEach &#123; val imageView = ImageView(context) imageView.scaleType = ImageView.ScaleType.CENTER_CROP if (it is VygImage) &#123; AsImage.show(it.detail).into(imageView) &#125; else &#123; AsImage.show(it).into(imageView) &#125; picContainer.addView(imageView, 0) &#125;&#125; 文本容器添加所有的文本12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 填充文本内容 */private fun fillTextContent(route: VygRoute, picList: MutableList&lt;Any&gt;) &#123; firstView.timeTv.text = route.showTime firstView.distanceTv.setTextWithEmpty(route.distance / 1000.00, &quot;%.1fkm&quot;) secondView.speedTv.setTextWithEmpty(route.avgSpeed.toDouble(), &quot;%.1fkm/h&quot;) secondView.altTv.setTextWithEmpty(route.maxAlt, &quot;%.0fm&quot;) textContainer.removeAllViews() textContainer.addView(firstView, 0) textContainer.addView(secondView, 0) val picSize = picList.size /* * 1 张或 3 张图片，展示 1、2、5 的样式 * 2 张，，展示 1、2 的样式 * 4 张或以上，固定展示 1、2、5，中间 3、4 展示图片打点描述的样式 */ if (picSize == 1 || picSize == 3) &#123; showTime = (BASE_DURATION - LAST_PAGE_DURATION - 2 * HIDE_DURATION) / 3 textContainer.addView(lastView, 0) &#125; else if (picSize == 4) &#123; showTime = (BASE_DURATION - LAST_PAGE_DURATION - DESC_PAGE_DURATION - 3 * HIDE_DURATION) / 4 val desc = LayoutInflater.from(context).inflate(R.layout.vyg__route_video_share_desc_page, textContainer, false) textContainer.addView(desc, 0) textContainer.addView(lastView, 0) setPointDesc(picList, 2, desc, route) &#125; else if (picSize == 5) &#123; showTime = (BASE_DURATION - LAST_PAGE_DURATION - DESC_PAGE_DURATION * 2 - 4 * HIDE_DURATION) / 5 val desc1 = LayoutInflater.from(context).inflate(R.layout.vyg__route_video_share_desc_page, textContainer, false) val desc2 = LayoutInflater.from(context).inflate(R.layout.vyg__route_video_share_desc_page, textContainer, false) textContainer.addView(desc1, 0) textContainer.addView(desc2, 0) textContainer.addView(lastView, 0) setPointDesc(picList, 2, desc1, route) setPointDesc(picList, 3, desc2, route) &#125; else &#123; showTime = (BASE_DURATION - HIDE_DURATION) / 2 &#125;&#125; showTime 为文本动画执行完之后的展示时间，因为动画总时长为 10 秒，文本内容越多，每个文本展示的时间就越短，所以需要计算 showTime，展示时间到了之后就进行隐藏：123456789101112131415161718192021/** * 展示隐藏动画 */private fun hideView(view: View) &#123; handler.postDelayed(&#123; if (!isPlaying) &#123; return@postDelayed &#125; showPicAnimation() view.animate() .alphaBy(1F) .alpha(0F) .setDuration(600L) .withEndAction &#123; textAnimationIndex-- startAnimation() &#125; .start() &#125;, showTime)&#125; 隐藏的时候触发图片动画：123456789101112131415161718192021222324/** * 展示图片缩放动画 */private fun showPicAnimation() &#123; picAnimationIndex-- if (picAnimationIndex == 0) &#123; return &#125; val view = picContainer.getChildAt(picAnimationIndex) view?.let &#123; it.pivotX = 0F it.pivotY = picContainer.measuredHeight / 2F it.animate() .scaleXBy(1F) .scaleX(0F) .scaleYBy(1F) .scaleY(0F) .alphaBy(1F) .alpha(0F) .setDuration(HIDE_DURATION) .start() &#125;&#125; textAnimationIndex 为当前展示文本动画的 index，picAnimationIndex 为当前展示图片动画的 index。然后提供一个入口，触发所有的动画：1234567891011121314151617181920212223242526272829303132333435363738394041/** * 播放动画 */fun play() &#123; isPlaying = true picAnimationIndex = picContainer.childCount textAnimationIndex = textContainer.childCount - 1 resetAnimationStatus() startLeftAnimation() startAnimation()&#125;/** * 开始动画 */private fun startAnimation() &#123; if (!isPlaying) &#123; return &#125; if (textAnimationIndex &lt; 0 || textAnimationIndex &gt;= textContainer.childCount) &#123; textAnimationIndex = 0 animationEnded() return &#125; val view = textContainer.getChildAt(textAnimationIndex) when (view) &#123; firstView -&gt; &#123; startFirstPageAnimation() &#125; secondView -&gt; &#123; startSecondPageAnimation(textAnimationIndex != 0) &#125; lastView -&gt; &#123; startLastPageAnimation() &#125; else -&gt; &#123; startDescPageAnimation(view) &#125; &#125;&#125; 通过取文本容器的孩子，判断是什么 View 来执行相应的动画，那么第二部分的动画就算是完成了。 左侧 Logo 动画这个在第二部分动画完成之后便不是什么问题了： 12345678910111213141516171819202122232425262728293031323334353637/** * 展示左侧 Logo、时间、起点动画 */private fun startLeftAnimation() &#123; leftRoot.bgView.animate() .translationXBy(dpMinus44) .translationX(0F) .setDuration(160L) .start() handler.postDelayed(&#123; leftRoot.logoTv.animate() .translationYBy(dpMinus118) .translationY(0F) .withEndAction &#123; leftRoot.dayTv.animate() .translationYBy(dp22) .translationY(0F) .setDuration(400L) .start() leftRoot.dateTv.animate() .translationYBy(dpMinus8) .translationY(0F) .withEndAction &#123; leftRoot.endCityLl.animate() .alphaBy(0F) .alpha(1F) .setDuration(240L) .start() &#125; .setDuration(400L) .start() &#125; .setDuration(160L) .start() &#125;, 80L)&#125; 如何停止播放所有的动画执行时间为 10 秒，当动画开始后，切换到别的 Tab 或页面时，动画应该停止播放，并且恢复到初始状态，然后点击播放按钮能正常从头开始播放。为了解决这个问题，引入一个变量记录当前正在播放动画的 View，利用 withStartAction 方法即可。 12345678firstView.distanceLl.animate() .alphaBy(0F) .alpha(1F) .withStartAction &#123; currentAnimationView = firstView.distanceLl &#125; .setDuration(240L) .start() 当页面切换时，停止动画并重置所有的 View 的状态： 1234567891011121314151617181920212223242526272829/** * 播放停止重置界面展示 */private fun resetInitStatus() &#123; currentAnimationView?.animate()?.cancel() leftRoot.bgView.translationX = 0F leftRoot.logoTv.translationY = 0F leftRoot.endCityLl.alpha = 1F leftRoot.dayTv.translationY = 0F leftRoot.dateTv.translationY = 0F var picView = picContainer.getChildAt(picAnimationIndex) picView?.animate()?.cancel() picView = picContainer.getChildAt(picContainer.childCount - 1) picView?.scaleX = 1F picView?.scaleY = 1F picView?.alpha = 1F val view = textContainer.getChildAt(textAnimationIndex) view?.animate()?.cancel() view?.visibility = View.INVISIBLE firstView.visibility = View.VISIBLE firstView.alpha = 1F firstView.distanceLl.alpha = 1F firstView.distanceTv.translationX = 0F firstView.timeLl.alpha = 1F firstView.timeTv.translationX = 0F&#125; 小结 View 的逐渐显示效果，可以在 View 外层套一层 ViewGroup，然后利用 translate 来实现。 animate() 后面的动画使用 alphaBy、translationXBy 等方法时，需要在动画开始的时候将 View 对应的属性设置成相应的值，否则动画会错误的执行（提前结束等）。 动画很多，做的时候要细心，将动画一个个拆分开来，然后逐一攻破。 优化点：能否将 animate() 改造成 RxJava 类似的调用链，避免回调地狱呢？","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android 绘制中国地图","date":"2019-01-25T06:07:52.000Z","path":"2019/01/25/china-map/","text":"最近的版本有这样一个需求： 有 3 个要素： 中国地图 高亮省区 中心显示数字 面对这样一个需求，该如何实现呢？ 高德地图因为项目是基于高德地图来做的，所以很自然而然的想到了高德。但是当查阅高德地图相关 Api 后，发现并没有能够实现这样需求的方法，所以只能另寻他法了。 图片叠加让设计师出图，实现第一个要素开发成本极低。至于高亮省区，也是继续让设计师出图，与全国地图分辨率保持一致，为每个省区设计一张高亮的图，其他地方透明，这样算下来设计师得出 35 张图。若不考虑性能，将图片无脑叠加倒也可以实现。但是作为 Android 开发都知道，这样的一张不算小的图片加载到手机里，占用的内存怕是个庞然大物，更别谈极端情况下要叠加 35 张这样的大图了。优化下叠加方案：将高亮的省区做成小图，一个包含了省区所有区域的矩形，省区内部高亮，其他区域透明，这样图变小了，但是就得计算小图相对于全国大图的相对位置，对于每个小图都得计算一个比例。同时，绘制高亮省区时可以每次都只取2张图进行叠加，叠加完后释放一张图再加载另一张图，而不用一次性全部加载在内存中。这种方案想想是 ok 的，但是感觉依然还是很麻烦。于是继续探索~ SVG Path其实网上有很多文章也是有类似的需求，简单搜一下就发现了 SVG 这个解决方案了。看了一眼，便决定就是它了！SVG：可缩放矢量图形（英语：Scalable Vector Graphics，SVG）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式。****元素是 SVG 基本形状中最强大的一个，它不仅能创建其他基本形状，还能创建更多其他形状。 SVG Path 用 Android 绘制这里先贴一下我找的北京市的 Path 数据： 123&lt;svg height=&quot;475&quot; width=&quot;565&quot;&gt; &lt;path id=&quot;Beijing&quot; d=&quot;M421.139,189.75L420.782,186.894L419.95,184.989L425.045,182.863L425.426,181.18L424.23699999999997,176.413H422.56899999999996L415.90299999999996,172.964L412.21299999999997,176.654C412.21299999999997,176.654,411.08799999999997,183.239,411.381,181.534C411.66999999999996,179.82999999999998,407.688,185.822,407.688,185.822L407.094,190.108L407.926,192.371L412.807,191.537L416.5,192.608L418.284,190.941L421.139,189.75Z&quot;/&gt;&lt;/svg&gt; 这里要注意一点：SVG Path 里的数据都是在一个固定宽高的矩形里的坐标集合，所以当 Android View 与 SVG 的宽高不一致时，需要进行缩放。注意下面代码中的 scale 属性： 123456789101112131415161718192021222324252627282930/** * 计算地图边界 * 1.黑龙江是中国最东，最北的省份 * 2.新疆是中国最西的省份 * 3.海南是中国最南的省份 */private fun computeBounds() &#123; val hljRF = RectF() xPaths[HEILONGJIANG_CODE]?.computeBounds(hljRF, true) val hnRF = RectF() xPaths[HAINAN_CODE]?.computeBounds(hnRF, true) mapWidth = hljRF.right mapHeight = hnRF.bottom&#125;override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec) val speSize = View.MeasureSpec.getSize(widthMeasureSpec) scale = speSize / mapWidth setMeasuredDimension(speSize, (speSize * mapHeight / mapWidth).toInt())&#125;override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) // 缩放画布 canvas.scale(scale, scale) ...&#125; 再来看到 Path 里有一些 M、L、Z 等字符，这些都是 Path 元素里的指令，后面紧跟的数字即是坐标。 M x,y 移动指令，映射 Path 中的 moveToL x,y 画直线指令，映射 Path 中的 lineToH x 画水平线指令，映射 Path 中的 lineTo，不过要使用上一个坐标的 yV y 画垂直线指令，映射 Path 中的 lineTo，不过要使用上一个坐标的 xC x1,y1,x2,y2,x,y 三次贝塞尔曲线指令，映射 Path 中的 cubicToS x2,y2,x,y 跟在 C 指令后面使用，用 C 指令的结束点做控制点，映射 cubicToQ x1,y1,x,y 二次贝塞尔曲线指令，映射 quadToT x,y 跟在 Q 指令后面使用，使用 Q 的 x,y 做控制点，映射 quadToZ path 关闭指令，映射 close 注意小写指令为使用相对坐标，下面 2 行 Path 得到的结果是一样的： 12M421.139,189.75L420.782,186.894M421.139,189.75l-0.357,-2.856 基于 Android Path 实现不了小写指令的那种效果，所以只能使用大写指令。这里贴一下一个将 SVG Path 转成 Android Path 的工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 仅限大写指令转换 */public class SvgPathToAndroidPath &#123; private int svgPathLenght = 0; private String svgPath = null; private int mIndex; private List&lt;Integer&gt; cmdPositions = new ArrayList&lt;&gt;(); /** * M x,y * L x,y * H x * V y * C x1,y1,x2,y2,x,y * Q x1,y1,x,y * S x2,y2,x,y * T x,y * */ public Path parser(String svgPath) &#123; this.svgPath = svgPath; svgPathLenght = svgPath.length(); mIndex = 0; Path lPath = new Path(); lPath.setFillType(Path.FillType.WINDING); //记录最后一个操作点 PointF lastPoint = new PointF(); findCommand(); for (int i = 0; i &lt; cmdPositions.size(); i++) &#123; Integer index = cmdPositions.get(i); switch (svgPath.charAt(index)) &#123; case &#x27;M&#x27;: &#123; String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); lPath.moveTo(lastPoint.x, lastPoint.y); &#125; break; case &#x27;L&#x27;: &#123; String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); lPath.lineTo(lastPoint.x, lastPoint.y); &#125; break; case &#x27;H&#x27;: &#123;//基于上个坐标在水平方向上划线，因此y轴不变 String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[0]), lastPoint.y); lPath.lineTo(lastPoint.x, lastPoint.y); &#125; break; case &#x27;V&#x27;: &#123;//基于上个坐标在水平方向上划线，因此x轴不变 String ps[] = findPoints(i); lastPoint.set(lastPoint.x, Float.parseFloat(ps[0])); lPath.lineTo(lastPoint.x, lastPoint.y); &#125; break; case &#x27;C&#x27;: &#123;//3次贝塞尔曲线 String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[4]), Float.parseFloat(ps[5])); lPath.cubicTo(Float.parseFloat(ps[0]), Float.parseFloat(ps[1]), Float.parseFloat(ps[2]), Float.parseFloat(ps[3]), Float.parseFloat(ps[4]), Float.parseFloat(ps[5])); &#125; break; case &#x27;S&#x27;: &#123;//一般S会跟在C或是S命令后面使用，用前一个点做起始控制点 String ps[] = findPoints(i); lPath.cubicTo(lastPoint.x,lastPoint.y,Float.parseFloat(ps[0]), Float.parseFloat(ps[1]), Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); lastPoint.set(Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); &#125; break; case &#x27;Q&#x27;: &#123;//二次贝塞尔曲线 String ps[] = findPoints(i); lastPoint.set(Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); lPath.quadTo(Float.parseFloat(ps[0]), Float.parseFloat(ps[1]), Float.parseFloat(ps[2]), Float.parseFloat(ps[3])); &#125; break; case &#x27;T&#x27;: &#123;//T命令会跟在Q后面使用，用Q的结束点做起始点 String ps[] = findPoints(i); lPath.quadTo(lastPoint.x,lastPoint.y,Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); lastPoint.set(Float.parseFloat(ps[0]), Float.parseFloat(ps[1])); &#125; break; break; case &#x27;Z&#x27;: &#123;//结束 lPath.close(); &#125; break; &#125; &#125; return lPath; &#125; private String[] findPoints(int cmdIndexInPosition) &#123; int cmdIndex = cmdPositions.get(cmdIndexInPosition); String pointString = svgPath.substring(cmdIndex + 1, cmdPositions.get(cmdIndexInPosition + 1)); return pointString.split(&quot;,&quot;); &#125; private void findCommand() &#123; cmdPositions.clear(); while (mIndex &lt; svgPathLenght) &#123; char c = svgPath.charAt(mIndex); if (&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;Z&#x27;) &#123; cmdPositions.add(mIndex); &#125; ++mIndex; &#125; &#125;&#125; 实现 利用工具类获取每个省区的 Android Path，全部绘制一遍，即可绘制出全国地图（优化：高亮的省区这一步不绘制，避免绘制两次）。 针对高亮省区，调整画笔颜色再绘制一遍即可。 显示数量：这个目前没想到什么好方法，只能让设计师参照地图宽高比标出每个中心点的位置，就像这样：然后手动算出每个点的横纵坐标占比，再进行绘制。绘制数量计算坐标时仍要考虑 scale 属性。 参考 Android 上绘制中国省份地图 SVG 转 Android Canvas Path","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Fragment 问题小结","date":"2019-01-10T06:49:12.000Z","path":"2019/01/10/fragment/","text":"ViewPager 用来做多 Tab 处理已经是十分常见的了，ViewPager 需要一个 Fragment List 来生成 Adapter，这些 Fragment 有时是完全一样的，界面元素、展示风格都一致，只是数据源不一致。通过抽象的思想，很容易写出基类，类似这样： 123456789abstract class BaseListFragment : BaseFragment&lt;MyData&gt;() &#123; override fun requestHttpData(pageModel: PageModel?): MutableList&lt;MyData&gt; &#123; return getData() &#125; abstract fun getData(): MutableList&lt;MyData&gt;&#125; 然后在创建 Fragment List 时，使用匿名类实现getData()方法来获取数据。就像这样： 1234567891011121314151617181920viewPager.adapter = object : FragmentPagerAdapter(fragmentManager) &#123; override fun getItem(position: Int): BaseListFragment &#123; when (position) &#123; 0 -&gt; &#123; if (fragment == null) &#123; fragment = object : BaseListFragment() &#123; override fun getData(): MutableList&lt;MyData&gt; &#123; // 获取数据 &#125; &#125; &#125; return fragment!! &#125; ... &#125; &#125; ...&#125; 但是这样会编译不过： Fragments should be static such that they can be re-instantiated by the system, and anonymous classes are not static. 然后加上@SuppressLint(&quot;ValidFragment&quot;)注解，可以编译过了，但是运行的时候仍然报错。 Fragment null must be a public static class to be properly recreated from instance state. 异常是在BackStackRecord.doAddOp()抛出的，看到源码： 123456789101112131415161718192021222324252627282930313233343536private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123; final Class fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123; throw new IllegalStateException(&quot;Fragment &quot; + fragmentClass.getCanonicalName() + &quot; must be a public static class to be properly recreated from&quot; + &quot; instance state.&quot;); &#125; fragment.mFragmentManager = mManager; if (tag != null) &#123; if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException(&quot;Can&#x27;t change tag of fragment &quot; + fragment + &quot;: was &quot; + fragment.mTag + &quot; now &quot; + tag); &#125; fragment.mTag = tag; &#125; if (containerViewId != 0) &#123; if (containerViewId == View.NO_ID) &#123; throw new IllegalArgumentException(&quot;Can&#x27;t add fragment &quot; + fragment + &quot; with tag &quot; + tag + &quot; to container view with no id&quot;); &#125; if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123; throw new IllegalStateException(&quot;Can&#x27;t change container ID of fragment &quot; + fragment + &quot;: was &quot; + fragment.mFragmentId + &quot; now &quot; + containerViewId); &#125; fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; addOp(new Op(opcmd, fragment));&#125; 抛出异常的 3 个条件： 匿名类 访问域不是 Public 是 成员类，但是访问域不是 Static 抛出来的异常也很明显了：Fragment 必须 public static 的类，以便系统可以用初始状态重建。这也和 Fragment newIntance 使用 setArguments 不谋而合。 12345678public static MyFragment newInstance() &#123; MyFragment fragment = new MyFragment(String param1, String param2); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment;&#125; Fragmnet 经常会被销毁重新实例化，Android Framework 只会调用 Fragment 无参的构造函数。如果直接将参数放到构造函数里，那么 Framework 在重建 Fragment 就会丢失这些参数了。再看下 Fragment 的实例化： 12345678910111213141516171819202122232425262728293031323334public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123; try &#123; Class&lt;?&gt; clazz = sClassMap.get(fname); if (clazz == null) &#123; // Class not found in the cache, see if it&#x27;s real, and try to add it clazz = context.getClassLoader().loadClass(fname); sClassMap.put(fname, clazz); &#125; Fragment f = (Fragment) clazz.getConstructor().newInstance(); if (args != null) &#123; args.setClassLoader(f.getClass().getClassLoader()); f.setArguments(args); &#125; return f; &#125; catch (ClassNotFoundException e) &#123; throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname + &quot;: make sure class name exists, is public, and has an&quot; + &quot; empty constructor that is public&quot;, e); &#125; catch (java.lang.InstantiationException e) &#123; throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname + &quot;: make sure class name exists, is public, and has an&quot; + &quot; empty constructor that is public&quot;, e); &#125; catch (IllegalAccessException e) &#123; throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname + &quot;: make sure class name exists, is public, and has an&quot; + &quot; empty constructor that is public&quot;, e); &#125; catch (NoSuchMethodException e) &#123; throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname + &quot;: could not find Fragment constructor&quot;, e); &#125; catch (InvocationTargetException e) &#123; throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname + &quot;: calling Fragment constructor caused an exception&quot;, e); &#125;&#125; 看吧，很清晰了，用的反射取到默认的构造函数，然后创建实例，使用 setArguments 设置参数。小结一下： 不能使用匿名 Fragment 不能使用非 public static 的 Fragment 参数传递使用 setArguments 那么再回到题头：基类已经有了，怎么样减少类的创建呢？不想再写多个子类。我的方法是：写一个通用类，在 Fragment 创建后，setAction 来设置 getData 操作。 123456789101112class CommonListFragment : BaseFragment&lt;MyData&gt;() &#123; private var getData: (() -&gt; MutableList&lt;MyData&gt;)? = null override fun requestHttpData(pageModel: PageModel?): MutableList&lt;MyData&gt;? &#123; return getData?.invoke() &#125; fun setAction(action: () -&gt; MutableList&lt;MyData&gt;) &#123; getData = action &#125;&#125; 题外话遇到 Activity 后台被杀，然后自动重建的问题。 12345678910111213141516171819202122class DetailActivity : BaseActivity() &#123; private var fragment: DetailFragment? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.fragment_container_activity) try &#123; val bundle = savedInstanceState ?: intent.extras val showShareGuide = bundle.getBoolean(KEY_SHOW_SHARE_GUIDE, false) fragment = DetailFragment.newInstance(showShareGuide) supportFragmentManager.beginTransaction().replace(R.id.container, fragment).commit() &#125; catch (e: Exception) &#123; ToastUtils.toast(e.message) finish() &#125; &#125; override fun onSaveInstanceState(outState: Bundle?) &#123; super.onSaveInstanceState(fragment?.arguments) &#125;&#125; 通过 setArguments 设置 KEY_SHOW_SHARE_GUIDE 参数到 DetailFragment，然后操作界面后把 KEY_SHOW_SHARE_GUIDE 从 true 置为了 false。App 进入后台被杀之后，重建回来的 KEY_SHOW_SHARE_GUIDE 会还是 true。将 onSaveInstanceState 改为如下，问题解决。 1234override fun onSaveInstanceState(outState: Bundle?) &#123; outState?.putBoolean(KEY_SHOW_SHARE_GUIDE, fragment?.arguments?.getBoolean(KEY_SHOW_SHARE_GUIDE) ?: false) super.onSaveInstanceState(outState)&#125;","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"极客时间推广课程","date":"2018-12-25T09:02:12.000Z","path":"2018/12/25/geek/","text":"前些日子购买了一波极客时间的几门课程，贴下二维码，扫码购买返现互惠~ Android 开发高手课： 程序员的数学基础课： 数据结构与算法之美：","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Android 高德地图 SDK 使用小记","date":"2018-12-21T05:47:30.000Z","path":"2018/12/21/amap/","text":"最近的项目是基于高德地图 SDK 来实现的，使用中有一些值得记录的 Tip，便有了这篇博客。 Logo使用高德地图 SDK，是不能去掉「高德地图」 Logo的，只能设置它显示的位置。 1mapView.getMap().getUiSettings().setLogoPosition(position); position：位置参数。屏幕左下角：AMapOptions.LOGO_POSITION_BOTTOM_LEFT；底部居中：AMapOptions.LOGO_POSITION_BOTTOM_CENTER；右下：AMapOptions.LOGO_MARGIN_RIGHT。如果想要隐藏 Logo，可以使用如下代码： 1mapView.getMap().getUiSettings().setLogoBottomMargin(-50); 设置负值可以让 Logo 显示在屏幕之外。 刻度尺显示刻度尺： 1mapView.getMap().getUiSettings().setScaleControlsEnabled(true); 刻度尺的位置是在「高德地图」 Logo 的上面的，可以通过设置 Logo 来改变刻度尺的位置，也可以通过如下代码来设置刻度尺的位置： 1234567891011121314/** * 调整地图比例尺的位置 * * @param translationX 正数往右移，负数往左移 * @param translationY 正数往下移，负数往上移 */public void changeScaleControlsPosition(float translationX, float translationY) &#123; View mapViewChild = mapView.getChildAt(0); if (mapViewChild instanceof ViewGroup) &#123; View scaleView = ((ViewGroup) mapViewChild).getChildAt(3); scaleView.setTranslationX(translationX); scaleView.setTranslationY(translationY); &#125;&#125; 代码中的0、3都是硬编码，升级 SDK 时需要兼容测试。 Polyline 与底图之间加蒙层需求是这样的：绘制的 Ployline、Marker 与底图之间有个蒙层，如何来实现？翻到一篇文章写了高德地图覆盖物的层级压盖关系： 1、基础底图（包括底图、底图道路、卫星图等）；2、地形图图层（GroundOverlay）；3、热力图图层（HeatMap）；4、实时路况图图层（BaiduMap.setTrafficEnabled(true);）；5、百度城市热力图（BaiduMap.setBaiduHeatMapEnabled(true);）；6、底图标注（指的是底图上面自带的那些POI元素）；7、几何图形图层（点、折线、弧线、圆、多边形）；8、标注图层（Marker），文字绘制图层（Text）；9、指南针图层（当地图发生旋转和视角变化时，默认出现在左上角的指南针）；10、定位图层（BaiduMap.setMyLocationEnabled(true);）；11、弹出窗图层（InfoWindow）；12、自定义View（MapView.addView(View);）； 所以，在底图和几何图层图层、标注图层之间，还可以使用GroundOverlay。所以可以使用如下代码添加中间图层以达到某些显示效果： 12345678val view = View(context)view.layoutParams = FrameLayout.LayoutParams(1, 1)view.setBackgroundColor(Color.parseColor(&quot;#C1000000&quot;))val options = GroundOverlayOptions()options.image(BitmapDescriptorFactory.fromView(view))options.positionFromBounds(aMap.projection.visibleRegion.latLngBounds)options.zIndex(1F)aMap.addGroundOverlay(options) 地图显示所有的元素地图默认显示北京，当我们绘制了 Polyline 或者 Marker，想让地图全部显示全的时候，可以使用如下代码： 12345val boundsBuilder = LatLngBounds.Builder()for (i in 0 until markers.size()) &#123; boundsBuilder.include(markers.get(i).getPosition())&#125;aMap.animateCamera(CameraUpdateFactory.newLatLngBounds(boundsBuilder.build(), 15)) // 第二个参数为四周留空宽度 也可以使用newLatLngBoundsRect(LatLngBounds latlngbounds, int paddingLeft, int paddingRight, int paddingTop, int paddingBottom)方法，分别来设置四周的留空宽度。 多”InfoWindow”展示高德地图 Marker 可绑定一个 Infowindow，但是全局只能有一个 Infowindow 显示，所以如果要展示多个 Infowindow，只能使用其他方式。给 Marker 设置 icon，有个工厂类BitmapDescriptorFactory来提供。所以可以自己填充 View，然后通过 fromView 设置到 Marker 上。看到 fromView 的源码： 1234567891011121314151617181920212223242526272829303132public static BitmapDescriptor fromView(View var0) &#123; try &#123; Context var1 = s.a; if (var1 != null) &#123; FrameLayout var2 = new FrameLayout(var1); var2.addView(var0); var2.setDrawingCacheEnabled(true); Bitmap var3 = ev.a(var2); BitmapDescriptor var4 = fromBitmap(var3); return var4; &#125; else &#123; return null; &#125; &#125; catch (Throwable var5) &#123; return null; &#125;&#125;public static Bitmap a(View var0) &#123; try &#123; b(var0); var0.destroyDrawingCache(); var0.measure(MeasureSpec.makeMeasureSpec(0, 0), MeasureSpec.makeMeasureSpec(0, 0)); var0.layout(0, 0, var0.getMeasuredWidth(), var0.getMeasuredHeight()); Bitmap var1 = var0.getDrawingCache(); return var1 != null ? var1.copy(Config.ARGB_8888, false) : null; &#125; catch (Throwable var2) &#123; he.c(var2, &quot;Utils&quot;, &quot;getBitmapFromView&quot;); var2.printStackTrace(); return null; &#125;&#125; 可以看到是生成一个 FrameLayout 添加我们自定义的 View，然后利用 drawingCache 来生成 bitmap，最后设置到 Marker 上。所以一旦 View 设置到 Marker 上，这个 View 便“死”了，如果要改变 Marker 的样式，则只能重新生成 View 然后再次设置。所以，对于有样式修改需求的 Marker，要记录生成 View 的参数。 屏幕位置、地图位置映射贴一下文档说明： Marker 覆盖点击多个 Marker 覆盖显示在地图上，点击 Marker 覆盖重叠的部分，并不是视觉上最上层的 Marker 在响应（Marker 的 zIndex 值一致），一直是最后绘制的 Marker 在响应。通过设置 Marker 的 zIndex 可以解决这个问题。 1234567891011private var zIndex = 0F get() &#123; field++ return field &#125;override fun onMarkerClick(marker: Marker): Boolean &#123; marker.zIndex = zIndex // do something... return true&#125; 自定义地图 需要展示上图效果的地图，可以使用自定义地图实现。 进入官网自定义地图页面，可以自定义地图展示样式，然后保存，后面可以在自己的自定义样式界面进行使用。 针对 Android 下载下来的是一个 zip 文件，6.6.0 版本及以后会有 2 个文件，style.data、style_extra.data。然后使用地图加载： 1234567891011121314151617181920212223242526272829303132val options = CustomMapStyleOptions()options.styleDataPath = copyCustomStyleFile(&quot;style.data&quot;)options.styleExtraPath = copyCustomStyleFile(&quot;style_extra.data&quot;)options.isEnable = true/** * 拷贝自定义样式文件到私有文件目录 */private fun copyCustomStyleFile(fileName: String): String? &#123; var outputStream: FileOutputStream? = null var inputStream: InputStream? = null var file: File? = null try &#123; inputStream = controller.mapView.context.assets.open(&quot;map/footprint/$fileName&quot;) val b = ByteArray(inputStream!!.available()) inputStream.read(b) file = File(DirUtils.getMapPath(), fileName) if (file.exists()) &#123; file.delete() &#125; file.createNewFile() outputStream = FileOutputStream(file) outputStream.write(b) &#125; catch (e: Exception) &#123; LogUtils.e(&quot;ShareInfoMapPresenter&quot;, e.toString()) &#125; finally &#123; IOUtils.close(inputStream) IOUtils.close(outputStream) &#125; return file?.absolutePath&#125; Polyline Click 和 Map Click 冲突当 AMap setOnPolylineClickListener 又设置 setOnMapClickListener，点击 Polyline 还会响应到 onMapClick，调试后发现 Polyline 的点击事件在前，所以可以这样处理一下： 123456789101112131415@Overridepublic void onMapClick(LatLng latLng) &#123; if (clickPolyline) &#123; clickPolyline = false; return; &#125; // do something&#125;@Overridepublic void onPolylineClick(Polyline polyline) &#123; clickPolyline = true; // do something&#125; 参考文档：Android地图SDK简介参考手册","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"CoordinatorLayout + RecyclerView 处理滑动","date":"2018-12-12T02:25:19.000Z","path":"2018/12/12/recyclerview-scroll/","text":"先看一下设计稿：最底层是个地图，再上面有一些按钮，最上层是路线信息 UI，页面可以滑动，滑动时地图和按钮不动，自然而然想到的 RecyclerView 来实现。早些时候只有 2 个按钮，使用了一种很笨拙的方式，与之前写过的一篇文章类似：一个关于Android滑动“因缺斯厅”的想法。这种方式，相当于有四层：地图-&gt;按钮-&gt;RecyclerView-&gt;与按钮相同位置的View，但是是透明的。界面布局就像这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/vyg__background_gray&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!-- 底层地图 --&gt; &lt;include layout=&quot;@layout/vyg__base_map_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/vyg__route_map_height&quot;/&gt; &lt;!-- 地图上的按钮 --&gt; &lt;LinearLayout android:id=&quot;@+id/mapLayerLl&quot; style=&quot;@style/vyg__map_action&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;12dp&quot; android:layout_marginTop=&quot;84dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:layout_width=&quot;20dp&quot; android:layout_height=&quot;20dp&quot; android:scaleType=&quot;centerInside&quot; android:src=&quot;@drawable/vyg__map_icon_layer&quot;/&gt; &lt;TextView android:id=&quot;@+id/mapLevelTv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;14级&quot; android:textColor=&quot;@color/vyg__font_333&quot; android:textSize=&quot;10sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/fullIv&quot; style=&quot;@style/vyg__map_action&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;12dp&quot; android:layout_marginTop=&quot;184dp&quot; android:scaleType=&quot;centerInside&quot; android:src=&quot;@drawable/vyg__map_icon_fullscreen&quot;/&gt; &lt;LinearLayout android:id=&quot;@+id/fullTrendLl&quot; style=&quot;@style/vyg__map_action&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;12dp&quot; android:layout_marginTop=&quot;134dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:layout_width=&quot;20dp&quot; android:layout_height=&quot;20dp&quot; android:scaleType=&quot;centerInside&quot; android:src=&quot;@drawable/vyg__route_icon_trend&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;趋势图&quot; android:textColor=&quot;@color/vyg__font_333&quot; android:textSize=&quot;10sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;!-- 列表 RecyclerView --&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/detailRv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;50dp&quot; android:clipToPadding=&quot;false&quot;/&gt; &lt;!-- 最上层的透明点击 View --&gt; &lt;ImageView android:id=&quot;@+id/exitFullIv&quot; style=&quot;@style/vyg__map_action&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;12dp&quot; android:layout_marginTop=&quot;140dp&quot; android:scaleType=&quot;centerInside&quot; android:src=&quot;@drawable/vyg__map_icon_fullscreen_exit&quot; android:visibility=&quot;gone&quot;/&gt; &lt;View android:id=&quot;@+id/trendView&quot; android:layout_width=&quot;44dp&quot; android:layout_height=&quot;44dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;12dp&quot; android:layout_marginTop=&quot;134dp&quot;/&gt; &lt;View android:id=&quot;@+id/mapLayerView&quot; android:layout_width=&quot;44dp&quot; android:layout_height=&quot;44dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;12dp&quot; android:layout_marginTop=&quot;84dp&quot;/&gt;&lt;/RelativeLayout&gt; 通过给透明 View 设置点击事件，来实现点击按钮的效果。但是要考虑一点：在界面滑动的时候，RecyclerView 会覆盖到地图上的按钮，这个时候最顶层的透明 View 点击区域应该是要变化的。所以早些时候有了这样的代码： 1234567891011121314151617181920212223trendView.setOnTouchListener &#123; _, event -&gt; if (event.action == MotionEvent.ACTION_UP) &#123; val y = event.y // 102 = 280（地图高度） - 134（trendView.marginTop）- 44（trendView.height） if (trendView.height + DimenUtils.dp2px(102F) - y &gt; offsetY) &#123; switchTrend() &#125; &#125; true&#125;mapLayerView.setOnTouchListener &#123; _, event -&gt; if (event.action == MotionEvent.ACTION_UP) &#123; val y = event.y // 152 = 280（地图高度） - 84（mapLayerView.marginTop）- 44（mapLayerView.height） if (mapLayerView.height + DimenUtils.dp2px(152F) - y &gt; offsetY) &#123; showLayerSwitchDialog() &#125; &#125; true&#125; 一堆 XML 中固定宽高的 dp，十分影响阅读，而且后续每加一个按钮都得这样：先地图上面覆盖一个按钮，然后在 RecyclerView 上层再覆盖一个相同位置透明的 View，并通过 setOnTouchListener 计算滑动位置来实现点击事件，十分繁杂。这次新版需求出来，直接多了3 4个按钮，再这样做我可能会死，只能思考另外的实现方案了。 其实核心思路是，在 RecyclerView 上面添加一个透明的 View，这样便能看到底层的地图和按钮了，但是又不能影响地图上按钮的点击。不幸的是 RecyclerView 会吃掉所有的点击事件，导致事件无法传达至底层的按钮，所以才会有了上面的那种思路。重写 RecyclerView 的 onTouchEvent 返回 false，本身不处理事件，这样底层按钮可以点击了，但是滑动有问题，也不可取。看网上说也有 NestedScrollView + RecyclerView 的，但是这样的话 RecyclerView 的复用机制貌似就没有了，因为它需要测量全部子 View。最后想到的便是 CoordinatorLayout + RecyclerView 了，尝试了一波，可以实现需求！看下调整后的 XML： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/vyg__route_detail_map_action&quot;/&gt; &lt;cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout android:id=&quot;@+id/unFullScreenRoot&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;50dp&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/barLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;330dp&quot; android:background=&quot;@color/vyg__transparent&quot; app:elevation=&quot;0dp&quot;&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_scrollFlags=&quot;scroll&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/detailRv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt; &lt;/cn.mucang.android.voyager.lib.business.route.detail.fragment.MyCoordinatorLayout&gt;&lt;/RelativeLayout&gt; 地图和底层按钮在 vyg__route_detail_map_action 中，然后上层使用 CoordinatorLayout + RecyclerView。透明的 AppBarLayout 在 RecyclerView 上面，使其能看到底层的地图，当滑动时，CoordinatorLayout 会先消费滑动，将 AppBarLayout 往上滑，直至 AppBarLayout 完全消失，RecyclerView 覆盖整个页面。当 AppBarLayout 尚未完全消失时，点击 AppBarLayout，因为其本身没有处理点击事件，所以事件最后会返回到 CoordinatorLayout 的 onTouchEvent，如果不复写，它会返回 true，直接消费点击事件，但是我需要的是不消费点击事件，这样事件就会传递到底层的按钮去响应。所以重写了一下 CoordinatorLayout： 12345678class MyCoordinatorLayout(context: Context, attributeSet: AttributeSet) : CoordinatorLayout(context, attributeSet) &#123; @SuppressLint(&quot;ClickableViewAccessibility&quot;) override fun onTouchEvent(ev: MotionEvent?): Boolean &#123; super.onTouchEvent(ev) return false &#125;&#125; 直接强制返回 false，目前没有发现不良影响。至此，方案完美落幕。地图上的按钮你想加多少就加多少，做不好算我输！","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"无声视频合成音频","date":"2018-11-23T02:02:03.000Z","path":"2018/11/23/media-mix/","text":"上篇文章，通过 MediaProjectionManager 结合 MediaRecorder 进行录屏并生成视频文件。新版本需求产品提了个：视频增加背景音乐，音频文件内置在 Apk 中。那么，怎么生成带音频的视频呢？通过调研发现，在用 MediaPlayer 进行录屏时，可以添加音频源，但是基本是使用麦克风录音，无法指定音频文件。代码如下： 12345678910111213141516171819202122232425/** * 初始化 MediaRecorder */@RequiresApi(Build.VERSION_CODES.LOLLIPOP)private fun initRecorder() &#123; mSaveFile = File(DirUtils.getPublicMediaPath(), &quot;$saveName.tmp&quot;) if (mSaveFile!!.exists()) &#123; mSaveFile!!.delete() &#125; mMediaRecorder = MediaRecorder() mMediaRecorder?.setVideoSource(MediaRecorder.VideoSource.SURFACE) // 使用麦克风录音 mMediaRecorder?.setAudioSource(MediaRecorder.AudioSource.MIC) mMediaRecorder?.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4) mMediaRecorder?.setOutputFile(mSaveFile!!.absolutePath) mMediaRecorder?.setVideoSize(mVideoWidth, mVideoHeight) mMediaRecorder?.setVideoEncoder(MediaRecorder.VideoEncoder.H264) mMediaRecorder?.setVideoEncodingBitRate(VIDEO_BIT_RATE) mMediaRecorder?.setVideoFrameRate(VIDEO_FRAME_RATE) try &#123; mMediaRecorder?.prepare() &#125; catch (e: IOException) &#123; LogUtils.e(TAG, e.toString()) &#125;&#125; 使用此种方案，通过代码mMediaRecorder?.setAudioSource(MediaRecorder.AudioSource.MIC)指定麦克风音频源。可以在录屏开始时，使用 MediaPlayer 进行音乐播放，那么麦克风就可以录入音频了，可是如果此时背景很嘈杂，或者有人说话也会给录进去，需求是只能包含音频文件里的音频，不能有其他的声音，所以此种方案不可行。所以换个思路：将无声视频与音频进行合成，生成一个有声视频。调研了一波，发现了可用的代码，整理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 无声视频添加音频 * 参考代码：https://stackoverflow.com/questions/31572067/android-how-to-mux-audio-file-and-video-file * * audioTrack 的 mime type 只支持： * MediaFormat.MIMETYPE_AUDIO_AMR_NB, * MediaFormat.MIMETYPE_AUDIO_AMR_WB, * MediaFormat.MIMETYPE_AUDIO_AAC */private fun muxing(musicName: String) &#123; val saveFile = File(DirUtils.getPublicMediaPath(), &quot;$saveName.mp4&quot;) if (saveFile.exists()) &#123; saveFile.delete() &#125; try &#123; saveFile.createNewFile() val videoExtractor = MediaExtractor() videoExtractor.setDataSource(mSaveFile!!.absolutePath) val audioExtractor = MediaExtractor() val afdd = MucangConfig.getContext().assets.openFd(musicName) audioExtractor.setDataSource(afdd.fileDescriptor, afdd.startOffset, afdd.length) val muxer = MediaMuxer(saveFile.absolutePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4) videoExtractor.selectTrack(0) val videoFormat = videoExtractor.getTrackFormat(0) val videoTrack = muxer.addTrack(videoFormat) audioExtractor.selectTrack(0) val audioFormat = audioExtractor.getTrackFormat(0) val audioTrack = muxer.addTrack(audioFormat) var sawEOS = false var frameCount = 0 val offset = 100 val sampleSize = 1000 * 1024 val videoBuf = ByteBuffer.allocate(sampleSize) val audioBuf = ByteBuffer.allocate(sampleSize) val videoBufferInfo = MediaCodec.BufferInfo() val audioBufferInfo = MediaCodec.BufferInfo() videoExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC) muxer.start() // 每秒多少帧 val frameRate = videoFormat.getInteger(MediaFormat.KEY_FRAME_RATE) // 得出平均每一帧间隔多少微妙 val videoSampleTime = 1000 * 1000 / frameRate while (!sawEOS) &#123; videoBufferInfo.offset = offset videoBufferInfo.size = videoExtractor.readSampleData(videoBuf, offset) if (videoBufferInfo.size &lt; 0) &#123; sawEOS = true videoBufferInfo.size = 0 &#125; else &#123; videoBufferInfo.presentationTimeUs += videoSampleTime videoBufferInfo.flags = videoExtractor.sampleFlags muxer.writeSampleData(videoTrack, videoBuf, videoBufferInfo) videoExtractor.advance() frameCount++ &#125; &#125; var sawEOS2 = false var frameCount2 = 0 while (!sawEOS2) &#123; frameCount2++ audioBufferInfo.offset = offset audioBufferInfo.size = audioExtractor.readSampleData(audioBuf, offset) if (audioBufferInfo.size &lt; 0) &#123; sawEOS2 = true audioBufferInfo.size = 0 &#125; else &#123; audioBufferInfo.presentationTimeUs = audioExtractor.sampleTime audioBufferInfo.flags = audioExtractor.sampleFlags muxer.writeSampleData(audioTrack, audioBuf, audioBufferInfo) audioExtractor.advance() &#125; &#125; muxer.stop() muxer.release() videoExtractor.release() audioExtractor.release() afdd.close() // 删除无声视频文件 mSaveFile?.delete() &#125; catch (e: Exception) &#123; LogUtils.e(TAG, &quot;Mixer Error:&quot; + e.message) // 视频添加音频合成失败，直接保存视频 mSaveFile?.renameTo(saveFile) &#125; finally &#123; MainThreadUtils.post &#123; listener?.finishRecord() if (mSaveFile != null) &#123; val intent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) intent.data = Uri.fromFile(saveFile) MucangConfig.getContext().sendBroadcast(intent) ToastUtils.toast(&quot;已保存到相册&quot;) &#125; mSaveFile = null &#125; &#125;&#125; 注意代码中的videoSampleTime，如果不加这个，代码在部分机型上会合成失败。 这里重点关注下bufferInfo.presentationTimeUs &#x3D; mediaExtractor.getSampleTime()因为mediaExtractor的提取顺序应该是dts的顺序不是pts的顺序，如果视频中存在b帧则getSampleTime不可能递增的，所以bufferInfo.presentationTimeUs&#x3D;mediaExtractor.getSampleTime()可能会报错，前面说了这个值必须递增。如果不存在b帧，pts&#x3D;&#x3D;dts，使用没问题。 参考： android - How to mux audio file and video file? MediaMuxer和MediaExtractor","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"录制仿 Keep 轨迹动画视频","date":"2018-10-18T09:01:32.000Z","path":"2018/10/18/screen-record/","text":"最近 Keep 更新了一个轨迹动画的分享，可以生成一个看起来高大上的视频。项目产品也提出了一样的需求，便参照着实现了一波。效果如下（虚拟机跑动画就已经很卡了，然后还要录 gif 就更卡了，凑合看~）： 整体思路就是： Android 原生播放动画（基于高德地图实现） 录制屏幕生成视频 播放动画无非就是一次画一条线，连起来就像一个点一直在往前面爬的效果了。然后请求录制屏幕，输出到一个文件，最后保存为视频即可。Android 录屏核心思路是使用系统 Api MediaProjectionManager，需要 Android 5.0 以上才可以使用。鉴于目前市场 Android 5.0 的手机已经很少了，所以便直接使用 MediaProjectionManager 了。使用步骤： mMediaProjectionManager.createScreenCaptureIntent() 申请录屏权限（因为要保存文件所以需要申请 WRITE_EXTERNAL_STORAGE 权限） 用户同意之后，初始化 VirtualDisplay 创建 MediaRecorder，设置好相关参数，核心设置视频源为 SURFACE： setVideoSource(MediaRecorder.VideoSource.SURFACE) 录制结束后释放资源，保存文件 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 录屏帮助类，仅限 Android 5.0 及以上使用 */class ScreenRecorder(val activity: Activity, val listener: VideoRecordListener?, private val saveName: String) &#123; private val REQUEST_MEDIA_PROJECTION_CODE = 1000 /** * 录制视频的分辨率、比特率、帧率 */ private var mVideoWidth: Int private var mVideoHeight: Int private val VIDEO_BIT_RATE = 12 * 1024 * 1024 private val VIDEO_FRAME_RATE = 60 @RequiresApi(Build.VERSION_CODES.LOLLIPOP) private var mMediaProjectionManager = activity.getSystemService(Context.MEDIA_PROJECTION_SERVICE) as? MediaProjectionManager private var mMediaRecorder: MediaRecorder? = null private var mVirtualDisplay: VirtualDisplay? = null private var mMetrics = DisplayMetrics() private var mSaveFile: File? = null init &#123; activity.windowManager.defaultDisplay.getMetrics(mMetrics) mVideoWidth = mMetrics.widthPixels mVideoHeight = mMetrics.heightPixels &#125; /** * 开始录制 */ @RequiresApi(Build.VERSION_CODES.LOLLIPOP) fun startRecord() &#123; PermissionUtils.requestPermissions(activity, PermissionsCallback &#123; if (it.grantedAll) &#123; listener?.beforeRecord() StartForResult.from(activity).startForResult(mMediaProjectionManager!!.createScreenCaptureIntent(), REQUEST_MEDIA_PROJECTION_CODE) &#123; requestCode, resultCode, data -&gt; if (requestCode == REQUEST_MEDIA_PROJECTION_CODE &amp;&amp; resultCode == Activity.RESULT_OK) &#123; initRecorder() MainThreadUtils.postDelayed(&#123; val mp = mMediaProjectionManager!!.getMediaProjection(resultCode, data) mVirtualDisplay = mp.createVirtualDisplay(&quot;ScreenCapture&quot;, mVideoWidth, mVideoHeight, mMetrics.densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, mMediaRecorder?.surface, null, null) mMediaRecorder?.start() listener?.startRecord() &#125;, 300) &#125; else &#123; listener?.cancelRecord() &#125; &#125; &#125; else &#123; ToastUtils.toast(&quot;录屏需要写存储权限&quot;) &#125; &#125;, Manifest.permission.WRITE_EXTERNAL_STORAGE) &#125; /** * 录制中断，删除视频文件 */ fun interruptRecord() &#123; releaseRecorder() if (mSaveFile != null) &#123; ToastUtils.toast(&quot;视频保存失败&quot;) &#125; mSaveFile?.delete() mSaveFile = null &#125; /** * 结束录制 */ fun finishRecord() &#123; releaseRecorder() if (mSaveFile != null) &#123; val newFile = File(DirUtils.getPublicMediaPath(), &quot;$saveName.mp4&quot;) // 录制结束后修改后缀为 mp4 mSaveFile!!.renameTo(newFile) val intent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) intent.data = Uri.fromFile(newFile) MucangConfig.getContext().sendBroadcast(intent) ToastUtils.toast(&quot;已保存到相册&quot;) &#125; mSaveFile = null &#125; /** * 释放资源 */ private fun releaseRecorder() &#123; mMediaRecorder?.stop() mMediaRecorder?.release() mMediaRecorder = null mVirtualDisplay?.release() mVirtualDisplay = null &#125; /** * 初始化 MediaRecorder */ @RequiresApi(Build.VERSION_CODES.LOLLIPOP) private fun initRecorder() &#123; mSaveFile = File(DirUtils.getPublicMediaPath(), &quot;$saveName.tmp&quot;) if (mSaveFile!!.exists()) &#123; mSaveFile!!.delete() &#125; mMediaRecorder = MediaRecorder() mMediaRecorder?.setVideoSource(MediaRecorder.VideoSource.SURFACE) mMediaRecorder?.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4) mMediaRecorder?.setOutputFile(mSaveFile!!.absolutePath) mMediaRecorder?.setVideoSize(mVideoWidth, mVideoHeight) mMediaRecorder?.setVideoEncoder(MediaRecorder.VideoEncoder.H264) mMediaRecorder?.setVideoEncodingBitRate(VIDEO_BIT_RATE) mMediaRecorder?.setVideoFrameRate(VIDEO_FRAME_RATE) try &#123; mMediaRecorder?.prepare() &#125; catch (e: IOException) &#123; LogUtils.e(&quot;ScreenRecorder&quot;, e.toString()) &#125; &#125; interface VideoRecordListener &#123; /** * 录制开始时隐藏不必要的UI */ fun beforeRecord() /** * 开始录制 */ fun startRecord() /** * 取消录制 */ fun cancelRecord() &#125;&#125;","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"startActivityForResult 的封装使用","date":"2018-10-10T08:59:25.000Z","path":"2018/10/10/start-for-result/","text":"startActivityForResult 相信大家都用过，调用和返回结果是分散开的，使用起来最好还是封装一下比较好。这里利用一个空的 Fragment 进行封装，代码比较简单。封装的回调类 StartForResultListener： 12345678public interface StartForResultListener &#123; /** * StartActivityForResult回调，同&#123;@link android.app.Activity#onActivityResult(int, int, Intent)&#125; */ void onActivityResult(int requestCode, int resultCode, Intent data);&#125; 接收回调的 Fragment： 12345678910111213141516public class StartForResultFragment extends Fragment &#123; private StartForResultListener mListener; public void setListener(StartForResultListener listener) &#123; mListener = listener; &#125; @Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (mListener != null) &#123; mListener.onActivityResult(requestCode, resultCode, data); mListener = null; &#125; &#125;&#125; 封装入口类 StartForResult： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StartForResult &#123; private static final String TAG = &quot;StartForResult&quot;; private static final String FRAG_TAG = &quot;__start_for_result&quot;; private StartForResultFragment mFragment; public static StartForResult from(Activity activity) &#123; return new StartForResult(activity); &#125; private StartForResult(Activity activity) &#123; if (!isActivityValid(activity)) &#123; LogUtils.e(TAG, &quot;Activity is null or has finished&quot;); return; &#125; mFragment = (StartForResultFragment) activity.getFragmentManager().findFragmentByTag(FRAG_TAG); if (mFragment == null) &#123; mFragment = new StartForResultFragment(); activity.getFragmentManager() .beginTransaction() .add(mFragment, FRAG_TAG) .commitAllowingStateLoss(); activity.getFragmentManager().executePendingTransactions(); &#125; &#125; public void startForResult(Intent intent, int requestCode, StartForResultListener listener) &#123; if (requestCode &lt;= 0 || listener == null) &#123; LogUtils.w(TAG, &quot;RequestCode should in &gt;0 and listener should not be null&quot;); &#125; if (mFragment == null) &#123; LogUtils.w(TAG, &quot;Please check you activity state&quot;); return; &#125; mFragment.setListener(listener); mFragment.startActivityForResult(intent, requestCode); &#125; @SuppressWarnings(&quot;RedundantIfStatement&quot;) private static boolean isActivityValid(Activity activity) &#123; if (activity == null || activity.isFinishing()) &#123; return false; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1 &amp;&amp; activity.isDestroyed()) &#123; return false; &#125; return true; &#125;&#125; 使用时，仅需要传入一个 Activity： 123StartForResult.from(activity).startForResult(intent, REQUEST_CODE_FOR_PIC) &#123; requestCode, resultCode, data -&gt; // 处理返回的结果&#125; 这样，逻辑不在分散，在哪里调用在哪里处理结果，不用再跳来跳去了~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 开发减少 shape 文件","date":"2018-09-27T09:15:17.000Z","path":"2018/09/27/shape/","text":"作为一名 Android 开发者，对于 shape 文件肯定不会陌生。但是，用时一时爽，到后面遇到缩包要求时，或者强迫症开发者不希望有重复的 shape 文件，便是有苦说不出了。通常，我们定义 shape 文件可能会根据业务来，代表这个 shape 文件在哪里用到，举个栗子：vyg__route_search_bg_selector.xml，开发人员看到这个 shape 文件可以知道是在路线搜索页面用到的。可是这样命名，当开发人员各自独立开发时，可能会有一大堆业务相关的 shape 文件，可能会和其他开发人员相关业务重复了。所以后面我们干脆改成这样了：vyg__shape_r2_f7f7f7.xml，代表 2dp 的 radius，然后填充色是 #F7F7F7。如果项目设计师严格按照一套标准来设计所有的背景，这样命名一套 shape 文件可以做到复用了。可如果设计师经常换人，或者不够专业等等其他原因，这里一个颜色，那里又是另外一个颜色，或者把 2dp 的圆角变成 4dp，如此下来，shape 文件依然会很多。就像这样： 现在做的项目还是个新项目，看着这日益增多的 shape 文件感觉还是得采取点措施处理一下。本着不重复造轮子的原则，Google 了一波，发现这是广大开发者都面对过的一个问题，目前看到的有几个方案。 自定义View通过自定义 View 或 ViewGroup，解析对应的 xml 属性，来生成相应的 BackgroundDrawable，这种方式不太灵活，即使用到 Android 自带的 TextView 等控件也得在 xml 中声明自定义的 View，比较蛋疼。最新的 support 包里也出了一个 Material Button，可以来设置简单的 shape 属性，和这个类似。 参考：是时候跟 shape 标签说拜拜了Material Button 代码生成通过代码直接生成相应的 BackgroundDrawable，然后设置到 View 上。比如这样： 1234FSelector.with(tvtext1) .addDrawable().circleAngle(dp2px(15)).bgColor(getColors(R.color.clr_fb720e)) .create() .bind(); 这种显然也不行的，每个 View 要设置背景得写多少这种代码？还不如直接写 shape 得了。 参考：解放双手,提高编码效率,减少大量的selecor文件 BackgroundLibrary有没有一种更好的方式呢？找了一阵子，终于找到了个还比较满意的：BackgroundLibrary针对这个库，作者也写了篇文章进行相关的说明，还不错。无需自定义View，彻底解放shape，selector吧引入只需要在BaseActivity里添加如下代码： 1BackgroundLibrary.inject(this) 然后直接在 xml 中声明对应的属性即可。通过这种方式，比较省心，也没有其他不必要的依赖，已经可以应付绝大多数场景了。用的是 Google 提供的 Api，没有使用到反射，针对高版本可能的非 SDK 接口限制的问题也不存在。缺点就是不能实时预览，也没有属性提示，熟悉后问题不大。实现原理作者也说了：通过低入侵的方式，加入一个自定义的 LayoutInflater.Factory，去解析添加的自定义属性，然后生成系统提供的 GradientDrawable、RippleDrawable、StateListDrawable 即可。目前来看算是最好的方案了，先用着，后面有问题再跟进，给作者点个赞~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"「小米MIX2」全面屏适配","date":"2018-09-13T02:53:11.000Z","path":"2018/09/13/phone-adapt/","text":"有这样一个需求：作为一个 Android 开发者，首先想到的就是用 PopupWindow 来实现。底部阴影的高度固定，剩余的高度全部填充到 PopupWindow，然后调用 PopupWindow 的 showAsDropDown 让它在应用标题栏下面显示就行了。 首先适配全面屏，在 AndroidManifest.xml 中添加如下代码： 1&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.1&quot; /&gt; 大体代码如下： 123456789class FilterPopup(val context: Activity) : PopupWindow(context) &#123; init &#123; val root = View.inflate(context, R.layout.popup, null) as LinearLayout width = ViewGroup.LayoutParams.MATCH_PARENT height = ViewGroup.LayoutParams.WRAP_CONTENT contentView = root // 省略...&#125; 本以为就结束了，结果在我的「小米MIX2」手机上显示有问题，底部会有一条白边，十分难受。于是我尝试把 height 设置成 MATCH_PARENT，白边是没了，但是整个 PopupWindow 占据了整个屏幕的高度，直接覆盖住了应用的标题栏。于是我开始设置 root 的 paddingTop 为标题栏的高度，嗯，显示刚刚好。可是在全国加点击事件时就尴尬了：点击事件给 PopupWindow 吃掉了。如果只有一个按钮，可以在 PopupWindow 上面覆盖个同样位置的 View fake 一下，可是标题栏还有搜索，想想比较麻烦就打消这个念头了。设置 MATCH_PARENT 不行，我直接设置真正的高度行不行呢？参照界面： 1height = 屏幕高度 - 状态栏高度 - 标题栏高度 - 导航栏高度（如果有显示导航栏） 获取屏幕高度： 1context.resources.displayMetrics.heightPixels 获取状态栏高度： 1Resources.getSystem().getDimensionPixelSize(Resources.getSystem().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;)); 标题栏高度是写死的 48dp。然后就是判断是否有导航栏，有也要减去导航栏的高度： 1234567891011121314151617fun getNavigationBarHeight(wm: WindowManager): Int &#123; if (!isNavigationBarShow(wm)) &#123; return 0 &#125; val resources = context.resources val resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;) return resources.getDimensionPixelSize(resourceId)&#125;fun isNavigationBarShow(wm: WindowManager): Boolean &#123; val display = wm.defaultDisplay val size = Point() val realSize = Point() display.getSize(size) display.getRealSize(realSize) return realSize.y != size.y&#125; 嗯，如果一切真这么顺利就不会有这篇文章了。首先获取屏幕高度就一直是错误的。方法返回 2030，可「小米MIX2」的高度是 2160 像素，差了 130。只能用如下方法才能获取到 2160： 123val outMetrics = DisplayMetrics()context.windowManager.defaultDisplay.getRealMetrics(outMetrics)outMetrics.heightPixels 关于刚刚的 130，经查阅正好是导航栏的高度。可我手机当前是全面屏手势的模式，没有显示导航栏，所以，还得判断是否是全面屏。又查阅了一番： 12345678910111213141516171819202122232425262728293031/** * 判断设备是否存在NavigationBar * * @return true 存在, false 不存在 */public static boolean deviceHasNavigationBar() &#123; boolean haveNav = false; try &#123; Class&lt;?&gt; windowManagerGlobalClass = Class.forName(&quot;android.view.WindowManagerGlobal&quot;); Method getWmServiceMethod = windowManagerGlobalClass.getDeclaredMethod(&quot;getWindowManagerService&quot;); getWmServiceMethod.setAccessible(true); Object iWindowManager = getWmServiceMethod.invoke(null); Class&lt;?&gt; iWindowManagerClass = iWindowManager.getClass(); Method hasNavBarMethod = iWindowManagerClass.getDeclaredMethod(&quot;hasNavigationBar&quot;); hasNavBarMethod.setAccessible(true); haveNav = (Boolean) hasNavBarMethod.invoke(iWindowManager); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return haveNav;&#125;public static boolean miuiNavigationGestureEnabled(Context context) &#123; try &#123; return Settings.Global.getInt(context.getContentResolver(), &quot;force_fsg_nav_bar&quot;) != 0; &#125; catch (Settings.SettingNotFoundException e) &#123; e.printStackTrace(); &#125; return false;&#125; 获取导航栏高度的方法返回的值倒是准确的，可是 isNavigationBarShow 方法则是一直返回的 true，即使我当前是全面屏手势模式，没有显示导航栏。最后整合一下： 123456789val outMetrics = DisplayMetrics()context.windowManager.defaultDisplay.getRealMetrics(outMetrics)var height = outMetrics.heightPixels - SystemUtils.getStateBarHeight() - DimenUtils.dp2px(48)if (SystemUtils.deviceHasNavigationBar() &amp;&amp; !SystemUtils.miuiNavigationGestureEnabled(context)) &#123; height -= SystemUtils.getNavigationBarHeight(context.windowManager)&#125;this.height = height 如此在我手机上，能够完美运行了。但是针对其他厂商的全面屏，还需要判断 Rom 类型，再判断是否开启全面屏手势，本文在此不做详细描述，可自行 Google。这里贴下 oppo 手机全面屏是否开启的方法： 1234567private static final String NAVIGATION_GESTURE = &quot;navigation_gesture_on&quot;;private static final int NAVIGATION_GESTURE_OFF = 0;public static boolean vivoNavigationGestureEnabled(Context context) &#123; int val = Settings.Secure.getInt(context.getContentResolver(), NAVIGATION_GESTURE, NAVIGATION_GESTURE_OFF); return val != NAVIGATION_GESTURE_OFF;&#125; 但是这样针对不同的 Rom 要做很多种判断，总感觉不靠谱。后面找到一种方式来判断是否展示导航栏： 1234567891011121314/** * 判断是否显示导航栏 */private fun isNavigationBarExist(activity: Activity): Boolean &#123; val vp = activity.window.decorView as? ViewGroup if (vp != null) &#123; for (i in 0 until vp.childCount) &#123; if (vp.getChildAt(i).id != NO_ID &amp;&amp; &quot;navigationBarBackground&quot; == activity.resources.getResourceEntryName(vp.getChildAt(i).id)) &#123; return true &#125; &#125; &#125; return false&#125; 经测试，在我的 MIX2 及同事的华为手机上，展示正常，在一些测试机上展示也 ok，便先采取这种方式了。 参考：MIX2 获取屏幕高度Bug判断用户是否打开了全面屏手势Android获取系统的硬件信息、系统版本以及如何检测ROM类型Android APP适配全面屏手机的技术要点Android全面屏虚拟导航栏适配","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"关于使用 kotlin 碰到的一个坑（三）","date":"2018-08-22T03:30:31.000Z","path":"2018/08/22/kotlin-question3/","text":"近期整理代码，出现了一个空指针异常，其源头为 MapController 类的一个方法： 123456789public void addOnMarkerClickListener(AMap.OnMarkerClickListener onMarkerClickListener) &#123; if (onMarkerClickListener == null) &#123; throw new NullPointerException(&quot;onMarkerClickListener can not null&quot;); &#125; if (onMarkerClickListeners == null) &#123; onMarkerClickListeners = new HashSet&lt;&gt;(); &#125; onMarkerClickListeners.add(onMarkerClickListener);&#125; 然后看到 kotlin 代码： 123456789101112131415class MapControllerTest1(val mapController: MapController) &#123; init &#123; init() &#125; private val onMarkClickListener = OnMarkerClickListener &#123; false &#125; private fun init() &#123; // do other things ... mapController.addOnMarkerClickListener(onMarkClickListener) &#125;&#125; 说明在执行 init 时 onMarkClickListener 为 null。编译 kotlin 代码到 Java 代码看看： 12345678910111213141516171819202122public final class MapControllerTest1 &#123; private final OnMarkerClickListener onMarkClickListener; @NotNull private final MapController mapController; private final void init() &#123; this.mapController.addOnMarkerClickListener(this.onMarkClickListener); &#125; @NotNull public final MapController getMapController() &#123; return this.mapController; &#125; public MapControllerTest1(@NotNull MapController mapController) &#123; Intrinsics.checkParameterIsNotNull(mapController, &quot;mapController&quot;); super(); this.mapController = mapController; this.init(); this.onMarkClickListener = (OnMarkerClickListener)null.INSTANCE; &#125;&#125; 可以看到 init 方法是在设置 onMarkClickListener 之前执行的，所以会报空指针异常。将代码改成如下： 123456789101112131415class MapControllerTest1(val mapController: MapController) &#123; private val onMarkClickListener = OnMarkerClickListener &#123; false &#125; init &#123; init() &#125; private fun init() &#123; // do other things ... mapController.addOnMarkerClickListener(onMarkClickListener) &#125;&#125; 此时便不会报空指针异常了。编译到 Java 代码查看： 12345678910111213141516171819202122public final class MapControllerTest1 &#123; private final OnMarkerClickListener onMarkClickListener; @NotNull private final MapController mapController; private final void init() &#123; this.mapController.addOnMarkerClickListener(this.onMarkClickListener); &#125; @NotNull public final MapController getMapController() &#123; return this.mapController; &#125; public MapControllerTest1(@NotNull MapController mapController) &#123; Intrinsics.checkParameterIsNotNull(mapController, &quot;mapController&quot;); super(); this.mapController = mapController; this.onMarkClickListener = (OnMarkerClickListener)null.INSTANCE; this.init(); &#125;&#125; 先赋值 onMarkClickListener，才执行 init，很显然不会报异常了。我们可以理解 init 为初始化代码块，若换成 Java 代码，则不论 onMarkerClickListener 在何处声明，都不会抛异常。 1234567891011121314151617181920public class MapControllerTest2 &#123; private MapController mapController; public MapControllerTest2(MapController mapController) &#123; this.mapController = mapController; init(mapController); &#125; private void init(MapController mapController) &#123; mapController.addOnMarkerClickListener(onMarkerClickListener); &#125; private AMap.OnMarkerClickListener onMarkerClickListener = new AMap.OnMarkerClickListener() &#123; @Override public boolean onMarkerClick(Marker marker) &#123; return false; &#125; &#125;;&#125; 给我的感觉就是 Kotlin 初始化顺序与 Java 不同了。查看到 Koltin 文档，看到这样一段： 主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起： 12345678910111213class InitOrderDemo(name: String) &#123; val firstProperty = &quot;First property: $name&quot;.also(::println) init &#123; println(&quot;First initializer block that prints $&#123;name&#125;&quot;) &#125; val secondProperty = &quot;Second property: $&#123;name.length&#125;&quot;.also(::println) init &#123; println(&quot;Second initializer block that prints $&#123;name.length&#125;&quot;) &#125;&#125; 划重点：初始化块按照它们出现在类体中的顺序执行。所以在 init 之后声明的变量在 init 中是调用不了的。将代码改成如下，会直接就编译不过： 123456789101112131415class MapControllerTest1(val mapController: MapController) &#123; init &#123; init() mapController.addOnMarkerClickListener(onMarkClickListener) &#125; private val onMarkClickListener = OnMarkerClickListener &#123; false &#125; private fun init() &#123; // do other things ... &#125;&#125; 此时会提示：Variable ‘onMarkClickListener’ must be initialized。只是凑巧我将 addOnMarkerClickListener 放到了另外一个函数体里面，导致编译通过，规避了这个问题。所以在写 Kotlin 的时候要注意代码的顺序！ 再摘一段比较重要的： 请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块： 123456789class Constructors &#123; init &#123; println(&quot;Init block&quot;) &#125; constructor(i: Int) &#123; println(&quot;Constructor&quot;) &#125;&#125; 执行结果： 12Init blockConstructor 试了一下，将代码改成如下： 12345678910111213141516171819class MapControllerTest1(val mapController: MapController) &#123; private var onMarkClickListener: OnMarkerClickListener? = null init &#123; init() mapController.addOnMarkerClickListener(onMarkClickListener) &#125; constructor(mapController: MapController, param: Int) : this(mapController) &#123; onMarkClickListener = OnMarkerClickListener &#123; false &#125; &#125; private fun init() &#123; // do other things ... &#125;&#125; 确实会抛异常。 文档很重要呀~ 参考：类与继承","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android 保活实践","date":"2018-08-16T05:55:56.000Z","path":"2018/08/16/keep-alive/","text":"作为 Android 开发者，当提到“保活”时，心中的滋味可谓是五味杂陈。互联网上也有各种“黑科技”来达到相应的目的。若是普通的应用，我是十分拒绝进行保活的，当用户不需要你了，还要偷偷地活着，做一些事情。最近参与开发的一款 App 是跟地图相关的，有着「录轨迹」的功能，当用户开启录制功能后，即使退出应用到后台，也是期望能够继续录制的，所以便研究了一番保活，并实践了一下，最后效果也还不错。说下总体方案：1 像素 Activity 、音频播放、前台服务。 首先，监听锁屏相关的广播： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class ScreenReceiver &#123; private static final String TAG = &quot;ScreenReceiver&quot;; private Context mContext; // 锁屏亮屏广播接收器 private ScreenBroadcastReceiver mScreenReceiver; // 屏幕状态改变回调接口 private ScreenStateListener mStateReceiverListener; public ScreenReceiver(Context mContext) &#123; this.mContext = mContext; &#125; public void register(ScreenStateListener mStateReceiverListener) &#123; this.mStateReceiverListener = mStateReceiverListener; // 动态启动广播接收器 this.mScreenReceiver = new ScreenBroadcastReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_ON); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(Intent.ACTION_USER_PRESENT); mContext.registerReceiver(mScreenReceiver, filter); &#125; public void unRegister() &#123; mContext.unregisterReceiver(mScreenReceiver); &#125; public class ScreenBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); LogUtils.e(TAG, &quot;ScreenBroadcastReceiver onReceive() action: &quot; + action); if (mStateReceiverListener == null) &#123; return; &#125; if (Intent.ACTION_SCREEN_ON.equals(action)) &#123; // 亮屏 mStateReceiverListener.onScreenOn(); &#125; else if (Intent.ACTION_SCREEN_OFF.equals(action)) &#123; // 息屏 mStateReceiverListener.onScreenOff(); &#125; else if (Intent.ACTION_USER_PRESENT.equals(action)) &#123; // 解锁 mStateReceiverListener.onUserPresent(); &#125; &#125; &#125; public interface ScreenStateListener &#123; /** * 屏幕亮屏 */ void onScreenOn(); /** * 屏幕息屏 */ void onScreenOff(); /** * 用户解锁 */ void onUserPresent(); &#125;&#125; 保活管理类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class KeepAliveManager &#123; public static final String BUSINESS_NAME_RECORD = &quot;BUSINESS_NAME_RECORD&quot;; @StringDef(&#123;BUSINESS_NAME_RECORD&#125;) @Retention(RetentionPolicy.SOURCE) public @interface KeepAliveName &#123;&#125; private static KeepAliveManager keepAliveManager = new KeepAliveManager(); private ScreenReceiver screenReceiver; private MediaPlayer mMediaPlayer; /** * 记录需要保活的业务功能名称 * 优点: * 1、不同业务的生命周期不同，避免不同业务之间需要通知当前状态、状态变更 * 2、当没有业务需要保活app时，自动关闭保活 * 3、用HashSet是因为它不允许add相同元素，如果添加相同元素也只会保存一份 */ private Set&lt;String&gt; needAliveBusinessName = new HashSet&lt;&gt;(); private KeepAliveManager() &#123; &#125; public static KeepAliveManager getInstance() &#123; return keepAliveManager; &#125; /** * 在需要保活的业务启动时 开启 */ public void start(@KeepAliveName String businessName) &#123; needAliveBusinessName.add(businessName); if (screenReceiver != null) &#123; //不需要重复保活 return; &#125; screenReceiver = new ScreenReceiver(MucangConfig.getContext()); screenReceiver.register(new ScreenReceiver.ScreenStateListener() &#123; @Override public void onScreenOn() &#123; ScreenManager.getInstance().finishActivity(); &#125; @Override public void onScreenOff() &#123; ScreenManager.getInstance().startActivity(); playMusic(); &#125; @Override public void onUserPresent() &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.stop(); &#125; &#125; &#125;); &#125; public void stop(@KeepAliveName String businessName) &#123; needAliveBusinessName.remove(businessName); // 当没有业务功能需要保活时，需要退出保活监听 if (needAliveBusinessName.size() == 0) &#123; if (screenReceiver != null) &#123; screenReceiver.unRegister(); screenReceiver = null; &#125; &#125; &#125; private void playMusic() &#123; mMediaPlayer = MediaPlayer.create(MucangConfig.getContext(), R.raw.silent); mMediaPlayer.setLooping(true); mMediaPlayer.start(); &#125;&#125; 很简单的一个单例类，调用 start 方法传入对应的业务启动保活，保活只会在锁屏时开启。当没有处于需要保活的业务场景时，则不会启动保活。然后看到 ScreenManager： 1234567891011121314151617181920212223242526272829303132333435363738public class ScreenManager &#123; private static final String TAG = &quot;ScreenManager&quot;; private Context mContext; private static ScreenManager mScreenManager; private WeakReference&lt;Activity&gt; mActivityRef; private ScreenManager() &#123; mContext = MucangConfig.getContext(); &#125; public static ScreenManager getInstance() &#123; if (mScreenManager == null) &#123; mScreenManager = new ScreenManager(); &#125; return mScreenManager; &#125; public void setSingleActivity(Activity mActivity) &#123; mActivityRef = new WeakReference&lt;&gt;(mActivity); &#125; public void startActivity() &#123; LogUtils.e(TAG, &quot;start LockScreenActivity...&quot;); Intent intent = new Intent(mContext, LockScreenActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(intent); &#125; public void finishActivity() &#123; LogUtils.e(TAG, &quot;finish LockScreenActivity...&quot;); if (mActivityRef != null) &#123; Activity mActivity = mActivityRef.get(); if (mActivity != null) &#123; mActivity.finish(); &#125; &#125; &#125;&#125; 主要功能就是启动、关闭一个 1 像素的 Activity。看下 LockScreenActivity： 123456789101112131415161718192021222324252627282930313233/** * 自定义锁屏activity * 注: * 1、锁屏时启动，用于将可能处于后台的进程拉到前台，降低被 Low Memory Killer 清理的概率 * 2、若此时本应用的进程已经处于前台进程，再加强一下也有利于保活 */public class LockScreenActivity extends FragmentActivity &#123; private static final String TAG = &quot;LockScreenActivity&quot;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); LogUtils.e(TAG, &quot;LockScreenActivity onCreate()&quot;); Window mWindow = getWindow(); mWindow.setGravity(Gravity.LEFT | Gravity.TOP); WindowManager.LayoutParams attrParams = mWindow.getAttributes(); attrParams.x = 0; attrParams.y = 0; attrParams.height = 1; attrParams.width = 1; mWindow.setAttributes(attrParams); ScreenManager.getInstance().setSingleActivity(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); LogUtils.e(TAG, &quot;LockScreenActivity onDestroy()&quot;); &#125;&#125; 同时，录制轨迹的服务使用 startForeground 方式。 12345678public class RecordService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); startForeground(1, createNotification(&quot;记录轨迹中&quot;, &quot;正在后台记录轨迹&quot;)); &#125;&#125; 结合以上代码，可以达到不错的保活效果了。可以看到，代码比较克制，只在特定需要保活的业务场景才开启保活，绝不会在后台不经用户同意做一些“恶心”的事情。另外，锁屏播放无声音乐会比较耗电，需要优化，可以在一段时间内播放一次。同时播放音乐可能会与有些音乐、视频 App 的播放冲突，从而达不到保活效果，这些都是可优化的方向。 参考：Android 进程保活招式大全","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 列表 Header 吸顶效果","date":"2018-07-23T07:19:58.000Z","path":"2018/07/23/sticky-header/","text":"现在 Android 开发中列表 Header 吸顶效果比较常见了，针对 ListView、RecyclerView 都有多种实现方式。之前开发也碰到过，都是用的三方库或者框架。今天主要写下直接利用 Android 原生来进行实现。页面大致如下： 针对本文的场景，相当于一个 HEADER 对应一组 Image。所以，最好是有个 Map 结构，然后每个 Image item 都能清楚的知道自己所属哪个 HEADER。 12345678910111213141516171819202122class MatchedImageAdapter(val map: LinkedHashMap&lt;HEADER, List&lt;Image&gt;&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123; private val dataList = ArrayList&lt;Any&gt;() private var currentKey: HEADER? = null init &#123; map.forEach &#123; dataList.add(it.key) dataList.addAll(it.value) &#125; &#125;&#125;/** * path 图片地址 * key 对应的 HEADER * date 时间 * selected 是否选中 */class Image(val path: String?, var key: HEADER?, var date: Long = 0, var lat: Double = 0.0, var lng: Double = 0.0, var selected: Boolean = false) : Serializable 然后按照这个结构，利用泛型，来实现列表多 Type 效果。 123456789private val dataList = ArrayList&lt;Any&gt;()override fun getItemViewType(position: Int): Int &#123; return if (dataList[position] is Header) &#123; TYPE_HEADER &#125; else &#123; TYPE_IMAGE_ITEM &#125;&#125; 另外，针对图片 Item 的网格布局，直接使用 GridLayoutManager 的 spanSize 就能达到效果。 12345678910val layoutManager = GridLayoutManager(context, MAX_COUNT)layoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() &#123; override fun getSpanSize(position: Int): Int &#123; return if (adapter!!.getItemViewType(position) == HEADER) &#123; 1 &#125; else &#123; 3 &#125; &#125;&#125; 看到 Header 有个“选择”按钮是可以点击的，所以就有了本文。不用支持点击的话，可以直接使用 ItemDecoration 来达到吸顶效果了。如果要支持点击效果，我采取的方案是：在 RecyclerView 上面盖一层 Header，然后用过滑动监听来设置 Header 的偏移，从而达到吸顶效果。那么核心便是滑动的监听了： 1234567891011121314151617181920212223242526272829303132333435matchedImageRv.addOnScrollListener(object : RecyclerView.OnScrollListener() &#123; override fun onScrolled(recyclerView: RecyclerView?, dx: Int, dy: Int) &#123; if (CollectionUtils.isEmpty(adapter!!.getDataList())) &#123; return &#125; // 获取到视图中第一个可见的item的position val firstVisiblePosition = layoutManager.findFirstVisibleItemPosition() if (firstVisiblePosition &lt; 0 || firstVisiblePosition &gt;= adapter!!.getDataList().size) &#123; return &#125; // 获取第一个 item 的 VH val viewHolder = matchedImageRv.findViewHolderForLayoutPosition(firstVisiblePosition) ?: return // 记录当前位置的数据 currentHeader = adapter!!.getDataList()[firstVisiblePosition] // 是否应该平移 HEADER val shouldTranslationY = shouldTranslationY(firstVisiblePosition) // 根据高度及 top 值判断是否需要设置 translationY val height = autoMatchHeader.height if (shouldTranslationY &amp;&amp; viewHolder.itemView.height + viewHolder.itemView.top &lt; height) &#123; val translationY = viewHolder.itemView.height + viewHolder.itemView.top - height autoMatchHeader.translationY = translationY.toFloat() &#125; else &#123; autoMatchHeader.translationY = 0f &#125; // 更新悬浮 Header 信息 refreshHeader() &#125;&#125;) 看下 shouldTranslationY 的代码： 123456789101112131415161718/** * 只有下一行数据是 Header，才应该进行平移 */fun shouldTranslationY(position: Int): Boolean &#123; if (adapter!!.getDataList()[position] is HEADER) &#123; return false &#125; for (i in 0 until 3) &#123; if (position + 1 + i &lt; adapter!!.getDataList().size) &#123; val data = adapter!!.getDataList()[position + 1 + i] if (data is HEADER) &#123; return true &#125; &#125; &#125; return false&#125; position 是当前位置，如果当前位置是 HEADER，那么下一行数据肯定不是 HEADER，直接返回 false。如果当前位置是图片 item，那么往下数 3 个，一定能得到下一行数据的类型。中途有可能被 HEADER 类型截断，从而直接返回。然后结合高度，top 值，来判断是否需要设置 translationY，从而达到吸顶效果。然后看下覆盖 HEADER 的点击事件设置： 123456789autoMatchHeader.selectAllTv.setOnClickListener &#123; val header = if (currentHeader is Image) &#123; (currentHeader as Image).key &#125; else &#123; currentHeader &#125; as HEADER adapter!!.onAllClick(header, adapter!!.getDataList().indexOf(header))&#125; 通过滑动获取当前位置的数据 currentHeader，然后改变这个 currentHeader 对应数据中的具体分组的数据。写的有点乱，但是要点都写出了，over~","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"关于使用 kotlin 碰到的一个坑（二）","date":"2018-07-19T07:01:49.000Z","path":"2018/07/19/kotlin-question2/","text":"最近新做的项目，有点性能问题，今天集中弄了下性能优化，又发现了一个 kotlin 中的坑。其实也不算是坑，只是使用不熟练而已。 介绍下场景：项目有用到高德地图，高德地图的 MapView 需要在 Activity 或者 Fragment 的声明周期中进行调用，就像这样： 1234567891011121314151617181920212223242526272829@Overridepublic void onCreate(Bundle savedInstanceState) &#123; mapView = contentView.findViewById(R.id.map_view); mapView.onCreate(savedInstanceState);&#125;@Overridepublic void onResume() &#123; super.onResume(); mapView.onResume();&#125;@Overridepublic void onPause() &#123; super.onPause(); mapView.onPause();&#125;@Overridepublic void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); mapView.onDestroy();&#125; 然后在我写的某个 Fragment 中用到了 MapView，是用 kotlin 写的。发现每次打开这个页面，内存占用只增不减，在排除了其他因素之后，将问题定位到了高德地图的回收上。 1234override fun onDestroy() &#123; super.onDestroy() downloadMap?.onDestroy()&#125; 这是 Fragment 里的 onDestroy 调用，断点到这里，发现 downloadMap 总是为 null。这是为啥呢？这个 downloadMap 就是定义到 xml 中的 MapView 呀。 1234&lt;com.amap.api.maps.MapView android:id=&quot;@+id/downloadMap&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 后面网上查阅资料，发现问题的本质：**kotlin 在 Fragment 中使用 xml 中 id 直接使用控件，也是使用了 findViewById ，同时进行缓存。释放缓存的操作在 onDestroyView 里，所以在 onDestroy 里，使用 xml id 获取的控件已经全部被置空了，所以无法使用。 ** AndroidStudio 中可以直接打开 kotlin Bytecode，进行反编译查看编译后的代码，Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode -&gt; Decompile，看到编译后的代码： 123456789101112131415161718192021222324252627282930313233343536373839public void onDestroy() &#123; super.onDestroy(); MapView var10000 = (MapView) this._$_findCachedViewById(id.downloadMap); if (var10000 != null) &#123; var10000.onDestroy(); &#125;&#125;public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View) this._$_findViewCache.get(var1); if (var2 == null) &#123; View var10000 = this.getView(); if (var10000 == null) &#123; return null; &#125; var2 = var10000.findViewById(var1); this._$_findViewCache.put(var1, var2); &#125; return var2;&#125;public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125;&#125;// $FF: synthetic methodpublic void onDestroyView() &#123; super.onDestroyView(); this._$_clearFindViewByIdCache();&#125; 果不其然，所以在 onDestroy 中我执行 MapView 的 onDestroy 时 MapView 已经为 null 了，从而导致内存一直占用，无法释放。那么在 Activity 中是否存在这样的问题呢？答案是不存在。Activity 中也会生成 _$_clearFindViewByIdCache 方法，但是没有地方调用。 结论：在利用 Kotlin 编写的 Fragemnt 中，如果有些特殊的 View 需要处理销毁事件，需要写在 onDestroyView 中，并且在 super 调用之前。这里的 View 必须是直接通过 kotlin 利用 id 从 xml 获取的 View，如果是自己手动写 findViewById 的方式则不会出现这个问题。若是在 Activity 中则没有限制。 参考：Kotlin 为什么不用findViewById","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"关于使用 kotlin 碰到的一个坑（一）","date":"2018-07-11T09:58:49.000Z","path":"2018/07/11/kotlin-question/","text":"今天碰到个问题，起初看的时候一脸懵逼，后面追溯问题根源，发现是 kotlin 里的一个坑。看下代码： 12345678override fun showRoadCondition(list: List&lt;MyObject&gt;) &#123; val size = Math.ceil(list.size / 8.0).toInt() for (i in (0 until size)) &#123; val min = Math.min((i + 1) * 8, list.size) val subList = list.subList(i * 8, min).toList() as ArrayList&lt;MyObject&gt; &#125; // 其他代码...&#125; 这样一个方法，需要将列表的数据，根据 8 个一组进行划分。subList 生成的一个 List 不是我们平常使用的 List，所以后面加上了 kotlin 自带的 toList() 方法，来转化成真正的 List。这段代码在大多数情况下都没有什么问题，但是当 list 的长度为 9、17、25等等时就会崩溃。所报异常为： 1java.util.Collections$SingletonList cannot be cast to java.util.ArrayList 很显然，强制转换的异常。起初真的是一脸懵逼啊，后面只能耐心解决问题，看到代码容易发现 toList 应该是问题所在。看下其源码： 12345678910111213/** * Returns a [List] containing all elements. */public fun &lt;T&gt; Iterable&lt;T&gt;.toList(): List&lt;T&gt; &#123; if (this is Collection) &#123; return when (size) &#123; 0 -&gt; emptyList() 1 -&gt; listOf(if (this is List) get(0) else iterator().next()) else -&gt; this.toMutableList() &#125; &#125; return this.toMutableList().optimizeReadOnlyList()&#125; 当 size &#x3D;&#x3D; 1 时调用的 listOf，继续跟： 1234567/** * Returns an immutable list containing only the specified object [element]. * The returned list is serializable. * @sample samples.collections.Collections.Lists.singletonReadOnlyList */@JvmVersionpublic fun &lt;T&gt; listOf(element: T): List&lt;T&gt; = java.util.Collections.singletonList(element) 一目了然了，当 size 为 1 时，toList 方法会生成一个 singletonList，而这个 List 无法转化成 ArrayList，从而导致崩溃。嗯，我的内心也是崩溃的…后面将 toList 改成 toMutableList 即可。 123456/** * Returns a [MutableList] filled with all elements of this collection. */public fun &lt;T&gt; Collection&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123; return ArrayList(this)&#125; 序列化java 中一个 Model 有字段不需要序列化时，可以使用 transient 关键字： 1public transient Rectangle rect; 然后 kotlin 中如此使用： 12@Transientpublic boolean isPlaying = false; 如果我在 java 代码中使用 @Transient，fastjson 解析就会报错了，因为 Rectangle 没有默认构造函数： 12@Transientpublic Rectangle rect; 所以 2 个关键字（注解）都要分开使用。 题外话关于 kotlin 的 var 变量，我们可能经常需要可以为 null 的类型。比如： 1var data: List&lt;MyObject&gt;? = null 可以通过 ? 进行判空，或者直接使用 ?.let{} 在非 null 的时候执行某些代码。也可以加上 ?:run {} 来执行为 null 时的操作： 1234567var data: List&lt;MyObject&gt;? = nulldata?.let &#123; maskView.visibility = View.VISIBLE&#125; ?: kotlin.run &#123; maskView.visibility = View.GONE&#125;","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Git data stream error","date":"2018-06-22T04:38:56.000Z","path":"2018/06/22/git-quesition/","text":"今天使用 Git 碰到个问题，在此小记一下。场景：git stash当前工作区，然后git pull --rebase: 然后执行git stash pop时报错。 执行git status也报错： Google 之后大致是因为 Git 记录一些文件的版本指针被损坏了。这个损坏可能不是人为的，可能你正在 push 或者 pull 一些文件的时候，电脑突然断电或者关机了，就可能会导致这个异常发生。至于为什么在我的场景中出现了这个问题，就不得而知了。下面来解决它，执行指令git fsck --full： 可以看到有问题的指针引用。这串字符串的前 2 位是你的.git/objects/文件夹下对应的文件夹目录，然后cd ./fe删除掉这个字符串，rm e91c5f...。 删除掉之后，回到工作目录，继续执行git fsck --full。 可以看到没有错误状态的 blob 或者 commit 了。此时 git 已经可以正常使用了。 再补充一下，指针的 hash 值可能由于某些原因出错了，需要重新生成 hash 值。 1git hash-object -w spec/routing/splits_routing_spec.rb spec&#x2F;routing&#x2F;splits_routing_spec.rb 为对应的文件。 参考： git commit stopped working - Error building trees 在使用 Git pull 时候报错 error: inflate","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"常用代码和指令小结","date":"2018-05-28T09:23:32.000Z","path":"2018/05/28/practical-cmd/","text":"这篇文章主要总结一下日常开发中常用的一些代码和指令。 ADB 指令设置调试 App有些时候需要在应用启动的时候直接调试，如果设好断点然后Debug App重新编译运行会很慢，通过如下指令可以直接设置调试 App，然后设置断点后自动继续。 1adb shell am set-debug-app -w com.example.appdebugsample 开启 GPU 过度绘制GPU 过度绘制的作用就不用多说了，直接指令开启，方便快捷。 12adb shell setprop debug.hwui.overdraw showadb shell setprop debug.hwui.overdraw false INSTALL_FAILED_TEST_ONLY安装 Apk 出现这样的错误。看下 adb install 的所有参数： 1234567891011121314app installation: install [-lrtsdg] PACKAGE install-multiple [-lrtsdpg] PACKAGE... push package(s) to the device and install them -l: forward lock application -r: replace existing application -t: allow test packages -s: install application on sdcard -d: allow version code downgrade (debuggable packages only) -p: partial application install (install-multiple only) -g: grant all runtime permissions uninstall [-k] PACKAGE remove this app package from the device &#x27;-k&#x27;: keep the data and cache directories adb install 加上 -t 参数即可安装成功。 1adb install -d -r &quot;apk path&quot; 降版本覆盖安装。 1adb ( -s 设备名 ) install ( -r ) 文件名称.apk 当有多个设备时，使用 -s来指定设备，使用 -r 指定是否覆盖安装。 查看应用信息1adb shell dumpsys package com.example.appdebugsample 网络调试1234## 电脑USB连接手机adb tcpip 5555## 断掉USBadb connect 10.10.28.35（connect后面跟上手机的ip地址） 断开连接 1adb disconnect 显示Task栈内activity信息1adb shell dumpsys activity activities | sed -En -e &#x27;/Running activities/,/Run #0/p&#x27; 快速获取当前Activity的名称： 1adb shell dumpsys window windows | grep -E &#x27;mCurrentFocus|mFocusedApp&#x27; --color=always Git 指令1git fetch origin branchname:branchname 拉取远程分支到本地分支或者创建本地新分支 1git checkout origin/remoteName -b localName 获取远程分支remoteName 到本地新分支localName，并跳到localName分支 1git push -u origin branchname 推送本地分支到远程分支 1git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt; 重命名分支 12345git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern&gt;] [-x | -X] [--] &lt;path&gt;...-d # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。-f # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。-i # 进入交互模式-n # 查看将要被删除的文件，并不实际删除文件 通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行： 1git clean -n 想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果clean.requireForce为false可以不加-f选项）： 1git clean -f 想删除当前工作目录下的未跟踪文件以及文件夹运行： 1git clean -df tag ： 123456git tag tagName // 轻量级 tag，不带标注git tag -a tagName -m &#x27;tag 说明&#x27; // 带标注的 taggit push origin --tags // 推送本地所有 tag 到远程仓库git push origin tagName // 推送某个 taggit tag -d tagName // 删除某个 taggit push origin :refs/tags/oldName 修复当前提交的错误： 1git commit --amend 并不是直接修改原 commit 的内容，而是生成一条新的 commit。 123git stash applygit stash apply stash@&#123;2&#125;git config [–local|–global|–system] -l 本地所有修改的，没有的提交的，都返回到原来的状态： 1git checkout . windows AS 安装 git for windows 2.16.2，cmd 控制台乱码。网上找了好多解决办法，都没法解决。最后只有降 git 版本。 http://blog.csdn.net/QasimCyrus/article/details/65628752 错误码定义的错误码如果无法做到每个 code 对应一个描述语，那么在 Toast 或 Dialog 展示错误时带上错误码，eg：ToastUtils.showShort(mContent, “登录失败（错误码：-8）”)，这样根据 -8 这个 code 很容易定位到问题。 适配全面屏在 AndroidManifest.xml 中添加最大屏幕高宽比： 1&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.1&quot; /&gt; Android 标准接口中，支持应用声明其支持的最大屏幕高宽比（maximum aspect ratio）。具体声明如下，其中的 ratio_float 被定义为是高除以宽，以16:9为例，ratio_float &#x3D; 16&#x2F;9 &#x3D; 1.778 (18.5:9则为2.056)。若开发者没有声明该属性，ratio_float 的默认值为1.86，小于2.056，因此这类应用在三星S8上，默认不会全屏显示，屏幕两边会留黑。 列表边界留白Android 上 ListView、GridView、RecyclerView 默认行都是置顶的，这样会很丑。一般为了解决这个问题都会在首行或尾行加上一个隐藏的View，那样实在是太麻烦了。 设置 ListView 或 GridView 的 android:clipToPadding ＝ false， 然后通过 paddingTop 和 paddingBottom 设置距离就好了。 TextView drawableRightTextView 在添加 drawableRight 等属性时，即使设置了居中也会有不对齐的现象，给它设置一个 includeFontPadding 为 false 的属性就好了。 123456789101112&lt;TextView android:id=&quot;@+id/topic_detail_reward_amount_tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginRight=&quot;12dp&quot; android:drawablePadding=&quot;4dp&quot; android:drawableRight=&quot;@drawable/saturn__income_coin&quot; android:gravity=&quot;center_vertical&quot; android:includeFontPadding=&quot;false&quot; android:textColor=&quot;#FF6B00&quot; android:textSize=&quot;15sp&quot; tools:text=&quot;+200&quot; /&gt; SeekBar 去掉滑块 thumb 周围的阴影，使用android:background=&quot;@null&quot;： 123456789&lt;com.xxxxxxx.widget.CustomSeekBar android:id=&quot;@+id/sb_light_bar&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;190.0px&quot; android:layout_centerInParent=&quot;true&quot; android:maxHeight=&quot;6dp&quot; android:background=&quot;@null&quot; android:progressDrawable=&quot;@drawable/video_light_seekbar&quot; android:thumb=&quot;@drawable/sele&quot; /&gt; seekbar默认两边会有间隙，导致不能符合预期效果。同时滑块可能会因为太大而显示不全，添加属性: 12345android:paddingStart=&quot;0dp&quot;android:paddingEnd=&quot;0dp&quot;&lt;!-- 滑块偏移 --&gt;android:thumbOffset=&quot;0dp&quot; thumb 的 icon 四周透明，但是显示效果不透明 1android:splitTrack=&quot;false&quot; https://www.jianshu.com/p/d7eb29d3d5c4 进度颜色控制： 第一进度条、第二进度条的位置不能更换，更换后第一进度条不能正常显示。 背景色不能添加clip标签，添加后不能正常显示。 第一、第二进度条若要正常显示，需要添加clip标签。 通过调整paddingLeft、paddingRight与thumbOffset来控制thumb的起点对齐、左右被遮盖。12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 背景色 --&gt; &lt;item android:id=&quot;@android:id/background&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;#ececec&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 第二进度条，用于缓冲显示（？） --&gt; &lt;!--&lt;item android:id=&quot;@android:id/secondaryProgress&quot;&gt;--&gt; &lt;!--&lt;clip&gt;--&gt; &lt;!--&lt;shape&gt;--&gt; &lt;!--&lt;solid android:color=&quot;#dcdcdc&quot; /&gt;--&gt; &lt;!--&lt;/shape&gt;--&gt; &lt;!--&lt;/clip&gt;--&gt; &lt;!--&lt;/item&gt;--&gt; &lt;!-- 第一进度条，用于显示已执行的进度 --&gt; &lt;item android:id=&quot;@android:id/progress&quot;&gt; &lt;clip&gt; &lt;shape&gt; &lt;solid android:color=&quot;#86e7de&quot; /&gt; &lt;/shape&gt; &lt;/clip&gt; &lt;/item&gt;&lt;/layer-list&gt; https://www.jianshu.com/p/7f00c5361094 结合音乐一般是以秒为单位来设置播放进度。使用 1000d 浮点数进行运算，然后再用rint取最近的整数进行返回，这样显示的进度更平缓。对于暂停、续播，当检查播放器有暂停进度时，在续播开始时先 setProgress 一下。eg：1234seekBar.setMax(duration);double position = SingleAudioPlayer.getInstance().getCurrentPosition();seekBar.setProgress((int) Math.rint(position / 1000d));","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"快速画 UML 图","date":"2018-05-08T05:57:45.000Z","path":"2018/05/08/uml/","text":"这几天有个内部的技术分享，是公司要求的一个流程，需要针对某个功能模块进行讲解。在制作 PPT 的过程中，需要画 UML 图。起初使用的ProcessOn，画出来之后感觉没啥效果，类之间的关系不能明确表现出来，而且制作很麻烦，得自己一天天敲文字，调位置。后面接触到PlantUML，可以直接使用类似 Markdown 的模式进行编辑，然后直接渲染成一张图片，简直不要太舒服，所以很想分享给大家！ 看下两个软件作图的比较：ProcessOn：PlantUML：高下立判啊！当然，在用 PlantUML 绘图时又重新仔细思考了下类的结构，所以两张图在结构上不一样。使用 PlantUML，后续若需要维护，修改起来十分方便！但是貌似有个缺点：不能表示内部类,或者是我还没找到使用的方式。 顺道帖下 UML 图推荐的几种类关系。 继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 实现指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性； 依赖可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用； 关联他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量； 聚合聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 组合组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 对于继承、实现这两种关系没多少疑问，他们体现的是一种类与类、或者类与接口间的纵向关系；其他的四者关系则体现的是类与类、或者类与接口间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准备定位是很难的，前面也提到，这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系；但总的来说，后几种关系所表现的强弱程度依次为：组合&gt;聚合&gt;关联&gt;依赖。 参考Markdown 绘制 UML 图 – PlantUML + GravizoPlantUML 在线作图网址UML中几种类间关系","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"关于重构的一些实践","date":"2018-05-07T02:11:43.000Z","path":"2018/05/07/refactor/","text":"关于本文即将阐述的一些东西，其实我也不知道算不算得上重构，姑且就算吧。重构，是软件开发者始终绕不过的一道坎，尤其当你接手一个“年迈”项目的时候。首先介绍下项目背景：Android Core 是所有 Lib、App 都有依赖的。近期 Core 做了一次大版本升级，将许多Deprecated标记的方法、类都删掉了，同时内部代码做了重构，有些 Api、类名都有相应的修改。那么现在作为图中的 Saturn(Lib) 这个位置，在引用新版本的 Core 之后，如何重构代码，使之能够正常工作？下面针对我碰到的几个点，做一下说明。 包名修改重构针对迁移包路径的，算是改动量最小的了。直接全局搜索相应的包名，进行替换即可。注意：这里千万不要加上 import ，因为很有可能 Core 中自定义 View 也更换了包名，同时在 xml 中有引用，加上 import 是搜不出 xml 中的引用的。举个例子：cn.xxx.android.ui.framework.view.commonview.CommonViewPager -&gt; cn.xxx.android.core.widget.CommonViewPager。某某 xml 中： 12345&lt;cn.xxx.android.ui.framework.view.commonview.CommonViewPager android:id=&quot;@+id/view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@+id/divider&quot; /&gt; 注意去掉图中的 import！ @Deprecated 类或方法删除一般我们标记一个类或者方法为 @Deprecated 时，都会指出它的替代方案，就像这样：这种情况就很简单了，根据替代方案进行相应修改即可。但是这个比较依赖人工注释，如若有同事忘记写这个了，那么就很头疼了：你不知道用什么方法来替代它。若能询问到标记 @Deprecated 的同事那也还好，万一同事离职了或他自己都忘记了，那如何处理呢？ 读懂代码，自己寻找替代方案 从 Core 中 copy 一份到自己的代码中 方案一只有在业务简单，逻辑清晰的情况下适用，当业务十分复杂，逻辑阅读起来也比较费力时，方案一的工作量就很庞大了。这个时候选择方案二合适点，后续有空再来优化。当然，这个后续有空可能就和明天一样，哈哈哈… 功能模块整个删除Core 之前有一套网络请求模块，在升级后，使用了另外一套，两套是完全不同的东西。但是在 Saturn 中很多网络请求仍然使用着旧的那套东西。碰到这种情况，目前想到的就只有 copy 了。其实对这种升级，我是很厌烦的，因为它完全不考虑兼容，强制所有用到 Core 的都进行整改，也不考虑其他同事的工作量，虽然它已经标记为 @Deprecated 很久了。 自定义 View碰到自定义 View 也给删除的，若没有替代方案，也只能 copy 代码了。但是自定义 View 的 copy 要多一步：资源文件。很多自定义 View 有自定义的属性或者样式之类的，这就要求你在 copy 代码同时，也要 copy 相应的资源文件。这里有个坑：Saturn 作为一个 Lib，如果原封不动的直接将文件 copy 过来，那么考虑一下 Venus。Venus 在兼容 Core 升级的时候，很有可能和 Saturn 采用同样的做法，那么两份相同的资源文件就会导致冲突了。这个冲突不是 Saturn 自身能测试得到的，只有在 Mercury App 进行集成的时候才会暴露出来。所以最好提前考虑一下，针对资源文件加上独有的前缀。比如： 123456789101112131415161718192021222324&lt;declare-styleable name=&quot;RoundCornerButton&quot;&gt; &lt;attr name=&quot;round_button_radius&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;round_button_radius_lt&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;round_button_radius_rt&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;round_button_radius_lb&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;round_button_radius_rb&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;round_button_bg_color&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;round_button_elevation&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;round_button_stroke_color&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;round_button_stroke_width&quot; format=&quot;dimension&quot; /&gt;&lt;/declare-styleable&gt;&lt;!-- 改成如下 --&gt;&lt;declare-styleable name=&quot;saturn__RoundCornerButton&quot;&gt; &lt;attr name=&quot;saturn__radius&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;saturn__radius_lt&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;saturn__radius_rt&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;saturn__radius_lb&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;saturn__radius_rb&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;saturn__bg_color&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;saturn__elevation&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;saturn__stroke_color&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;saturn__stroke_width&quot; format=&quot;dimension&quot; /&gt;&lt;/declare-styleable&gt; 为了完全避免冲突，最好样式名、自定义属性名都加上前缀，如果过长可适当删减，同时记得修改自定义 View 中的引用。 12345678910111213141516171819202122232425262728293031323334public RoundCornerButton(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); // 获取自定义的属性,设置相应背景 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.saturn__RoundCornerButton); try &#123; float allRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius, 0); float ltRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_lt, 0); float rtRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_rt, 0); float lbRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_lb, 0); float rbRadius = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__radius_rb, 0); int color = typedArray.getColor(R.styleable.saturn__RoundCornerButton_saturn__bg_color, 0); int strokeColor = typedArray.getColor(R.styleable.saturn__RoundCornerButton_saturn__stroke_color, 0); int strokeWidth = typedArray.getDimensionPixelOffset(R.styleable. saturn__RoundCornerButton_saturn__stroke_width, 0); float elevation = typedArray.getDimension(R.styleable.saturn__RoundCornerButton_saturn__elevation, 0); drawable = new GradientDrawable(); drawable.setColor(color); if (allRadius == 0) &#123; drawable.setCornerRadii(new float[]&#123;ltRadius, ltRadius, rtRadius, rtRadius, rbRadius, rbRadius, lbRadius, lbRadius&#125;); &#125; else &#123; drawable.setCornerRadius(allRadius); &#125; if (strokeColor != 0) &#123; drawable.setStroke(strokeWidth, strokeColor); &#125; ViewCompat.setBackground(this, drawable); changeElevation(elevation); &#125; catch (Exception e) &#123; LogUtils.d(&quot;exception&quot;, e); &#125; finally &#123; typedArray.recycle(); &#125;&#125; 小结针对这种重构，小结一下： 有替代方案直接上替代方案。 没有替代方案，在时间充足的情况下，可尝试读懂代码，自己寻找替代方案；若时间不充足则只能 copy 代码了。 注意自定义 View 相关内容。 在开发过程中，碰到 @Deprecated 标记的类或者方法尽早整改吧，不然万一哪天版本升级这个类或者方法没了，在量大的情况下，就很蛋疼了。 Saturn 作为一个 Lib，在对外提供 SDK 的情况下，最好不要删除、改变现有方法，尽量提供新的方法保证兼容。","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"使用 Charles 进行手机抓包","date":"2018-05-03T08:41:22.000Z","path":"2018/05/03/charles/","text":"开发中，我们经常会有抓包的需求。通过抓包，能一目了然请求的参数以及返回的数据是否符合预期，在定位问题的时候有很大的帮助作用。这里便写一下自己认为还不错的一个抓包工具Charles。 下载这个根据系统版本自行谷歌、百度吧。 连接 运行 Charles，点击 Proxy -&gt; Proxy Settings，设置代理端口（一般默认8888），然后勾选 Enable 的选项，点击 OK 结束设置。 运行 cmd 输入指令查看电脑 ip。 打开手机 Wlan 设置，将 Wifi 的代理设置成步骤 2 中的 ip 地址，及步骤 1 中的端口。 确定之后，电脑 Charles 就会弹出对话框，询问是否允许代理，勾选 Allow。 有些情况下，可能我们设置手机 Wlan 代理之后，一直不弹对话框。可能是 ip 已经存在导致的。点击 Proxy -&gt; Access Control Settings，可以进行连接设备的设置。 确认连接 OK 之后，手机上的网络请求都会走代理，到电脑的 Charles 上了，然后通过 Charles 就能看到具体的网络请求信息了。 断点可能某些情况下，我们需要手动修改 Request 或 Reponse 的值，这就需要断点了。 打开 Charles 调试开关。 右键需要断点的请求，勾选 Breakpoints。 可能这个请求带有 sign 这样的唯一参数，导致后面所有的请求都会不太一样，这时可以编辑断点，去掉相应的参数。 手机执行请求，Charles 会先拦截到 Request，这时可以修改请求的参数等等。修改结束之后点击下面的 Execute 发送请求。图中实例的请求没有传递什么参数，所以没什么数据。 请求返回成功之后会自动拦截返回的 Reponse，这时可以查看请求的内容，以及返回的具体 Reponse，也可进行相应的修改。 小结整个工具使用起来比较简单方便，也能实现基本的手机抓包需求，推荐使用。就是如果不注册的话，会经常在启动也暂停几秒到十几秒不等，可以购买支持一下，当然网上也有免费的激活账号，可以自行查阅。 Https 抓包公司生产环境的接口都是 https 的，不做配置就抓不到了。这里说一下小米手机配置 https 抓包的操作。 电脑 Charles 软件安装 SSL 证书。 手机下载 SSL 证书：浏览器打开图里的地址，下载文件，记录好下载路径。 打开手机安全与隐私设置，小米手机在「系统安全」设置中，然后选择「加密与凭据」，再选「从存储设备安装」。这时会打开文件管理器（可能需要先启用「文件」应用）。然后选择刚刚下载的路径，选择 pem 证书文件即可。 问题电脑升级到 win10 之后，抓包无效了，需要配置下网络入站规则。设置 -&gt; 网络和 Internet -&gt; windows 防火墙 -&gt; 高级设置 -&gt; 入站规则找到 Charles 相关的，找不到则新建一个规则，并允许连接。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Java HashSet 的原理","date":"2018-04-12T06:49:04.000Z","path":"2018/04/12/hashset/","text":"项目里有用到 HashSet 数据结构，之前几乎没怎么用过，只是了解一点，不能存放重复的元素。但是一直没有看过代码。今天基于这个契机，看了下代码研究了下内在原理。颇有感触，在此记录一下。 当看到 HashSet 的代码时，瞅了一眼，算上注释竟然不足 400 行。可以说，整个 HashSet 最重要的便是它的构造函数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private transient HashMap&lt;E,Object&gt; map;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;/** * Constructs a new set containing the elements in the specified * collection. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor * (0.75) and an initial capacity sufficient to contain the elements in * the specified collection. * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and default load factor (0.75). * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;/** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.) The backing * HashMap instance is a LinkedHashMap with the specified initial * capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @param dummy ignored (distinguishes this * constructor from other int, float constructor.) * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 怎么样，一目了然了吧？HashSet 特喵的就是用的 HashMap 来实现的。那么 HashSet 如何避免元素被重复添加呢？看下 add 方法： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 简短得不能再短。看下 PRESENT 是什么： 12// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object(); 看到这就清楚了。这个 PRESENT 对象全局就只会有一个，当我们的 obejct 作为 map 的 key 时，通过 map 的 put 方法进行添加。如果 object 是一样的，那么 key 就是一样，map 通过这个 key 会找到 PRESENT 对象，这个对象和我们 add 传入的是一个对象，那么 map 就会认为元素已经存在，不再进行重复插入了。如此便实现了 Set 集合的不重复元素功能。 最后看下 HashSet 的迭代器： 123public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 意料之中！ 所以啊，在做某些东西的时候，可以先思考，如何利用现有的东西。某些构思、想法真的是很奇妙，多看源码！！！","tags":[{"name":"Java","slug":"Java","permalink":"http://lijia92.github.io/tags/Java/"}]},{"title":"异步任务的原生实现","date":"2018-03-28T09:14:56.000Z","path":"2018/03/28/async-task-model/","text":"现在谈到异步任务，相信大多数开发者都会直接选择 RxJava，但是仍然会有不用 RxJava 的项目。这种情况下如何来做异步任务呢？ 其实不论是 RxJava 抑或是 Android 自带的 AysncTask，内部实现原理都是 Thread + Handler。如果线程想要返回 Result，那么只能使用 Callable来实现子线程，AsyncTask 便是使用的 Callable。 下面说下项目中的使用场景：一个界面由一个列表构成，但列表的构成十分复杂，item type 很多，需要请求多个网络接口来返回所需要的数据。网络接口请求互相独立，没有依赖关系，可使用多线程进行请求。如果使用 Android 提供的 AsyncTask，则在 doInBackground 依次执行网络接口，就丧失了多线程的优势，当然你也可以在 doInBackground 再起子线程执行网络请求，然后在返回的时候使用阻塞，等到所有接口执行完毕才返回，原理其实是一样的。 下面说下项目中的做法： 创建一个全局的线程池，用来执行异步任务。12private static ExecutorService es;es = Executors.newFixedThreadPool(10); 封装一个任务队列类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class BatchTask &#123; private List&lt;Future&gt; futureList; private TaskCallback callback; public BatchTask(TaskCallback callback) &#123; futureList = new LinkedList&lt;&gt;(); this.callback = callback; &#125; public BatchTask addTask(Callable task) &#123; if (task != null) &#123; futureList.add(es.submit(task)); &#125; return this; &#125; public void getResult() &#123; for (Future future : futureList) &#123; try &#123; if (callback != null) &#123; callback.onCallback(future.get()); &#125; &#125; catch (Exception e) &#123; LogUtils.d(BatchTask.class.getSimpleName(), e); &#125; &#125; &#125; public interface TaskCallback &#123; void onCallback(Object object); &#125; public static class MyTaskCallback implements TaskCallback &#123; private List&lt;Object&gt; dataList; public MyTaskCallback() &#123; this.dataList = new ArrayList&lt;&gt;(); &#125; @Override public void onCallback(Object object) &#123; if (object == null) &#123; return; &#125; if (object instanceof List) &#123; List list = (List) object; if (CollectionUtils.isNotEmpty(list)) &#123; dataList.addAll(list); &#125; &#125; else &#123; dataList.add(object); &#125; &#125; public List&lt;Object&gt; getDataList() &#123; return dataList; &#125; &#125;&#125; 添加任务：12345678batchTask = new BatchTask();batchTask.addTask(task1);batchTask.addTask(task2);...batchTask.getResult();callback.getDataList(); 使用的时候，先创建一个子线程，然后调用 addTask，线程池就会去执行这个任务了，但是当要获取 Result 时，由于 future.get() 是一个阻塞方法，它会一直等待任务执行结束才会返回结果，所以返回的数据顺序和我们 addTask 的顺序一致。同时使用一个 dataList 来接受这些返回的结果，这样的话在拿到数据之后不用再手动进行排序了。然后利用 Handler 将数据发送到主线程进行展示即可。可以看出来，就和 AsyncTask 差不多！ 其实就和开头说的一样，异步任务的实质就是 Thread + Handler。只不过目前有一些封装的异步任务库，导致对其底层实现的原理不是很清晰。现在这个项目里，就是使用原生的一些东西，看起来就更加明朗、深刻了。当然了，原生的或者 AsyncTask 写起来确确实实不如 RxJava 来得简洁方便了，尤其涉及到多任务、数据变换的时候。所以，能用 RxJava 就还是用 RxJava 吧。","tags":[{"name":"Java","slug":"Java","permalink":"http://lijia92.github.io/tags/Java/"}]},{"title":"面试资料整理","date":"2018-03-23T09:25:20.000Z","path":"2018/03/23/interview/","text":"离职之后，从深圳回到武汉，当然还是得找工作的。这里就整理一下我看过的有帮助的的一些资料。面试的时候可能一些知识你都知道，但是不成章法，不能流利的说出来，这里就得多加练习了。自己对照着面试题目进行回答，练习口才。 面试超详细Android面试的准备与经历分享 | 百度(offer)阿里、腾讯、百度、华为、京东、搜狗和滴滴最新面试题汇集我所经历的Android面试BAT大厂面试题整理 HanlderAndroid Handler消息机制实现原理Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ 线程池Android开发——Android中常见的4种线程池 透过单例模式看 Java 并发那些年，我们一起写过的“单例模式”Java 并发编程：volatile的使用及其原理漫画：什么是 CAS 机制？漫画：什么是CAS机制？（进阶篇）漫画：什么是volatile关键字？Java 中的多线程你只要看这一篇就够了 Java 中的枚举java枚举类型的实现原理从一道面试题开始说起 枚举、动态代理的原理 JVM 内存模型 &amp; GCJVM结构、GC工作机制详解 BinderBinder的设计和框架为什么 Android 要采用 Binder 作为 IPC 机制？ 类的加载机制 &amp; 插件化Android动态加载基础 ClassLoader工作机制Android中的ClassLoader热修复入门：Android 中的 ClassLoader 集合Java 8系列之重新认识HashMapLinkedHashMap 的实现原理图解HashMap(一)Android内存优化（使用SparseArray和ArrayMap代替HashMap） 事件分发：安卓自定义View进阶-事件分发机制原理安卓自定义View进阶-事件分发机制详解 自定义 View：给高级 Android 工程师的进阶手册安卓自定义View教程目录","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"好久不见","date":"2018-03-16T08:07:56.000Z","path":"2018/03/16/long-time-no-see/","text":"好久没更新博客了，今天抽空写点东西。最近一篇博客，讲的是怎么拷贝代码，那为什么会有这样一篇文章呢？ 嘿嘿，2018 年 2 月 9 号，我离职了。在公司呆了有段时间了，觉得公司技术其实是很不错的，可惜发展不太好。前期融资的钱烧得差不多了，却仍然没有创造合理的商业模式进行营利，导致公司很难运营下去，也很难继续拉到投资。公司开始拖欠工资，后面很多员工都陆续离职了。我呢，想着可能还有点机会，一直继续干。但是坚持到年底仍然没什么起色，心灰意冷，就只能离职了。 2017 年是我在深圳呆的第 3 个年头了，前面 2 年同学之间经常吃吃喝喝打打照面，觉得深圳就是家，不会有孤独感。但是 17 年开始，同学谈朋友的谈朋友，忙的忙，一些同学一年下来见不到 2 回，每逢周末屋子里经常就我 1 个，已经 1 个人看了不下 20 场电影了，强烈的孤独感油然而生。 孤独是一个人的旅行，我们必须经历，成为更好的自己。 经历过孤独之后，有没有成为更好的自己我不知道，我只知道：我想家了。家里的父母日渐年迈，自己却不曾在家照顾，从大学开始就基本是一年才回一次家，内心满是歉疚，回家吧，回家吧。 2017 年经历的一些都不是什么好事：行情的饱和、创业的艰辛、朋友间的来来去去…但这些既然发生了，那就是我该要去经历的，一帆风顺也不见得是什么好事。 年轻的时候，总想着能干出一番大事，但经历过一些事情之后，却觉得平平淡淡才是真。今年看一部电影《天才少女》，一位智力过人的天才少女，母亲自杀，最后由舅舅和外婆来争夺抚养权。舅舅只想让孩子过普通人生活，外婆要将小女孩培养成数学天才。两种价值观的冲突，你很难说哪种是对的，哪种是错的。 教育就像悖论，等到当事人明白什么是最适合自己的方式的时候，已经在他人安排好的人生路上走得太久，无法回头。 想想现在自己脚下的路是他人安排的吗？不，不是的，这就够了。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"解锁拷贝代码的新姿势","date":"2018-01-22T07:13:26.000Z","path":"2018/01/22/code-copy/","text":"作为程序员，我们总会有各种拷贝代码的需求，例如现场部署，基友探讨，亦或是 公司电脑 -&gt; 自家电脑 等等。最最无脑的就是直接硬盘拷贝了，复制代码文件夹或压缩文件，直接拷贝到自己的硬盘或 U 盘里。但是作为安卓开发，如果要拷贝安卓代码，那就很费劲了。因为 Android Studio 会生成各种与代码无关的文件，尤其是 build 文件夹，有些时候代码可能就一两百兆，但是 build 文件夹就能有大几百兆甚至上 G 了。当然我们可以先 clean，然后再拷贝，但是如果项目复杂，多个工程多个 Module 互相依赖的，那就得每个 Module 都执行一遍 clean 了，想想那有多繁杂。 现在大多的代码版本控制都是采用的 Git，我们需要的其实就只是代码文件，其他的一概不需要，而 Git 内部的 .gitignore 不是正好对应我们的需求吗？所以，我们得从版本控制的角度来拷贝代码。相信大多数公司项目的代码都是私有仓库，只能在公司内网访问到。但我们可以给代码添加远程仓库 origin，这个 origin 可以指到 Github 或自己搭建的 Git 服务器，但是如果是公司代码是不建议这么做的，泄密了嘛～若是自己写的小工具，三方库倒是没什么影响，但这也不是本文要说的重点。 今天就说一下利用 Git 拷贝代码的新姿势，SVN 或其他版本控制工具不在此文范围之内。其实就是一个 Git 命令：git bundle。 来看看一个简单的例子。 假设你有一个包含两个提交的仓库： 123456789101112$ git logcommit 9a466c572fe88b195efd356c3f2bbeccdb504102Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Wed Mar 10 07:34:10 2010 -0800 second commitcommit b1ec3248f39900d2a406049d762aa68e9641be25Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Wed Mar 10 07:34:01 2010 -0800 first commit 然后利用git bundle指令来打包： 123456$ git bundle create repo.bundle HEAD masterCounting objects: 6, done.Delta compression using up to 2 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 441 bytes, done.Total 6 (delta 0), reused 0 (delta 0) 然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。 在使用 bundle 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。 你可以将这个 repo.bundle 文件通过邮件或者U盘传给别人。 另一方面，假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。 你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。 123456$ git clone repo.bundle repoInitialized empty Git repository in /private/tmp/bundle/repo/.git/$ cd repo$ git log --oneline9a466c5 second commitb1ec324 first commit 如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 -b master 或者其他被引入的分支，否则 Git 不知道应该检出哪一个分支。 如此，拿着生成的打包文件便可随时随地的拷贝代码了。 另外，我们可以只打包部分 commit。现在假设你提交了 3 个修订，并且要用邮件或者U盘将新的提交放在一个包里传回去。 123456$ git log --oneline71b84da last commit - second repoc99cf5b fourth commit - second repo7011d3d third commit - second repo9a466c5 second commitb1ec324 first commit 首先我们需要确认我们希望被打包的提交区间。 和网络协议不太一样，网络协议会自动计算出所需传输的最小数据集，而我们需要手动计算。 当然你可以像上面那样将整个仓库打包，但 最好仅仅打包变更的部分 —— 就是我们刚刚在本地做的 3 个提交。 为了实现这个目标，你需要计算出差别。 就像我们在 提交区间 介绍的，你有很多种方式去指明一个提交区间。 我们可以使用 origin/master..master或者master ^origin/master之类的方法来获取那 3 个在我们的 master 分支而不在原始仓库中的提交。 你可以用 log 命令来测试。 1234$ git log --oneline master ^origin/master71b84da last commit - second repoc99cf5b fourth commit - second repo7011d3d third commit - second repo 这样就获取到我们希望被打包的提交列表，让我们将这些提交打包。 我们可以用 git bundle create 命令，加上我们想用的文件名，以及要打包的提交区间。 123456$ git bundle create commits.bundle master ^9a466c5Counting objects: 11, done.Delta compression using up to 2 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (9/9), 775 bytes, done.Total 9 (delta 0), reused 0 (delta 0) 现在在我们的目录下会有一个 commits.bundle 文件。 如果我们把这个文件发送给我们的合作者，她可以将这个文件导入到原始的仓库中，即使在这期间已经有其他的工作提交到这个仓库中。 当她拿到这个包时，她可以在导入到仓库之前查看这个包里包含了什么内容。 bundle verify 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。 123456$ git bundle verify ../commits.bundleThe bundle contains 1 ref71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/masterThe bundle requires these 1 ref9a466c572fe88b195efd356c3f2bbeccdb504102 second commit../commits.bundle is okay 如果打包工具仅仅把最后两个提交打包，而不是三个，把指令中 commit 改为 7011d3d，原始的仓库是无法导入这个包的，因为这个包缺失了必要的提交记录。这时候 verify 的输出类似： 123$ git bundle verify ../commits-bad.bundleerror: Repository lacks these prerequisite commits:error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo 而我们的第一个包是合法的，所以我们可以从这个包里提取出提交。 如果你想查看这边包里可以导入哪些分支，同样有一个命令可以列出这些顶端： 12$ git bundle list-heads ../commits.bundle71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master verify 子命令同样可以告诉你有哪些顶端。 该功能的目的是查看哪些是可以被拉入的，所以你可以使用 fetch 或者 pull 命令从包中导入提交。 这里我们要从包中取出 master 分支到我们仓库中的 other-master 分支： 123$ git fetch ../commits.bundle master:other-masterFrom ../commits.bundle * [new branch] master -&gt; other-master 可以看到我们已经将提交导入到 other-master 分支，以及在这期间我们自己在 master 分支上的提交。 12345678$ git log --oneline --decorate --graph --all* 8255d41 (HEAD, master) third commit - first repo| * 71b84da (other-master) last commit - second repo| * c99cf5b fourth commit - second repo| * 7011d3d third commit - second repo|/* 9a466c5 second commit* b1ec324 first commit 因此，当你在没有合适的网络或者可共享仓库的情况下，git bundle 很适合用于共享或者网络类型的操作。 小插曲注意打包命令git bundle create commits.bundle master ^9a466c5中的 ^ 符号，做了几次实验，若没有这个符号，打出来的包都可以通过验证。并且这个包是包含了所有提交的 bundle，没有增量 commits，所以这个符号在打增量 commits 包时一定不能忘。 12345➜ git git:(master) ✗ git bundle verify 6.bundle这个包中含有这个引用：31814aab295f73d45130b7278c4b03656f1d75cd refs/heads/master这个包记录一个完整历史。6.bundle 可以 之前买了凯哥的《Git 原理详解及实用指南》，第二章里有一个图：之前一直搞不懂偶尔那条线是怎么来实现的，加群询问也没什么答案，现在算是知道了。同事之间直接利用打包指令，生成打包文件，利用这个文件来直接交互。 关于 Git 的更多讲述，请参考官方文档。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"2017","date":"2018-01-19T15:14:57.000Z","path":"2018/01/19/summary-2017/","text":"已然 2018 年了，想想过去的一年里，竟然没有一丁点想要写下来的东西。曾经满腔热血，不甘平凡的我，竟也被岁月磨平了棱角变得平淡，无趣。但理想总是该缅怀一下的，或许某一天你会有了力量，风雨兼程，勇往前行。 《理想》作曲 : 赵雷作词 : 赵雷一个人住在这城市为了填饱肚子就已精疲力尽还谈什么理想那是我们的美梦 梦醒后 还是依然奔波在风雨的街头有时候想哭就把泪 咽进一腔热血的胸口 公车上我睡过了车站一路上我望着霓虹的北京我的理想把我丢在这个拥挤的人潮车窗外已经是一片白雪茫茫 又一个四季在轮回而我一无所获的坐在街头只有理想在支撑着那些麻木的血肉 理想今年你几岁你总是诱惑着年轻的朋友你总是谢了又开 给我惊喜又让我沉入失望的生活里 公车上我睡过了车站一路上我望着霓虹的北京我的理想把我丢在这个拥挤的人潮车窗外已经是一片白雪茫茫 又一个四季在轮回而我一无所获的坐在街头只有理想在支撑着那些麻木的血肉 理想今年你几岁你总是诱惑着年轻的朋友你总是谢了又开 给我惊喜又让我沉入失望的生活里 又一个年代在变换我已不是无悔的那个青年青春被时光抛弃已是当父亲的年纪 理想永远都年轻你让我倔强地反抗着命运你让我变得苍白却依然天真的相信花儿会再次的盛开 阳光之中 到处可见奔忙的人们被拥挤着 被一晃而飞的光阴忽略过","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Kotlin 结合 RxJava 使用杂谈","date":"2018-01-11T09:01:36.000Z","path":"2018/01/11/talk/","text":"相信现在越来越多的开发者都在使用 RxJava 和 Kotlin，当二者相遇，写出来的代码堪称优雅！ 我对 Kotlin 的并没有很特别的感觉，它就类似于 Swift 相比于 OC，大量的语法糖着实能使写代码的效率变高，但是是否能左右 Android 开发的现状还未可知。 我之前写过这样一段话，在使用 Kotlin 的这段时间里，我对它的看法慢慢改变了。尤其引入 RxJava 后，结合 Lambda 表达式，写起代码简直像要飞起来！ 早些时候，我们查询数据，调用网络接口都是通过 Thread + Handler，或者 Android 自己封装的 AsyncTask，再或者 CursorLoader 等等，只要涉及要到异步，代码写起来都十分繁琐。首先你得实现 AsyncTask 或 CursorLoader 的接口，然后在子线程写数据读取的逻辑，然后通过 Handler 或者发送广播来通知界面显示。噢，现在想起来就觉得头大。然后 RxJava 的出现解放了我们，引入 RxJava 后，整个操作都变得十分简单，代码逻辑也十分清晰，相信用过的人都知道。然后结合 Kotlin 的语法糖，写起代码来简直不要太爽！举个栗子： M 层封装的数据操作：12345678910fun queryAllSkuValue(): Observable&lt;List&lt;SKUValue&gt;&gt; &#123; return Observable .create(ObservableOnSubscribe&lt;List&lt;SKUValue&gt;&gt; &#123; e -&gt; read &#123; srvMgr -&gt; e.onNext(srvMgr.skuService.queryAllSKU().toList()) &#125; e.onComplete() &#125;) .compose(applySchedulers())&#125; Presenter 调用接口，获取数据，处理数据：12345678910111213fun querySkuBean() &#123; compositeDisposable.add( skuProvider.queryAllSkuValue() .map &#123; SkuBean.newSkuBean(it) &#125; .subscribe(&#123; view?.showProductSkuBean(it) &#125;, &#123; view?.showError(msgOrError(it, &quot;数据查询失败&quot;)) &#125;) )&#125; 可以看到，RxJava 结合 Kotlin 使我们的代码异常干净，清晰。RxJava 的 map、flatMap 等等的操作符，结合起 Lambda 表达式，真的太简洁了！当然，如果仅仅是 Lambda，你使用 Java 8 也是可以的。但是 Kotlin 还提供了很多其他的特性，之前也写文章说过。我之前小看了 Kotlin，它提供的很多操作符不仅可以减少代码量，也可以提高阅读性。比如 filter 操作符：12345678910111213141516171819202122232425262728293031// 代码1private void searchCuisineByCategory(String sortText) &#123; List&lt;Product&gt; productList = new ArrayList&lt;&gt;(); if (CONDITION_ALL.equalsIgnoreCase(sortText)) &#123; productList.addAll(getProductList()); &#125; else &#123; for (ProductBean productBean : mCuisineBeanList) &#123; String categoryName = productBean.product.type; if (!TextUtils.isEmpty(categoryName) &amp;&amp; categoryName.equals(sortText)) &#123; productList.add(productBean.product); &#125; &#125; &#125; mSoldOutAdapter.setProductList(productList);&#125;// 代码2fun searchByCategory(sortText: String) &#123; val list = ArrayList&lt;Product&gt;() if (CONDITION_ALL.equals(sortText, ignoreCase = true)) &#123; list.addAll(productList) &#125; else &#123; productList .filter &#123; val categoryName = it.type sortText == categoryName &#125; .mapTo(list) &#123; it &#125; &#125; view?.showProductList(list)&#125; 代码有些许调整，但是业务逻辑都是筛选。对比代码，显然代码2的清晰多了。代码1通过循环遍历列表，然后查找对应条件的数据，你必须跟入到代码内部才知道这段代码的意义。而代码2，当你看到 filter 就能知道：哦，这是个筛选条件，用于过滤数据，就能一下明白代码的含义。可能刚开始使用时需要先了解一下，但是当熟悉后，就能一下子读懂代码的含义了。其实说白了，Kotlin 提供那么多操作符，就是来精简代码的，让你看到这个操作符就能一下明白代码的大致意思了。当然这仅仅是个例子，就在昨天的开发场景中，我使用了大量的 RxJava 以及 Kotlin，写代码的心情十分愉悦！但是目前对于 RxJava 还不算特别掌握，此篇文章只是随便谈一谈，后续会再专门写写 RxJava。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Android 获取 BuildConfig 信息","date":"2018-01-04T01:36:15.000Z","path":"2018/01/04/build-config/","text":"项目开发中，我们的 App 这个 Module 定义了3个 buildType： 1234567891011buildTypes &#123; release &#123; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;0&#x27;) &#125; debug &#123; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;1&#x27;) &#125; beta &#123; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;2&#x27;) &#125;&#125; 通过参数 HOST_TYPE 来指定数据的环境。debug 为内网测试版，beta 为外网测试版，release 为正式版本。项目有3个产品线：手机、POS机、收银机，Module 的依赖是这样的：App 作为 Application，其他作为 Library。 现在需要在收银机登录页打上版本的标识，方便调试（因为经常搞混…）。例如 v3.1.0(debug)，v3.1.0(beta)，正式版本则是 v3.1.0。那么现在就需要在收银机 Module 中获取 BuildConfig 的信息，一个是 BuildConfig.DEBUG，以及 BuildConfig.BUILD_TYPE。但是无论我 App 切换成 debug，beta，还是 release，收银机中获取到的值都是BuildConfig.DEBUG = false，BuildConfig.BUILD_TYPE = &quot;release&quot;。可以看出来，BuildConfig 信息是根据当前 Module 来的，每个 Module 的 BuildConfig 是各自进行配置的。而作为 Library Module，我们直接把 debug 给忽略了，所以 Library Module 一直是 release 版本。 123456variantFilter &#123; variant -&gt; def buildType = variant.buildType.name if (buildType.contains(&quot;debug&quot;)) &#123; setIgnore(true) &#125;&#125; 那么 如何在 Library Module 获取 App Module 中的 BuildConfig 信息呢？ 方案一Library Module 进行与 App Module 一样的 buildType 设置。然后 App 的依赖就像这样： 12345dependencies &#123; releaseCompile project(path: &#x27;:Library&#x27;, configuration: &#x27;release&#x27;) debugCompile project(path: &#x27;:Library&#x27;, configuration: &#x27;debug&#x27;) betaCompile project(path: &#x27;:Library&#x27;, configuration: &#x27;beta&#x27;)&#125; 这当然可以解决问题，但是 Library 添加多个编译类型无疑会加长编译时间，而且所有 buildVariant 都得进行配置，侵入性太强，不可取。 方案二使 Library Module 能够 import 到外层真正运行 App 的 BuildConfig，如下： 12345678910111213141516171819202122public class AppUtils &#123; private static Boolean isDebug = null; public static boolean isDebug() &#123; return isDebug == null ? false : isDebug.booleanValue(); &#125; public static void syncIsDebug(Context context) &#123; if (isDebug == null) &#123; try &#123; String packageName = context.getPackageName(); Class buildConfig = Class.forName(packageName + &quot;.BuildConfig&quot;); Field DEBUG = buildConfig.getField(&quot;DEBUG&quot;); DEBUG.setAccessible(true); isDebug = DEBUG.getBoolean(null); &#125; catch (Throwable t) &#123; // Do nothing &#125; &#125; &#125;&#125; 通过反射得到真正执行的 Module 的 BuildConfig，在自己的 Application 内调用： 1AppUtils.syncIsDebug(getApplicationContext()); 这样看起来达到目的了。但仔细想想会发现这种解决方案还是有问题，因为 BuildConfig.java 的 packageName 是 Module 的 Package Name，即 AndroidManifest.xml 中的 package 属性，而 context.getPackageName() 得到的是应用的 applicationId，这个 applicationId 通过 build.gradle 是可以修改的。所以当 build.gradle 中的 applicationId 与 AndroidManifest.xml 中的 package 属性不一致时，上面的反射查找类路径便会出错。而恰恰项目中利用了 gradle 配置的 applicationId，所以此方案也不可取。 方案三AppCommon 中新建一个类，利用这个类保存 App Module 中的 BuildConfig 信息。 12345678910111213141516171819202122232425public class BuildTypeHelper &#123; /** * 是否可调试 */ private static boolean mIsDebug = false; /** * 编译类型：debug、beta、release */ private static String mBuildType = &quot;&quot;; public static void init(boolean isDebug, String buildType) &#123; mIsDebug = isDebug; mBuildType = buildType; &#125; public static String getBuildType() &#123; return mBuildType; &#125; public static boolean isDebug() &#123; return mIsDebug; &#125;&#125; 然后在 App Module 中的 Application 初始化时进行赋值： 12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); BuildTypeHelper.init(BuildConfig.DEBUG, BuildConfig.BUILD_TYPE); &#125;&#125; 然后在 Library Module 中取值使用： 12345if (BuildTypeHelper.isDebug()) &#123; mVersionTv.setText(String.format(&quot;v%s(%s)&quot;, AppUtils.getCurrentVersionName(this), BuildTypeHelper.getBuildType()));&#125; else &#123; mVersionTv.setText(String.format(&quot;v%s&quot;, AppUtils.getCurrentVersionName(this)));&#125; 再说一点如果只是想获取 BuildConfig.DEBUG，可以使用 ApplicationInfo.FLAG_DEBUGGABLE。我们反编译 Debug 包和 Release 包对比看看有没有其他的区别，会发现他们 AndroidManifest.xml 中 Application 节点的 android:debuggable 值是不同的。Debug 包值为 true，Release 包值为 false，这是编译自动修改的。 123456789101112131415public class AppUtils &#123; private static Boolean isDebug = null; public static boolean isDebug() &#123; return isDebug == null ? false : isDebug.booleanValue(); &#125; public static void syncIsDebug(Context context) &#123; if (isDebug == null) &#123; isDebug = context.getApplicationInfo() != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; &#125; &#125;&#125; 在自己的 Application 内调用进行初始化： 1AppUtils.syncIsDebug(getApplicationContext()); 这样以后调用 AppUtils.isDebug() 即可判断是否是 Debug 版本，比如在上面的 LogUtils 中。同时适用于 Module 是 Lib 和 applicationId 被修改的情况，比 BuildConfig.DEBUG 靠谱的多。这个方案有个注意事项就是自己 App Module 中不能主动设置 android:debuggable，否则无论 Debug 还是 Release 版会始终是设置的值。当然本身就没有自动设置的必要。但是因为本例中还需要获取 BuildConfig.BUILD_TYPE，所以没有采取此方案。 参考Android Debug 版本判断及为什么 BuildConfig.DEBUG 始终为 falseAndroidStudio多模块编译之子模块的调试","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"关于 MVP 模式的一点思考（续）","date":"2017-12-22T02:04:41.000Z","path":"2017/12/22/mvp-2/","text":"之前有一个关于 MVP 的疑惑：1个 Presenter 能否对应多个 View？，在我的这篇文章中有写过。现在回过头来仔细想想，感觉有点不对劲：1个 Presenter 为什么会有对应多个 View 的需求呢？那篇文章中的使用场景是： 我有 A B C 三个页面，我有一个 Presenter，用来处理一个数据类型的增删改查，但是界面上，A界面只需要查询，B界面只需要删除，C界面只需要增和改。 我们都知道，Presenter 是用来抽离 Activity 或 Fragment 中的业务代码的，何为业务代码？就是这个页面涉及到的业务逻辑。关于数据的增删改查，那是 M 应该做的事，而绝不是 Presenter 该去处理的。 所以，Presenter 应当只对应一个 View，如果有界面复用 Presenter 的情况，那我们得考虑为什么会有这种情况呢？复用 Presenter 代表着业务逻辑是一致的，不同的页面理当有着不同的业务逻辑。当然，这里说的业务是简单，最小颗粒化的业务，如果一个页面十分复杂，Presenter 中集合了大量业务代码，那么在某些小的页面是有可能复用 Presenter 中的部分业务代码的。所以这种情况下，Presenter 会对应多个 View，那么这个场景使用上篇文章中的做法是可以的：复用 Presenter，将 View 抽离，利用继承实现多个界面的定制需求，但不会是上篇文章中的那种使用场景。 为什么会有上篇文章中的场景呢？因为目前项目中的 Presenter 做了 M 该做的事，举个栗子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class PrinterPresenter extends AbsPresenter implements IPrinterPresenter, LoaderManager.LoaderCallbacks&lt;Cursor&gt; &#123; private IView mView; private AddOrUpdatePrinterTask mAddOrUpdateTask; private DeletePrinterTask mDeleteTask; public PrinterPresenter(@NonNull IView view) &#123; super(view); this.mView = view; &#125; @Override public void loadTemplates() &#123; mLoaderManager.initLoader(AppConst.LOADER_ID.PRINTER_TEMPLATE, bundle, this); &#125; @Override public void loadPrinters() &#123; mLoaderManager.initLoader(AppConst.LOADER_ID.PRINTER_INFO, null, this); &#125; @Override public void destroyLoader() &#123; mLoaderManager.destroyLoader(AppConst.LOADER_ID.PRINTER_INFO); mLoaderManager.destroyLoader(AppConst.LOADER_ID.ALL_INVENTORY_TYPE_ID); &#125; @Override public void savePrinter(PrinterInfo printerInfo) &#123; mAddOrUpdateTask = new AddOrUpdatePrinterTask(mContext, printerInfo); mAddOrUpdateTask.execute(); &#125; @Override public void deletePrinter(PrinterInfo printerInfo) &#123; mDeleteTask = new DeletePrinterTask(mContext, printerInfo); mDeleteTask.execute(); &#125; @Override public void onDestroyView() &#123; mView = null; destroyLoader(); super.onDestroyView(); &#125; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) &#123; CursorLoader cursorLoader = null; if (id == AppConst.LOADER_ID.PRINTER_INFO) &#123; cursorLoader = new CursorLoader(mContext, MMRContract.Printer.getContentUri(mContext.getPackageName()), null, null, null, null); &#125; else if (id == AppConst.LOADER_ID.PRINTER_TEMPLATE) &#123; cursorLoader = new CursorLoader(mContext, MMRContract.Printer.getTemplateContentUri(mContext.getPackageName()), null, selection, new String[]&#123;version, logoVersion&#125;, null); &#125; return cursorLoader; &#125; @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) &#123; int id = loader.getId(); switch (id) &#123; case AppConst.LOADER_ID.PRINTER_INFO: if (mView != null &amp;&amp; mView instanceof IPrinterInfoView) &#123; ((IPrinterInfoView) mView).showPrinters(printerList); &#125; break; case AppConst.LOADER_ID.ALL_INVENTORY_TYPE_ID: if (mView != null &amp;&amp; mView instanceof IPrinterSetView) &#123; ((IPrinterSetView) mView).showAllCategories(categories); &#125; break; case AppConst.LOADER_ID.PRINTER_TEMPLATE: // do something break; &#125; &#125; @Override public void onLoaderReset(Loader loader) &#123; &#125; private class AddOrUpdatePrinterTask extends AsyncTask&lt;Void, Void, Uri&gt; &#123; // 添加或更新打印机异步任务 &#125; private class DeletePrinterTask extends AsyncTask&lt;Void, Void, Integer&gt; &#123; // 删除打印机异步任务 &#125;&#125; 代码做了精简，表达出意思即可。可以看到，Presenter 实现了 LoaderManager.LoaderCallbacks 接口，（项目中数据的获取大部分是采用的 CursorLoader 来实现的），然后看到对应的 ContentProvider，根据不同的 uri 进行相应的增删改查： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class PrinterProviderHelper extends BaseProviderHelper &#123; private UriMatcher mUriMatcher; private static final int CODE_PRINTER = 1; private static final int CODE_PRINTER_TEMPLATE = 2; private static final int CODE_PRINTER_ACTIVE_INFO = 3; public PrinterProviderHelper(Context ctx, String authority) &#123; super(ctx); mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); mUriMatcher.addURI(authority, MMRContract.Printer.PATH_PRINTER_TEMPLATE, CODE_PRINTER_TEMPLATE); mUriMatcher.addURI(authority, MMRContract.Printer.PATH_PRINTER, CODE_PRINTER); &#125; @Override public int match(Uri uri) &#123; return mUriMatcher.match(uri); &#125; @Override protected Uri insert(ServiceManager serviceManager, Uri uri, ContentValues values) &#123; if (serviceManager == null) &#123; return null; &#125; switch (mUriMatcher.match(uri)) &#123; case CODE_PRINTER: // 实际添加打印机的方法 int result = serviceManager.getPrinterInfoService().addOrUpdatePrinter(printerInfo); break; default: break; &#125; return super.insert(serviceManager, uri, values); &#125; @Override protected Cursor query(ServiceManager serviceManager, Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; if (serviceManager == null) &#123; return null; &#125; switch (mUriMatcher.match(uri)) &#123; case CODE_PRINTER: // 实际查询打印机信息的方法 PrinterInfo[] printerInfo = serviceManager.getPrinterInfoService().queryPrinterInfo(); break; case CODE_PRINTER_TEMPLATE: // 查询打印机模板的方法 break; default: break; &#125; return cursor; &#125; @Override protected int delete(ServiceManager serviceManager, Uri uri, String selection, String[] selectionArgs) &#123; if (serviceManager == null) &#123; return 0; &#125; PrinterInfoService printerInfoService = serviceManager.getPrinterInfoService(); switch (mUriMatcher.match(uri)) &#123; case CODE_PRINTER: // 实际删除删除打印机的方法 int result = serviceManager.getPrinterInfoService().deletePrinter(mac) return result; default: break; &#125; return super.delete(serviceManager, uri, selection, selectionArgs); &#125;&#125; 可以看到，PrinterProviderHelper 才是我们的 M 层，但是它并没有对数据的操作进行封装，仅仅提供了最底层的方法，数据操作的封装反而写到了 Presenter 里，这就是不合理的地方，导致了前面出现的场景：A 界面只需要查询，B 界面只需要删除，C 界面只需要增和改，而增删改查的接口都封装在了 Presenter 里面，以至于出现需要复用 Presenter 的伪需求。理论上应该由 M 封装数据操作，然后 P 持有 M 的引用，进行方法调用即可。就像这样： 12345678910111213141516171819202122232425262728293031class M &#123; PrinterInfo[] getPrinterInfo()&#123; // 封装获取打印机方法 &#125; int addOrUpdatePrinter(PrinterInfo info)&#123; // 封装添加打印机方法 &#125; int deletePrinter(String mac)&#123; // 封装删除打印机方法 &#125; ...&#125;class P &#123; private M m; PrinterInfo[] getPrinterInfo()&#123; return m.getPrinterInfo(); &#125; int addOrUpdatePrinter(PrinterInfo info)&#123; return m.addOrUpdatePrinter(info); &#125; int deletePrinter(String mac)&#123; return m.deletePrinter(mac); &#125;&#125; 如此这般， A B C 3个界面对应各自的 P，对于数据的操作只需要持有 M 进行方法调用就好了，那么关于 View 接口的定制也是一对一的，不会出现多的 do nothing 的方法了。其实这在Google 中的 MVP 架构演示中就已经表达出来了。只不过来到公司项目的中 Presenter 就是这样实现的，加上大多数时候程序员都是以功能优先，很少有时间真正去思考一些东西。至于数据操作涉及的异步线程的切换，使用 CursorLoader、AsyncTask 亦或是 RxJava 都是可以的，这就看项目实际情况了。","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"Kotlin - 代码篇","date":"2017-12-21T03:15:32.000Z","path":"2017/12/21/kotlin-code/","text":"写过几个星期的 Kotlin 代码了，再也不用 findViewById 了，使用起来稍微简洁一点。今天小结一下，基础用法就不多说了，直接写几点我感触较深的。 空安全当使用Java开发的时候，我们的代码大多是防御性的。如果我们不想遇到 NullPointerException，我们就需要在使用它之前不停地去判断它是否为 null。Kotlin，则是空安全的，我们可以通过一个安全调用操作符 (写做 ? )来明确地指定一个对象是否能为空。 12345678910111213141516// 这里不能通过编译. Artist 不能是 nullvar notNullArtist: Artist = null// Artist 可以是 nullvar artist: Artist? = null// 无法编译, artist可能是 null,我们需要进行处理artist.print()// 只要在artist != null时才会打印artist?.print()// 智能转换. 如果我们在之前进行了空检查,则不需要使用安全调用操作符调用if (artist != null) &#123; artist.print()&#125;// 只有在确保 artist 不是 null 的情况下才能这么调用，否则它会抛出异常artist!!.print()// 使用 Elvis操作符 来给定一个在是 null 的情况下的替代值val name = artist?.name ?: &quot;empty&quot; 关于 Elvis操作符 其实是三目条件运算符的简略写法。可以这样理解： A ?: B 等价于 if(A &#x3D;&#x3D; null) B A?.B ?: C 等价于 if(A !&#x3D; null) A.B else C 变量所有的变量都需要由 val 或 var 来修饰，val 代表不可变变量，初始化后无法被修改，而 var 代表可变变量，后面允许被修改。在 Kotlin 中，一个非抽象的属性在构造函数执行完之前需要被赋值，如果声明的时候带上了 ? 表示可以为空，那么之后使用时就得各种?或!!操作符了，极其不便。很多时候，我们的赋值肯定不为空，但是依赖 Activity 或 Fragment 等 Android 组件的生命周期，无法直接赋值。这个时候有 2 种做法： 使用 lazyinit：1234567private lateinit var tableRegionAdapter: CommonMetaAdapteronCreate()&#123; ... // 进行初始化 tableRegionAdapter = CommonMetaAdapter(mActivity)&#125; lateinit修饰符所修饰的属性必须是非空类型，而且不能是原生类型（Int、Float、Char等），而且该修饰符只能用于类体中，不能在主构造函数中，也不能修饰局部变量，并且只可用于 var 类型变量。 by lazy：1private val menus: Array&lt;String&gt; by lazy &#123; arrayOf(MENU_PRINT_MANAGE) &#125; by lazy是使用了属性委托的方式，来实现懒初始化，用于修饰 val 变量。只会在第一次调用的时候进行初始化，后续调用时直接返回同样的值。当变量仅仅初始化一次并且全局共享，且更多的是内部使用时应该使用这种模式。属性委托中还有一种声明非空属性的方法：1private val menus by Delegates.notNull&lt;Array&lt;String&gt;&gt;() 利用Delegates.notNull可直接声明非空变量，并在其他地方进行初始化。关于属性委托的更多信息，请参考委托属性。注意：val 修饰的变量并不代表就是常量，具体请参考Kotlin中常量的探究。 静态方法之前的 Java 代码使用 Activity 跳转的时候经常在目标 Activity 中定义 navigateTo 方法，就像这样： 12345678910public class DeliverActivity extends AppBarActivity &#123; public static final String EXTRA_KEY_MANIFEST = &quot;extra.manifest&quot;; public static void navigateToForResult(Fragment fragment, int requestCode, Manifest manifest) &#123; Intent intent = new Intent(fragment.getActivity(), DeliverActivity.class); intent.putExtra(EXTRA_KEY_MANIFEST, manifest); fragment.startActivityForResult(intent, requestCode); &#125;&#125; 这样我们定义的 EXTRA_KEY_MANIFEST 设为 private，只有 DeliverActivity 类能使用，避免定义成 public 影响到其他类。所有的变量都是内部消化，跳转时不用进行拷贝。而 Kotlin 中没有静态方法这一说，可以使用 伴生对象 来实现静态： Kotlin允许我们去定义一些行为与静态对象一样的对象。尽管这些对象可以用众所周知的模式来实现，比如容易实现的单例模式。我们需要一个类里面有一些静态的属性、常量或者函数，我们可以使用 companion object。这个对象被这个类的所有对象所共享，就像Java中的静态属性或者方法。 使用起来就是这样： 123456789101112131415161718192021class ChooseDiningTableActivity : AppBarActivity() &#123; companion object StaticDiningTable &#123; val EXTRA_RESULT = &quot;extra.result&quot; private val EXTRA_TABLE_LIST = &quot;extra.tableList&quot; private val EXTRA_TABLE_REGION_LIST = &quot;extra.tableRegionList&quot; private val EXTRA_PEOPLE_COUNT = &quot;extra.peopleCount&quot; fun navigateTo(fragment: BaseFragment, requestCode: Int, tableList: ArrayList&lt;DiningTable&gt;, tableTypeList: ArrayList&lt;TableRegion&gt;, peopleCount: Int) &#123; val intent = Intent(fragment.context, ChooseDiningTableActivity::class.java) intent.putExtra(EXTRA_TABLE_LIST, tableList) intent.putExtra(EXTRA_TABLE_REGION_LIST, tableTypeList) intent.putExtra(EXTRA_PEOPLE_COUNT, peopleCount) fragment.startActivityForResult(intent, requestCode) &#125; &#125;&#125;// 使用跟 Java 调用静态方法一样ChooseDiningTableActivity.navigateTo(this, REQUEST_CODE_FOR_CHOOSE_TABLE, diningTableList, tableTypeList, item.customerNumber) 高阶函数高阶函数是将函数用作参数或返回值的函数，就有点像 c++ 中的函数指针。当你提供一个方法，方法执行完之后接收一个回调，然后执行回调中的方法，这种场景想必大家都遇到过。一般就是定义一个接口，然后传入一个接口实现类进去，就像 setOnClickListener 一样。但是高阶函数就省去了接口这一步，直接传入一个函数作为参数，进行回调。举个栗子： 12345public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123; for (item in this) destination.add(transform(item)) return destination&#125; 使用时： 1234567891011override fun showTableRegions(tableRegionList: MutableList&lt;TableRegion&gt;) &#123; val allRegion = CommonMetaBean() allRegion.name = ALL_TABLE_REGION val list = ArrayList&lt;CommonMetaBean&gt;() list.add(allRegion) tableRegionList.mapTo(list) &#123; CommonMetaBean(it.regionID, it.regionName) &#125; tableRegionAdapter.setDataList(list) tableRegionAdapter.notifyDataSetChanged()&#125; 集合操作符 mapTo 接收一个函数 transform 作为参数，将自身的 item 转化为另外一个对象，然后 add 到 destination 目标集合中。一个有用的约定：如果函数字面值只有一个参数， 那么它的声明可以省略（连同 -&gt;），其名称是 it。 就像我实例中的代码一样。再举个很实用的例子：列表定义 Adapter，如果有点击事件，我们一般会在 Adapter 中定义一个接口，然后在 Adapter 初始化的时候传入接口的实现类，就像这样： 123456789101112131415161718class Adapter extends BaseAdapter &#123; public Adapter(Context context, OnFunctionClickListener listener) &#123; mListener = listener; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; holder.moreIv.setOnClickListener(v -&gt; &#123; if (mListener != null) &#123; mListener.onFunctionClick(data); &#125; &#125;); &#125; public interface OnFunctionClickListener &#123; onFunctionClick(Object obj); &#125;&#125; 当使用 Kotlin 之后，我们可以直接忽略接口的定义，直接传入一个匿名函数，就可以实现这样的功能了，简单很多，就像这样： 123456789101112131415161718class LogTimeAdapter(private val context: Context, dataList: ArrayList&lt;TimeBean&gt;, private val onClick: (TimeBean) -&gt; Unit) : RecyclerView.Adapter&lt;LogTimeAdapter.ViewHolder&gt;() &#123; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; val timeBean = dataList[position] val timeDesc = DateUtils.getDateString(timeBean.beginTime.toInt()) + &quot; 至 &quot; + DateUtils.getDateString(timeBean.endTime.toInt()) with(holder.itemView) &#123; // 注意这里，onClick 是在构造函数中直接传入的匿名函数，省去了接口的定义 setOnClickListener &#123; onClick(timeBean) &#125; &#125; &#125; override fun getItemCount(): Int = dataList.size class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)&#125; lambdaKotlin 的使用是离不开 lambda 表达式的。最典型的例子： 1view.setOnClickListener() &#123; toast(&quot;Hello world!&quot;) &#125; 请注意，如果 lambda 是该调用的唯一参数，则调用中的圆括号可以完全省略： 1view.setOnClickListener &#123; toast(&quot;Hello world!&quot;) &#125; 如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称： 1map.forEach &#123; _, value -&gt; println(&quot;$value!&quot;) &#125; 关于 lambda 一个简短的概述： lambda 表达式总是被大括号括着； 其参数（如果有的话）在 -&gt; 之前声明（参数类型可以省略）； 函数体（如果存在的话）在 -&gt; 后面。 如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。因此，下两个片段是等价的： 123456789ints.filter &#123; val shouldFilter = it &gt; 0 shouldFilter&#125;ints.filter &#123; val shouldFilter = it &gt; 0 return@filter shouldFilter&#125; 其他 默认任何类都是基础继承自 Any (与java中的 Object 类似)，但是我们可以继承其它类。所有的类默认都是不可继承的(final)，所以我们只能继承那些明确声明 open 或者 abstract 的类:12open class Animal(name: String)class Person(name: String, surname: String) : Animal(name) 拓展函数：12345fun Fragment.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123; Toast.makeText(getActivity(), message, duration).show()&#125;fragment.toast(&quot;Hello world!&quot;) 扩展函数并不是真正地修改了原来的类，它是以静态导入的方式来实现的。扩展函数可以被声明在任何文件中，因此有个通用的实践是把一系列有关的函数放在一个新建的文件里。 集合操作符：forEach、max、filter、mapTo等等，Kotlin 中的集合为我们提供了很多的操作符，但是你大可不必去背它。当我们用 Java 写出一些集合操作的代码时， Android Studio 会智能识别我们的代码，然后提示可以被哪些操作符给替代，这个时候转一下就好了。 其他操作符：Kotlin 还提供了很多其他的操作符，let、with、apply等等，这些操作符都可以简化我们的代码。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Java 中的 Comparator","date":"2017-12-20T08:04:13.000Z","path":"2017/12/20/comparator/","text":"最近写过一个界面，涉及到排序。用到了 Collections 中的 sort 方法： 123456789101112131415Collections.sort(mData, new Comparator&lt;BookMemberReport&gt;() &#123; @Override public int compare(BookMemberReport lhs, BookMemberReport rhs) &#123; if (sortFlag == SORT_FLAG_SALE_DESCENDING) &#123; return (int) (rhs.saleAmount - lhs.saleAmount); &#125; else if (sortFlag == SORT_FLAG_SALE_ASCENDING) &#123; return (int) (lhs.saleAmount - rhs.saleAmount); &#125; else if (sortFlag == SORT_FLAG_COUNT_DESCENDING) &#123; return rhs.orderCount - lhs.orderCount; &#125; else if (sortFlag == SORT_FLAG_COUNT_ASCENDING) &#123; return lhs.orderCount - rhs.orderCount; &#125; return 0; &#125;&#125;); Collections 根据传入的 Comparator 进行排序。刚开始写的时候通过不停的试，把正确的结果给试出来了。但是对于其原理却不是很清晰，今天便稍微扒一扒其源码。 1234567891011121314public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; if (list.getClass() == ArrayList.class) &#123; Arrays.sort(((ArrayList) list).elementData, 0, list.size(), (Comparator) c); return; &#125; Object[] a = list.toArray(); Arrays.sort(a, (Comparator)c); ListIterator&lt;T&gt; i = list.listIterator(); for (int j=0; j&lt;a.length; j++) &#123; i.next(); i.set((T)a[j]); &#125;&#125; 跟到 Arrays.sort() 方法： 12345678910public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a); &#125; else &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); &#125;&#125; 在 else 分支中还有一个分支，看到 userRequested： 12345678910/** * Old merge sort implementation can be selected (for * compatibility with broken comparators) using a system property. * Cannot be a static boolean in the enclosing class due to * circular dependencies. To be removed in a future release. */static final class LegacyMergeSort &#123; // Android-changed: Never use circular merge sort. private static final boolean userRequested = false;&#125; 所以所有的排序应该都是走的 TimSort 分支。但是这不影响研究 Comparator 接口的原理，进入到 legacyMergeSort： 12345678/** To be removed in a future release. */private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) &#123; T[] aux = a.clone(); if (c==null) mergeSort(aux, a, 0, a.length, 0); else mergeSort(aux, a, 0, a.length, 0, c);&#125; 继续跟进： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Src is the source array that starts at index 0 * Dest is the (possibly larger) array destination with a possible offset * low is the index in dest to start sorting * high is the end index in dest to end sorting * off is the offset into src corresponding to low in dest * To be removed in a future release. */private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off, Comparator c) &#123; int length = high - low; // Insertion sort on smallest arrays if (length &lt; INSERTIONSORT_THRESHOLD) &#123; for (int i=low; i&lt;high; i++) for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--) swap(dest, j, j-1); return; &#125; // Recursively sort halves of dest into src int destLow = low; int destHigh = high; low += off; high += off; int mid = (low + high) &gt;&gt;&gt; 1; mergeSort(dest, src, low, mid, -off, c); mergeSort(dest, src, mid, high, -off, c); // If list is already sorted, just copy from src to dest. This is an // optimization that results in faster sorts for nearly ordered lists. if (c.compare(src[mid-1], src[mid]) &lt;= 0) &#123; System.arraycopy(src, low, dest, destLow, length); return; &#125; // Merge sorted halves (now in src) into dest for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123; if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0) dest[i] = src[p++]; else dest[i] = src[q++]; &#125;&#125; 看到第一个 if 语句，看到 INSERTIONSORT_THRESHOLD 变量： 123456/** * Tuning parameter: list size at or below which insertion sort will be * used in preference to mergesort. * To be removed in a future release. */private static final int INSERTIONSORT_THRESHOLD = 7; 即只要是数组个数小于 7 的，直接走 if 语句进行排序，然后返回。重点： 1234for (int i=low; i&lt;high; i++) for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--) swap(dest, j, j-1);return; 即第 j-1 个元素跟 j 进行比较，通过 compare 返回的值，如果大于 0，则进行交换。看到 compare 接口： 123456789101112/** * @param o1 the first object to be compared. * @param o2 the second object to be compared. * @return a negative integer, zero, or a positive integer as the * first argument is less than, equal to, or greater than the * second. * @throws NullPointerException if an argument is null and this * comparator does not permit null arguments * @throws ClassCastException if the arguments&#x27; types prevent them from * being compared by this comparator. */int compare(T o1, T o2); 所以很清晰了，如果 compare 返回的值大于 0，那么就会将这 2 个元素交换，即将大元素放在前面进行降序，反之则是正序。文中代码基于 Android-25，Android-26 中已经剔除 LegacyMergeSort。 1234567891011public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a); &#125; else &#123; // Android-changed: LegacyMergeSort is no longer supported // if (LegacyMergeSort.userRequested) // legacyMergeSort(a, c); // else TimSort.sort(a, 0, a.length, c, null, 0, 0); &#125;&#125; 虽然分析选取的代码并不会执行，但是丝毫不影响研究 Comparator 的原理。无论源码怎么变化，只要 Comparator 接口不变，那么它的原理便会始终是这样的。抛弃复杂的，选取简单的，使源码阅读起来更为快捷。好了，简单的阅读完了，可以阅读一下复杂的 TimSort.sort 了。","tags":[{"name":"Java","slug":"Java","permalink":"http://lijia92.github.io/tags/Java/"}]},{"title":"Support 库，注意你的版本号","date":"2017-12-15T09:18:29.000Z","path":"2017/12/15/support-version/","text":"项目开发，引进了一个新的三方库，导致之前能运行的代码出现问题，错误堆栈： 12345678910111213141516171819FATAL EXCEPTION: mainProcess: com.lijia.app.catering.dev, PID: 29387java.lang.NoClassDefFoundError: android.support.v4.animation.AnimatorCompatHelper at android.support.v7.widget.DefaultItemAnimator.resetAnimation(DefaultItemAnimator.java:514) at android.support.v7.widget.DefaultItemAnimator.animateAdd(DefaultItemAnimator.java:217) at android.support.v7.widget.SimpleItemAnimator.animateAppearance(SimpleItemAnimator.java:114) at android.support.v7.widget.RecyclerView.animateAppearance(RecyclerView.java:3243) at android.support.v7.widget.RecyclerView.access$800(RecyclerView.java:147) at android.support.v7.widget.RecyclerView$4.processAppeared(RecyclerView.java:436) at android.support.v7.widget.ViewInfoStore.process(ViewInfoStore.java:249) at android.support.v7.widget.RecyclerView.dispatchLayoutStep3(RecyclerView.java:3098) at android.support.v7.widget.RecyclerView.dispatchLayout(RecyclerView.java:2917) at android.support.v7.widget.RecyclerView.onLayout(RecyclerView.java:3283) at android.view.View.layout(View.java) at android.view.ViewGroup.layout(ViewGroup.java) at android.widget.LinearLayout.setChildFrame(LinearLayout.java) at android.widget.LinearLayout.layoutVertical(LinearLayout.java) at android.widget.LinearLayout.onLayout(LinearLayout.java) ... 即是在 v4 包中找不到类：AnimatorCompatHelper。Google 了一下，发现这个类在 v4 包版本 26 以上就被剔除了，而 RecyclerView 引用了这个类。所以先查看下依赖，来看看自己依赖的 v4 版本。执行命令： 1./gradlew app:dependencies --configuration cateringDevCompile 因为我的 buildVariant 很多，这里利用 configuration 参数指定一个 variant，缩减编译的时间。给出的 Log 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546cateringDevCompile - Classpath for compiling the cateringDev sources.\\--- project :ui-jch +--- org.jetbrains.kotlin:kotlin-android-extensions-runtime:1.2.0 | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.2.0 | \\--- org.jetbrains:annotations:13.0 +--- project :ui-common-portrait | +--- project :appcommon | | +--- com.yanzhenjie:recyclerview-swipe:1.0.2 | | | \\--- com.android.support:recyclerview-v7:23.4.0 | | | +--- com.android.support:support-annotations:23.4.0 -&gt; 26.1.0 | | | \\--- com.android.support:support-v4:23.4.0 -&gt; 26.1.0 (*) | | +--- com.jph.takephoto:takephoto_library:3.0.1 | | | +--- com.android.support:support-v4:24.0.0 -&gt; 26.1.0 (*) | | | +--- com.soundcloud.android.crop:lib_crop:1.0.0 | | | | +--- com.android.support:support-v4:23.0.1 -&gt; 26.1.0 (*) | | | | \\--- com.android.support:support-annotations:23.0.1 -&gt; 26.1.0 | | | \\--- com.darsh.multipleimageselect:multipleimageselect:1.0.4 | | | +--- com.android.support:appcompat-v7:23.1.1 -&gt; 26.1.0 | | | | +--- com.android.support:support-annotations:26.1.0 | | | | +--- com.android.support:support-v4:26.1.0 (*) | | | | +--- com.android.support:support-vector-drawable:26.1.0 | | | | | +--- com.android.support:support-annotations:26.1.0 | | | | | \\--- com.android.support:support-compat:26.1.0 (*) | | | | \\--- com.android.support:animated-vector-drawable:26.1.0 | | | | +--- com.android.support:support-vector-drawable:26.1.0 (*) | | | | \\--- com.android.support:support-core-ui:26.1.0 (*) | | | \\--- com.github.bumptech.glide:glide:3.6.0 | | +--- me.alzz:kosp:1.0.0 | | | +--- org.jetbrains.kotlin:kotlin-stdlib-jre7:1.1.51 -&gt; 1.2.0 | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.2.0 (*) | | | \\--- com.android.support:appcompat-v7:26.1.0 (*) | | +--- com.lijia.lib:modservice:7.1.0-SNAPSHOT | | | +--- com.lijia:useragent:7.1.0-SNAPSHOT | | | | +--- com.lijia.lib:modcore:7.1.0-SNAPSHOT | | | | | +--- com.android.support:support-annotations:25.0.1 -&gt; 26.1.0 | | | | | \\--- com.lijia.lib:common:7.1.0-SNAPSHOT | | | | | +--- com.android.support:design:23.2.1 -&gt; 23.3.0 | | | | | | +--- com.android.support:appcompat-v7:23.3.0 -&gt; 26.1.0 (*) | | | | | | +--- com.android.support:support-v4:23.3.0 -&gt; 26.1.0 (*) | | | | | | \\--- com.android.support:recyclerview-v7:23.3.0 -&gt; 23.4.0 (*) | | | | | \\--- com.tencent.bugly:crashreport:latest.release -&gt; 2.6.6.1 | | | | \\--- com.lijia.lib:common:7.1.0-SNAPSHOT (*) | | +--- com.lijia.lib:webserver:7.0.0 | | \\--- org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0 (*) | \\--- com.tencent.mm.opensdk:wechat-sdk-android-without-mta:1.4.0(*) - dependencies omitted (listed previously) 分析可以看到自己依赖的 support 库都是 23 24版本的，所以不会导致问题，但是加上依赖me.alzz:kosp之后，依赖的 support v7 版本是 26.1.0，而 v7 库又依赖了 v4 库，所以 v4 库被升到了 26.1.0，但是用到的 Recycleview 在 design 包中，版本号是 23.3.0，依赖的一个库com.yanzhenjie:recyclerview-swipe将其升到了 23.4.0，所以 Recycleview 的版本和 support-v4 的版本是对应不上的，才导致的这个问题。所以将依赖的 design 包升级到 26 即可解决问题。 1compile &#x27;com.android.support:design:26.1.0&#x27; 出现这个问题的原因就是 support 各种库的版本不一致。一般不容易出现这个问题，但是我的项目 进行模块化，将代码分为了很多模块，对应到不同的工程，不同的 Module，导致 gradle 文件是分散的，经常改了这处忘了那处。这里写下这篇文章也是加深下印象，也给自己提个醒，以后一定要注意 support 库的版本号，不然有可能导致崩溃。 题外话gradle 插件升级 3.0.0 之后执行查找依赖变化了，执行命令后返回的 Log 如下： 12cateringDevCompile - Compile dependencies for &#x27;cateringDev&#x27; sources (deprecated: use &#x27;cateringDevImplementation&#x27; instead). (n)No dependencies 换成： 1./gradlew app:dependencies --configuration cateringDevImplementation 返回的 Log 如下： 1234cateringDevImplementation - Implementation only dependencies for &#x27;cateringDev&#x27; sources. (n)\\--- project ui-jch (n)(n) - Not resolved (configuration is not meant to be resolved) 无法直观的看到依赖树，这个时候直接去掉 configuration，然后执行，可以看到所有编译的依赖树，然后选取你要的 buildVariant 即可，比如： 1./gradlew app:dependencies --configuration cateringDevDebugCompileClasspath","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Kotlin - 配置篇","date":"2017-12-05T10:05:32.000Z","path":"2017/12/05/kotlin-config/","text":"最近随着 Google 的大力推荐，越来越多开发者开始使用 Kotlin 了。其实我对 Kotlin 的并没有很特别的感觉，它就类似于 Swift 相比于 OC，大量的语法糖着实能使写代码的效率变高，但是是否能左右 Android 开发的现状还未可知。我接触 Kotlin 的主要原因是：业务代码太无聊啦。相信很多开发者都跟我有同样的感触，在一个公司待久了，技术框架摸透之后，后面的开发就基本是纯业务开发了，写界面，写业务代码，对于技术提升没有什么实质的帮助，就是真正的码农。为了改变这一现状，我不断在新需求中使用一些新的技术，比如 RxJava、Retrofit 等等，说是新技术其实也不新了，都出来都很久了，只是自己在项目中没有用到，接触得不多。在新需求中引入这些技术，可以边开发边学习，解决写业务代码的无聊，还能拓宽视野，学习新知识。虽然不一定会成为主流，但学习一下总是没问题的，因此开始接触 Kotlin。这篇文章主要先讲讲 Kotlin 的配置。 Kotlin 插件最新的 Android Studio 已默认装了 Kotlin 插件了，在旧版本可自己手动安装 Kotlin 插件。 安装插件后，选择一个 Java 文件，点击 Code -&gt; Convert Java File To Kotlin File，即可转换成 Kotlin 文件了。 配置 Kotlin 环境在 kt 文件中，随便使用一下 Kotlin 的特性，例如 List 的 filter 操作符，然后报错按下 Alt + Enter 弹出的方框中就有配置 Kotlin 的选项。如上图，选择要配置的 Module，确定后就会有自动配置了。项目根目录的 build.gradle 中： 12345678910111213buildscript &#123; // kotlin 版本 ext.kotlin_version = &#x27;1.2.0&#x27; repositories &#123; jcenter() google() &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:3.0.0&#x27; // 依赖 kotlin 插件 classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; &#125;&#125; 然后 Module 的 build.gradle 中： 12345apply plugin: &#x27;kotlin-android&#x27;dependencies &#123; implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot;&#125; 当然，你可以自己做这些配置。注意到apply plugin: &#39;kotlin-android&#39;，这个配置是针对 Module 的。如果有多个 Module 都需要用到 Kotlin，则每个 Module 都需要做这个配置。比如 app -&gt; library -&gt; core，app、library 中都使用了 kotlin，那么 app、library 2个 Module 都需要配置apply plugin: &#39;kotlin-android&#39;，否则会提示找不到符号:xxx（xxx为 Kotlin 编写的类）。 Kotlin 拓展Kotlin 团队研发的可以让开发更简单的插件是 Kotlin Android Extensions。这个插件可以自动绑定 View，再也不用 findViewById 了。要使用这个插件，在 Module 的 build.gradle 中配置： 1apply plugin: &#x27;kotlin-android-extensions&#x27; 然后一行代码导入即可直接使用布局中的 View。 1import kotlinx.android.synthetic.main.＜布局＞.* 假设当前布局文件是activity_main.xml，我们只需要引入kotlinx.android.synthetic.main.activity_main.*。导入完成后即可调用在 xml 文件中以视图控件命名属性的对应扩展，比如下例： 1234&lt;TextView android:id=&quot;@+id/hello&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 然后 activity 中可以直接如下使用： 1hello.text = &quot;Hello World!&quot; 再也不用 findViewById 了。当然你如果引用 ButterKnife 也可以省去 findViewById，只不过实现方式不一样。如此使用需要注意生命周期，在 view 还没创建时调用肯定是会失败的。注意到import kotlinx.android.synthetic.main.＜布局＞.*中的main，这是因为大多数时候我们的布局都是在 main 文件夹下，当我们定义了多种 buildVariant 时，就像Gradle 多版本管理（续）中写到的一样，那么我们就会有很多文件夹来分别对应这些 buildVariant 以实现多版本控制的需求了。那么这个时候我们的布局就不是在main文件夹中了。此时我们需要开启 Experimental Mode。 123androidExtensions &#123; experimental = true&#125; 然后选择对应的 buildVariant，我们可以直接导入对应的布局了。 参考Kotlin 中文教程《Kotlin for android developers》中文版翻译","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android 约束布局的使用","date":"2017-11-20T02:00:12.000Z","path":"2017/11/20/constraint/","text":"习惯了用 LinearLayout、RelativeLayout 等布局，但是在某些界面的优化上这些布局很难做到。说下我项目中的实际例子：一件商品有品名、数量、单价、金额等几条属性，要显示在一行。 注意，图中金额属性没有显示全，但这不是本文要写的内容。当文本过长显示不下，这是个历史难题。 本文要讲述的是如何利用约束布局来优化界面的显示。看到图中，我们通长使用 LinearLayout 的 weight 属性，给每一列设置一个 weight，相信大多数人都是这么做的，就像这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:paddingBottom=&quot;@dimen/margin_x_x_small&quot; android:paddingLeft=&quot;@dimen/padding_middle_large&quot; android:paddingRight=&quot;@dimen/padding_middle_large&quot; android:paddingTop=&quot;@dimen/margin_x_x_small&quot;&gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;8&quot; android:orientation=&quot;horizontal&quot;&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/product_count_tv&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;2&quot; android:gravity=&quot;center_vertical|end&quot; android:maxLines=&quot;1&quot; android:textColor=&quot;@color/font_main&quot; android:textSize=&quot;@dimen/font_body&quot; tools:text=&quot;4000.00&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;4&quot; android:gravity=&quot;center&quot; android:layout_gravity=&quot;center_vertical&quot; android:orientation=&quot;vertical&quot; android:paddingLeft=&quot;@dimen/margin_small&quot;&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/total_amount_tv&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;4&quot; android:gravity=&quot;end|center_vertical&quot; android:maxLines=&quot;1&quot; android:paddingLeft=&quot;@dimen/margin_small&quot; android:textColor=&quot;@color/font_main&quot; android:textSize=&quot;@dimen/font_body&quot; tools:text=&quot;4000.00&quot; /&gt;&lt;/LinearLayout&gt; 示例中的比例是8:2:4:4，标题与流水使用相同的比例。第一列与标题左对齐，后面几列与标题右对齐，这样写出来的界面效果会比较整洁。但是存在一种情况：商品名称很短，但是数量却很多。就像上图所示。那么数量所占的 2 &#x2F; 18 的比例是无法显示出1000000这个数量的，商品名称又很短导致浪费很多空间，但是图中却完美显示了。原因就在于 约束布局，这也是本文的重点。直接贴出使用约束布局的XML： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;55dp&quot; android:paddingBottom=&quot;@dimen/margin_x_x_small&quot; android:paddingLeft=&quot;@dimen/padding_middle_large&quot; android:paddingRight=&quot;@dimen/padding_middle_large&quot; android:paddingTop=&quot;@dimen/margin_x_x_small&quot;&gt; &lt;View android:id=&quot;@+id/view_mask1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintHorizontal_weight=&quot;8&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/view_mask2&quot; /&gt; &lt;View android:id=&quot;@+id/view_mask2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintHorizontal_weight=&quot;2&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/view_mask1&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/view_mask3&quot; /&gt; &lt;View android:id=&quot;@+id/view_mask3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintHorizontal_weight=&quot;4&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/view_mask2&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/view_mask4&quot; /&gt; &lt;View android:id=&quot;@+id/view_mask4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintHorizontal_weight=&quot;4&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/view_mask3&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; &lt;com.makeramen.roundedimageview.RoundedImageView android:id=&quot;@+id/product_icon_iv&quot; android:layout_width=&quot;45dp&quot; android:layout_height=&quot;45dp&quot; android:scaleType=&quot;center&quot; app:riv_corner_radius=&quot;@dimen/round_view_circular&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/product_name_ll&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;45dp&quot; android:layout_marginLeft=&quot;@dimen/margin_x_x_x_small&quot; android:layout_marginRight=&quot;@dimen/margin_x_x_x_small&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;vertical&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/product_icon_iv&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/product_count_tv&quot;&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/product_count_tv&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;45dp&quot; android:ellipsize=&quot;end&quot; android:gravity=&quot;center_vertical|end&quot; android:maxLines=&quot;1&quot; android:textColor=&quot;@color/font_main&quot; android:textSize=&quot;@dimen/font_body&quot; app:layout_constraintRight_toRightOf=&quot;@+id/view_mask2&quot; tools:text=&quot;4000.00&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/product_price_ll&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;45dp&quot; android:layout_marginLeft=&quot;@dimen/margin_x_x_x_small&quot; android:layout_marginStart=&quot;@dimen/margin_x_x_x_small&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/product_count_tv&quot; app:layout_constraintRight_toRightOf=&quot;@+id/view_mask3&quot;&gt; ... &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/total_amount_tv&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;45dp&quot; android:layout_marginLeft=&quot;@dimen/margin_x_x_x_small&quot; android:layout_marginStart=&quot;@dimen/margin_x_x_x_small&quot; android:ellipsize=&quot;end&quot; android:gravity=&quot;end|center_vertical&quot; android:maxLines=&quot;1&quot; android:textColor=&quot;@color/font_main&quot; android:textSize=&quot;@dimen/font_body&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/product_price_ll&quot; app:layout_constraintRight_toRightOf=&quot;@+id/view_mask4&quot; tools:text=&quot;40000.00&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 可以看到约束布局的一些属性：layout_constraintLeft_toRightOf。布局的左边在谁的右边，字面意思，很好理解。其他类似的还有 layout_constraintRight_toRightOf 、layout_constraintRight_toLeftOf等等。看到上面最上层有几个 view_mask，这是用来做对齐的，因为标题和流水没有在一个布局里。商品列与 view_mask1 左对齐，其他几列与相应的 view_mask 右对齐。然后看一下布局的宽度属性，我都是设置的0dp，这是因为在约束布局里，0dp代表MATCH_CONSTRAINT，它会利用约束自动设置控件的宽度。那么MATCH_PARENT去哪了？官网做了如下说明： Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left&#x2F;right or top&#x2F;bottom constraints being set to “parent”. MATCH_CONSTRAINT则是实现本文效果的核心。我并不需要给每列属性设置宽度，我需要的仅仅是：品名在数量的左边，数量在品名的右边，当品名字符串很长时，它可以无限接近数量字符串，直到没有剩余空间。虽然只是一点小小的优化，但是能改进某些情况下界面的显示效果，好处还是有的，今后还是多尝试用用约束布局，但是我是肯定不会用拖拽来实现布局的╮(╯▽╰)╭。 参考：拒绝拖拽 使用ConstraintLayout优化你的布局吧","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Retrofit 学习小结","date":"2017-11-15T10:40:56.000Z","path":"2017/11/15/retrofit-code/","text":"之前的一篇文章Retrofit初识尝试用了下 Retrofit。说来惭愧，到现在才写这篇文章。由于项目中没有使用的缘故，一直停留在了解的程度。最近自己学习做了个Gank客户端，一点点学习当前主流的技术，今天研究了下 Retrofit 的源码，颇有感触，便记录下来。 使用关于正常的使用，参考之前的那篇文章。这里再写一下结合 RxJava 的使用。 定义接口：12345678public interface GankService &#123; @GET(&quot;day/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;) Observable&lt;GankDailyResult&gt; getDailyData(@Path(&quot;year&quot;) int year, @Path(&quot;month&quot;) int month, @Path(&quot;day&quot;) int day); @GET(&quot;data/&#123;type&#125;/&#123;count&#125;/&#123;page&#125;&quot;) Observable&lt;GankCategoryResult&gt; getCategoryData(@Path(&quot;type&quot;) String type, @Path(&quot;count&quot;) int count, @Path(&quot;page&quot;) int page);&#125; 初始化 Retrofit，生成代理对象：12345678Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_GANK_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client(okHttpClient.build()) .build();mService = retrofit.create(GankService.class); 调用接口：123456789101112GankRequestManager.getInstance().getCategory(type, PAGE_SIZE, mPage) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;GankCategoryResult&gt;() &#123; @Override public void accept(GankCategoryResult gankCategoryResult) throws Exception &#123; mPage++; if (mView != null) &#123; mView.showList(type, gankCategoryResult.results); &#125; &#125; &#125;); 动态代理在项目中我们只定义了接口，并没有实现，后面却能直接调用接口，这不得不借助 Java 的动态代理特性。Retrofit 即是使用动态代理来生成代理对象： 12345678910111213141516171819202122232425public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 通过Proxy.newProxyInstance来生成代理对象，当调用接口时，会回调到 invoke 方法中，然后生成 OkHttpCall 对象，用于后面真正的发起网络请求。OkHttpCall 是 okhttp 的核心类，这里不做过多讲述。 Android 通过 Handler 回调主线程普通调用 Retrofit 的形式是这样的： 12345678910call.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; &#125;&#125;); 回调中即是在主线程，我们可以用于更新 UI，这是如何做到的呢？回到 Retrofit 的构建： 12345678910111213141516171819202122232425public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(&quot;Base URL required.&quot;); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly);&#125; platform 是如何生成的呢？看到 Retrofit.Builder： 123456789101112Builder(Platform platform) &#123; this.platform = platform; ...&#125;public Builder() &#123; this(Platform.get());&#125;Builder(Retrofit retrofit) &#123; ...&#125; 再来看 Platform： 123456789101112131415private static Platform findPlatform() &#123; try &#123; Class.forName(&quot;android.os.Build&quot;); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName(&quot;java.util.Optional&quot;); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform();&#125; 显然，在 Android 中会返回 Android（）： 12345678910111213141516static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); return new ExecutorCallAdapterFactory(callbackExecutor); &#125;s MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 看到没， Android platform 会初始化一个绑定 MainLooper 的 Handler，很清晰了。 1234567891011121314151617181920212223242526@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, &quot;callback == null&quot;); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;);&#125; 回调中的 Runnable 则是由 Handler 发出的，显然是在主线程了。 CallAdapterFactory使用 RxJava，会有 RxJava2CallAdapter 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465final class RxJava2CallAdapter&lt;R&gt; implements CallAdapter&lt;R, Object&gt; &#123; private final Type responseType; private final @Nullable Scheduler scheduler; private final boolean isAsync; private final boolean isResult; private final boolean isBody; private final boolean isFlowable; private final boolean isSingle; private final boolean isMaybe; private final boolean isCompletable; RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync, boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) &#123; this.responseType = responseType; this.scheduler = scheduler; this.isAsync = isAsync; this.isResult = isResult; this.isBody = isBody; this.isFlowable = isFlowable; this.isSingle = isSingle; this.isMaybe = isMaybe; this.isCompletable = isCompletable; &#125; @Override public Type responseType() &#123; return responseType; &#125; @Override public Object adapt(Call&lt;R&gt; call) &#123; Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125; if (scheduler != null) &#123; observable = observable.subscribeOn(scheduler); &#125; if (isFlowable) &#123; return observable.toFlowable(BackpressureStrategy.LATEST); &#125; if (isSingle) &#123; return observable.singleOrError(); &#125; if (isMaybe) &#123; return observable.singleElement(); &#125; if (isCompletable) &#123; return observable.ignoreElements(); &#125; return observable; &#125;&#125; 通过 adapt 方法来生成目标的对象。使用 RxJava 则是生成 Observable。返回的 observable 只有在发生订阅关系时才会调用请求。 1234567891011121314151617181920212223@SchedulerSupport(SchedulerSupport.NONE)@Overridepublic final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;); // 请求真正发生的地方 subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can&#x27;t call onError because no way to know if a Disposable has been set or not // can&#x27;t call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(&quot;Actually not, but can&#x27;t throw other exceptions due to RS&quot;); npe.initCause(e); throw npe; &#125;&#125; subscribeActual 则是请求真正发生的地方： 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 通过 RxJava2CallAdapter 返回的 observable 是 CallEnqueueObservable 或 CallExecuteObservable： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126final class CallEnqueueObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123; private final Call&lt;T&gt; originalCall; CallEnqueueObservable(Call&lt;T&gt; originalCall) &#123; this.originalCall = originalCall; &#125; @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; // Since Call is a one-shot type, clone it for each new observer. Call&lt;T&gt; call = originalCall.clone(); retrofit2.adapter.rxjava2.CallEnqueueObservable.CallCallback&lt;T&gt; callback = new retrofit2.adapter.rxjava2.CallEnqueueObservable.CallCallback&lt;&gt;(call, observer); observer.onSubscribe(callback); // 异步调用 call.enqueue(callback); &#125; private static final class CallCallback&lt;T&gt; implements Disposable, Callback&lt;T&gt; &#123; private final Call&lt;?&gt; call; private final Observer&lt;? super Response&lt;T&gt;&gt; observer; boolean terminated = false; CallCallback(Call&lt;?&gt; call, Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; this.call = call; this.observer = observer; &#125; @Override public void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response) &#123; if (call.isCanceled()) return; try &#123; observer.onNext(response); if (!call.isCanceled()) &#123; terminated = true; observer.onComplete(); &#125; &#125; catch (Throwable t) &#123; if (terminated) &#123; RxJavaPlugins.onError(t); &#125; else if (!call.isCanceled()) &#123; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; &#125; &#125; @Override public void onFailure(Call&lt;T&gt; call, Throwable t) &#123; if (call.isCanceled()) return; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; @Override public void dispose() &#123; call.cancel(); &#125; @Override public boolean isDisposed() &#123; return call.isCanceled(); &#125; &#125;&#125;final class CallExecuteObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123; private final Call&lt;T&gt; originalCall; CallExecuteObservable(Call&lt;T&gt; originalCall) &#123; this.originalCall = originalCall; &#125; @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; // Since Call is a one-shot type, clone it for each new observer. Call&lt;T&gt; call = originalCall.clone(); observer.onSubscribe(new retrofit2.adapter.rxjava2.CallExecuteObservable.CallDisposable(call)); boolean terminated = false; try &#123; // 同步调用 Response&lt;T&gt; response = call.execute(); if (!call.isCanceled()) &#123; observer.onNext(response); &#125; if (!call.isCanceled()) &#123; terminated = true; observer.onComplete(); &#125; &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); if (terminated) &#123; RxJavaPlugins.onError(t); &#125; else if (!call.isCanceled()) &#123; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; &#125; &#125; private static final class CallDisposable implements Disposable &#123; private final Call&lt;?&gt; call; CallDisposable(Call&lt;?&gt; call) &#123; this.call = call; &#125; @Override public void dispose() &#123; call.cancel(); &#125; @Override public boolean isDisposed() &#123; return call.isCanceled(); &#125; &#125;&#125; 异步调用 call.enqueue，同步调用 call.execute，这也正是 okhttp 的使用方法，所以 Retrofit 的核心仍是 okhttp，只不过做了更好的封装。 当我们不使用 RxJava 时，会有默认的 ExecutorCallAdapterFactory 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, &quot;callback == null&quot;); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125;&#125; 还有一个 DefaultCallAdapterFactory，只有在callbackExecutor == null的条件才会创建这个类： 12345678910111213141516171819202122232425262728final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123; static final CallAdapter.Factory INSTANCE = new retrofit2.DefaultCallAdapterFactory(); @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return call; &#125; &#125;; &#125;&#125;CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; return retrofit2.DefaultCallAdapterFactory.INSTANCE;&#125; 通过适配器模式，可是适配各种使用场景，当我们有特定的需求，自定义 CallAdapterFactory 即可。Converter 也是类似的原理。当配置多个 Converter 或者 CallAdapter 时，只有第一个生效。如下代码 RxJava2CallAdapterFactory 生效。 12.addCallAdapterFactory(RxJava2CallAdapterFactory.create()).addCallAdapterFactory(Java8CallAdapterFactory.create()) 设计模式Retrofit 中使用到的设计模式不可谓不多。 建造者模式：这个模式相信大家都很熟悉了。Retrofit 算是比较复杂的一个类了，直接创建一个 Retrofit 将会在碰到这些用不到的方法上困惑，建造者模式提供了一个很好的思路。 装饰模式：不管内部多么复杂，在使用时只需要围绕 Retrofit 类就够了。简化了开发者的学习成本，易于使用。另外封装了系统内部类的关系，对内是高内聚的，对外是松耦合的。 代理模式：动态代理创建接口实现类，接口的调用都由 OkHttpCall 来执行。 工厂模式：源码中可是有不少的 Factory。 适配器模式：CallAdapter 通过泛型定义 adapt 方法，开发者可自定义 CallAdapter 实现 adapt 方法来返回自己想要的对象。1T adapt(Call&lt;R&gt; call); 当然，不止于这几种模式，只是这几种是我能直观感受到的，再一次感叹 Retrofit 设计的妙处！ 设计模式的魅力便在于此，尽管它很复杂，但是开发者使用起来却很简单，也很容易拓展实现自定义需求，好的框架应当如此，努力学习吧！","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"在硬件设备上运行应用","date":"2017-11-01T06:39:22.000Z","path":"2017/11/01/device/","text":"最近做收银机上的软件，之前都是用无线调试，有个功能需要要测一下断网的情况，然后断网后无线调试就不能用了。然后接上 USB，通过 Android Studio 能看到设备但无法使用。 然后通过 adb devices 能看到设备，但是提示权限不允许，并且提示到官网来解决。跟到网站中可以看到 如果您在 Ubuntu Linux 上开发，则需要为想要在开发中使用的每一种设备类型添加一个包含 USB 配置的 udev 规则文件。 这个便是问题所在了，跟着描述进行操作后面便可以使用 USB 调试了。 以 root 身份登录，并创建此文件：&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;51-android.rules。使用下面的格式将各个供应商添加到文件中：1SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;0bb4&quot;, MODE=&quot;0666&quot;, GROUP=&quot;plugdev&quot; 在本例中，供应商 ID 为 HTC 的 ID。MODE 赋值指定读&#x2F;写权限，GROUP 则定义哪个 Unix 组拥有设备节点。 注：取决于您的环境，规则语法可能稍有不同。如有需要，请查阅适用于您的系统的 udev 文档。有关规则语法的概述，请参阅编写 udev 规则的指南。 现在，请执行：1chmod a+r /etc/udev/rules.d/51-android.rules 然后文中还附上了 USB 供应商 ID 表。 公司 USB 供应商 ID Acer 502 ASUS 0b05 Dell 413c Foxconn 489 Fujitsu 04c5 Fujitsu Toshiba 04c5 Garmin-Asus 091e Google 18d1 Haier 201E Hisense 109b HP 03f0 HTC 0bb4 Huawei 12d1 Intel 8087 K-Touch 24000 KT Tech 2116 Kyocera 482 Lenovo 17ef LG 1004 Motorola 22b8 MTK 0e8d NEC 409 Nook 2080 Nvidia 955 OTGV 2257 Pantech 10a9 Pegatron 1d4d Philips 471 PMC-Sierra 04da Qualcomm 05c6 SK Telesys 1f53 Samsung 400000000 Sharp 04dd Sony 054c Sony Ericsson 0fce Sony Mobile Communications 0fce Teleepoch 2340 Toshiba 930 ZTE 19d2 当你不知道自己的 USB 设备属于哪个供应商时，可以通过lsusb指令查看所有的 USB 设备，然后拔掉 USB，再次执行指令，然后对比一下看少了哪条记录，就能知道 USB 设备的 idVendor 了。 可以看到是Qualcomm -&gt; 05c6。当知道供应商时直接查询表格就可以了。 题外话本来不想贴表格的，觉得 Markdown 弄表格贼麻烦，但是还是搜了一下，找到一个比较方便的方法。Markdown 快速生成表格第三种方式很简单，先粘到 excel 中，然后执行 exe， Linux 下只需要在指令前面加个 wine 即可（安装过 wine 环境）。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Gradle 多版本管理（续）","date":"2017-10-24T02:20:01.000Z","path":"2017/10/24/gradle-app-2/","text":"之前写过一篇Gradle多版本管理，主要是通过productFlavors来控制产品版本。这篇文章将结合buildTypes来说一下多版本管理。在正常开发中，我们一般会有至少 2 个环境：Debug、Release，即测试环境和生产环境。显然这 2 个环境要用 2 套不同的数据，那么在我们的 App 里必然就需要有个地方来控制这个环境。当然，我们可以在 Debug 的时候用 Debug 环境，然后当要发版时手动改成 Release 环境，但是这很麻烦，很难排除忘记修改的情况，那么等待重新编译将是个很漫长的过程。其实Gradle可以很好的解决这个问题：利用 buildTypes 来控制编译类型。buildTypes 默认会有 debug、release 2 个类型，当然我们还可以添加自己的。比如有个beta环境，用于外网测试。当对接一些三方平台的接口时，有的只能用外网，那么只能整一套外网的测试环境了，比如美团外卖。好，现在假设我们有 debug、beta、release 3 个 buildTypes，然后 pad、phone、custom ３个 productFlavors，接下来就是针对这些环境做配置了： 1234567891011121314151617181920212223242526272829303132333435363738394041signingConfigs &#123; lijia &#123; keyAlias &#x27;lijia&#x27; keyPassword &#x27;123456&#x27; storeFile file(&#x27;../lijia.jks&#x27;) storePassword &#x27;123456&#x27; &#125;&#125;buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;0&#x27;) signingConfig signingConfigs.lijia &#125; debug &#123; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;1&#x27;) &#125; beta &#123; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;2&#x27;) signingConfig signingConfigs.lijia &#125;&#125;productFlavors &#123; // pad版 pad &#123; applicationId &quot;com.study.lijia.gradleapp.pad&quot; &#125; // 手机版 phone &#123; applicationId &quot;com.study.lijia.gradleapp.phone&quot; &#125; // 定制版 custom &#123; applicationId &quot;com.study.lijia.gradleapp&quot; &#125;&#125; 除了 debug 版不需要签名，其他的编译版本都需要签名。这里随便生成一个，配置在 grandl e中。可以看到我们通过buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#39;2&#39;)来进行配置HOST_TYPE，配置好了后需要在应用启动的时候进行设置。一般放在 Application 中： 12345678910public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 设置编译类型 AppCore.setType(BuildConfig.HOST_TYPE); &#125;&#125; 然后 AppCore 根据 HOST_TYPE 来读取、操作不同环境的数据。 123456789101112131415161718192021222324public class AppCore &#123; private final static int TYPE_RELEASE = 0; private final static int TYPE_DEBUG = 1; private final static int TYPE_BETA = 2; private static int mHostType = TYPE_DEBUG; public static void setType(int type) &#123; mHostType = type; &#125; public static String getContentFromCore() &#123; if (mHostType == TYPE_RELEASE) &#123; return &quot;Hello World From Release&quot;; &#125; else if (mHostType == TYPE_DEBUG) &#123; return &quot;Hello World From Debug&quot;; &#125; else if (mHostType == TYPE_BETA) &#123; return &quot;Hello World From Beta&quot;; &#125; return &quot;Hello World&quot;; &#125;&#125; 然后选择 release 版本运行会显示Hello World From Release，其他版本也会显示对应的字符串。那么我们在打包的时候直接打包 Release Build Variant 就行了。当 Debug 或 Beta 进行调试时，选择 Debug（Beta）Build Variant 即可，通过配置可以减少程序员可能造成的错误。当然，如果只是场景比较简单，你也可以直接代码里写if (BuildConfig.DEBUG)。另外如果 Release 版本出问题后面进行跟踪时， Release 的包默认是会混淆优化资源的，而且不可调试，只能改配置。但是如果是根据 Gradle 配置的，我可以直接在 debug 版本里设置 release 的值： 1234567release &#123; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;0&#x27;)&#125;debug &#123; buildConfigField(&quot;Integer&quot;, &quot;HOST_TYPE&quot;, &#x27;0&#x27;) // 设置和 release 一样的值，运行跟踪问题&#125; 另外一般接入三方 SDK 的时候都会有很多平台的 so，x86 平台一般只是虚拟机用到，在 release 版本中是不需要的，那么就可以配置，在 release 版本中去除 x86，这样也可以减小包的体积。 1234567891011121314151617buildTypes &#123; release &#123; ndk &#123; abiFilters &#x27;armeabi&#x27;, &#x27;armeabi-v7a&#x27; &#125; &#125; debug &#123; ndk &#123; abiFilters &#x27;armeabi&#x27;, &#x27;armeabi-v7a&#x27;, &#x27;x86&#x27; &#125; &#125; beta &#123; ndk &#123; abiFilters &#x27;armeabi&#x27;, &#x27;armeabi-v7a&#x27;, &#x27;x86&#x27; &#125; &#125;&#125; 通过buildTypes与productFlavors二者结合可以构建出很多的版本，而且可以进行很灵活的配置。文中例子３个 buildTypes，３个 productFlavors，那么就会有3 * 3 = 9个Build Variant了。当然这只是一个Module的配置，当我们Module很多时，上层 App 定义产品 Build Variant，然后依赖 Module 的不同 Build Variant，这样下来我们可以构建各种各样的版本来适应各种需求定制了。再说个项目中用到的场景。业务越做越广，涉及到商家之前的合作也越来越多。很多商家有自己的定制需求，比如换 Logo 啊，换启动图标啊，等等，总不能需求来一个我们就手动改下资源，然后打包吧。所以通过 Gradle 配置好了 Build Variant 了，然后不同的变种下面放置不同的资源，达到打包含不同资源（或其他定制需求）的包的目的。 12345678910111213141516buildTypes &#123; retail &#123; &#125; catering &#123; &#125; takeout &#123; &#125;&#125;publishNonDefault trueproductFlavors &#123; mmr &#123;&#125; xgt &#123;&#125; efs &#123;&#125;&#125; 这是我们项目中配置的，然后区分文件夹放置不同的资源： 注意这种配置并不是只有3 * 3 = 9个变种，而是有１５个。buildTypes 默认包含 debug，release，尽管我们没有显示的配置，所以应该是5 * 3 = 15个变种。当不需要某些变种时，可以直接忽略掉： 12345678910111213141516variantFilter &#123; variant -&gt; def ignoreVariants = [ &quot;xgtTakeout&quot;, &quot;efsTakeout&quot;, &quot;efsCatering&quot;, ] def buildType = variant.buildType.name // To check for a certain build type, use variant.buildType.name == &quot;&lt;buildType&gt;&quot; if (buildType.contains(&quot;debug&quot;) || buildType.contains(&quot;release&quot;)) &#123; // Gradle ignores any variants that satisfy the conditions above. setIgnore(true) &#125; else if (ignoreVariants.contains(variant.name)) &#123; setIgnore(true) &#125;&#125; 重新编译，就可以看到变种只剩６个了。Gradle 的功能真的是太强大了，需要持续学习。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android 中的 ClassLoader","date":"2017-10-19T11:26:14.000Z","path":"2017/10/19/classloader/","text":"今天发现了一个在对象序列化时的错误。 123456789101112131415161718192021222324252627282930313233343536E/Parcel: Class not found when unmarshalling: com.lijia.study.InventoryDetailjava.lang.ClassNotFoundException: com.lijia.study.InventoryDetail at java.lang.Class.classForName(Native Method) at java.lang.Class.forName(Class.java:309) at android.os.Parcel.readParcelableCreator(Parcel.java:2281) at android.os.Parcel.readParcelable(Parcel.java:2245) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readMapInternal(Parcel.java:2468) at android.os.Parcel.readHashMap(Parcel.java:1678) at android.os.Parcel.readParcelable(Parcel.java:2252) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readArrayMapInternal(Parcel.java:2485) at android.os.BaseBundle.unparcel(BaseBundle.java:221) at android.os.Bundle.getParcelable(Bundle.java:755) at android.content.Intent.getParcelableExtra(Intent.java:5088) ... Caused by: java.lang.ClassNotFoundException: com.lijia.study.InventoryDetail at java.lang.Class.classForName(Native Method) at java.lang.BootClassLoader.findClass(ClassLoader.java:781) at java.lang.BootClassLoader.loadClass(ClassLoader.java:841) at java.lang.ClassLoader.loadClass(ClassLoader.java:469) at java.lang.Class.classForName(Native Method) at java.lang.Class.forName(Class.java:309) at android.os.Parcel.readParcelableCreator(Parcel.java:2281) at android.os.Parcel.readParcelable(Parcel.java:2245) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readMapInternal(Parcel.java:2468) at android.os.Parcel.readHashMap(Parcel.java:1678) at android.os.Parcel.readParcelable(Parcel.java:2252) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readArrayMapInternal(Parcel.java:2485) at android.os.BaseBundle.unparcel(BaseBundle.java:221) at android.os.Bundle.getParcelable(Bundle.java:755) at android.content.Intent.getParcelableExtra(Intent.java:5088) ... Caused by: java.lang.NoClassDefFoundError: Class not found using the boot class loader; no stack available 日志只截取了核心的部分，意思说得很明显了，无法找到类InventoryDetail进行序列化。最后定位错误为使用InventoryDetail类作为HashMap的Value，进行序列化失败。看下使用类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ChooseProductItem implements Parcelable &#123; public SkuBean productSkuBean; public Product product; public double stock = 0D; public HashMap&lt;String, Double&gt; chooseCountMap = new HashMap&lt;&gt;(); public HashMap&lt;String, Double&gt; stockMap = new HashMap&lt;&gt;(); // 重点 public HashMap&lt;String, InventoryDetail&gt; inventoryMap = new HashMap&lt;&gt;(); public HashMap&lt;String, List&lt;CountingTransaction&gt;&gt; countTransMap = new HashMap&lt;&gt;(); public ArrayList&lt;Manifest.ManifestTransaction&gt; transactionList = new ArrayList&lt;&gt;(); private String productNamePinyinFirstWords; public ChooseProductItem(Product product) &#123; this.product = product; &#125; @Override public int describeContents() &#123; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeParcelable(productSkuBean, flags); dest.writeParcelable(this.product, 0); dest.writeDouble(this.stock); dest.writeMap(chooseCountMap); dest.writeMap(stockMap); dest.writeMap(inventoryMap); dest.writeMap(countTransMap); dest.writeList(transactionList); &#125; protected ChooseProductItem(Parcel in) &#123; this.productSkuBean = in.readParcelable(SkuBean.class.getClassLoader()); this.product = in.readParcelable(Product.class.getClassLoader()); this.stock = in.readDouble(); this.chooseCountMap = in.readHashMap(HashMap.class.getClassLoader()); this.stockMap = in.readHashMap(HashMap.class.getClassLoader()); this.inventoryMap = in.readHashMap(HashMap.class.getClassLoader()); this.countTransMap = in.readHashMap(CountingTransaction.class.getClassLoader()); this.transactionList = in.readArrayList(Manifest.ManifestTransaction.class.getClassLoader()); &#125; public static final Creator&lt;ChooseProductItem&gt; CREATOR = new Creator&lt;ChooseProductItem&gt;() &#123; public ChooseProductItem createFromParcel(Parcel source) &#123; return new ChooseProductItem(source); &#125; public ChooseProductItem[] newArray(int size) &#123; return new ChooseProductItem[size]; &#125; &#125;;&#125; 最后错误定位到： 1this.inventoryMap = in.readHashMap(HashMap.class.getClassLoader()); 这里在读取 HashMap 的时候找不到类，导致序列化失败。 这里先讲述一下 ClassLoader。Android 中的 ClassLoader 类型分为两种类型，分别是系统 ClassLoader 和自定义 ClassLoader 。其中系统 ClassLoader 包括三种分别是 BootClassLoader、PathClassLoader 和 DexClassLoader。 BootClassLoader：Android 系统启动时会使用 BootClassLoader 来预加载常用类。BootClassLoader 是一个单例类，需要注意的是 BootClassLoader 的访问修饰符是默认的，只有在同一个包中才可以访问，因此我们在应用程序中是无法直接调用的。 PathClassLoader：Android 系统使用 PathClassLoader 来加载系统类和应用程序的类，如果是加载非系统应用程序类，则会加载data&#x2F;app&#x2F;目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载哪种文件，最终都是要加载dex文件，在这里为了方便理解，我们将dex文件以及包含dex的apk文件或jar文件统称为dex相关文件。PathClassLoader 不建议开发直接使用。 DexClassLoader：DexClassLoader 可以加载dex文件以及包含dex的apk文件或jar文件，也支持从SD卡进行加载，这也就意味着 DexClassLoader 可以在应用未安装的情况下加载dex相关文件。因此，它是热修复和插件化技术的基础。 现在回过头来看之前的代码： 12345public HashMap&lt;String, InventoryDetail&gt; inventoryMap = new HashMap&lt;&gt;();...this.inventoryMap = in.readHashMap(HashMap.class.getClassLoader()); readHashMap传入的参数是ClassLoader，我传入的是HashMap.class.getClassLoader()，HashMap 作为系统自带常用类，是由BootClassLoader进行加载的，而我应用自己编写的类InventoryDetail是由PathClassLoader进行加载的。那么显然，在BootClassLoader中找由PathClassLoader加载的类显然是找不到的，便会报错了。可以看到chooseCountMap、stockMap传入的也是HashMap.class.getClassLoader()，因为其 Value 类型为 Double，也是系统常用类，也是由BootClassLoader进行加载的，所以不会有问题。以后在涉及到 ClassLoader 的时候可要细心点了。这里简单验证一下： 12345678910111213ClassLoader classLoader1 = Double.class.getClassLoader();ClassLoader classLoader2 = HashMap.class.getClassLoader();ClassLoader classLoader3 = MyClass.class.getClassLoader();Log.e(&quot;TAG&quot;, classLoader1.toString());Log.e(&quot;TAG&quot;, classLoader2.toString());Log.e(&quot;TAG&quot;, classLoader3.toString());...10-19 20:07:49.659 16333-16333/? E/TAG: java.lang.BootClassLoader@212c4b0d10-19 20:07:49.659 16333-16333/? E/TAG: java.lang.BootClassLoader@212c4b0d10-19 20:07:49.659 16333-16333/? E/TAG: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.study.lijia.myapplication-2/base.apk&quot;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]] 很显然了。 另外说下，ArrayList 在序列化的时候可以直接使用： 1this.transactionList = in.createTypedArrayList(Manifest.ManifestTransaction.CREATOR); 可以消除Unchecked assignment: &#39;java.util.ArrayList&#39; to &#39;java.util.ArrayList&lt;xxx.Manifest.ManifestTransaction&gt;&#39;的警告，只不过使用createTypedArrayList时 List 需要显示定义成 ArrayList。 Android解析ClassLoader（二）Android中的ClassLoader","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android 集成讯飞语音SDK","date":"2017-09-26T08:42:29.000Z","path":"2017/09/26/xunfei/","text":"项目开发需要用到文字转语音的功能，利用 Android 系统自带的Text-to-Speech可以实现英文转语音，但是对于中文就无能为力了。对于中文转语音需要特定引擎的支持，谷歌自带的Pico TTS是不支持的，我的小米手机是度秘语音引擎支持中文，显然我们没法去控制用户用什么手机，所以抛弃原生的TTS，考虑接入讯飞语音SDK。 注册开发者账号进入讯飞开放平台注册账号。 创建应用登录账号，进入控制台，选择创建新应用。 下载SDK点击SDK下载。选择下载服务、平台、应用，然后点击下载。我这里只选择了在线语音合成，免费的。然后得到SDK： 集成SDK首先将对应手机CPU平台的 so 文件导入到工程中，jar 包导入到 libs 中。 在 Application 中初始化讯飞语音： 1SpeechUtility.createUtility(this, SpeechConstant.APPID +&quot;=xxxxxxxx&quot;); 在调用的地方初始化语音对象： 12345678910111213141516171819202122232425private SpeechSynthesizer mTts;private void initMSC() &#123; mTts = SpeechSynthesizer.createSynthesizer(mActivity, new InitListener() &#123; @Override public void onInit(int code) &#123; if (code == ErrorCode.SUCCESS) &#123; // 设置在线合成 mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); // 设置在线合成发音人 mTts.setParameter(SpeechConstant.VOICE_NAME, &quot;xiaoqi&quot;); //设置合成语速 mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;); //设置合成音调 mTts.setParameter(SpeechConstant.PITCH, &quot;50&quot;); //设置合成音量 mTts.setParameter(SpeechConstant.VOLUME, &quot;100&quot;); //设置播放器音频流类型 mTts.setParameter(SpeechConstant.STREAM_TYPE, &quot;3&quot;); // 设置播放合成音频打断音乐播放，默认为true mTts.setParameter(SpeechConstant.KEY_REQUEST_FOCUS, &quot;true&quot;); &#125; &#125; &#125;);&#125; 然后调用API： 1234int code = mTts.startSpeaking(&quot;Hello 中国&quot;);if (code != ErrorCode.SUCCESS &amp;&amp; code != ErrorCode.ERROR_COMPONENT_NOT_INSTALLED) &#123; ToastUtils.showShort(mActivity, &quot;语音合成失败,错误码: &quot; + code);&#125; 过程比较简单，稍微记录一下，更多详情可以参阅官方文档。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 双屏异显","date":"2017-09-13T10:42:54.000Z","path":"2017/09/13/presentation/","text":"最近在做收银机相关的开发，涉及到双屏异显的一些东西，之前也没有接触过，在查阅一番资料之后，把功能走通了，这里小记一下。 PresentationPresentation 是一种特殊的对话框，主要用于在另外一块屏幕上显示内容。默认为克隆模式，即副屏显示和正屏一样的内容。当需要显示不同内容时，需要自定义 Presentation，并为其指定一个 Display。这里随便定义一个 Presentation： 123456789101112public class MyPresentation extends Presentation &#123; public MyPresentation(Context outerContext, Display display) &#123; super(outerContext, display); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.presentation_second_screen); &#125;&#125; 声明权限因为 Presentation 是对话框，所以需要以下权限： 12&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot; /&gt; 获取 Displays在实例化 Presentation 之前需要先获取 Displays。 12345678910private void initDisplays() &#123; if (android.os.Build.VERSION.SDK_INT &lt; android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; return; &#125; DisplayManager mDisplayManager; mDisplayManager = (DisplayManager) this.getSystemService(Context.DISPLAY_SERVICE); mDisplays = new Display[0]; mDisplays = mDisplayManager.getDisplays();&#125; mDisplays 即代表设备所有的屏幕。 实例化 Presentation12345678910111213private void initPresentation() &#123; if (android.os.Build.VERSION.SDK_INT &lt; android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; return; &#125; if (mPresentation == null &amp;&amp; mDisplays != null &amp;&amp; mDisplays.length &gt; 1) &#123; mPresentation = new MyPresentation(this, mDisplays[mDisplays.length - 1]); if (mPresentation.getWindow() != null) &#123; mPresentation.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT); &#125; mPresentation.show(); &#125;&#125; 通过 show() 方法即可展示了。 Tips 双屏需要API &gt;= 17才可使用。 需要兼容只有一块屏幕的设备。所以在展示时，最好加上mDisplays.length &gt; 1的判断，避免在单屏设备上展示了副屏要展示的内容。 直接在 Activity onCreate 中初始化进行展示时，会展示不了，需要延迟一点进行展示。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 日常开发的一些小知识","date":"2017-08-29T09:06:48.000Z","path":"2017/08/29/small-tips/","text":"前段时间终于下定决心自己实践 RxJava，Retrofit 等当前十分流行的库，利用 Gank.io 的公共 API，做一个自己的 Gank 客户端。项目地址： Gank。只要有闲暇时间便会写写代码，慢慢完善。期间有一些小的知识点，但是却很实用，这里便列一下。关于 RxJava，Retrofit 目前学习还不是很深入，这里便不展开了。 @SerializedName现在与服务端通信通常都是Json，但是服务器返回的Json串的key是服务端自己的命名规则（可能是中文key，或者大写开头），我们直接通过Gson解析就必须一一对应，但是这样的命名在Java里很不友好。那么就可以通过@SerializedName注解给Bean类进行“重命名”，这样在解析的时候便可以直接利用我们自己的命名规则命名变量了。举个栗子：http://gank.io/api/day/2017/08/03返回的数据包含Android，福利等不符合Java规范的key，那么就可以这样： 12345678910111213141516public class DataResults &#123; @SerializedName(&quot;Android&quot;) List&lt;ItemData&gt; androidList; @SerializedName(&quot;iOS&quot;) List&lt;ItemData&gt; iOSList; @SerializedName(&quot;休息视频&quot;) List&lt;ItemData&gt; restList; @SerializedName(&quot;前端&quot;) List&lt;ItemData&gt; jsList; @SerializedName(&quot;福利&quot;) List&lt;ItemData&gt; welfareList;&#125; 如此便可以直接通过Gson解析，并且变量名是以我们自己的命名规则进行命令的了。 水波纹效果Android 5.0 及以上才有水波纹效果。简单实现: 1android:background=&quot;?attr/selectableItemBackground&quot; 也可以添加手动添加drawable: 1234&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;?android:colorControlHighlight&quot;&gt;&lt;/ripple&gt; 然后设置给布局的 background， 布局必须可点击。同时为了兼容，最好建立drawable-v21来区分开来。建立低版本的 drawable 去对应 5.0 以下的版本。当然，目前也有很多库可以实现 5.0 以下的水波纹效果，可以参考RippleEffect。 android5.0 水波纹点击效果 Intent传递复杂数据我们知道可以通过 Intent 在多个 Activity、Fragment 之间进行数据传递。基本数据类型不用说，当传递自定义数据类型时，需要实现 Serializable 或 Parcelable 接口。前者通过 Intent 的 getSerializableExtra() 获取数据，后者通过 getParcelableExtra()、getParcelableArrayExtra()、getParcelableArrayListExtra() 获取数据。但是当我们传递的数据是ArrayList&lt;List&lt;Object&gt;&gt;这种嵌套 List 数据呢？当我们是通过 Parcelable 接口进行传递时，会碰到如下的错误： 1Error:(46, 88) 错误: 不兼容的类型: ArrayList&lt;Parcelable&gt;无法转换为ArrayList&lt;List&lt;MyObject&gt;&gt; 即类型无法强转。当我们通过 Serializable 接口进行传递时，没有错误，只会有警告： 1Unchecked cast: &#x27;java.io.Serializable&#x27; to &#x27;java.util.ArrayList&lt;java.util.List&lt;com.study.lijia.gank.data.MyObject&gt;&gt;&#x27; 这警告只需添加@SuppressWarnings(&quot;unchecked&quot;)即可消除。看到 ArrayList 的定义: 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 实现了 Serializable，自然是能转换的，但是没有实现 Parcelable，所以无法使用 Parcelable 传递ArrayList&lt;List&lt;Object&gt;&gt;这种嵌套 List 数据。碰到这种需求则只能通过 Serializable 接口来了，或者更换数据传递的方式。 获取资源经常我们会通过mContext.getResources().getColor(R.color.black);来获取我们定义在 color.xml 中的颜色，但是 getColor(@ColorRes int id) 已经被标记为@Deprecated，导致代码里看起来就是一条横线，很不舒服。当然我们可以通过 getColor(@ColorRes int id, @Nullable Theme theme) 来替换它，但是又会有这个问题： 1Call requires API level 23 (current min is 15): android.content.res.Resources#getColor 代码强迫症肯定依然受不了。此时我们可以通过 ContextCompat 来获取 1ContextCompat.getColor(mContext, R.color.black); 它的实现： 12345678public static final int getColor(Context context, @ColorRes int id) &#123; final int version = Build.VERSION.SDK_INT; if (version &gt;= 23) &#123; return ContextCompatApi23.getColor(context, id); &#125; else &#123; return context.getResources().getColor(id); &#125;&#125; 一目了然了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"管理 Github 上的 star","date":"2017-08-04T09:01:29.000Z","path":"2017/08/04/github-star/","text":"Github 逛久了，相信大家都会有很多star，虽然很多star后面再也不会看的。但是只要有那么一丁点的可能回头看，我们还是需要将自己的star整理一下，不然感觉都是无从下手。那么问题便来了：如何管理 Github 上的 star ?答案便是 Astral。这是我偶然发现的一个网站，它可以用来给 Github 上的 star 分类。具体界面是这样子的: 界面很简单，打开就能直接上手用，整理了一个下午，终于将自己的 200 多个 star 全部清理个便，分了几个 TAG，后面再回顾的时候便会方便多了。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"尝试使用 Android SVG","date":"2017-07-26T10:50:34.000Z","path":"2017/07/26/svg/","text":"普遍的 Android 开发可以理解为移动端界面开发，那么界面自然是重中之重。当设计师给到你设计稿时，你便需要将设计稿中的东西用代码做出来。项目开发中便遇到了这样一个设计稿： 这算是一个很基本的对话框了，没什么难度。写这篇文章主要是为了记一下图中关闭按钮的实现。这个关闭按钮算是再简单不过的一个图标了，那么要如何实现呢？当然可以找到设计师要切图。但是这里我想尝试一下 Android 中的 SVG，顺便也是减轻设计师的工作量，经常劳烦别人也不是什么好事。 SVG什么是 SVG ?简单来说：SVG 即 可缩放矢量图形(Scalable Vector Graphics)，是使用XML来描述二维图形和绘图程序的语言，其定义遵循W3C标准。它有哪些特点： SVG 可被非常多的工具读取和修改(比如记事本) SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强 SVG 是可伸缩的，可以保证高清晰度的被放大 SVG 文件是纯粹的 XML 特殊说明一下，SVG 相比 Bitmap，它最大的优点就是放大不会失真。当 Bitmap 需要为不同分辨率适配多套图标时，一套 SVG 即可搞定一切分辨率。 如何使用这里说一下最简单的使用方法： 首先去阿里巴巴矢量图标库(当然也有其他的网站)搜索需要的图标。 下载需要图标的 SVG 图像。 到Android SVG to VectorDrawable将下载的 SVG 图像转成 XML（也可通过 Android Studio 本身的支持进行转换），然后直接用到 Android Studio 中的 drawable 中即可。 举个栗子在网站搜索关闭图标： 选择上图中第三个图标，选择下载： 选择图标颜色，大小，选择SVG 下载。然后将下载的文件拖到上面所说的网站中即可生产 XML： 然后直接用到 drawable 即可： 当然你可以利用 Android Studio 本身的 VectorDrawable 支持： 文中关于 SVG 的使用算是最简单的了，但是 SVG 还有很多其他的用法，它有很多标签，来实现各种效果，有兴趣的同学可以自行谷歌。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"关于 ConcurrentModificationException 异常","date":"2017-07-11T08:24:35.000Z","path":"2017/07/11/java-set/","text":"List、Map等这类数据结构在日常开发中的使用不可谓不多，经常会有遍历的同时进行修改的情况。例如： 1234567Integer[] numbers = new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(numbers));for (Integer integer : list) &#123; if (integer % 5 == 0) &#123; list.remove(integer); &#125;&#125; 这段代码在执行的时候便会抛出异常： 1234Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at com.example.MyClass.main(MyClass.java:16) 这个异常出现通常是遍历一个集合的同时，在修改这个集合。看到next方法： 123456789101112131415public E next() &#123; this.checkForComodification(); int var1 = this.cursor; if(var1 &gt;= ArrayList.this.size) &#123; throw new NoSuchElementException(); &#125; else &#123; Object[] var2 = ArrayList.this.elementData; if(var1 &gt;= var2.length) &#123; throw new ConcurrentModificationException(); &#125; else &#123; this.cursor = var1 + 1; return var2[this.lastRet = var1]; &#125; &#125;&#125; 然后看到checkForComodification： 12345final void checkForComodification() &#123; if(ArrayList.this.modCount != this.expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 即当modCount 与 expectedModCount 不相等时，会抛 ConcurrentModificationException 异常。其实很早之前就会碰到这个问题，使用Iterator进行遍历和操作就不会出现这个问题了，但是一直没有深究其原因。 之前听同事说，for each内部就是使用的Iterator。但是最近项目中就算使用了for each也还是出现了上面的异常。于是决心细究一番。将上面的示例代码转成 class 文件，可以看到： 12345678910Integer[] numbers = new Integer[]&#123;Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), Integer.valueOf(5), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8), Integer.valueOf(9), Integer.valueOf(10)&#125;;ArrayList list = new ArrayList(Arrays.asList(numbers));Iterator var4 = list.iterator();while(var4.hasNext()) &#123; Integer integer = (Integer)var4.next(); if(integer.intValue() % 5 == 0) &#123; list.remove(integer); &#125;&#125; 确实看到了Iterator的身影，但是却忽视了真正重要的一点:remove()方法的执行者。将遍历代码改成如下: 1234567Iterator iterator = list.iterator();while (iterator.hasNext()) &#123; Integer integer = (Integer) iterator.next(); if (integer % 5 == 0) &#123; iterator.remove(); &#125;&#125; 便可执行通过了。看到 class 文件如下： 123456while(iterator.hasNext()) &#123; Integer integer = (Integer)iterator.next(); if(integer.intValue() % 5 == 0) &#123; iterator.remove(); &#125;&#125; 可以看到都是通过Iterator进行遍历，唯独在执行remove操作的时候，报错的示例执行对象是list本身，而正确的示例执行对象是iterator。那么接下来对比下二者的remove方法，便可找到真相了。看到ArrayList自身实现的remove方法： 123456789101112131415161718192021222324252627282930public boolean remove(Object var1) &#123; int var2; if(var1 == null) &#123; for(var2 = 0; var2 &lt; this.size; ++var2) &#123; if(this.elementData[var2] == null) &#123; this.fastRemove(var2); return true; &#125; &#125; &#125; else &#123; for(var2 = 0; var2 &lt; this.size; ++var2) &#123; if(var1.equals(this.elementData[var2])) &#123; this.fastRemove(var2); return true; &#125; &#125; &#125; return false;&#125;private void fastRemove(int var1) &#123; ++this.modCount; int var2 = this.size - var1 - 1; if(var2 &gt; 0) &#123; System.arraycopy(this.elementData, var1 + 1, this.elementData, var1, var2); &#125; this.elementData[--this.size] = null;&#125; 看到ArrayList中Iterator实现的remove方法： 12345678910111213141516public void remove() &#123; if(this.lastRet &lt; 0) &#123; throw new IllegalStateException(); &#125; else &#123; this.checkForComodification(); try &#123; ArrayList.this.remove(this.lastRet); this.cursor = this.lastRet; this.lastRet = -1; this.expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException var2) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; 如此便一目了然了，ArrayList 本身的 remove 方法执行完之后没有同步 modCount 与 expectedModCount，而 Iterator 有同步。在遍历的时候会 checkForComodification，当使用的非 Iterator 的 remove 方法，会造成 2 个 count 不相等，如此便会抛出异常了。那么细想一下：为什么 Java 集合在遍历的时候要做这样的检查呢？这里引用一下网友的想法，大家自行思考吧～ 设置modCount和expectedModCount的目的是为了检测iterator的有效性，检测是否有其它操作对HashMap的结构进行了修改，由于这些操作不是通过当前iterator进行的，因此有可能破坏iterator的有效性。通过iterator执行remove只能删除当前iterator所在的元素，不会让iterator失效。而通过HashMap.remove()实际上可以删除任意元素，这个元素有可能正是iterator内部的next变量已经引用了的元素，造成iterator失效。 最后说 2 点题外话： Arrays.asList不接受 Java 基本数据类型数组作为参数。原因asList接受的参数为Object，而基本数据类型不是。但是代码List list = Arrays.asList(new int[]&#123;1,2,3&#125;)不会报错，因为int[]是Object，此代码会生产一个size = 1的列表。 通过Arrays.asList方法返回的List是不能修改的。 参考：Java遍历HashMap并修改(remove)把Java数组转换为List时的注意事项Java 集合细节（二）：asList 的缺陷","tags":[{"name":"Java","slug":"Java","permalink":"http://lijia92.github.io/tags/Java/"}]},{"title":"关于 ViewPager 的2点特性","date":"2017-06-30T01:54:26.000Z","path":"2017/06/30/viewpager/","text":"新手引导是每个 App 都具备的。如果新手引导直接用 Activity 来做，可能就会比较繁杂和冗余。所以一般都是 ViewPager 来实现。那么便会有 2 个问题： 不能手动滑动 当前 item 跳转到下一个 item 要平滑滑动 自定义ViewPager可以解决这 2 个问题，下面直接上代码： 1234567891011121314151617181920212223242526272829303132333435package android.support.v4.view;import android.content.Context;import android.util.AttributeSet;import android.view.MotionEvent;/** * 1、禁止左右滑动 * 2、setCurrentItem平滑切换 */public class NoScrollViewPager extends ViewPager &#123; public NoScrollViewPager(Context context) &#123; super(context); &#125; public NoScrollViewPager(Context context, AttributeSet attr) &#123; super(context, attr); &#125; void smoothScrollTo(int x, int y, int velocity) &#123; super.smoothScrollTo(x, y, 1); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; return false; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125;&#125; 禁止滑动通过触摸事件返回false，这个很好理解了。setCurrentItem及时添加第二个参数为true也没有平滑滑动的效果，参考stackoverflow。 引申Java 有四种访问权限修饰符： 访问权限 类 包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 通过上面的stackoverflow可以看到，当Android Sdk的某个方法是default时,我们是没有权限调用的，有 2 种方式来解决问题： 反射 建立相同路径的包名，包访问域可以访问到default方法","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"初识 zsh","date":"2017-06-09T02:21:18.000Z","path":"2017/06/09/zsh/","text":"昨天写关于 git 的文章的时候，需要来回切分支，而且 bash 也看不到当前是哪个分支，得不停git branch来看，显得十分麻烦。于是便不得不逼着自己一把，来熟悉一波zsh了。 同事有用zsh的，而且鼎力推荐，因为目前的工作和学习与命令行的交集不是很深，所以一直没有开始用。最近发现bash相比zsh确实是难用许多，便只能硬着头皮来学习了。之所以是硬着头皮，是因为自己对 Linux 系统不是很熟悉，虽然现在是在用，但是对于 Linux 的很多特性都不是很了解，命令行、Shell 脚本算是 Linux 一大特色。 zsh有着强大的功能，但是其配置也是异常复杂，于是 Github 上便有了这样的一个库：oh-my-zsh，oh-my-zsh是为了简化zsh的配置而提供的一个配置模板，可以更好的管理zsh的各项配置。可以看到它有 55k 的 star，可见其火爆程度。现在才来接触，显得挺惭愧的。 关于oh-my-zsh的安装直接照着 github 中的README一步一步来就好了。就提醒一点，安装完之后需要注销掉用户，重启也可以，然后再重新登录，才可以看到zsh。 关于zsh的优势，网上众说纷纭，但是我目前用的不多，体会得不深。现在就我体会到的来说几点。 git支持很直接的一个体现就是进入到有 git 版本控制的目录，会显示出当前所在的分支。 再也不同git branch来看当前是什么分支了。另外，oh-my-zsh也配置了很多 git 命令别名，方便使用。比如gst代表git status，gco代表git checkout，还有许许多多的配置，可以参考Plugin:git。 Tab自动补全比如我想进入到 blog 目录，我敲cd b然后按Tab，zsh变回把所有 b 开头的目录列出来，然后再按Tab，它会帮你选择目录，当选到自己想要的目录时，按回车就可以进入了，是不是非常方便！！！ 大小写忽略大小写切换是很常见的，在上个例子中，即使我敲成cd B也能找到blog目录。 autojump当目录层级很深的时候，想要进入到那个目录得一直cd--ls--cd--ls，就像这样： 看着就觉得头疼，因为实在无法记住那么长的目录。对此，autojump可谓是一大神作。先安装： 1sudo apt-get install autojump 然后打开.zshrc，找到plugins，加入autojump： 1plugins=(git autojump) 之后便是这种姿势打开目录了： 怎么样，是不是简直爽爆了！？再也不用臃肿的敲着蛋疼的cd了。当在一次终端行为中，有了多个进入的目录，可以直接输入d来看到目录，然后直接输入数字便可以快捷进入到相应的目录中了。 简直就是方便！又多了一个不得不用zsh的理由了！！！ 快速打开当前所在文件夹编辑.zshrc文件，加入： 1alias o=&quot;nautilus .&quot; 当命令行处于某个文件夹下时，直接键入o即可打开当前文件夹。 这其实只是给zsh配置了一个别名，任何我们常用的操作都可以根据自己喜好配置别名，方便使用。 目前体验的到的可能就这几个我很欣赏的特性了。当然也是才刚刚开始使用，后面有别的再行补充。这里先贴一下网友的配置，后面可能用得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# ZSH的环境变量export ZSH=/Users/dawang/.oh-my-zsh# 主题设置# 主题列表在 ~/.oh-my-zsh/themes/# 如果设置为 &quot;random&quot;, 每次开启都会是不同的主题ZSH_THEME=&quot;agnoster&quot;# 如果想要大小写敏感，可以取消注释下面的一行# CASE_SENSITIVE=&quot;true&quot;# 如果想要连接符不敏感，可以取消注释下面的一行。_ 和 - 将可以互换# HYPHEN_INSENSITIVE=&quot;true&quot;# 如果不想要自动更新，可以取消注释下面的一行# DISABLE_AUTO_UPDATE=&quot;true&quot;# 自动更新的时间间隔，单位是天，这里设置 30 天更新一次export UPDATE_ZSH_DAYS=30# 如果不想要 ls 命令输出带颜色，可以取消注释下面的一行# DISABLE_LS_COLORS=&quot;true&quot;# 是否禁止更改终端标题,不要禁止,不然所有终端tab只显示zsh了,而不随着目录的改变而改变显示# DISABLE_AUTO_TITLE=&quot;true&quot;# 自动纠正命令,不启用,不怎么好用# ENABLE_CORRECTION=&quot;true&quot;# 按tab键补全命令的时候,如果没什么可补全的就会出现三个红点,更人性化显示，这里我们启用COMPLETION_WAITING_DOTS=&quot;true&quot;# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# 不要在意这些细节，不需要改动# DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;# 历史命令日期显示格式# 有三种方式: &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;，我比较习惯最后那种HIST_STAMPS=&quot;yyyy-mm-dd&quot;# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# 插件设置，如果添加太多启动速度会比较慢plugins=(git autojump)[[ -s ~/.autojump/etc/profile.d/autojump.zsh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.zsh# 剩下部分比较不常改动# User configurationexport PATH=&quot;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/TeX/texbin&quot;# export MANPATH=&quot;/usr/local/man:$MANPATH&quot;source $ZSH/oh-my-zsh.sh# You may need to manually set your language environment# export LANG=en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then# export EDITOR=&#x27;vim&#x27;# else# export EDITOR=&#x27;mvim&#x27;# fi# Compilation flags# export ARCHFLAGS=&quot;-arch x86_64&quot;# ssh# export SSH_KEY_PATH=&quot;~/.ssh/dsa_id&quot;# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run `alias`.## Example aliases# alias zshconfig=&quot;mate ~/.zshrc&quot;# alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot; 题外话Ubuntu用了也有段时间了，但是感觉还是像用Windows一样在用Ubuntu，很多东西还是依赖图形化界面。但是作为一个开发人员，Shell脚本更值得去拥抱。所以决心后面多用多学，真正拥抱Linux。 最后安利一波 Ubuntu 下录制 Gif 的方案：安装 Wine，下载 GifCam.exe，然后直接运行 GifCam.exe。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"关于 Git 的使用小记","date":"2017-06-07T12:04:42.000Z","path":"2017/06/07/git/","text":"相信选择选择绝大部分开发者都使用的 Git 来进行版本控制，关于 Git 比较基本的东西就不说了，这里主要记录一下我用到的 2 个较为进阶一点的命令。 git revert场景：假定现在有一个分支develop/1.0.0，该分支用于发布1.0.0版本的包，develop/1.0.0依赖一个 module，该 module 的版本与之对应也是1.0.0，就在将要打包的时候， develop 分支新增了一个提交，这个提交依赖 module 的1.0.1版本，可能是由于同事之间的沟通不足导致这种问题，不需要提交的被提交了。在发布1.0.0版本的包时，是不应该包含最新的提交的。那么可以怎么样做呢？revert 意为回退。可以使用git revert指令，回退最新的一次提交。举个例子：初始化一个 git 仓库，添加一个文件git，做一次提交init。然后编辑git文件，做一次提交feature A。准备以当前节点打包时，又多了一次提交feature B，此次提交是不需要包含到此次打包的代码里的。 此时git log可以看到 3 次提交： 执行指令： 1git revert 10ffa5 10ffa5为需要回退的 commit id，即上图中feature B那次提交，版本号没必要写全，前几位就可以了，Git会自动去找。填写提交信息： 执行结束后，代码便回退到feature A的提交了,可以安心打包了。 打完包后，可以基于develop/1.0.0分支 new branchdevelop/1.0.1，然后切到develop/1.0.1执行指令： 1git revert 13fbb4 之前feature B的提交便回来了，可以继续开发了。 git cherry-pick场景：假定现在有 2 个分支feature/A、feature/B，然后发现了一个 bug，这个 bug 是公共代码造成的，即 2 个分支都存在这样的 bug。选择在feature/A上修复这个 bug，但不能直接 merge feature/A到feature/B上，因为 2 个分支在进行不同特性的开发。那么可以怎么样做呢？cherry-pick 是对已经存在的 commit 进行再次提交。举个例子：我们在feature/A分支修复问题后提交。然后切到feature/B分支，执行指令： 1git cherry-pick a89acbe4 因为我的例子中，2 个分支都对同一个文件同一个位置做了修改，所以冲突了。提示： 所以需要先解决冲突，然后执行： 1git cherry-pick --continue 好了，再来看看修复bug的提交是否存在feature/B分支中吧。 最后贴一下关于 Git 的一个很好的教程：git-recipes","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"关于混淆的一个小纰漏","date":"2017-05-09T05:37:46.000Z","path":"2017/05/09/confuse/","text":"混淆，相信只要是上线的的应用都会运用到。这里记一下项目中因为混淆而导致的一个较难发现的问题。 问题是这样的：有一个实体类PrintTemplate类，当我调用一个网络接口，会从服务器获取这个类的一个 list，然后我会用 Json 转成字符串存到本地，当要用的时候根据 key 去取对应的模板字符串，然后转成类实体进行使用。当然，混淆规则中没有保持这个类不被混淆。 假设现在的版本是 V1.0，测试打出来的 Release 包是没有问题的。然后版本更新到 V1.1，单独测试也是没问题的。但是，如果是从 V1.0 升到的 V1.1，那么在取对应的模板字符串，然后转成类实体进行使用这一步就会出错了，无法解析到正常的类。如果没有添加异常保护，则会直接崩溃了。 示例代码： 1234567891011121314151617181920212223242526272829303132public static PrintTemplate getPrinterTemplate(String bookId, int templateId) &#123; PrintTemplate template = null; String str = getString(KEY_PRINTER_TEMPLATE + &quot;_&quot; + bookId + &quot;_&quot; + templateId); if (!TextUtils.isEmpty(str)) &#123; try &#123; // 这里没有添加异常捕获，导致直接崩溃 template = JSON.parseObject(str, PrintTemplate.class); &#125; catch (Exception e) &#123; template = null; &#125; &#125; return template;&#125;public static void savePrinterTemplate(List&lt;PrintTemplate&gt; templates, String bookId) &#123; List&lt;TemplateBean&gt; templateTypes = new ArrayList&lt;&gt;(); for (PrintTemplate template : templates) &#123; // 逐一保存每个模板 String str = JSONObject.toJSONString(template); putString(KEY_PRINTER_TEMPLATE + &quot;_&quot; + bookId + &quot;_&quot; + template.id, str); TemplateBean bean = new TemplateBean(); bean.id = template.id; bean.name = template.typeName; if (!templateTypes.contains(bean)) &#123; templateTypes.add(bean); &#125; &#125; // 保存所有的业务类型 String typeValues = JSONArray.toJSONString(templateTypes); putString(KEY_PRINTER_TEMPLATE_TYPE, typeValues);&#125; 问题的根源很简单，就是类被混淆了嘛。举个栗子，类的属性为 id, name，存入的字符串可能是&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:&quot;2&quot;&#125;&quot;，a 对应 id，b 对应 name，但是当版本升级后，这个类混淆后属性可能就变成了 c 和 d，那么当拿到那个混淆后的字符串进行重新解析的时候肯定就会有问题了。但是只有版本升级的时候才会出现这个问题，平时自己的测试恰好就把这个问题给规避了。这里记录一下，还好尽早改正了，对用户的影响不大。 这里顺便贴一下混淆的一些规则，开发中要保持警惕： 如果使用了Gson之类的工具要使JavaBean类即实体类不被混淆。 如果使用了自定义控件那么要保证它们不参与混淆。 如果使用了枚举要保证枚举不被混淆。 对第三方库中的类不进行混淆。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"针对ListView多Type的优化","date":"2017-05-09T02:46:58.000Z","path":"2017/05/09/multi-type/","text":"在之前写过一篇多 Type 的错误使用使用ListView多Type的错误姿势，下面写一下针对这种使用场景的优化。 可以看到之前的代码很繁杂，根据各种 Type 有各种 position 的判断，在 getView 的时候代码一坨一坨的看着很不舒服，那么有没有什么优化策略呢？可以知道多 Type 的使用原因是界面多种展示风格，本质的原因则是数据类型的不一致，即数据源中有多种数据类型，那么就可以直接 利用泛型来实现数据的区分，整合一个 List mDataList 里面包含所有的数据，在根据 getItem 来获取单个的 item，根据其数据类型来判断属于哪种 Type。 根据策略，将头部的布局抽成String类型，将打印机的布局抽成PrinterInfo类型，后面获取item后根据类型来判断是头布局，还是打印机布局。优化后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268public class PrinterManagerAdapter extends BaseAdapter &#123; private static final int TYPE_HEADER = 0; private static final int TYPE_PRINTER = 1; private static final String TITLE_BLUETOOTH_PRINTER = &quot;蓝牙打印机&quot;; private static final String TITLE_NET_PRINTER = &quot;网络打印机&quot;; private static final String TITLE_CLOUD_PRINTER = &quot;云打印机&quot;; private Context mContext; private LayoutInflater mInflater; private OnItemFunctionClickListener listener; private List&lt;Object&gt; mDataList = new ArrayList&lt;&gt;(); public PrinterManagerAdapter(Context context, ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; mContext = context; mInflater = LayoutInflater.from(context); initDataList(printers); setNotSwipeItems(listView); &#125; private void initDataList(List&lt;PrinterInfo&gt; printerList) &#123; mDataList.clear(); List&lt;PrinterInfo&gt; bluetoothPrinterList = new ArrayList&lt;&gt;(); List&lt;PrinterInfo&gt; netPrinterList = new ArrayList&lt;&gt;(); List&lt;PrinterInfo&gt; cloudPrinterList = new ArrayList&lt;&gt;(); for (PrinterInfo info : printerList) &#123; if (info.printerType == PrinterInfo.TYPE_BLUETOOTH) &#123; bluetoothPrinterList.add(info); &#125; else if (info.printerType == PrinterInfo.TYPE_NETWORK) &#123; netPrinterList.add(info); &#125; else if (info.printerType == PrinterInfo.TYPE_CLOUD) &#123; cloudPrinterList.add(info); &#125; &#125; mDataList.add(TITLE_BLUETOOTH_PRINTER); mDataList.addAll(bluetoothPrinterList); mDataList.add(TITLE_NET_PRINTER); mDataList.addAll(netPrinterList); mDataList.add(TITLE_CLOUD_PRINTER); mDataList.addAll(cloudPrinterList); &#125; private void setNotSwipeItems(SwipePartMenuListView listView) &#123; List&lt;Integer&gt; titleList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mDataList.size(); i++) &#123; if (mDataList.get(i) instanceof String) &#123; titleList.add(i); &#125; &#125; listView.setCannotSwipePositionList(titleList); &#125; public void setPrinters(ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; initDataList(printers); setNotSwipeItems(listView); &#125; public void setListener(OnItemFunctionClickListener listener) &#123; this.listener = listener; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; int viewType = getItemViewType(position); if (viewType == TYPE_HEADER) &#123; return getTitleView(position, convertView, parent); &#125; else &#123; return getPrinterView(position, convertView, parent); &#125; &#125; private View getPrinterView(int position, View convertView, ViewGroup parent) &#123; PrinterViewHolder printerHolder; if (convertView == null) &#123; printerHolder = new PrinterViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_devices, parent, false); printerHolder.connect = (TextView) convertView.findViewById(R.id.printer_connect_tv); printerHolder.divider = convertView.findViewById(R.id.printer_last_divider); printerHolder.setting = (TextView) convertView.findViewById(R.id.printer_setting_tv); printerHolder.title = (TextView) convertView.findViewById(R.id.printer_title_tv); printerHolder.connectIcon = (ImageView) convertView.findViewById(R.id.printer_connect_iv); convertView.setTag(printerHolder); &#125; else &#123; printerHolder = (PrinterViewHolder) convertView.getTag(); &#125; PrinterInfo printer = (PrinterInfo) mDataList.get(position); initPrinter(printerHolder, printer); if (position == getCount() - 1) &#123; printerHolder.divider.setVisibility(View.VISIBLE); &#125; else &#123; printerHolder.divider.setVisibility(View.GONE); &#125; return convertView; &#125; private View getTitleView(int position, View convertView, ViewGroup parent) &#123; HeaderViewHolder headerHolder; if (convertView == null) &#123; headerHolder = new HeaderViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_title, parent, false); headerHolder.headerTitle = (TextView) convertView.findViewById(R.id.printer_category_tv); headerHolder.headerIcon = (ImageView) convertView.findViewById(R.id.printer_icon_iv); headerHolder.headerAdd = (ImageView) convertView.findViewById(R.id.printer_add_device_iv); headerHolder.headerDivider = convertView.findViewById(R.id.printer_title_divider); convertView.setTag(headerHolder); &#125; else &#123; headerHolder = (HeaderViewHolder) convertView.getTag(); &#125; String title = (String) mDataList.get(position); headerHolder.headerTitle.setText(title); headerHolder.headerAdd.setOnTouchListener(new OnTouchEffectedListener()); if (TITLE_BLUETOOTH_PRINTER.equals(title)) &#123; headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_bluetooth); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onRightClick(PrinterInfo.TYPE_BLUETOOTH); &#125; &#125; &#125;); &#125; else if (TITLE_NET_PRINTER.equals(title)) &#123; headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_wifi); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onRightClick(PrinterInfo.TYPE_NETWORK); &#125; &#125; &#125;); &#125; else if (TITLE_CLOUD_PRINTER.equals(title)) &#123; headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_cloud); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_scan); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onRightClick(PrinterInfo.TYPE_CLOUD); &#125; &#125; &#125;); &#125; if (position == getCount() - 1) &#123; headerHolder.headerDivider.setVisibility(View.VISIBLE); &#125; else &#123; headerHolder.headerDivider.setVisibility(View.GONE); &#125; return convertView; &#125; private void initPrinter(PrinterViewHolder holder, final PrinterInfo printerInfo) &#123; if (holder != null) &#123; boolean connected = false; holder.title.setText(printerInfo.name); List&lt;IPrinter&gt; printers = PrinterManager.getInstance().getPrinterList(); for (IPrinter printer : printers) &#123; if (printer.getPrinterId().equals(printerInfo.mac)) &#123; connected = true; holder.connect.setText(&quot;断开&quot;); holder.connectIcon.setImageResource(R.drawable.ic_connect); break; &#125; &#125; if (!connected) &#123; holder.connect.setText(&quot;连接&quot;); holder.connectIcon.setImageResource(R.drawable.ic_break); &#125; holder.setting.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; PrinterSettingActivity.navigateTo(mContext, printerInfo); &#125; &#125;); final boolean finalConnected = connected; holder.connect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onConnectClick(printerInfo, finalConnected); &#125; &#125; &#125;); &#125; &#125; @Nullable public PrinterInfo getPrinterInfo(int position) &#123; Object o = mDataList.get(position); if (o instanceof PrinterInfo) &#123; return (PrinterInfo) o; &#125; else &#123; return null; &#125; &#125; @Override public int getItemViewType(int position) &#123; Object o = mDataList.get(position); if (o instanceof PrinterInfo) &#123; return TYPE_PRINTER; &#125; else &#123; return TYPE_HEADER; &#125; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public int getCount() &#123; return mDataList.size(); &#125; @Override public Object getItem(int position) &#123; return mDataList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; private class HeaderViewHolder &#123; private TextView headerTitle; private ImageView headerIcon; private ImageView headerAdd; private View headerDivider; &#125; private class PrinterViewHolder &#123; private TextView connect; private TextView title; private View divider; private TextView setting; private ImageView connectIcon; &#125; public interface OnItemFunctionClickListener &#123; void onConnectClick(PrinterInfo printer, boolean connected); /** * 点击标题右侧按钮 * @param printerType 打印机类型。例如 &#123;@link PrinterInfo#TYPE_BLUETOOTH&#125; */ void onRightClick(int printerType); &#125;&#125; 核心代码便在initDataList中，所有的对象都是继承自 Object 的，利用instanceof可以判断放入的是哪种数据类型，一种数据类型对应一种 Type。对比之前的代码，可以看到调整后的代码可读性更高，也更简洁了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"关于 MVP 模式的一点思考","date":"2017-04-25T07:04:41.000Z","path":"2017/04/25/mvp-1/","text":"针对 MVC 的解耦，目前 MVP 模式已经被很多开发者所使用，项目中所使用的便是 MVP 模式。 在我用到 MVP 模式后，我有个疑惑：1个 Presenter 能否对应多个 View？这个问题，在网上已经有很多人展开讨论了：使用 MVP 时，如何让同一个 P 服务多个 V？ 这个issue跟我的情况很类似。我有 A B C 三个页面，我有一个 Presenter，用来处理一个数据类型的增删改查，但是界面上，A界面只需要查询，B界面只需要删除，C界面只需要增和改。基于 Presenter与View 一一对应的情况下，很容易就写出如下的代码： 1234567891011121314151617181920public interface IMyPresenter &#123; void query(); void insert(); void update(); void delete();&#125;public interface IMyView &#123; void showList(); void showInsertResult(); void showUpdateResult(); void showDeleteResult();&#125; 在 IMyPresenter 的具体实现中回调 IMyView 的方法，通知界面进行展示。A B C 三个界面都实现 IMyView，然后就会有一个蛋疼的现象：很多do nothing的方法。比如 A 界面会这样： 123456789101112131415public void showList()&#123; // show something&#125;public void showInsertResult()&#123; // do nothing&#125;public void showUpdateResult()&#123; // do nothing&#125;public void showDeleteResult()&#123; // do nothing&#125; 因为 A 界面就没用到增删改的接口，所以自然不用实现相应的 View 接口，这看起来就很蛋疼了。 现在假设我们使用多个 Presenter,使一个 Presenter 对应一个 View，也就是写3个 Presenter,一个负责查询对应界面 A，一个负责删除对应界面 B，一个负责增和改对应界面 C。显然是没什么毛病的，但是会多许多的 Presenter，除了写起来很费事繁杂，还有一个缺点：若界面有业务交集（比如 A 界面不仅有查询，还有个删除，那么就会和 B 界面重复），就会导致 Presenter 严重冗余，几个 Presenter 里面的代码大块大块的相似。另外这个 Presenter 本是增删改查一套业务，结果硬生生拆成多个 Presenter，总感觉不合适。 所以在我的实际情况中，上述两种方案我都没有采用。这里便说下我的一些想法：Presenter 仍然独立处理业务，将 View 进行抽离解耦，提供一个顶层的 View 给 Presenter 使用，当要调到具体的 View 方法时，使用 instance of 判断，然后强转进行调用。修改后的代码大致如下： 1234567891011121314151617public interface IMyView &#123;&#125;public interface IAView extends IMyView &#123; void showList();&#125;public interface IBView extends IMyView &#123; void showDeleteResult();&#125;public interface IAView extends IMyView &#123; void showUpdateResult(); void showInsertResult();&#125; 然后 IMyPresenter 的实现持有 IMyView 的实例，在调用的地方进行强转。 123456public void delete()&#123; // do something if (mView != null &amp;&amp; mView instanceof IBView) &#123; ((IBView) mView).showDeleteResult(); &#125;&#125; 用这种方法，可以一定程度上解决一个 Presenter 对应多个 View 的问题。只能是一定程度上，是因为若 View 对应的业务场景有很复杂的交叉，那么就需要定义非常多的 View 与之对应，并且有很深的继承关系，也是不太合适。若真是碰到这种场景，我可能就会考虑 Google 所说的 MVP Clean 模式了。","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"博客免密提交、部署到Github","date":"2017-04-19T02:08:07.000Z","path":"2017/04/19/no-password/","text":"每次写完博客，hexo d的时候需要输入一次Github账号密码，git push的时候又需要输入一次，有点烦了。最近转到 Ubuntu 工作，也换了台电脑，之前的配置都忘记了，于是重新查了一下，这里摘录一下，忘记了后面可以回头来看。 hexo d 免密输入在 user 根目录下新建.netrc文件，填写内容： 123machine github.comlogin username //username为github账户名 （不是用来登录的邮箱或手机号）password password //password为github账户的密码 保存之后，再执行 hexo d 时即可直接部署，不用输入账号密码了。 git push 免密输入因为是用的 https 方式，进入到 git 控制的根目录，执行： 1gedit .git/config 看到： 12345678[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote &quot;origin&quot;] url = https://github.com/LiJia92/LiJia92.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* 编辑url为： 1https://LiJia92:5201314lijia@github.com/LiJia92/LiJia92.github.io.git 即：https://username:password@github.com/username/project.git，username就是你账号名。 参考github https方式免密码提交代码 在git config 中添加用户名密码Hexo免输入密码部署到Github 2025&#x2F;07&#x2F;02更新更换新电脑后，git push时即使输入账户密码也无法推送成功，一直提示鉴权失败。通过 AI 得到如下解释： 这是由于 GitHub 自 2021 年 8 月 13 日起已全面禁用密码认证，必须使用个人访问令牌（PAT）​或 SSH 密钥进行身份验证。 于是我改用 SSH 验证了： 1git remote set-url origin git@github.com:LiJia92/LiJia92.github.io.git 前提是已经将新电脑的 SSH key 配置到 Github 中。","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"使用ListView多Type的错误姿势","date":"2017-04-18T11:33:01.000Z","path":"2017/04/18/wrong/","text":"项目中，有这样的一个需求： 有三种打印机类型，每种类型可以添加、删除对应类型的打印机。按照以往，我写的Adapter是这样的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220public class PrinterManagerAdapter extends BaseAdapter &#123; public final static int BLUETOOTH_HEADER = 0; public final static int BLUETOOTH_PRINTER = 1; public final static int NET_HEADER = 2; public final static int NET_PRINTER = 3; public final static int CLOUD_HEADER = 4; public final static int CLOUD_PRINTER = 5; private Context mContext; private LayoutInflater mInflater; private OnItemFunctionClickListener listener; private List&lt;PrinterInfo&gt; mPrinters = new ArrayList&lt;&gt;(); private int blueToothCount = 0; private int netCount = 0; private int cloudCount = 0; public PrinterManagerAdapter(Context context, List&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; mContext = context; mPrinters = printers; mInflater = LayoutInflater.from(context); getNotSwipeItem(listView); &#125; private void getNotSwipeItem(SwipePartMenuListView listView) &#123; blueToothCount = 0; netCount = 0; cloudCount = 0; for (PrinterInfo info : mPrinters) &#123; if (info.printerType == PrinterInfo.TYPE_BLUETOOTH) &#123; blueToothCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_NETWORK) &#123; netCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_CLOUD) &#123; cloudCount++; &#125; &#125; List&lt;Integer&gt; titleList = new LinkedList&lt;&gt;(); titleList.add(0); titleList.add(1 + blueToothCount); titleList.add(2 + blueToothCount + netCount); listView.setCannotSwipePositionList(titleList); &#125; public void setPrinters(List&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; this.mPrinters = printers; getNotSwipeItem(listView); &#125; public void setListener(OnItemFunctionClickListener listener) &#123; this.listener = listener; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; PrinterManagerViewHolder holder; final int viewType = getItemViewType(position); holder = new PrinterManagerViewHolder(); if (viewType == BLUETOOTH_HEADER || viewType == NET_HEADER || viewType == CLOUD_HEADER) &#123; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.item_printer_title, parent, false); holder.headerTitle = (TextView) convertView.findViewById(R.id.printer_category_tv); holder.headerIcon = (ImageView) convertView.findViewById(R.id.printer_icon_iv); holder.headerAdd = (ImageView) convertView.findViewById(R.id.printer_add_device_iv); holder.headerDivider = convertView.findViewById(R.id.printer_title_divider); convertView.setTag(holder); &#125; else &#123; holder = (PrinterManagerViewHolder) convertView.getTag(); &#125; &#125; else &#123; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.item_printer_devices, parent, false); holder.connect = (TextView) convertView.findViewById(R.id.printer_connect_tv); holder.divider = convertView.findViewById(R.id.printer_last_divider); holder.setting = (TextView) convertView.findViewById(R.id.printer_setting_tv); holder.title = (TextView) convertView.findViewById(R.id.printer_title_tv); holder.connectIcon = (ImageView) convertView.findViewById(R.id.printer_connect_iv); convertView.setTag(holder); &#125; else &#123; holder = (PrinterManagerViewHolder) convertView.getTag(); &#125; &#125; switch (viewType) &#123; case BLUETOOTH_HEADER: holder.headerTitle.setText(&quot;蓝牙打印机&quot;); holder.headerAdd.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.btn_setting_goods_add)); holder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; BlueToothPrinterActivity.navigateTo(mContext); &#125; &#125;); break; case NET_HEADER: holder.headerTitle.setText(&quot;网络打印机&quot;); holder.headerAdd.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.btn_setting_goods_add)); holder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; NetPrinterActivity.navigateTo(mContext); &#125; &#125;); break; case CLOUD_HEADER: holder.headerTitle.setText(&quot;云打印机&quot;); holder.headerAdd.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.btn_setting_goods_scan)); if (position == getCount() - 1) &#123; holder.headerDivider.setVisibility(View.VISIBLE); &#125; break; case BLUETOOTH_PRINTER: PrinterInfo printer = mPrinters.get(position - 1); initPrinter(holder, printer); break; case NET_PRINTER: PrinterInfo netPrinter = mPrinters.get(position - 2); initPrinter(holder, netPrinter); break; case CLOUD_PRINTER: if (position == getCount() - 1) &#123; holder.divider.setVisibility(View.VISIBLE); &#125; PrinterInfo cloudPrinter = mPrinters.get(position - 3); initPrinter(holder, cloudPrinter); break; &#125; return convertView; &#125; private void initPrinter(PrinterManagerViewHolder holder, final PrinterInfo printerInfo) &#123; boolean connected = false; holder.title.setText(printerInfo.name); HashMap&lt;String, IPrinter&gt; printers = PrinterManager.getInstance().getPrinterList(); if (printers.keySet().contains(printerInfo.mac)) &#123; connected = true; holder.connect.setText(&quot;断开&quot;); holder.connectIcon.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_connect)); &#125; else &#123; holder.connect.setText(&quot;连接&quot;); holder.connectIcon.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_break)); &#125; holder.setting.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; PrinterSettingActivity.navigateTo(mContext, printerInfo); &#125; &#125;); final boolean finalConnected = connected; holder.connect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onConnectClicked(printerInfo, finalConnected); &#125; &#125; &#125;); &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return BLUETOOTH_HEADER; &#125; else if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; return BLUETOOTH_PRINTER; &#125; else if (position == blueToothCount + 1) &#123; return NET_HEADER; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; return NET_PRINTER; &#125; else if (position == netCount + blueToothCount + 2) &#123; return CLOUD_HEADER; &#125; else &#123; return CLOUD_PRINTER; &#125; &#125; @Override public int getCount() &#123; if (mPrinters != null) &#123; return mPrinters.size() + 3; &#125; return 0; &#125; @Override public Object getItem(int position) &#123; return null; &#125; @Override public long getItemId(int position) &#123; return position; &#125; private class PrinterManagerViewHolder &#123; // Header private TextView headerTitle; private ImageView headerIcon; private ImageView headerAdd; private View headerDivider; // Printer private TextView connect; private TextView title; private View divider; private TextView setting; private ImageView connectIcon; &#125; public interface OnItemFunctionClickListener &#123; void onConnectClicked(PrinterInfo printer, boolean connected); &#125;&#125; 我将 view 分为了6个 Type ，三种头部 Type 使用一种布局，三种打印机 Type 使用一种布局，然后总共用了一个 ViewHoloder 。然后发现一个问题：当我删除一个打印机之后，刷新界面的时候崩溃了问题其实很简单：就是删除的打印机（BLUETOOTH_PRINTER Type）convertView 进入到缓存里面，然后下个 Item 的 Type 是 NET_HEADER Type，由于重用机制，这个 Item 会重用 convertView，此时这个 convertView 绑定的 ViewHoloder 是 Printer 部分，而自己要使用的是 Header 部分，其 view 都为 null了，导致空指针崩溃。解决办法：添加代码 1234@Overridepublic int getViewTypeCount() &#123; return 6;&#125; ListView 的缓存机制是可以针对不同 Type 来进行缓存的，当不复写这个方法的时候，其默认的实现是 返回1 ,所以导致getItemViewType返回的 Type 实际上是没有用的，不管是什么 Type， ListView 填充的 convertView 永远是一样的。所以，当改成 返回6 的时候， ListView 便会填充 6 种 convertView 了，所绑定的 ViewHoloder 具有的属性也会一样，就避免了空指针崩溃了。当和同事讨论这点的时候，同事指出： 有几种布局，就用几种 Type，几种 ViewHoloder，一一对应才是官方推荐的行为。自己想了下，确实是的。当网络打印机这个 Item 要显示的时候，如果缓存中有蓝牙打印机的 convertView，我是用不了的，因为他们的 Type 不一样。这样的一个做法，就是自己把 ListView 的缓存机制整乱了。修改后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253public class PrinterManagerAdapter extends BaseAdapter &#123; private final static int TYPE_HEADER = 0; private final static int TYPE_PRINTER = 1; private Context mContext; private LayoutInflater mInflater; private OnItemFunctionClickListener listener; private ArrayList&lt;PrinterInfo&gt; mPrinters; private int blueToothCount = 0; private int netCount = 0; private int cloudCount = 0; public PrinterManagerAdapter(Context context, ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; mContext = context; mPrinters = printers; mInflater = LayoutInflater.from(context); setNotSwipeItems(listView); &#125; private void setNotSwipeItems(SwipePartMenuListView listView) &#123; blueToothCount = 0; netCount = 0; cloudCount = 0; for (PrinterInfo info : mPrinters) &#123; if (info.printerType == PrinterInfo.TYPE_BLUETOOTH) &#123; blueToothCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_NETWORK) &#123; netCount++; &#125; else if (info.printerType == PrinterInfo.TYPE_CLOUD) &#123; cloudCount++; &#125; &#125; List&lt;Integer&gt; titleList = new ArrayList&lt;&gt;(); titleList.add(0); titleList.add(1 + blueToothCount); titleList.add(2 + blueToothCount + netCount); listView.setCannotSwipePositionList(titleList); &#125; public void setPrinters(ArrayList&lt;PrinterInfo&gt; printers, SwipePartMenuListView listView) &#123; this.mPrinters = printers; setNotSwipeItems(listView); &#125; public void setListener(OnItemFunctionClickListener listener) &#123; this.listener = listener; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; HeaderViewHolder headerHolder = null; PrinterViewHolder printerHolder = null; int viewType = getItemViewType(position); if (viewType == TYPE_HEADER) &#123; if (convertView == null) &#123; headerHolder = new HeaderViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_title, parent, false); headerHolder.headerTitle = (TextView) convertView.findViewById(R.id.printer_category_tv); headerHolder.headerIcon = (ImageView) convertView.findViewById(R.id.printer_icon_iv); headerHolder.headerAdd = (ImageView) convertView.findViewById(R.id.printer_add_device_iv); headerHolder.headerDivider = convertView.findViewById(R.id.printer_title_divider); convertView.setTag(headerHolder); &#125; else &#123; headerHolder = (HeaderViewHolder) convertView.getTag(); &#125; &#125; else &#123; if (convertView == null) &#123; printerHolder = new PrinterViewHolder(); convertView = mInflater.inflate(R.layout.item_printer_devices, parent, false); printerHolder.connect = (TextView) convertView.findViewById(R.id.printer_connect_tv); printerHolder.divider = convertView.findViewById(R.id.printer_last_divider); printerHolder.setting = (TextView) convertView.findViewById(R.id.printer_setting_tv); printerHolder.title = (TextView) convertView.findViewById(R.id.printer_title_tv); printerHolder.connectIcon = (ImageView) convertView.findViewById(R.id.printer_connect_iv); convertView.setTag(printerHolder); &#125; else &#123; printerHolder = (PrinterViewHolder) convertView.getTag(); &#125; &#125; switch (viewType) &#123; case TYPE_HEADER: if (headerHolder != null) &#123; if (position == 0) &#123; headerHolder.headerTitle.setText(&quot;蓝牙打印机&quot;); headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_bluetooth); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; BlueToothPrinterActivity.navigateTo(mContext, mPrinters); &#125; &#125;); &#125; else if (position == blueToothCount + 1) &#123; headerHolder.headerTitle.setText(&quot;网络打印机&quot;); headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_wifi); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_add); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;// NetPrinterActivity.navigateTo(mContext); &#125; &#125;); &#125; else if (position == netCount + blueToothCount + 2) &#123; headerHolder.headerTitle.setText(&quot;云打印机&quot;); headerHolder.headerIcon.setImageResource(R.drawable.ic_printer_cloud); headerHolder.headerAdd.setImageResource(R.drawable.btn_setting_goods_scan); headerHolder.headerAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;// NetPrinterActivity.navigateTo(mContext); &#125; &#125;); if (position == getCount() - 1) &#123; headerHolder.headerDivider.setVisibility(View.VISIBLE); &#125; else &#123; headerHolder.headerDivider.setVisibility(View.GONE); &#125; &#125; &#125; break; case TYPE_PRINTER: if (printerHolder != null) &#123; int index; if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; index = position - 1; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; index = position - 2; &#125; else &#123; index = position - 3; if (position == getCount() - 1) &#123; printerHolder.divider.setVisibility(View.VISIBLE); &#125; else &#123; printerHolder.divider.setVisibility(View.GONE); &#125; &#125; PrinterInfo printer = mPrinters.get(index); initPrinter(printerHolder, printer); &#125; break; default: break; &#125; return convertView; &#125; private void initPrinter(PrinterViewHolder holder, final PrinterInfo printerInfo) &#123; if (holder != null) &#123; boolean connected = false; holder.title.setText(printerInfo.name); HashMap&lt;String, IPrinter&gt; printers = PrinterManager.getInstance().getPrinterList(); if (printers.keySet().contains(printerInfo.mac)) &#123; connected = true; holder.connect.setText(&quot;断开&quot;); holder.connectIcon.setImageResource(R.drawable.ic_connect); &#125; else &#123; holder.connect.setText(&quot;连接&quot;); holder.connectIcon.setImageResource(R.drawable.ic_break); &#125; holder.setting.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; PrinterSettingActivity.navigateTo(mContext, printerInfo); &#125; &#125;); final boolean finalConnected = connected; holder.connect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onConnectClicked(printerInfo, finalConnected); &#125; &#125; &#125;); &#125; &#125; public PrinterInfo getPrinterInfo(int position) &#123; int index; if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; index = position - 1; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; index = position - 2; &#125; else &#123; index = position - 3; &#125; return mPrinters.get(index); &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return TYPE_HEADER; &#125; else if (position &gt; 0 &amp;&amp; position &lt;= blueToothCount) &#123; return TYPE_PRINTER; &#125; else if (position == blueToothCount + 1) &#123; return TYPE_HEADER; &#125; else if (position &gt; blueToothCount + 1 &amp;&amp; position &lt;= netCount + blueToothCount + 1) &#123; return TYPE_PRINTER; &#125; else if (position == netCount + blueToothCount + 2) &#123; return TYPE_HEADER; &#125; else &#123; return TYPE_PRINTER; &#125; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public int getCount() &#123; if (mPrinters != null) &#123; return mPrinters.size() + 3; &#125; return 3; &#125; &#125; @Override public long getItemId(int position) &#123; return position; &#125; private class HeaderViewHolder &#123; private TextView headerTitle; private ImageView headerIcon; private ImageView headerAdd; private View headerDivider; &#125; private class PrinterViewHolder &#123; private TextView connect; private TextView title; private View divider; private TextView setting; private ImageView connectIcon; &#125; public interface OnItemFunctionClickListener &#123; void onConnectClicked(PrinterInfo printer, boolean connected); &#125;&#125; 这样的话，结构其实会更加清晰，拆分得更具体。另外，注意一点： 代码中的 Type 类型 TYPE_HEADER 是从0开始的。这是因为不从 0 开始当 Adapter notifyDataSetChanged 时就会报错。举个栗子： 12private final static int TYPE_HEADER = 5;private final static int TYPE_PRINTER = 6; 报错信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051FATAL EXCEPTION: mainProcess: com.maimairen.app.jinchuhuo.dev, PID: 15967java.lang.ArrayIndexOutOfBoundsException: length=2; index=5 at android.widget.AbsListView$RecycleBin.addScrapView(AbsListView.java:6726) at android.widget.ListView.layoutChildren(ListView.java:1644) at android.widget.AbsListView.onLayout(AbsListView.java:2148) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) at android.widget.LinearLayout.onLayout(LinearLayout.java:1495) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) at android.widget.FrameLayout.onLayout(FrameLayout.java:273) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) at android.widget.LinearLayout.onLayout(LinearLayout.java:1495) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) at android.widget.FrameLayout.onLayout(FrameLayout.java:273) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) at android.widget.LinearLayout.onLayout(LinearLayout.java:1495) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) at android.widget.FrameLayout.onLayout(FrameLayout.java:273) at com.android.internal.policy.PhoneWindow$DecorView.onLayout(PhoneWindow.java:2678) at android.view.View.layout(View.java:16653) at android.view.ViewGroup.layout(ViewGroup.java:5438) at android.view.ViewRootImpl.performLayout(ViewRootImpl.java:2198) at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:1958) at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1134) at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6050) at android.view.Choreographer$CallbackRecord.run(Choreographer.java:860) at android.view.Choreographer.doCallbacks(Choreographer.java:672) at android.view.Choreographer.doFrame(Choreographer.java:608) at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:846) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5438) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629) 可以看到，ListView 从缓存中去取 view 的时候，是用的 Type 的值来作为 index 的，所以 Type 类型一定是从0开始的。因为自己长期以来一直是之前的那种做法，错了太多次了，却没有及时发现错误，经过这次同事的指正，总算是纠正过来了。写篇博客备忘，忘性太大了～","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"CoordinatorLayout之Behavior认识","date":"2017-03-31T11:09:45.000Z","path":"2017/03/31/coordinatorlayout/","text":"背景项目开发中，我们经常有滑动控件固定某一个部分在顶部的需求，效果类似这样： 在Material Design出来之前，我们可能会有方案一： 给 ListView C 添加一个HeadView（包含A、B），然后另外准备一个外部的B在屏幕顶部，一开始不可见。ListView当前滚动高度超过A的高度时，显示外部的B；滚动高度小于A时隐藏外部的B。 正如我此时的项目中的一样，但是项目中的B是一个搜索框，类似这样： 可以看到 B 的构成是相对复杂的，B 相关的事件操作也会写 2 遍，很显然的会导致整个代码结构非常臃肿，所以需要寻找方案二。 嵌套滚动机制在我早些的一篇文章使用Android新特性：Material Design中有说起一个控件：CoordinatorLayout。它是一个增强型的 FrameLayout。它的作用有两个： 作为一个布局的根布局 最后一个为子视图之间相互协调手势效果的一个协调布局 为子视图协调手势效果主要是基于 Android 的嵌套滚动机制。 所谓嵌套滚动其实就是界面布局中包含一个可滚动的列表和一个不可滚动的View，这样在滚动列表时，首先将不可滚动View移出屏幕或移进屏幕，待不可滚动View固定时，才会继续滚动滚动列表的内容。 关于嵌套滚动机制更详细的一些说明有很多文章都说的不错，稍后会在参考中放出链接。 实例我们知道可以通过Behavior来实现各种嵌套滑动效果。最为典型的就是AppBarLayout中的ScrollingViewBehavior。很经典的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/background_light&quot; android:fitsSystemWindows=&quot;true&quot; &gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/main.appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; android:fitsSystemWindows=&quot;true&quot; &gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/main.collapsing&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:expandedTitleMarginEnd=&quot;64dp&quot; &gt; &lt;ImageView android:id=&quot;@+id/main.backdrop&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:fitsSystemWindows=&quot;true&quot; android:src=&quot;@drawable/material_flat&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/main.toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; &gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; android:lineSpacingExtra=&quot;8dp&quot; android:text=&quot;@string/lorem&quot; android:padding=&quot;@dimen/activity_horizontal_margin&quot; /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_margin=&quot;@dimen/activity_horizontal_margin&quot; android:src=&quot;@drawable/ic_comment_24dp&quot; app:layout_anchor=&quot;@id/main.appbar&quot; app:layout_anchorGravity=&quot;bottom|right|end&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 通过给滑动控件设置app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;来实现控制 ToolBar 隐藏或消失的效果。但是这个 Behavior 是依赖于 AppBarLayout 的，换成其他的控件将会失效。 尝试一基于我的情况，我的Header可能是这样的： 1234&lt;LinearLayout&gt; &lt;!-- 展示库存的HeaderA --&gt; &lt;!-- 展示过滤搜索的HeaderB --&gt;&lt;/LinearLayout&gt; 所以我期初的做法是定义 Behavior ,然后通过依赖让 LinearLayout 与 RecyclerView 联动。布局代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/activity_behavior&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot; app:layout_behavior=&quot;com.study.lijia.coordinatorlayoutdemo.RecyclerBehavior&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_behavior=&quot;com.study.lijia.coordinatorlayoutdemo.HeaderBehavior&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;56dp&quot; android:background=&quot;#4400ff00&quot; android:gravity=&quot;center&quot; android:text=&quot;Header A&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;#4400ffff&quot; android:gravity=&quot;center&quot; android:text=&quot;Header B&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; HeaderBehavior： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class HeaderBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private View childA; // Header A private View childB; // Header B private int childAHeight; private int childBHeight; public HeaderBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; if (child instanceof LinearLayout) &#123; LinearLayout dependent = (LinearLayout) child; if (dependent.getChildCount() == 2) &#123; childA = dependent.getChildAt(0); childB = dependent.getChildAt(1); childAHeight = childA.getHeight(); childBHeight = childB.getHeight(); &#125; &#125; return target instanceof RecyclerView; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0) &#123; //表示向上滚动 float trY = child.getY() - dy &lt;= -childAHeight ? -childAHeight : child.getTranslationY() - dy; child.setY(trY); child.setTag(dy); &#125; else if (dy &lt; 0) &#123; //向下滚动 if (target instanceof RecyclerView) &#123; int scrollY = getScrollY((RecyclerView) target); if (scrollY == 0) &#123; if (target.getTranslationY() &lt; childBHeight) &#123; child.setTag(dy); &#125; else &#123; float trY = child.getY() - dy &gt;= 0 ? 0 : child.getY() - dy; child.setY(trY); child.setTag(dy); &#125; &#125; &#125; &#125; &#125;// @Override// public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY) &#123;// ((NestedScrollView) child).fling((int)velocityY);// return true;// &#125; private int getScrollY(RecyclerView target) &#123; RecyclerView recyclerView = target; LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); int position = layoutManager.findFirstVisibleItemPosition(); View firstVisiableChildView = layoutManager.findViewByPosition(position); int itemHeight = firstVisiableChildView.getHeight(); return (position) * itemHeight - firstVisiableChildView.getTop(); &#125;&#125; RecyclerBehavior： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class RecyclerBehavior extends CoordinatorLayout.Behavior&lt;RecyclerView&gt; &#123; private Context context; private View childA; // Header A private View childB; // Header B private int childAHeight; private int childBHeight; public RecyclerBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, RecyclerView child, View dependency) &#123; if (dependency instanceof LinearLayout) &#123; LinearLayout dependent = (LinearLayout) dependency; if (dependent.getChildCount() == 2) &#123; childA = dependent.getChildAt(0); childB = dependent.getChildAt(1); childAHeight = childA.getHeight(); childBHeight = childB.getHeight(); return true; &#125; &#125; return false; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, RecyclerView child, View dependency) &#123; int y = (int) (dependency.getY() + dependency.getBottom()); Log.e(&quot;TAG&quot;, &quot;y:&quot; + y); int z; if (y &gt; childBHeight) &#123; child.setTranslationY(y); &#125; else &#123; if (dependency.getTag() != null) &#123; int x = (int) child.getTranslationY(); z = x - (int) (dependency.getTag()); if (z &lt; 0) &#123; z = 0; &#125; else if (z &gt; childBHeight + childAHeight) &#123; z = childAHeight + childBHeight; &#125; Log.e(&quot;TAG&quot;, &quot;z:&quot; + z); child.setTranslationY(z); &#125; &#125; return true; &#125;&#125; 最后实现的效果可以说基本满足了。但是当发生Fling滑动时，便会很容易出现问题。因为上面的Header LinearLayout并没有处理Fling的操作。后面我自定义LinearLayoutWithFling利用OverScroller来实现Fling但是结果并不如意。 尝试二自定义实现NestedScrollingParent接口的 LinearLayout ,然后内部来处理 RecyclerView 的滑动。布局代码如下： 12345678910111213141516171819202122232425262728&lt;com.study.lijia.coordinatorlayoutdemo.StickyNavLayout android:id=&quot;@+id/activity_behavior&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;56dp&quot; android:background=&quot;#4400ff00&quot; android:gravity=&quot;center&quot; android:text=&quot;Header A&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;#4400ffff&quot; android:gravity=&quot;center&quot; android:text=&quot;Header B&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot; /&gt;&lt;/com.study.lijia.coordinatorlayoutdemo.StickyNavLayout&gt; StickyNavLayout如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class StickyNavLayout extends LinearLayout implements NestedScrollingParent &#123; private NestedScrollingParentHelper parentHelper = new NestedScrollingParentHelper(this); private View mTop; private View mNav; private View thirdView; private int mTopViewHeight; private OverScroller mScroller; private VelocityTracker mVelocityTracker; private int mTouchSlop; private int mMaximumVelocity, mMinimumVelocity; private float mLastY; private boolean mDragging; public StickyNavLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); setOrientation(LinearLayout.VERTICAL); mScroller = new OverScroller(context); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); mMaximumVelocity = ViewConfiguration.get(context).getScaledMaximumFlingVelocity(); mMinimumVelocity = ViewConfiguration.get(context).getScaledMinimumFlingVelocity(); &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); mTop = getChildAt(0); mNav = getChildAt(1); thirdView = getChildAt(2); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mTopViewHeight = mTop.getMeasuredHeight(); //上面测量的结果是viewPager的高度只能占满父控件的剩余空间 //重新设置viewPager的高度 ViewGroup.LayoutParams layoutParams = thirdView.getLayoutParams(); layoutParams.height = getMeasuredHeight() - mNav.getMeasuredHeight(); Log.e(&quot;TAG&quot;, &quot;height:&quot; + layoutParams.height); thirdView.setLayoutParams(layoutParams); &#125; @Override public void scrollTo(int x, int y) &#123; Log.e(&quot;TAG&quot;, &quot;y:&quot; + y); //限制滚动范围 if (y &lt; 0) &#123; y = 0; &#125; if (y &gt; mTopViewHeight) &#123; y = mTopViewHeight; &#125; super.scrollTo(x, y); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(0, mScroller.getCurrY()); invalidate(); &#125; &#125; public void fling(int velocityY) &#123; mScroller.fling(0, getScrollY(), 0, velocityY, 0, 0, 0, mTopViewHeight); invalidate(); &#125;//实现NestedScrollParent接口------------------------------------------------------------------------- @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123; return true; &#125; @Override public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes) &#123; parentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes); &#125; @Override public void onStopNestedScroll(View target) &#123; parentHelper.onStopNestedScroll(target); &#125; @Override public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; &#125; @Override public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; boolean hiddenTop = dy &gt; 0 &amp;&amp; getScrollY() &lt; mTopViewHeight; boolean showTop = dy &lt; 0 &amp;&amp; getScrollY() &gt;= 0 &amp;&amp; !ViewCompat.canScrollVertically(target, -1); if (hiddenTop || showTop) &#123; scrollBy(0, dy); consumed[1] = dy; &#125; &#125; //boolean consumed:子view是否消耗了fling //返回值：自己是否消耗了fling。可见，要消耗只能全部消耗 @Override public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) &#123; Log.e(&quot;onNestedFling&quot;, &quot;called&quot;); return false; &#125; //返回值：自己是否消耗了fling。可见，要消耗只能全部消耗 @Override public boolean onNestedPreFling(View target, float velocityX, float velocityY) &#123; Log.e(&quot;onNestedPreFling&quot;, &quot;called&quot;); if (getScrollY() &lt; mTopViewHeight) &#123; fling((int) velocityY); return true; &#125; else &#123; return false; &#125; &#125; @Override public int getNestedScrollAxes() &#123; return parentHelper.getNestedScrollAxes(); &#125;&#125; 达到的效果姑且不错，但是当我想要加入下拉刷新SwipeRefreshLayout的时候，感觉不是很好加。SwipeRefreshLayout也是基于嵌套滑动机制的一个下拉刷新类，StickyNavLayout与SwipeRefreshLayout要共同处理 RecyclerView 的滑动事件，会冲突。 方案三–回归本质当几经尝试后，感觉还是对原理没摸清，于是回过头来看 AppBarLayout 的 Behavior 。结果我特喵的发现AppBarLayout 就是 LinearLayout，很符合我的项目实情。然后利用layout_scrollFlags来控制Header A的显示、隐藏，并且加入下拉刷新也很方便，最后便采用了原生的方法了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/activity_behavior&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@null&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;56dp&quot; android:background=&quot;#4400ffff&quot; android:gravity=&quot;center&quot; android:text=&quot;Header A&quot; android:textSize=&quot;18sp&quot; app:layout_scrollFlags=&quot;scroll&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;#4400ff00&quot; android:gravity=&quot;center&quot; android:text=&quot;Header B&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot; /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 下拉刷新加载 RecyclerView 那里实际效果看起来很怪，最后调整将 SwipeRefreshLayout 作为根节点， CoordinatorLayout 作为其子 View ，这个时候下拉刷新会有问题，因为2者都实现了 NestedScrollParent 接口，采取的方法是监听 AppBarLayout 的 offset，根据这个值来是否禁用 SwipeRefreshLayout。 12345678910mAppBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() &#123; @Override public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) &#123; if (verticalOffset &gt;= 0) &#123; mRefreshLayout.setEnabled(true); &#125; else &#123; mRefreshLayout.setEnabled(false); &#125; &#125;&#125;); 示例代码 参考demo为了速成，很多代码都是从以下参考文章中直接拿的-。- ListView 两种固定标头的技巧 Android CoordinatorLayout和Behavior (译)掌握 Coordinator Layout CoordinatorLayout高级用法-自定义Behavior NestedScrolling机制(二)——实例 SwipeRefreshLayout 与 CoordinatorLayout 嵌套刷新","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Gradle 多版本管理","date":"2017-03-16T08:54:10.000Z","path":"2017/03/16/gradle-app/","text":"之前有写过一篇Android Studio使用Gradle进行多渠道打包，多渠道打包算是Gradle最常用的功能了，但是它的强大可不止于此。 简介Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。使用Gradle的优势: 自动处理包相依关系 - 取自 Maven Repos 的概念 自动处理布署问题 - 取自 Ant 的概念 条件判断写法直觉 - 使用 Groovy 语言 更多关于Gradle的学习可以阅读Gradle User Guide 中文版。 多版本其实很多东西在你没有接触的时候，它的一些概念你是很难理解的。我现在重新去理解它，因为我碰到了这样一个情形：由于业务的拓展导致项目越来越复杂，由最初的一个手机基本App版本衍生出很多其他版本，比如pos机，收银机，pad等等，又或者是针对某些具体用户定制的版本。而这些版本的业务是基本一致的，只是在界面或者交互上有一些不一样，这个时候要如何构建自己的项目呢？答案当然是Gradle。 下面举个栗子。创建一个AS项目，在app的build.radle中加入如下代码： 1234567891011121314productFlavors &#123; // pad版 pad &#123; &#125; // 手机版 phone &#123; &#125; // 定制版 custom &#123; &#125;&#125; 然后我们看到Build Variant:3个版本对应debug release，6个编译指令。在不同版本的编译指令中，我们可以做不同的事情。比如替换包名： 1234567891011121314productFlavors &#123; // pad版 pad &#123; applicationId &quot;com.study.lijia.gradleapp.pad&quot; &#125; // 手机版 phone &#123; applicationId &quot;com.study.lijia.gradleapp.phone&quot; &#125; // 定制版 custom &#123; applicationId &quot;com.study.lijia.gradleapp&quot; &#125;&#125; 这样我们在手机上就可以安装三个不同的版本了。再继续上面的情形，三个版本的绝大部分东西是一样的，只是有个别页面不一样。那么可以这样做： 依然继续上面的栗子。在app src目录下，新建目录，与main目录平行，目录名称与gradle中配置的一致。然后继续创建java、res文件夹，再就是写代码了。注意多个文件夹中的文件名以及路径要一样，代码必须添加java文件夹，资源必须添加res文件夹。公共模块中不能包含与其一样的类，否则当切到相应的版本会导致类重复。 当我们选择一个版本时候，另外不可用的代码就会变成红色J标志。如上图中，我选的custom版本，那么pad与phone目录下的代码都变成红色J了，代表当前版本没有用到此代码。改变Build Variant，然后运行，将3个版本都装到设备上，运行后可以看到每个版本的内容是不一样的。（ubuntu录制gif还没找到很好的方法，就不放图了，可以自己跑代码看。）运行都是各自的代码，main下面的代码则是公共模块。 通过上面的栗子，我们知道可以通过productFlavors做各种版本配置。 依赖当项目变得越来越复杂，就不仅仅是单个项目或者Module能解决的了的。我们通常会有很多个Module，继上面的栗子。 项目拓展后，我们新建了pad，phone，appcore3个module，最顶层的app定义实现各种presenter，pad主要针对pad版的界面，phone主要是针对phone版的界面，appcore则是公共底层，用于数据管理等。那么如果是pad版就有app-&gt;pad-&gt;appcore这样的依赖链。在app的build.gradle中配置: 1234567dependencies &#123; padCompile project(path: &#x27;:pad&#x27;, configuration: &#x27;commenDebug&#x27;) phoneCompile project(path: &#x27;:phone&#x27;, configuration: &#x27;commenDebug&#x27;) // custom依赖phone的special版 customCompile project(path: &#x27;:phone&#x27;, configuration: &#x27;specialDebug&#x27;)&#125; 可以结合productFlavors的gradle配置，这里是配置依赖。path是指定module，configuration是指定那个版本。因为我们在pad，phone中也有productFlavors配置。 123456789101112131415publishNonDefault trueproductFlavors &#123; commen &#123; &#125; special &#123; &#125;&#125;dependencies &#123; commenCompile project(path: &#x27;:appcore&#x27;) specialCompile project(path: &#x27;:appcore&#x27;)&#125; 注意publishNonDefault true必须加上，否则会提示找不到依赖项。 这句话是设置没有默认发布类型。因为我们在productFlavors中设置了版本，而默认的是debug和release，所以会导致找不到依赖。 It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant. Publishing a variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project. 摘自官网。 这时我们修改app的Build variant，下面相关的依赖则会跟着变化，因为我们做了这样的配置。 多渠道通过productFlavors配置多版本，但是如果此时又要配置多渠道该怎么办呢？最笨的方法，自然是依然通过productFlavors来配置了。但是这里要做1个乘法，如果有3个版本，每个版本又有15个渠道，那么可就得配置45个渠道了，简直要累死。。。 那么有没有不笨的方法呢？方法终归是有的，美团的瓦力便是个不错的方法。它是在生成母包之后，动态替换里面的变量，重新生成渠道包，省去了编译时间，极大的减少了AS gradle编译的时间。瓦力相关信息可参考新一代开源Android渠道包生成工具Walle。 任务Gradle可以配置各种task，接上面的来讲，可以在生成母包之后直接执行瓦力的渠道替换。比如举个栗子，配置pad版的渠道： 1234567891011121314151617181920212223242526task releasePAD &lt;&lt; &#123; def flavorMap = [ // 官网版本 &quot;maimairen&quot; : &quot;MHP4PDQFZXZRVNSDXK3G&quot;, // 360平台 &quot;_360cn&quot; : &quot;KB3G2X6SKY379YWWBD56&quot;, // 腾讯应用宝 &quot;QQyyb&quot; : &quot;DCRCMBNQDWMV4GDQCTXW&quot;, ] def sourceApk = &quot;./build/outputs/apk/app-pad-release.apk&quot; if (!file(sourceApk).exists()) &#123; throw new RuntimeException(&quot;找不到原始apk,请先执行 assemblePadRelease!!&quot;); &#125; flavorMap.each &#123; def flavor = it.key def flurryKey = it.value exec &#123; executable &quot;bash&quot; args &quot;-c&quot;, &quot;java -jar ./walle-cli-all.jar put -c $flavor -e flurryKey=$flurryKey $sourceApk ./build/outputs/apk/app-$flavor-release.apk&quot; &#125; &#125;&#125; 示例代码","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"博客主题更新","date":"2017-02-16T06:54:43.000Z","path":"2017/02/16/theme-update/","text":"之前一直用的是next主题，后面看到过yilia主题，感觉也不错，便切换到了yilia主题。但是在用的时候有个问题一直让我很不爽：空行的处理让代码上下空出很多行。就像这样： 到主题的issues#339里面也找到了跟我遇到一样问题的朋友。是yilia主题中的一个bug，作者也回复了已经修改，更新后这个bug便没有了。接下来，我就很尴尬了：我当时为了多电脑在同步博客的同时，也删除了主题的git版本管理，导致此时我无法更新主题了,囧。。。 那么该怎么办呢？感觉只能用死办法重新下一次了-.-。首先直接删除主题目录下的yilia文件夹（删除前备份一下，因为yilia中也有_config.yml），然后执行命令： 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载下来后，更新配置文件，然后再删掉yilia文件夹下得.git版本控制文件夹，这样新更新下来的yilia代码就会处于之前设置的整个git仓库的管理下了，分支是source。后面便和之前的操作保持一致就好了~yilia主题的近期更新： 打赏 搜索 “更好的”标签云 “更好的”分享 一些动画 作者出的搜索直接合并了之前的标签。跟进作者的配置，修改yilia的配置： 123456789# slider的设置slider: # 是否默认展开tags板块 showTags: truesmart_menu: innerArchive: &#x27;搜索&#x27; friends: &#x27;友链&#x27; aboutme: &#x27;关于我&#x27; 重新部署后，界面如下： 说明很简单明了了，照着操作一遍后即可。 当执行后仍然如此的话，那就是Node.js的版本与jsonContent不兼容导致，要么升级Node.js版本，要么降低jsonContent版本。 此次更新后，博客整体变得更好看了~ PS：只是以后如果博客主题要更新，就得这样来一次了，着实有点蛋疼&gt;.&lt;。。。","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Android任意View边沿渐变透明","date":"2017-02-16T02:04:39.000Z","path":"2017/02/16/translucent-view/","text":"之前在做直播产品的时候，有个需求：弹幕列表在滑入滑出的时候要有渐变效果。当时想了几种方案但是都没有做到满意的效果，后面便搁置了。直到我看到了这个库：Android任意View边沿渐变透明，看了下效果，正是我当时需要的。虽然时过境迁，现在没有在意这个需求了，但是从心底里还是想知道它是如何实现的。 将代码clone下来后，发现代码其实就一个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class EdgeTransparentView extends FrameLayout &#123; private Paint mPaint; private int position; private float drawSize; private int topMask = 0x01; private int bottomMask = topMask &lt;&lt; 1; private int leftMask = topMask &lt;&lt; 2; private int rightMask = topMask &lt;&lt; 3; private int mWidth; private int mHeight; public EdgeTransparentView(Context context) &#123; this(context, null); &#125; public EdgeTransparentView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public EdgeTransparentView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.FILL); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT)); final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.EdgeTransparentView); position = typedArray.getInt(R.styleable.EdgeTransparentView_edge_position, 0); drawSize = typedArray.getDimension(R.styleable.EdgeTransparentView_edge_width, Utils.d2p(getContext(), 20)); typedArray.recycle(); &#125; @Override protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); initShader(); mWidth = getWidth(); mHeight = getHeight(); &#125; //渐变颜色 private int[] mGradientColors = &#123;0xffffffff, 0x00000000&#125;; //渐变位置 private float[] mGradientPosition = new float[]&#123;0, 1&#125;; private void initShader() &#123; mPaint.setShader(new LinearGradient(0, 0, 0, drawSize, mGradientColors, mGradientPosition, Shader.TileMode.CLAMP)); &#125; @Override protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; int layerSave = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); boolean drawChild = super.drawChild(canvas, child, drawingTime); if (position == 0 || (position &amp; topMask) != 0) &#123; canvas.drawRect(0, 0, mWidth, drawSize, mPaint); &#125; if (position == 0 || (position &amp; bottomMask) != 0) &#123; int save = canvas.save(); canvas.rotate(180, mWidth / 2, mHeight / 2); canvas.drawRect(0, 0, mWidth, drawSize, mPaint); canvas.restoreToCount(save); &#125; int offset = (mHeight - mWidth) / 2; if (position == 0 || (position &amp; leftMask) != 0) &#123; int saveCount = canvas.save(); canvas.rotate(90, mWidth / 2, mHeight / 2); canvas.translate(0, offset); canvas.drawRect(0 - offset, 0, mWidth + offset, drawSize, mPaint); canvas.restoreToCount(saveCount); &#125; if (position == 0 || (position &amp; rightMask) != 0) &#123; int saveCount = canvas.save(); canvas.rotate(270, mWidth / 2, mHeight / 2); canvas.translate(0, offset); canvas.drawRect(0 - offset, 0, mWidth + offset, drawSize, mPaint); canvas.restoreToCount(saveCount); &#125; canvas.restoreToCount(layerSave); return drawChild; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125;&#125; 这里开始一点点分析与学习。 自定义属性： 12345678910111213&lt;resources&gt; &lt;!--边沿透明View--&gt; &lt;declare-styleable name=&quot;EdgeTransparentView&quot;&gt; &lt;attr name=&quot;edge_position&quot;&gt; &lt;flag name=&quot;top&quot; value=&quot;0x01&quot;/&gt; &lt;flag name=&quot;bottom&quot; value=&quot;0x02&quot;/&gt; &lt;flag name=&quot;left&quot; value=&quot;0x04&quot;/&gt; &lt;flag name=&quot;right&quot; value=&quot;0x08&quot;/&gt; &lt;/attr&gt; &lt;attr name=&quot;edge_width&quot; format=&quot;dimension&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 定义了2个属性，一个是要透明的边（上下左右），一个是要透明的宽度。这里利用0x01、0x02十六进制这样的标识，后面再通过“&amp;”操作符来用于标志位的判断真是个不错的idea。 渐变：代码中的渐变是利用给画笔设置shader来实现的。关键代码： 1mPaint.setShader(new LinearGradient(0, 0, 0, drawSize, mGradientColors, mGradientPosition, Shader.TileMode.CLAMP)); 看下LinearGradient的构造函数： 1234567891011121314151617181920212223242526272829/** Create a shader that draws a linear gradient along a line. @param x0 The x-coordinate for the start of the gradient line @param y0 The y-coordinate for the start of the gradient line @param x1 The x-coordinate for the end of the gradient line @param y1 The y-coordinate for the end of the gradient line @param colors The colors to be distributed along the gradient line @param positions May be null. The relative positions [0..1] of each corresponding color in the colors array. If this is null, the the colors are distributed evenly along the gradient line. @param tile The Shader tiling mode*/public LinearGradient(float x0, float y0, float x1, float y1, int colors[], float positions[], TileMode tile) &#123; if (colors.length &lt; 2) &#123; throw new IllegalArgumentException(&quot;needs &gt;= 2 number of colors&quot;); &#125; if (positions != null &amp;&amp; colors.length != positions.length) &#123; throw new IllegalArgumentException(&quot;color and position arrays must be of equal length&quot;); &#125; mType = TYPE_COLORS_AND_POSITIONS; mX0 = x0; mY0 = y0; mX1 = x1; mY1 = y1; mColors = colors; mPositions = positions; mTileMode = tile; init(nativeCreate1(x0, y0, x1, y1, colors, positions, tile.nativeInt));&#125; 可以知道前面4个参数都是设置起始、结束坐标。colors是渐变的颜色：0xffffffff–&gt;0x00000000，tile是shader mode。 123456789101112131415161718192021public enum TileMode &#123; /** * replicate the edge color if the shader draws outside of its * original bounds */ CLAMP (0), /** * repeat the shader&#x27;s image horizontally and vertically */ REPEAT (1), /** * repeat the shader&#x27;s image horizontally and vertically, alternating * mirror images so that adjacent images always seam */ MIRROR (2); TileMode(int nativeInt) &#123; this.nativeInt = nativeInt; &#125; final int nativeInt;&#125; 画：在drawChild中，会优先调用super.drawChild(canvas, child, drawingTime);因为我们的layer要遮罩在子View上，才能有这种效果，所以画layer一定要在其之后执行。根据position的判断，来判断上下左右4条边哪些边需要画layer，通过旋转画布来画不同的边，画完后恢复现场，进行下一个判断。 setXfermode：可能刚开始会没注意到这个方法的调用，但是它的作用不可谓不大。看到核心代码： 1mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT)); 这个便是给画笔设置xfermode，没有这句代码效果可就很不如意咯。这里便要拓展学习一下了，贴一下爱哥的博客。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"我的2016","date":"2017-01-09T05:55:40.000Z","path":"2017/01/09/summary/","text":"对，已经是1月9号了，早在8天前2016年便成为了过去，总觉得必须要写点什么。恰逢今天来了兴致，便随便叨叨几句。 在新的一年里，我们总会兴冲冲的立下我们的小目标（先挣它一个亿~），但是一年里，有多少是你付出的呢？这个世界从来就不存在免费的午餐。 注意看图中的时间。是的，2015年！2015年立下的几个小目标在2016年过完却是一个都没有实现，这可真是个悲伤的故事。但是我们仍然要相信，美好的事情总会发生。 2016年3月14日7点零2分，我的小外甥出生，为我冠上舅舅之名。同天的11点31分，我的小外甥女也出生了，哥哥叫汪乐涵，妹妹叫王语悠。2个小家伙在家人的悉心照顾下，健康快乐的成长着。一眨眼，2个小家伙都快过周岁了，时间过得可真快呢。 2016年3月28日，我开始跑步锻炼，控制饮食。强度并不大，但也坚持了2个月，直到难以忍受深圳6月份的酷暑便没跑了。经过这段时间的锻炼，体重成功减轻10斤，也算是达到我的预期了。计划着天气变凉一点后，便重新开始跑步的。奈何今年深圳的天气，完全不按套路出牌。直接夏天到“冬天”，冷了几天就重新回到夏天。1月份的天气穿个短袖都嫌热，还特么有蚊子！所以，算是给自己找了个借口，下半年相比上半年就比较懈怠了。期间我的目标就是维持体重不再增加。现在每周六都会跑上4、5公里，倒也不至于一点运动量都没有。 也就是天气变热后直到国庆，我有另外一项运动：游泳。在15年的时候便开始学游泳来着，却一直没有学会，16年基本都是保持着每周一次的频率。我一直都很郁闷，因为我之前学一些东西都是功夫下到了，自然就会了，可这游泳却不同，怎么学都学不会，可能真是天性怕水？真是让我卑微到了尘土里。直到9月10日，那天的我突然就掌握了换气的诀窍，那感觉，就好像被打通了任督二脉一样，直接一跃成为大侠。当然至今我也只会最简单的蛙泳，也说不上好，但好歹能换气，能一次性从水道的一端游到另一端。 2016年6月10日，我们计划着去海滩露营，理想很美好，现实很残酷。我们租了一辆GL8从住所自驾开到杨梅坑，老司机说累了不想开，后面由我接手了，于是惊心动魄的2小时旅程开始了。事后，他们一直说车子左摇右晃，吓得他们赶紧系紧了安全带，当然我这个司机是一点感觉都没有的。在到达目的地后突然发现车胎爆掉了，正直下午6点，打公司到租赁公司派人过来修会很麻烦，附近也没有修车厂，所以我们便照着网上的教程，抄着家伙自己修了起来，最后竟真被我们成功换了个备胎上去。扎好帐篷，天就已经黑了，乌漆墨黑什么都看不到，不一会竟然特么的下起雨来了！没错，下雨了！！！我们一群人真是哔了狗了- -。躲在帐篷里，又热又闷，还特么有蚊子，租的帐篷质量本身又堪忧，整整一晚都是被折磨得死去活来，都不知道我们是怎么过来的。我们一群人肯定是闲疯了才这么自找苦吃，恩，一定是的。 2016年9月17日，我去到了桂林龙脊梯田。从没见过梯田这样的景色，初来乍到之时，便深深地被那景色给吸引住了。话不多说，多放点图自身来感受吧。 2016年9月24日，五月天Just rock it！深圳演唱会，蛮早蛮早之前就已经买好了票，终于是等到这一天，只要能听到一曲现场版的《温柔》，此行无憾矣！虽然我没有经历过一份真正的感情，但是当我听到《温柔》还你自由版时，我的心脏便不由自主的跟着它一起跳动，中间的独白，让我为之疯狂。这是我的温柔，还给你的自由~ 希望你也喜欢这首歌。 2016年10月6日，回到孝感参加同学的婚礼，算是大学同学里的第一对新人。祝福他们。 发现到了年龄，很自然的就变成之前很不想变成的样子，同学吃饭聚会，现在是越来越多的谈论到房子，车子，孩子。哎，终归还是老了，不服是不行的。只是害怕会有一天，我变成了自己最不想变成的那个样子。 过了一年我仍然是条单身汪。但是现在相比过去，我看得更加淡了，不管什么样的人生都是人生，重要的是自己过得快乐，现在一般的狗粮我可是不吃的。这个世界还有很多美好的事情，人生辽阔，不要只活在爱恨里。总而言之一切随缘，生死看淡，不服就干。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"iOS 学习之旅","date":"2016-12-16T02:23:53.000Z","path":"2016/12/16/ios-tips/","text":"接触iOS也有一阵子了，也参与到项目做了有些事情，主要是从改bug入手，边学边做，下面记录一下自己在学习中遇到一些点。 CategoryObjective-C提供了一种与众不同的方式——Category，可以动态的为已经存在的类添加新的行为。这样可以保证类的原始设计规模较小，功能增加时再逐步扩展。使用Category对类进行扩展时，不需要访问其源代码，也不需要创建子类。Category使用简单的方式，实现了类的相关方法的模块化，把不同的类方法分配到不同的分类文件中。 1234567891011121314151617181920212223SomeClass.h@interface SomeClass : NSObject&#123;&#125;-(void) print;@end#import &quot;SomeClass.h&quot;@interface SomeClass (Hello)-(void)hello;@end#import &quot;SomeClass+Hello.h&quot;@implementationSomeClass (Hello)-(void)hello&#123; NSLog (@&quot;name：%@ &quot;, @&quot;Jacky&quot;);&#125;@end#import &quot;SomeClass+Hello.h&quot;SomeClass * sc =[[SomeClass alloc] init];[sc hello] 这里还有一个约定成俗的习惯，将声明文件和实现文件名称统一采用“原类名+Category”的方式命名。 ProtocolProtocol，简单来说就是一系列不属于任何类的方法列表，其中声明的方法可以被任何类实现。这种模式一般称为代理（delegation）模式。你通过Protocol定义各种行为，在不同的场景采用不同的实现方式。在iOS和OS X开发中，Apple采用了大量的代理模式来实现MVC中View和Controller的解耦。 1234567891011@protocol ProcessDataDelegate &lt;NSObject&gt;@required- (void) processSuccessful: (BOOL)success;@optional- (id) submitOrder: (NSNumber *) orderid;@end@interface TestAppDelegate : NSObject&lt;ProcessDataDelegate&gt;;@end @required和@optional，表示如果要实现这个协议，那么processSuccessful方法是必须要实现的，submitOrder则是可选的 如果不注明，那么方法默认是@required的，必须实现。用尖括号（&lt;…&gt;）括起来的ProcessDataDelegate就是创建的Protocol。如果要采用多个Protocol，可以在尖括号内引入多个Protocol名称，并用逗号隔开即可。例如&lt;ProcessDataDelegate,xxxDelegate&gt;。Protocol本身是可以继承的。 123456@protocol A -(void)methodA;@end@protocol B &lt;A&gt; -(void)methodB;@end OC中没有方法的重载OC中没有方法的重载！OC中没有方法的重载！OC中没有方法的重载！重要的事情说三遍~遇到个问题一直不能理解，原来就是因为OC没有方法的重载！在Java中，可以根据参数的个数、类型来重载方法，在OC中没有这一说。 123-(return_type) instance_method1; // 无参数-(return_type) instance_method2: (int) p1; // 1个参数-(return_type) instance_method3: (int) p1 andPar: (int) p2; // 2个参数 看到2个参数的例子，在参数前面会有andPar，这个结合instance_method3才构成一个方法。调用的时候： 123[obj instance_method1];[obj instance_method2:p1];[obj instance_method3:p1 andPar:p2]; 数组 NSArray：不可变数组，NSArray保存的对象可以是不同的对象。但只能保存对象，int ,char,double等基本数据类型不能直接保存，需要通过转换成对象才能加入数组。 [array count] : 数组的长度。 [array objectAtIndex 0]: 传入数组脚标的id 得到数据对象。 [arrayWithObjects; …] :向数组对象初始化赋值。这里可以写任意对象的指针,结尾必须使用nil。 NSMutableArray：可变数组，[NSMutableArray arrayWithCapacity:6] :初始化可变数组对象的长度，如果后面代码继续添加数组超过长度6以后NSMutableArray的长度会自动扩充，6是自己可以设置的颗粒度。 [array addObject:…] : 向可变数组尾部添加数据对象。 [array addObjectsFromArray:..] :向可变数组尾部添加一个数组对象。 blockblock，带有自动变量的匿名函数，回调，用^表示。 123456789int b = 0;void (^blo)() = ^&#123; NSLog(@&quot;Input:b=%d&quot;,b);&#125;;b = 3;blo();/** * Input:b=0 */ 虽然在调用blo之前改变了b的值，但是输出的还是Block编译时候b的值，所以截获瞬间自动变量就是：在Block中会保存变量的值，而不会随变量的值的改变而改变。 1234int b = 0;void (^blo)() = ^&#123; b = 3;&#125;; 这段代码编译出错，编译器提示的大概就是不能在Block中改变变量的值。因为在Block中截获了变量的瞬间值以后就不能再改变变量的值，如果想要在Block中改变变量的值，那么只需要在变量声明的时候加上__Block修饰符，像这样： 1234__block int b = 0;void (^blo)() = ^&#123; b = 3;&#125;; 然而这样的情况又是允许的： 1234NSMutableArray *array = [[NSMutableArray alloc]init];void (^blo)() = ^&#123; [array addObject:@&quot;Obj&quot;];&#125;; 为什么呢，因为只是对截获的变量进行了操作，而没有进行赋值，所以对于截获变量，可以进行操作而不可以进行赋值。 self 与 _定义个属性a： 1234@interface Test:NSObject @property int a; -(void) changeAValue:(int) newValue; @end 直接用属性名访问： 123-(void) changeAValue:(int) newValue &#123; _a = newValue; // 默认生成的属性成员变量前面会自动加上“_”前缀 &#125; 通过self.a的形式访问： 123-(void) changeAValue:(int) newValue &#123; self.a = newValue; &#125; 这两种访问方式有区别吗？答案是肯定的。通过第一种方式访问，其实是类似于C++的访问方式，是直接访问的实例变量并赋值。而第二种方式，并不像其表面那么直观，它其实是通过调用编译器自动生成的对于a变量的赋值函数来实现的。即： 123-(void) changeAValue:(int) newValue &#123; self.a = newValue; // 此处实际是调用 [self setA:newValue]; &#125; 类的属性仅在本类中可以访问，子类无法通过_a的形式访问。但是可以通过继承父类的存取方法访问。 resignFirstResponder这个方法是取消第一响应者状态的。如果对textfield使用的话，那么调用这个方法，textfield的第一响应者状态就会取消，然后键盘就消失了。 delegate模式类似于Android中的listener。系统提供各种interface，然后调用interface中的方法，至于具体实现，可以由我们自己定义。Android: 12345678910111213141516editText.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void afterTextChanged(Editable editable) &#123; &#125;&#125;); iOS： 12345@interface YourClass ()&lt;UITextFieldDelegate&gt;UITextField *_mobileTextField;_mobileTextField = [[UITextField alloc]init];_mobileTextField.delegate = self; UITextFieldDelegate就类比于TextWatcher，它内容如下： 12345678910111213141516@protocol UITextFieldDelegate &lt;NSObject&gt;@optional- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField; // return NO to disallow editing.- (void)textFieldDidBeginEditing:(UITextField *)textField; // became first responder- (BOOL)textFieldShouldEndEditing:(UITextField *)textField; // return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end- (void)textFieldDidEndEditing:(UITextField *)textField; // may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called- (void)textFieldDidEndEditing:(UITextField *)textField reason:(UITextFieldDidEndEditingReason)reason NS_AVAILABLE_IOS(10_0); // if implemented, called in place of textFieldDidEndEditing:- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string; // return NO to not change text- (BOOL)textFieldShouldClear:(UITextField *)textField; // called when clear button pressed. return NO to ignore (no notifications)- (BOOL)textFieldShouldReturn:(UITextField *)textField; // called when &#x27;return&#x27; key pressed. return NO to ignore.@end 通过_mobileTextField.delegate &#x3D; self就类似于添加了listener，然后实现相应的方法，就可以做自己的事情了。 权限 This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data. 意思就是没有配置权限，需要在 info.plist 文件添加一个 NSPhotoLibraryUsageDescription的 key，然后添加一个描述。 1234567891011&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;&lt;string&gt;此 App 需要您的同意才能读取媒体资料库&lt;/string&gt;&lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;cameraDesciption&lt;/string&gt;&lt;key&gt;NSContactsUsageDescription&lt;/key&gt; &lt;string&gt;contactsDesciption&lt;/string&gt;&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;microphoneDesciption&lt;/string&gt; dispatch_async线程相关的语法： 1234567dispatch_async(queue, ^&#123; //block具体代码&#125;); //异步执行block，函数立即返回dispatch_sync(queue, ^&#123; //block具体代码&#125;); //同步执行block，函数不返回 实际运用中，一般可以用dispatch这样来写，常见的网络请求数据多线程执行模型： 1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //子线程中开始网络请求数据 //更新数据模型 dispatch_sync(dispatch_get_main_queue(), ^&#123; //在主线程中更新UI代码 &#125;);&#125;); dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); &#x2F;&#x2F;获得程序进程缺省产生的并发队列，可设定优先级来选择高、中、低三个优先级队列。dispatch_get_main_queue(); &#x2F;&#x2F;获得主线程的dispatch队列。 UITextFiled类似Android中的EditText。可以使用leftView、rightView来实现padding效果，以及编辑状态下添加删除按钮。 1234567891011121314151617- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField &#123; _titleTextField.textAlignment = NSTextAlignmentLeft; _titleTextField.width = (self.width -170) / 2 + 170 - 12; UIView *leftEmpty = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 12, 32)]; _titleTextField.leftView = leftEmpty; _titleTextField.leftViewMode = UITextFieldViewModeWhileEditing; UIButton *rightClean = [UIButton buttonWithType:UIButtonTypeCustom]; [rightClean setFrame:CGRectMake(0, 0, 36 , 18)]; [rightClean setImage:[UIImage imageNamed:@&quot;ct_x&quot;] forState:UIControlStateNormal]; [rightClean setTitle:@&quot; &quot; forState:UIControlStateNormal]; rightClean.titleLabel.font = [UIFont systemFontOfSize:15]; [rightClean addTarget:self action:@selector(cleanText) forControlEvents:UIControlEventTouchUpInside]; _titleTextField.rightView = rightClean; _titleTextField.rightViewMode = UITextFieldViewModeWhileEditing; return YES;&#125; 也可以直接使用layer来实现shader： 1234567891011_titleTextField = [[UITextField alloc]initWithFrame:CGRectMake((self.width - 170) / 2, 0, 170, self.height)];_titleTextField.borderStyle = UITextBorderStyleNone;_titleTextField.returnKeyType = UIReturnKeyDone;_titleTextField.backgroundColor = UIColorByHex(0x000000);_titleTextField.layer.cornerRadius = 15;_titleTextField.delegate = self;_titleTextField.textColor = [UIColor whiteColor];_titleTextField.textAlignment = NSTextAlignmentCenter;_titleTextField.placeholder = @&quot;给直播写个标题吧&quot;;_titleTextField.font = [UIFont systemFontOfSize:16];[_titleTextField setValue:UIColorByHex(0xCCCCCC) forKeyPath:@&quot;_placeholderLabel.textColor&quot;]; 拼接字符串12345NSDate * senddate=[NSDate date];NSDateFormatter *dateformatter=[[NSDateFormatter alloc] init];[dateformatter setDateFormat:@&quot;YYYY.MM.dd HH:mm:ss&quot;];NSString * morelocationString=[dateformatter stringFromDate:senddate];_titleTextField.text = [NSString stringWithFormat:@&quot;%@ %@&quot;, [UIDevice currentDevice].name, morelocationString]; 也可以使用NSMutableString。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Xcode的基本使用","date":"2016-12-07T06:36:05.000Z","path":"2016/12/07/xcode/","text":"要开发iOS，Xcode是少不了的，这里摘录一下Xcode的基本使用。 基本导航区：导航作用，可以查看项目总体结构。编辑区：用于编写代码的区域。调试区：用于输出和显示调试信息的区域。实用区：用于显示属性和提供xib类库的区域。工具栏：可以选择运行的设备等。 快捷键 全局查找：command + 3（command + shift + F，可以直接输入关键字进行查找） 查看断点：command + 7 查看文件目录：command + 1 查看下一处：command + G 跳转到指定行：command + L 快速定位当前类在文件中的位置：command + shift + J 上下位移代码：command+option + 【（】） 以调试的形式运行程序：command + Y 搜索类：command + shift + O 清空控制台信息：command + K 模拟器回到Home：command + shift + H 模拟器旋转屏幕：command + 左右箭头 删除光标之前的代码：command + delete 注释代码：command + &#x2F; 到行首（尾）：cmd + 左（右） .m 与.h文件之间切换：command + control + 上&#x2F;下 清除工程：command + shift + K 调试可以和Android studio一样点击左侧栏，设置断点。右键断点，可以弹出断点设置。F6单步调试、F7跳入，F8继续。在调试时，也可以看下面的调试栏进行操作。可以直接拖拽断点到编辑区就能删除断点了，类似QQ的消息数目提示。 代码块管理利用#pragma注释，管理代码块。如下图，可以很清晰知道代码块内的方法。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Objective-C 基本语法","date":"2016-12-07T03:05:24.000Z","path":"2016/12/07/enter-oc/","text":"最近的一段时间都是在学习OC语法，然后看代码，改项目中的bug。OC基本语法是比较固定的，网上的文章都大同小异，这里摘录一下方便后面回顾。 基础Objective-C扩展了ANSI C，是C的超集，也就是说： 任何C源程序，不经修改，即可通过Objective-C编译器成功编译。 Objective-C源程序中可以直接使用任何C语言代码。注意以下几点： OC中头文件后缀为.h，实现文件为.m，类似于c++中的.h于.cpp。 在OC语言中混合使用C或者C++代码，包含有C语言或者C++语言时，文件的后缀使用.mm。同时一般如果是纯粹的C++文件，源代码文件后缀为.cpp，头文件使用.hpp为后缀。 import和include的功能是一样的，都是将引入的文件原封不动拷贝到当前位置。import的优点：会自动防止重复拷贝，同时兼容C语言的引入。 “ ”优先在当前文件路径查找， &lt; &gt;优先在系统环境查找。 字符串相比Java，OC的字符串需要在前面加上“@”符号，否则编译器会理解为c语言中的字符串，导致一些莫名错误。 12NSString title = @&quot;Hello&quot;;if(title == @&quot;hello&quot;) &#123;&#125; 函数调用不带参数： 1[obj method]; 带1个参数： 1[counter increase:1]; 带多个参数： 12- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue &#123;...&#125; //定义方法[myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; //调用方法 类接口和实现Objective-C的类分为接口定义和实现两个部分。接口定义（Interface）放在头文件中，文件扩展名是.h，实现（implementation）放在实现文件中，文件扩展名是.m。 接口定义也可以写在.m文件中，但最好不要这么干。 需要注意的是，与Objective-C的interface概念最接近的是C和C++里的头文件，它与implementation是成双成对出现的，作用是声明类的成员变量和方法。它与Java的interface概念完全不同： Objective-C里，interface有且只有一个实现，Java的interface可以有0-N个实现。 Objective-C里，interface可以定义成员属性，Java里不可以。 在Objective-C里，和Java的Interface概念相似的是Protocol。定义： 123456789@interface MyClass &#123; int memberVar1; id memberVar2;&#125;-(return_type) instance_method1;-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 实现： 1234567891011121314@implementation MyClass &#123; int memberVar3;&#125;-(return_type) instance_method1 &#123; ....&#125;-(return_type) instance_method2: (int) p1 &#123; ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ....&#125;@end 接口和实现以@interface、@implementation开头，都以@end结束。“@”符号在Objective-C中是个很神奇的符号。 方法写在.h头文件里的方法都是公开的，Objective-C里没有私有方法的概念。 类方法：类似于Android的静态方法，是属于类的，不需要实例化对象就可以进行调用，用”+”来表示。定义： 1234567891011@interface MyClass +(void) sayHello;@end@implementation MyClass+(void) sayHello &#123; NSLog(@&quot;Hello, World&quot;);&#125;@end 使用： 1[MyClass sayHello]; 实例方法：这就跟Android中的费静态方法类似，需要实例化对象才能进行调用，用”-“来表示。定义： 1234567891011@interface MyClass : NSObject-(void) sayHello;@end@implementation MyClass-(void) sayHello &#123; NSLog(@&quot;Hello, World&quot;);&#125;@end 使用： 12mycls = [MyClass new];[mycls sayHello]; 属性可以使用@property来声明属性。 123456789#import &lt;Foundation/Foundation.h&gt;@interface Car : NSObject@property(nonatomic,strong) NSString *carName;@property(nonatomic,strong) NSString *carType;- (NSString *)carInfo;@end 它会自动生成getter、setter。当然你也可以复写getter、setter，添加一些额外的功能。它也有一些关键字，具有特殊的作用。 原子性： atomic（默认）：atomic意为操作是原子的，意味着只有一个线程访问实例变量。atomic是线程安全的，至少在当前的存取器上是安全的。它是一个默认的特性，但是很少使用，因为比较影响效率，这跟ARM平台和内部锁机制有关。 nonatomic：nonatomic跟atomic刚好相反。表示非原子的，可以被多个线程访问。它的效率比atomic快。但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。 存取器控制： readwrite（默认）：表示该属性同时拥有setter和getter。 readonly：readonly表示只有getter没有setter。有时候为了语意更明确可能需要自定义访问器的名字：1@property (nonatomic, setter = mySetter:,getter = myGetter ) NSString *name; 内存管理： assign（默认）：assign用于值类型，如int、float、double和NSInteger，CGFloat等表示单纯的复制。还包括不存在所有权关系的对象，比如常见的delegate。 retain：在setter方法中，需要对传入的对象进行引用计数加1的操作。简单来说，就是对传入的对象拥有所有权，只要对该对象拥有所有权，该对象就不会被释放。 strong：strong是在iOS引入ARC的时候引入的关键字，是retain的一个可选的替代。表示实例变量对传入的对象要有所有权关系，即强引用。strong跟retain的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。 weak：在setter方法中，需要对传入的对象不进行引用计数加1的操作。简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用weak声明的实例变量指向nil，即实例变量的值为0。 copy：与strong类似，但区别在于实例变量是对传入对象的副本拥有所有权，而非对象本身。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Hexo多台电脑同步博客","date":"2016-11-29T11:06:25.000Z","path":"2016/11/29/multi-pc/","text":"前言iMac到了之后，这2天一直在熟悉系统，准备记点东西写到博客里，发现需要解决Hexo多台电脑同步的问题，其实蛮早之前就打算弄的，方便自己在家里也能写写博客，但是考虑要带电脑到公司，而且这也确实是与工作无关的事情，只能周末来弄，但是周末是吧，大家懂的，压根不想来呀233333，所以便拖到今天了。 原理先来想想多台电脑同步博客的原理。假设电脑A已经可以正常写博客发布了，这个时候B电脑也想发布博客该如何做呢？我们知道，发不到Github pages上的东西是静态内容，这些是Hexo生成的，这些东西其实不需要我们管，我们只要在hexo d的时候就会帮我们生成然后上传到github。所以我们需要同步的只是源文件。这里的源文件指的就是md文件、theme相关文件、以及博客配置文件等一切跟Hexo无关的文件。 举个栗子，这里看看Hexo目录。我们需要同步的就是suorce、themes、以及_config.yml了，其他都是Hexo生成的。那么接下来便是同步这些文件了。同步的话我们可以在github.io的仓库下建个分支source（也可以建仓库，原理是一样的），然后将这些源文件同步到source分支，当另一台电脑要写博客时，先从该分支pull最新的数据，然后hexo new，当部署完之后将自己新建的源文件push到该分支。而hexo d的时候，根据我们_config.yml中的配置，会推到master分支，2个分支是互不影响的。 1234deploy: type: git repository: https://github.com/LiJia92/LiJia92.github.io.git branch: master 记住一点，每次写博客的时候先pull，完毕的时候push。 A 电脑操作首先，我们要同步themes，就把theme文件夹下面对应的.git删掉，删掉之后便是没有之前的版本控制了，意味着你不能再更新主题了-。-，但是其实一般主题我们再配置后就很少修改它了，所以为了同步主题设置姑且删掉吧。然后在hexo目录下执行下面的命令初始化仓库： 1git init 然后配置.gitignore： 1234/.deploy_git/node_modules/publicdb.json db.json是每次部署的时候会自动生成，会经常变动，导致冲突，所以我们把它忽略。然后添加远程分支，并push： 12345git checkout -b sourcegit add .git commit -m &quot;first commit&quot;git remote add origin https://github.com/LiJia92/LiJia92.github.io.gitgit push origin source 执行完毕后再github.io上便能看到source分支了，这个分支里的内容便是源文件了。 B 电脑操作假设新电脑已经装好Git，Node，Hexo这些环境，那么只需要同步下来source分支的内容即可。 123git initgit remote add origin https://github.com/LiJia92/LiJia92.github.io.gitgit pull origin source # 从source分支拉取内容 建议先将hexo目录下的source、themes等source分支上有的内容删掉，避免冲突。这样B电脑便具备了和A电脑一样的源文件环境了，接下来便可以进行写博客了。 最后每次在写博客的时候，需要执行一次pull操作： 1git pull origin source 写完之后push： 123git add . git commit -m &quot;update new paper&quot;git push origin source 记得带上分支名称source。 Tip 看到一些博客说是要设置github的默认branch，这个设置只是针对采用git clone方式拷贝代码的，如果通过我文中的方法是不需要设置默认branch的。另外，我在B电脑git push的时候出错了：12error: src refspec source does not match any.error: failed to push some refs to &#x27;https://github.com/LiJia92/LiJia92.github.io.git&#x27; 查了一下，是因为我直接本地git init的分支名字叫master，然后要push的分支名为source，不一致导致的。通过下面的指令重命名分支：1git branch -mv master source 再push即可。也可以在init之后就直接checkout branch source。 在我hexo d之后在github看不到我的contributions，Google之，是因为邮箱的问题，切换到iMac之后，邮箱变成了lijia@lijiadeiMac.local，利用git log可以看到相关的记录。这个时候需要将邮箱改成之前绑定的邮箱，然后重新部署就能看到提交记录了。1git config --global user.email 你的邮件地址 hexo d提示Deployer not found:git，执行：1npm install hexo-deployer-git --save 然后重新deploy即可。 参考通过 git 实现多台电脑同步博客Hexo利用Github分支在不同电脑上写博客为什么Github没有记录你的Contributions","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"熟悉OS X系统","date":"2016-11-28T08:01:18.000Z","path":"2016/11/28/OS-X/","text":"等了一个星期，公司配备的iMac总算是到了，今天装上后体验了一下，有很多地方还是很不习惯，后面需要慢慢适应，这里列几点感悟。 FinderFinder便是类似Windows中的文件管理器了吧，只不过OS X不分什么C、D、E、F盘什么的，感觉就是只有简单的几个分类：应用程序、下载、桌面、文稿。同事说有什么东西全部往桌面丢就行了，也不知是真是假。 鼠标打开系统偏好设置，选择鼠标项，会有一些设置，还有一些手势，在你打钩后边能生效，也是类似Mackbook的一些手势，方便做一些操作。 Mission ControlMission Control会提供一个所有已打开的窗口、桌面空间、全屏应用和Split View空间的鸟瞰图，让你能轻松在它们之间进行切换。 触摸角打开系统偏好设置，选择Mission Control项，左下角会有触摸角的设置。当把鼠标移到屏幕的角落的时候可以触发一些操作，4个角可以设置4个操作。 App Store这个就是苹果软件商店了，没什么好说的。需要安装QQ、微信、Xcode等软件直接在里面搜索后购买就行了。购买的时候是需要绑定Apple ID的，这个直接绑定就好了。 终端后续的日常开发肯定离不开终端，例如查看Git版本。按下Command + Space可以出现spotlight搜索，输入terminal回车即可运行终端。 屏幕取词选中单词，按下Command + Control + D即可即时翻译。) 常用快捷键首先了解下符号与按键的对应关系 Command ⌘ Shift ⇧ Option ⌥ Control ⌃ Caps Lock ⇪ Fn 快捷键 描述 Command-X 剪切：删除所选项并将其拷贝到剪贴板。 Command-C 将所选项拷贝到剪贴板。这同样适用于 Finder 中的文件。 Command-V 将剪贴板的内容粘贴到当前文稿或 app 中。这同样适用于 Finder 中的文件。 Command-Z 撤销前一个命令。随后您可以按 Command-Shift-Z 来重做，从而反向执行撤销命令。在某些 app 中，您可以撤销和重做多个命令。 Command-A 全选各项。 Command-F 查找：打开“查找”窗口，或在文稿中查找项目。 Command-G 再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Command-Shift-G。 Command-H 隐藏最前面的 app 的窗口。要查看最前面的 app 但隐藏所有其他 app，请按 Command-Option-H。 Command-M 将最前面的窗口最小化至 Dock。要最小化最前面的 app 的所有窗口，请按 Command-Option-M。 Command-N 新建：打开一个新文稿或窗口。 Command-O 打开所选项，或打开一个对话框以选择要打开的文件。 Command-P 打印当前文稿。 Command-S 存储当前文稿。 Command-W 关闭最前面的窗口。要关闭该 app 的所有窗口，请按 Command-Option-W。 Command-Q 退出 app。 Option-Command-Esc 强制退出：选择要强制退出的 app。或者，按住 Command-Shift-Option-Esc 3 秒钟来仅强制最前面的 app 退出。 Command–空格键 Spotlight：显示或隐藏 Spotlight 搜索栏。要从 Finder 窗口执行 Spotlight 搜索，请按 Command–Option–空格键。如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示 Spotlight。 空格键 快速查看：使用快速查看预览所选项。 Command-Tab 切换 app：在打开的 app 中切换到下一个最近使用的 app。 Shift-Command-波浪号 (~) 切换窗口：切换到最前端应用中下一个最近使用的窗口。 Shift-Command-3 屏幕快照：拍摄整个屏幕的屏幕快照。了解更多屏幕快照快捷键。 Command-逗号 (,) 偏好设置：打开最前面的 app 的偏好设置。 Command-F3 打开桌面 Command-H 隐藏当前 更多快捷键参见官方文档。 最后感觉就是各种手势，各种简单的操作定义复杂的操作，极大的节省时间，而且高逼格，以后我也要走上装逼的道路了！","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android 转 iOS","date":"2016-11-21T09:55:53.000Z","path":"2016/11/21/ios/","text":"过完一个周末来上班，今天被技术负责人约着谈了一下，主题是：让我转iOS开发。 其实在刚刚听到这个消息的时候，内心是窃喜的。因为自国庆以来，做的主要工作是预研性质的，诸如网络连接、音视频、图像处理这些非常专业的领域。也不是说自己不能够学习，主要是这些领域都是需要非常专业的人来做这些事情。通过我自学，预研，然后来做相关的开发，说实话，我自己都觉得不靠谱。所以一直以来，我对自己的工作都不是很不满意，虽然通过查资料，看文章，了解了相关东西的一点点皮毛，但是这些皮毛感觉没啥用，如果你不在这些专业的领域继续深挖进去，可以说我之前1、2月的工作都是做的无用功。当然，稍微拓宽了自己的知识层面这是不可否认的。 虽然是以谈的方式来进行的，但是其实我也没得选择了，只能选择同意。难不成不同意然后等着被辞退吗。目前公司是全力进攻iOS端的项目，Android可能要到后续iOS出到稳定的产品了才能慢慢接入进来，但那都是之后的事情了，基于当下的话必须给我找点事干，所以便让我来做iOS，说是同意的话就马上配电脑，前面一段时间可以自己学习，后面才会安排一些事情，其实这样挺好的。于我接触了点新鲜东西，还能体验体验苹果电脑，于公司花成本来培养我，我后面也可以帮忙现在的iOS同事做些事情，缓解他的压力。 就在前不久，苹果发布新的Mackbook Pro了，主要是配备了Touch Bar和Touch Id，但是价格却是异常的贵。15英寸最低配的都得1万8软妹币。。。我的内心是崩溃的，我是打算出了新款花1万左右买台笔记本来体验一下，结果苹果闹了这么一出。纠结了好久，最后还是决定没有买，代价实在太大了。13英寸虽说便宜些，但是我还是喜欢大屏的，1万8的价格我配台外星人打游戏能打得飞起。我最近在玩梦幻西游，每天下班回家就刷刷神器副本啥的，买Mac也是考虑到梦幻有Mac客户端，但是我室友花了1万8买了台15英寸的回来，打梦幻打了一会就直接红屏了，还好我没买。 现在公司能够配电脑让我去学习，我还能体验体验苹果电脑，这也解决了我之前买Mac的心结，最后也是自愿选的转iOS，后面就是要开始学习iOS的入门开发了，不过天下语言一个样，有了Java基础，再来转相信也是挺容易的。况且，大学的入门语言就是C++呢，虽然后面全忘了，但是花点功夫去学学，相信还是能捡起来的。 加油！ 从今天开始打算在自己的博客加入一些生活杂谈方面的笔录，而不再只作为技术博客。毕竟生活不只是工作、技术，也有其他的乐趣所在嘛。","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://lijia92.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}]},{"title":"Android直播利用Socket传输实时数据","date":"2016-11-16T01:52:34.000Z","path":"2016/11/16/socket/","text":"前言通过前面一段时间的摸索，iOS的Multipeer Connectivity与Android的Wifi-Direct并不兼容，一些三方可能都是需要连接热点才能实现跨平台传输。热点是需要连接到同一个网络环境下的，那么考虑下Socket是否可行呢？理论上，应该是没问题的。为了验证，我这边便开始Android端的测试，至于跨平台就得等到iOS那边一起合作来验证了。 Socket连接这里分一个Client（采集实时数据），一个server（接收数据进行处理）这样的两个角色。在一个局域网下，他们要互相建立连接首先便是要能互相发现。我的方案是：Server监听一个端口，Client发送一个绑定端口的广播（UDP），广播信息包含Client的ip，Server再收到广播之后，利用收到的ip发送一个单播到Client，单播信息包含Server的ip，Client收到之后便知道Server的ip了，那么便可以建立连接了。 获取ip： 12345678910111213141516171819202122232425262728293031private static String getIP(Context application) &#123; WifiManager wifiManager = (WifiManager) application.getSystemService(Context.WIFI_SERVICE); if (!wifiManager.isWifiEnabled()) &#123; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; return inetAddress.getHostAddress(); &#125; &#125; &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); String ip = intToIp(ipAddress); return ip; &#125; return null;&#125;private static String intToIp(int i) &#123; return (i &amp; 0xFF) + &quot;.&quot; + ((i &gt;&gt; 8) &amp; 0xFF) + &quot;.&quot; + ((i &gt;&gt; 16) &amp; 0xFF) + &quot;.&quot; + (i &gt;&gt; 24 &amp; 0xFF);&#125; Server监听端口： 1234567891011121314151617181920212223242526272829public void startListening() &#123; stop = false; mHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; byte[] buf = new byte[1024]; DatagramSocket ds = new DatagramSocket(LISTENING_PORT); DatagramPacket dp = new DatagramPacket(buf, buf.length); String ip = getIP(MyApplication.getApplication()); Log.e(&quot;TAG&quot;, &quot;startListening:&quot; + ip); ds.receive(dp); ds.close(); StringBuffer sb = new StringBuffer(); int i; for (i = 0; i &lt; 1024; i++) &#123; if (buf[i] == 0) &#123; break; &#125; sb.append((char) buf[i]); &#125; sendIpBroadcast(sb.toString()); setupServer(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 上面代码会在ds.receive(dp)阻塞，直到收到消息。Client发送广播： 12345678910111213141516171819public void sendIpBroadcast() &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; final String message = getIP(MyApplication.getApplication()); try &#123; InetAddress adds = InetAddress.getByName(BROADCAST_IP); DatagramSocket ds = new DatagramSocket(); DatagramPacket dp = new DatagramPacket(message.getBytes(), message.length(), adds, LISTENING_PORT); ds.send(dp); ds.close(); startListening(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; Client将自己的ip通过UDP广播发送出来，同时监听一个端口，用于接收Server发出的广播（带Server ip）。Server的ds.receive(dp)执行，获取到Client ip之后，便是发送自身的ip，以及建立ServerSocket。 1234567891011121314151617private void setupServer() &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; mServerSocket = new ServerSocket(SERVER_PORT); while (!stop) &#123; Socket socket = mServerSocket.accept(); socketList.add(socket); new Thread(new MyServerRunnable(socket)).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; mServerSocket.accept()也是个阻塞方法，直到有Client连接进来。Client通过监听收到Server ip，之后便是建立连接了。 123456789101112private void connect(final String serverIp) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; socket = new Socket(serverIp, SERVER_PORT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 通过socket = new Socket(serverIp, SERVER_PORT);即可建立连接了（也是阻塞方法）。 时间对齐对于直播这种实时传递音视频数据的需求，在传递数据的时候都是需要打上时间戳的，用于计算超时。但是在不同手机上的时钟表现是不一样的，所以需要选取一个标准，这里我选用Server的时间。那么Client的时间如何与Server的时间对齐呢？我的方案是：Client发送本身时间到Server，Server在收到请求后回复自身的时间到Client，Client记录下发送请求的时间，与收到回复的时间。记发送请求的时间为C1，收到回复的时间为C2，Server回复的时间为S1。我们假定网络是稳定的，那么便能得到如下结论： (C1 + C2) &#x2F; 2 &#x3D;&#x3D;&gt; S1即Client在（C1 + C2）&#x2F; 2这个时刻，Server的时间是S1. 记后续发请求的时间为C’，记此时Server的时间为S’，那么便会有如下公式： C’ - (C1 + C2) &#x2F; 2 &#x3D; S’ - S1 (Client与Server同时流逝的时间是一致的)&#x3D;&#x3D;&gt; S’ &#x3D; C’ - (C1 + C2)&#x2F;2 + S1 &#x3D;&#x3D;&gt; S’ &#x3D; C’ - C2 + (C2-C1) &#x2F; 2 + S1 如此在Client每次发送实时音视频数据时，便可依据Client此刻的时间计算出Server端的时间，打上时间戳后传递到Server端，Server端收到后可以与Server此刻的时间对比，来进行超时的计算或其他的一些处理。这里姑且理解delta = (C2-C1) / 2为Client传递数据到Server的时间。这个时间越小，对齐得便越精准。所以需要多发送几次请求，然后取最小的delta。另外发送请求的时候包上时间数据，模拟收发的数据量是一致的。 传递H264数据通过我之前的文章，已经可以采集到H264的数据了，格式是byte数组，那么要如何通过Socket传递到Server呢？我之前是利用BufferedWriter的write(String msg)方法，new String(byte[] data)。服务端在收到后通过String.getBytes()还原byte[]，但是将这种数据传递到MediaCodec进行解码，输出不出正确的视频。所以后面干脆就直接利用DataOutputStream传递byte[]数组了。解码代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void initMediaDecode() &#123; Log.e(&quot;TAG&quot;, &quot;initMediaDecode&quot;); MediaFormat format = MediaFormat.createVideoFormat(&quot;video/avc&quot;, 1280, 720); try &#123; decoder = MediaCodec.createDecoderByType(&quot;video/avc&quot;); // 直接输出到surfaceView decoder.configure(format, surfaceView.getHolder().getSurface(), null, 0); decoder.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; new DecodeThread().start();&#125;private class DecodeThread extends Thread &#123; MediaCodec.BufferInfo mBufferInfo; int mCount = 0; public DecodeThread() &#123; mBufferInfo = new MediaCodec.BufferInfo(); &#125; @Override public void run() &#123; while (true) &#123; try &#123; if (h264data.size() &gt; 0) &#123; byte[] data = h264data.get(0); h264data.remove(0); Log.e(&quot;Media&quot;, &quot;save to file data size:&quot; + data.length); // 保存数据到文件 // Util.save(data, 0, data.length, path, true); ByteBuffer[] inputBuffers = decoder.getInputBuffers(); int inputBufferIndex = decoder.dequeueInputBuffer(100); if (inputBufferIndex &gt;= 0) &#123; ByteBuffer inputBuffer = inputBuffers[inputBufferIndex]; inputBuffer.clear(); inputBuffer.put(data); decoder.queueInputBuffer(inputBufferIndex, 0, data.length, mCount * TIME_INTERNAL, 0); &#125; // Get output buffer index int outputBufferIndex = decoder.dequeueOutputBuffer(mBufferInfo, 100); while (outputBufferIndex &gt;= 0) &#123; Log.e(&quot;Media&quot;, &quot;onFrame index:&quot; + outputBufferIndex); decoder.releaseOutputBuffer(outputBufferIndex, true); outputBufferIndex = decoder.dequeueOutputBuffer(mBufferInfo, 0); &#125; &#125; else &#123; sleep(TIME_INTERNAL); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 通过此种解码，发现解码的视频花屏，但是存入到文件中再打开则是比较清晰流畅的，估计是解码有问题。 Demo代码","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android-iOS 跨平台传输方案调研","date":"2016-10-28T08:21:48.000Z","path":"2016/10/28/cross-platform/","text":"现状 iOS：在iOS7中，引入了一个全新的框架——Multipeer Connectivity（多点连接）。利用Multipeer Connectivity框架，即使在没有连接到WiFi（WLAN）或移动网络（xG）的情况下，距离较近的Apple设备（iMac&#x2F;iPad&#x2F;iPhone）之间可基于蓝牙和WiFi（P2P WiFi）技术进行发现和连接实现近场通信。 Android：Wi-Fi peer-to-peer（P2P，对等网络），它允许具备相应硬件的Android 4.0（API level 14）或者更高版本的设备可以直接通过wifi而不需要其它中间中转节点就能直接通信（Android的Wi-Fi P2P框架符合Wi-Fi联盟的Wi-Fi Direct™直连认证标志）。使用这些API，你可以搜索并连接其它同样支持Wi-Fi P2P的设备，然后再通过一个高速的连接进行互相通信，并且这个连接的有效距离要比蓝牙连接的有效距离要长的多。这对于需要在用户之间共享数据的应用程序非常有用，例如多玩家游戏或者照片分享之类应用。 但是iOS的MC框架与Android的Wifi Direct不兼容，通过苹果开发者论坛iOS and Wi-Fi Direct了解：关于不同技术在iOS、Android上的兼容性，如下图： 蓝牙 经典蓝牙阶段：在蓝牙4.0（Bluetooth Low Energy）之前，也就是所谓的经典蓝牙，苹果的蓝牙拒绝接入不信任的设备。也就是说，没得连。 蓝牙4.0阶段：从ios6.0开始，iPhone支持BLe以后，问题得到了改善，因为在蓝牙4.0以后不再存在经典蓝牙的那个限制。ios7.0以后，BLe在 iOS 7 技术性提升里占到的重要位置。但是Android在这方面的脚步就慢很多了。 Android4.3：SDK从4.3以后开始正式在官方层面支持蓝牙4.0，可以使用安卓设备建立主机。注意，这里是说可以建立主机，也就是只能是安卓建立主机，iOS设备连接才可以。安卓无法去连接iOS的主机。 Android L：也就是Android 5.0，从这个版本开始，谷歌正式支持主从机的建立。 Android与IOS之间如何实现蓝牙通信数据传输？ 现有产品 快牙 快牙（ZAPYA），是一款全球首创、实现跨平台文件传输的应用，能帮助智能手机用户之间实现高速海量数据传输。支持安卓（Android）、苹果（iOS）、WP、PC等多种智能终端间的互联互通。通过快牙，可以和任何人分享应用、照片、视频、音乐及其他任意格式文件。目前快牙全球用户数量已超3亿，遍及海内外178个国家和地区，在同类型的传输应用中稳居第一。 茄子快传 茄子快传是北京众联极享科技有限公司推出的一款跨平台、多场景的移动数字互动平台（手机内容传输工具）。通过设备间建立的数据传输通路，茄子快传实现了在没有外部WiFi网络或者数据网络的情况下的数据高速收发，过程中无需消耗数据流量。用户操作简单，没有复杂的配对配置，无需登录账户、添加好友，支持多人互传，让用户摆脱数据线、蓝牙等复杂的分享方式，用一种简单、直观的交互让用户体验到近距离线下社交中与人分享的快乐。 通过以上2款产品，可以实现跨平台数据传输。 我利用2台Android手机测试，都是需要创建热点进行传输。Android与iOS测试，也是需要开启热点的，并且在iOS下需要手动链接到对应的热点。 第三方 AllJoyn AllJoyn，由高通公司主导的高通创新中心（Qualcomm Innovation Center）所开发的开放源代码专案，主要用于近距离无线传输，透过Wifi或蓝牙技术，进行定位与点对点档案传输。 FireChat FireChat，是一个专门用于手机的APP，由开放花园公司开发。它能使智能手机在没有网络存取时，经由无线网状网络的蓝牙、Wi-Fi，或苹果公司的多点连线（Multipeer Connectivity）对等网络架构连线。 Underdark Mobile peer-to-peer mesh networking library.Integrates into iOS and Android apps and works over Wi-Fi and Bluetooth. 目前只是知道这些三方库，至于其内部的实现原理还不了解，但应该是结合Wi-Fi与蓝牙来实现的。 小结通过目前已有的技术（不做多余的工作），应该是做不到跨平台传输的。但是如果自己通过开发Wi-Fi以及蓝牙，应该是可以实现跨平台传输的。至于开发的难点以及技术点，我也不清楚。 其他参考The Sorry State of Peer to Peer iOS to Android connectivityPeer to peer android and iOS with Wifi direct (multipeer connectivity?)Is iOS 7 Multipeer Connectivity compatible with Android Wi-Fi Direct?9 of the best apps for sharing files between devices and friends","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"【Android音视频开发】- 实时采集音频并编码","date":"2016-10-22T01:54:26.000Z","path":"2016/10/22/live-audio/","text":"前言通过我的上一篇文章，利用Camera实时采集视频，并用MediaCodec编码，可以得到YUV、H264文件了。那么接下来便是采集音频并编码了。 基础概念在音频开发中，有一些基础的概念是必须要知道的。 采样率（samplerate）采样就是把模拟信号数字化的过程，不仅仅是音频需要采样，所有的模拟信号都需要通过采样转换为可以用0101来表示的数字信号，示意图如下所示：蓝色代表模拟音频信号，红色的点代表采样得到的量化数值。采样频率越高，红色的间隔就越密集，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音。通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。 量化精度（位宽）上图中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。常见的位宽是：8bit 或者 16bit。 声道数（channels）由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。单声道（Mono）和双声道（Stereo）比较常见，顾名思义，前者的声道数为1，后者为2。 音频帧（frame）音频数据是流式的，本身并没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理&#x2F;传输的方便，一般约定俗成取 2.5 ms ~ 60 ms为单位的数据量为一帧音频。 这个时间被称之为“采样时间”，其长度没有特别的标准。我们可以计算一下一帧音频帧的大小。假设某通道的音频信号是采样率为 8 kHz，位宽为16 bit，20 ms 一帧，双通道，则一帧音频数据的大小为： 1int size = 8000 x 16bit x 0.02s x 2 = 5120 bit = 640 byte 采集 Android SDK 提供了两套音频采集的API，分别是：MediaRecorder 和 AudioRecord，前者是一个更加上层一点的API，它可以直接把手机麦克风录入的音频数据进行编码压缩（如AMR、MP3等）并存成文件，而后者则更接近底层，能够更加自由灵活地控制，可以得到原始的一帧帧PCM音频数据。如果想简单地做一个录音机，录制成音频文件，则推荐使用 MediaRecorder，而如果需要对音频做进一步的算法处理、或者采用第三方的编码库进行压缩、以及网络传输等应用，则建议使用 AudioRecord，其实 MediaRecorder 底层也是调用了 AudioRecord 与 Android Framework 层的 AudioFlinger 进行交互的。 由上可知，在直播中实时采集音频自然是要用AudioRecord了。 编码通过AudioRecord我们可以获取到原始的PCM数据了，接下来就是利用MediaCodec来进行编码成AAC数据了。 示例代码变量声明： 123456private static final int DEFAULT_SOURCE = MediaRecorder.AudioSource.MIC; // 麦克风private static final int DEFAULT_SAMPLE_RATE = 44100; // 44.1KHz采样率private static final int DEFAULT_CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_STEREO; // 立体声private static final int DEFAULT_AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT; // 16位宽private static final int DEFAULT_BIT_RATE = 32000; // 比特率private static final String AAC_MIME = &quot;audio/mp4a-latm&quot;; // AAC编码 初始化AudioRecord： 12345678910111213141516171819202122232425/** * 初始化AudioRecord * * @return */private boolean initAudioRecord() &#123; if (mIsCaptureStarted) &#123; Log.e(TAG, &quot;Capture already started !&quot;); return false; &#125; mMinBufferSize = AudioRecord.getMinBufferSize(DEFAULT_SAMPLE_RATE, DEFAULT_CHANNEL_CONFIG, DEFAULT_AUDIO_FORMAT); if (mMinBufferSize == AudioRecord.ERROR_BAD_VALUE) &#123; Log.e(TAG, &quot;Invalid parameter !&quot;); return false; &#125; Log.d(TAG, &quot;getMinBufferSize = &quot; + mMinBufferSize + &quot; bytes !&quot;); mAudioRecord = new AudioRecord(DEFAULT_SOURCE, DEFAULT_SAMPLE_RATE, DEFAULT_CHANNEL_CONFIG, DEFAULT_AUDIO_FORMAT, mMinBufferSize); if (mAudioRecord.getState() == AudioRecord.STATE_UNINITIALIZED) &#123; Log.e(TAG, &quot;AudioRecord initialize fail !&quot;); return false; &#125; return true;&#125; 初始化MediaCodec： 1234567891011121314151617181920/** * 初始化MediaCodec */private void initMediaCodec() &#123; try &#123; mMediaCodec = MediaCodec.createEncoderByType(AAC_MIME); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; MediaFormat format = new MediaFormat(); format.setString(MediaFormat.KEY_MIME, AAC_MIME); format.setInteger(MediaFormat.KEY_BIT_RATE, DEFAULT_BIT_RATE); format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 2); format.setInteger(MediaFormat.KEY_SAMPLE_RATE, DEFAULT_SAMPLE_RATE); format.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC); format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, mMinBufferSize * 2); mMediaCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mAudioRecord.startRecording(); mMediaCodec.start();&#125; 调用mAudioRecord.startRecording()开始采集，并启动线程从AudioRecord获取数据，最后调用mAudioRecord.stop();停止采集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private class AudioCaptureRunnable implements Runnable &#123; @Override public void run() &#123; while (!mIsLoopExit) &#123; byte[] buffer = new byte[mMinBufferSize]; int ret = mAudioRecord.read(buffer, 0, mMinBufferSize); if (ret == AudioRecord.ERROR_INVALID_OPERATION) &#123; Log.e(TAG, &quot;Error ERROR_INVALID_OPERATION&quot;); &#125; else if (ret == AudioRecord.ERROR_BAD_VALUE) &#123; Log.e(TAG, &quot;Error ERROR_BAD_VALUE&quot;); &#125; else &#123; Log.d(TAG, &quot;OK, Captured &quot; + ret + &quot; bytes !&quot;); Util.save(buffer, 0, buffer.length, pcmPath, true); ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers(); ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers(); int inputBufferIndex = mMediaCodec.dequeueInputBuffer(-1); if (inputBufferIndex &gt;= 0) &#123; ByteBuffer inputBuffer = inputBuffers[inputBufferIndex]; inputBuffer.clear(); inputBuffer.put(buffer); mMediaCodec.queueInputBuffer(inputBufferIndex, 0, buffer.length, System.nanoTime(), 0); &#125; MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); while (outputBufferIndex &gt;= 0) &#123; ByteBuffer outputBuffer = outputBuffers[outputBufferIndex]; outputBuffer.position(bufferInfo.offset); outputBuffer.limit(bufferInfo.offset + bufferInfo.size); byte[] outData = new byte[bufferInfo.size + 7]; addADTStoPacket(outData, bufferInfo.size + 7); outputBuffer.get(outData, 7, bufferInfo.size); outputBuffer.position(bufferInfo.offset); Util.save(outData, 0, outData.length, aacPath, true); mMediaCodec.releaseOutputBuffer(outputBufferIndex, false); outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); &#125; &#125; &#125; &#125;&#125; 核心代码便是这些了，运行程序后最后会生成PCM、AAC文件，将AAC文件用VLC打开也是可以播放的。 工程代码示例 ADTS可以看到上述代码中有addADTStoPacket这个方法： 12345678910111213141516171819202122/** * Add ADTS header at the beginning of each and every AAC packet. * This is needed as MediaCodec encoder generates a packet of raw * AAC data. * &lt;p&gt; * Note the packetLen must count in the ADTS header itself. **/private void addADTStoPacket(byte[] packet, int packetLen) &#123; int profile = 2; //AAC LC //39=MediaCodecInfo.CodecProfileLevel.AACObjectELD; int freqIdx = 4; //44.1KHz int chanCfg = 2; //CPE // fill in ADTS data packet[0] = (byte) 0xFF; packet[1] = (byte) 0xF9; packet[2] = (byte) (((profile - 1) &lt;&lt; 6) + (freqIdx &lt;&lt; 2) + (chanCfg &gt;&gt; 2)); packet[3] = (byte) (((chanCfg &amp; 3) &lt;&lt; 6) + (packetLen &gt;&gt; 11)); packet[4] = (byte) ((packetLen &amp; 0x7FF) &gt;&gt; 3); packet[5] = (byte) (((packetLen &amp; 7) &lt;&lt; 5) + 0x1F); packet[6] = (byte) 0xFC;&#125; ADTS头中相对有用的信息 采样率、声道数、帧长度。想想也是，我要是解码器的话，你给我一堆得AAC音频ES流我也解不出来。每一个带ADTS头信息的AAC流会清晰的告送解码器他需要的这些信息。更多信息请参见参考。 参考Android音频开发（1）：基础知识Android音频开发（2）：如何采集一帧音频Android音频开发之AudioRecord录音实现多媒体封装格式详解— AAC ADTS格式分析How to generate the AAC ADTS elementary stream with Android MediaCodec","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"【Android音视频开发】- 实时采集视频并编码","date":"2016-10-20T06:54:45.000Z","path":"2016/10/20/live-code-video/","text":"前言通过我的上一篇文章，实时采集视频的LocalSocket方式在新的Android SDK上是跑不通的，那么便只剩下Camera了。本文将利用Camera来进行实时采集视频，MediaCodec进行硬编码来输出yuv、h264文件。 YUV通过Camera采集到的原始数据是YUV（NV21）格式的，何为YUV？ YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。YUV是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。 YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0。 YUV 4:4:4采样，每一个Y对应一组UV分量。 YUV 4:2:2采样，每两个Y共用一组UV分量。 YUV 4:2:0采样，每四个Y共用一组UV分量。 这里只抛出这样一个概念，详情请参见文末的参考。 H264H264作为当前最火热的编码方式，它有着特殊的分层结构。 H.264 的功能分为两层：视频编码层(VCL, Video Coding Layer)和网络提取层(NAL, Network Abstraction Layer)。VCL 数据即编码处理的输出，它表示被压缩编码后的视频数据 序列。在 VCL 数据传输或存储之前,这些编码的 VCL 数据，先被映射或封装进 NAL 单元中。每个 NAL 单元包括一个原始字节序列负荷(RBSP, Raw Byte Sequence Payload)、一组对应于视频编码的 NAL 头信息。RBSP 的基本结构是：在原始编码数据的后面填加了结尾比特。一个bit“1”若干比特“0”，以便字节对齐。 在H264中，无论是SPS、PPS或者是slice data，都是由一个NAL unit所组成。NALU头结构：NALU类型(5bit)、重要性指示位(2bit)、禁止位(1bit)。 NALU类型：1～12由H.264使用，24～31由H.264以外的应用使用。 重要性指示：标志该NAL单元用于重建时的重要性，值越大，越重要。 禁止位：网络发现NAL单元有比特错误时可设置该比特为1，以便接收方丢掉该单元。 这里依然是抛出这样一个概念，详情请参见文末的参考。（因为我自己也没怎么弄懂，哈哈哈~） 实例下面直接结合Camera与MediaCodec来实现视频采集与编码，并且输出yuv、h264文件。初始化MediaCodec: 12345678910111213141516171819202122232425private void initMediaCodec() &#123; int degree = getDegree(); framerate = 15; bitrate = 2 * width * height * framerate / 20; EncoderDebugger debugger = EncoderDebugger.debug(getApplicationContext(), width, height); mConvertor = debugger.getNV21Convertor(); try &#123; mMediaCodec = MediaCodec.createByCodecName(debugger.getEncoderName()); MediaFormat mediaFormat; if (degree == 0) &#123; mediaFormat = MediaFormat.createVideoFormat(&quot;video/avc&quot;, height, width); &#125; else &#123; mediaFormat = MediaFormat.createVideoFormat(&quot;video/avc&quot;, width, height); &#125; mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, framerate); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, debugger.getEncoderColorFormat()); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mMediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mMediaCodec.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 获取Camera： 12345678910111213141516171819202122232425262728293031private boolean createCamera(SurfaceHolder surfaceHolder) &#123; try &#123; mCamera = Camera.open(mCameraId); Camera.Parameters parameters = mCamera.getParameters(); int[] max = determineMaximumSupportedFrameRate(parameters); Camera.CameraInfo camInfo = new Camera.CameraInfo(); Camera.getCameraInfo(mCameraId, camInfo); int cameraRotationOffset = camInfo.orientation; int rotate = (360 + cameraRotationOffset - getDegree()) % 360; parameters.setRotation(rotate); parameters.setPreviewFormat(ImageFormat.NV21); parameters.setPreviewSize(width, height); parameters.setPreviewFpsRange(max[0], max[1]); mCamera.setParameters(parameters); mCamera.autoFocus(null); int displayRotation; displayRotation = (cameraRotationOffset - getDegree() + 360) % 360; mCamera.setDisplayOrientation(displayRotation); mCamera.setPreviewDisplay(surfaceHolder); return true; &#125; catch (Exception e) &#123; StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); String stack = sw.toString(); Toast.makeText(this, stack, Toast.LENGTH_LONG).show(); destroyCamera(); e.printStackTrace(); return false; &#125;&#125; 采集并编码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Camera.PreviewCallback previewCallback = new Camera.PreviewCallback() &#123; byte[] mPpsSps = new byte[0]; @Override public void onPreviewFrame(byte[] data, Camera camera) &#123; // data即是NV21的数据 if (data == null) &#123; return; &#125; ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers(); ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers(); byte[] dst; Camera.Size previewSize = mCamera.getParameters().getPreviewSize(); if (getDegree() == 0) &#123; dst = Util.rotateNV21Degree90(data, previewSize.width, previewSize.height); &#125; else &#123; dst = data; &#125; Util.save(data, 0, data.length, yuvPath, true); try &#123; int bufferIndex = mMediaCodec.dequeueInputBuffer(5000000); if (bufferIndex &gt;= 0) &#123; inputBuffers[bufferIndex].clear(); mConvertor.convert(dst, inputBuffers[bufferIndex]); mMediaCodec.queueInputBuffer(bufferIndex, 0, inputBuffers[bufferIndex].position(), System.nanoTime() / 1000, 0); MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); while (outputBufferIndex &gt;= 0) &#123; ByteBuffer outputBuffer = outputBuffers[outputBufferIndex]; byte[] outData = new byte[bufferInfo.size]; outputBuffer.get(outData); //记录pps和sps if (outData[0] == 0 &amp;&amp; outData[1] == 0 &amp;&amp; outData[2] == 0 &amp;&amp; outData[3] == 1 &amp;&amp; outData[4] == 103) &#123; mPpsSps = outData; &#125; else if (outData[0] == 0 &amp;&amp; outData[1] == 0 &amp;&amp; outData[2] == 0 &amp;&amp; outData[3] == 1 &amp;&amp; outData[4] == 101) &#123; //在关键帧前面加上pps和sps数据 byte[] frameData = new byte[mPpsSps.length + outData.length]; System.arraycopy(mPpsSps, 0, frameData, 0, mPpsSps.length); System.arraycopy(outData, 0, frameData, mPpsSps.length, outData.length); outData = frameData; &#125; Util.save(outData, 0, outData.length, path, true); mMediaCodec.releaseOutputBuffer(outputBufferIndex, false); outputBufferIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, 0); &#125; &#125; else &#123; Log.e(&quot;easypusher&quot;, &quot;No buffer available !&quot;); &#125; &#125; catch (Exception e) &#123; StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); String stack = sw.toString(); Log.e(&quot;save_log&quot;, stack); e.printStackTrace(); &#125; finally &#123; mCamera.addCallbackBuffer(dst); &#125; &#125;&#125;; 获取摄像头支持的分辨率代码： 123456789public static void determineClosestSupportedResolution(Camera.Parameters parameters) &#123; String supportedSizesStr = &quot;Supported resolutions: &quot;; List&lt;Camera.Size&gt; supportedSizes = parameters.getSupportedPreviewSizes(); for (Iterator&lt;Camera.Size&gt; it = supportedSizes.iterator(); it.hasNext(); ) &#123; Camera.Size size = it.next(); supportedSizesStr += size.width + &quot;x&quot; + size.height + (it.hasNext() ? &quot;, &quot; : &quot;&quot;); &#125; Log.e(&quot;TAG&quot;, supportedSizesStr);&#125; 后面运行，点击开始进行录制，再次点击结束录制，会在sdcard上生成2个文件test_1280x720.yuv、test_1280x720.h264。下载工具后进行查看文件便能看到录制的视频了。YUV工具我是用的雷神改作的一个：修改了一个YUV&#x2F;RGB播放器。H264工具则是用的VLC。 工程代码示例 Tip：Camera采集默认是横屏，所以竖屏采集输出的图像需要旋转90度，解决方法参见参考即demo中的代码。 参考Camera的简单使用浅析Android Camera原始帧格式转换 —— 获取Camera图像（一）直播必备之YUV使用总结 —— Android常用的几种格式：NV21&#x2F;NV12&#x2F;YV12&#x2F;YUV420P的区别CameraMediaCodecVideo Rendering with 8-Bit YUV FormatsYUV420SP图像的旋转图文详解YUV420数据格式Android 实时视频采集—Cameara预览采集H.264中如何判斷某一段是否為SPS(Sequence Parameter Set)或PPS(Picture Parameter Set)EasyPusher安卓Android手机直播推送之MediaCodec 硬编码H264格式Android屏幕直播方案","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"【Android音视频开发】- 实时采集视频","date":"2016-10-20T02:24:19.000Z","path":"2016/10/20/live-capture-video/","text":"前言通过我的上一篇文章，可以知道直播大致有几个步骤：音视频采集 -&gt; 美颜&#x2F;滤镜&#x2F;特效处理 -&gt; 编码 -&gt; 封包 -&gt; 推流 -&gt; 分发 -&gt; 解码&#x2F;渲染&#x2F;播放。那么首先便从采集开始，这里我先做的视频采集。那么实时采集视频有哪些方案呢？ 调研通过各种调研，查阅文章，了解到目前Android实时采集视频大致有3种方式： 通过Android Camera拍摄预览中设置setPreviewCallback实现onPreviewFrame接口，实时截取每一帧视频流数据 通过通过Android的MediaRecorder，在SetoutputFile函数中绑定LocalSocket实现 流媒体服务器方式，利用ffmpeg或GetStreamer等获取Camera视频 通过学习，大致了解了1，2两种方式的实现方式，但是对于第3种方式，暂时没有研究。 spydroid当我们在接触一个全新领域的时候，最希望的是能实实在在看到一个demo产品，通过demo产品我们更容易理解其内在的原理。在网上看到了许多的开源项目，最后选择了spydroid，感觉它跟Android结合更紧密。更多的信息可以参考Android视频采集方案总结。 拷贝工程通过github看到的项目是Eclipse结构，这里我把代码拷贝下来后，通过AS打开，配置一些信息后项目结构如下： streaming是作者封装的一套库。 A solution for streaming H.264, H.263, AMR, AAC using RTP on Android 运行项目拷贝到AS后，有部分错误，修复后成功运行在MI 4LTE。它可以通过http，也可以通过rtsp进行推流，打开rtsp推流的开关，首页会多了一个VLC的地址。我在Win 10上使用Chrome接收失败，打开网站后Connect一直连不上。所以采取的VLC方式。打开VLC输入首页提示的地址，即可看到推流成功了。demo跑通后，便有了一个直观的感受，接下来便是看代码了。 代码从SpydroidActivity开始，会看到它连接了一个Service： 12345678910111213private ServiceConnection mRtspServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mRtspServer = (CustomRtspServer) ((RtspServer.LocalBinder)service).getService(); mRtspServer.addCallbackListener(mRtspCallbackListener); mRtspServer.start(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123;&#125;&#125;; 看到RtspServer中的start方法： 1234567891011public void start() &#123; if (!mEnabled || mRestart) stop(); if (mEnabled &amp;&amp; mListenerThread == null) &#123; try &#123; mListenerThread = new RequestListener(); &#125; catch (Exception e) &#123; mListenerThread = null; &#125; &#125; mRestart = false;&#125; 再看到RequestListener： 12345678910111213141516171819202122232425262728293031323334353637383940class RequestListener extends Thread implements Runnable &#123; private final ServerSocket mServer; public RequestListener() throws IOException &#123; try &#123; mServer = new ServerSocket(mPort); start(); &#125; catch (BindException e) &#123; Log.e(TAG,&quot;Port already in use !&quot;); postError(e, ERROR_BIND_FAILED); throw e; &#125; &#125; public void run() &#123; Log.i(TAG,&quot;RTSP server listening on port &quot;+mServer.getLocalPort()); while (!Thread.interrupted()) &#123; try &#123; new WorkerThread(mServer.accept()).start(); &#125; catch (SocketException e) &#123; break; &#125; catch (IOException e) &#123; Log.e(TAG,e.getMessage()); continue; &#125; &#125; Log.i(TAG,&quot;RTSP server stopped !&quot;); &#125; public void kill() &#123; try &#123; mServer.close(); &#125; catch (IOException e) &#123;&#125; try &#123; this.join(); &#125; catch (InterruptedException ignore) &#123;&#125; &#125;&#125; 这是一个进程类，在构造方法中直接调用了Thread.start()，那么便会执行到run()方法。可以看到，初始化了一个ServerSocket，然后当有客户端连接后（通过VLC输入地址开始播放即是连接到这个ServerSocket），便会执行WorkerThread线程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253class WorkerThread extends Thread implements Runnable &#123; private final Socket mClient; private final OutputStream mOutput; private final BufferedReader mInput; // Each client has an associated session private Session mSession; public WorkerThread(final Socket client) throws IOException &#123; mInput = new BufferedReader(new InputStreamReader(client.getInputStream())); mOutput = client.getOutputStream(); mClient = client; mSession = new Session(); &#125; public void run() &#123; Request request; Response response; Log.i(TAG, &quot;Connection from &quot;+mClient.getInetAddress().getHostAddress()); while (!Thread.interrupted()) &#123; request = null; response = null; // Parse the request try &#123; request = Request.parseRequest(mInput); &#125; catch (SocketException e) &#123; // Client has left break; &#125; catch (Exception e) &#123; // We don&#x27;t understand the request :/ response = new Response(); response.status = Response.STATUS_BAD_REQUEST; &#125; // Do something accordingly like starting the streams, sending a session description if (request != null) &#123; try &#123; response = processRequest(request); &#125; catch (Exception e) &#123; // This alerts the main thread that something has gone wrong in this thread postError(e, ERROR_START_FAILED); Log.e(TAG,e.getMessage()!=null?e.getMessage():&quot;An error occurred&quot;); e.printStackTrace(); response = new Response(request); &#125; &#125; // We always send a response // The client will receive an &quot;INTERNAL SERVER ERROR&quot; if an exception has been thrown at some point try &#123; response.send(mOutput); &#125; catch (IOException e) &#123; Log.e(TAG,&quot;Response was not sent properly&quot;); break; &#125; &#125; // Streaming stops when client disconnects boolean streaming = isStreaming(); mSession.syncStop(); if (streaming &amp;&amp; !isStreaming()) &#123; postMessage(MESSAGE_STREAMING_STOPPED); &#125; mSession.release(); try &#123; mClient.close(); &#125; catch (IOException ignore) &#123;&#125; Log.i(TAG, &quot;Client disconnected&quot;); &#125; public Response processRequest(Request request) throws IllegalStateException, IOException &#123; Response response = new Response(request); //Ask for authorization unless this is an OPTIONS request if(!isAuthorized(request) &amp;&amp; !request.method.equalsIgnoreCase(&quot;OPTIONS&quot;)) &#123; response.attributes = &quot;WWW-Authenticate: Basic realm=\\&quot;&quot;+SERVER_NAME+&quot;\\&quot;\\r\\n&quot;; response.status = Response.STATUS_UNAUTHORIZED; &#125; else &#123; /* ********************************************************************************** */ /* ********************************* Method DESCRIBE ******************************** */ /* ********************************************************************************** */ if (request.method.equalsIgnoreCase(&quot;DESCRIBE&quot;)) &#123; // Parse the requested URI and configure the session mSession = handleRequest(request.uri, mClient); mSessions.put(mSession, null); mSession.syncConfigure(); String requestContent = mSession.getSessionDescription(); String requestAttributes = &quot;Content-Base: &quot; + mClient.getLocalAddress().getHostAddress() + &quot;:&quot; + mClient.getLocalPort() + &quot;/\\r\\n&quot; + &quot;Content-Type: application/sdp\\r\\n&quot;; response.attributes = requestAttributes; response.content = requestContent; // If no exception has been thrown, we reply with OK response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************* Method OPTIONS ********************************* */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(&quot;OPTIONS&quot;)) &#123; response.status = Response.STATUS_OK; response.attributes = &quot;Public: DESCRIBE,SETUP,TEARDOWN,PLAY,PAUSE\\r\\n&quot;; response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************** Method SETUP ********************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(&quot;SETUP&quot;)) &#123; Pattern p; Matcher m; int p2, p1, ssrc, trackId, src[]; String destination; p = Pattern.compile(&quot;trackID=(\\\\w+)&quot;, Pattern.CASE_INSENSITIVE); m = p.matcher(request.uri); if (!m.find()) &#123; response.status = Response.STATUS_BAD_REQUEST; return response; &#125; trackId = Integer.parseInt(m.group(1)); if (!mSession.trackExists(trackId)) &#123; response.status = Response.STATUS_NOT_FOUND; return response; &#125; p = Pattern.compile(&quot;client_port=(\\\\d+)-(\\\\d+)&quot;, Pattern.CASE_INSENSITIVE); m = p.matcher(request.headers.get(&quot;transport&quot;)); if (!m.find()) &#123; int[] ports = mSession.getTrack(trackId).getDestinationPorts(); p1 = ports[0]; p2 = ports[1]; &#125; else &#123; p1 = Integer.parseInt(m.group(1)); p2 = Integer.parseInt(m.group(2)); &#125; ssrc = mSession.getTrack(trackId).getSSRC(); src = mSession.getTrack(trackId).getLocalPorts(); destination = mSession.getDestination(); mSession.getTrack(trackId).setDestinationPorts(p1, p2); boolean streaming = isStreaming(); mSession.syncStart(trackId); if (!streaming &amp;&amp; isStreaming()) &#123; postMessage(MESSAGE_STREAMING_STARTED); &#125; response.attributes = &quot;Transport: RTP/AVP/UDP;&quot; + (InetAddress.getByName(destination).isMulticastAddress() ? &quot;multicast&quot; : &quot;unicast&quot;) + &quot;;destination=&quot; + mSession.getDestination() + &quot;;client_port=&quot; + p1 + &quot;-&quot; + p2 + &quot;;server_port=&quot; + src[0] + &quot;-&quot; + src[1] + &quot;;ssrc=&quot; + Integer.toHexString(ssrc) + &quot;;mode=play\\r\\n&quot; + &quot;Session: &quot; + &quot;1185d20035702ca&quot; + &quot;\\r\\n&quot; + &quot;Cache-Control: no-cache\\r\\n&quot;; response.status = Response.STATUS_OK; // If no exception has been thrown, we reply with OK response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************** Method PLAY *********************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(&quot;PLAY&quot;)) &#123; String requestAttributes = &quot;RTP-Info: &quot;; if (mSession.trackExists(0)) requestAttributes += &quot;url=rtsp://&quot; + mClient.getLocalAddress().getHostAddress() + &quot;:&quot; + mClient.getLocalPort() + &quot;/trackID=&quot; + 0 + &quot;;seq=0,&quot;; if (mSession.trackExists(1)) requestAttributes += &quot;url=rtsp://&quot; + mClient.getLocalAddress().getHostAddress() + &quot;:&quot; + mClient.getLocalPort() + &quot;/trackID=&quot; + 1 + &quot;;seq=0,&quot;; requestAttributes = requestAttributes.substring(0, requestAttributes.length() - 1) + &quot;\\r\\nSession: 1185d20035702ca\\r\\n&quot;; response.attributes = requestAttributes; // If no exception has been thrown, we reply with OK response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************** Method PAUSE ********************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(&quot;PAUSE&quot;)) &#123; response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************* Method TEARDOWN ******************************** */ /* ********************************************************************************** */ else if (request.method.equalsIgnoreCase(&quot;TEARDOWN&quot;)) &#123; response.status = Response.STATUS_OK; &#125; /* ********************************************************************************** */ /* ********************************* Unknown method ? ******************************* */ /* ********************************************************************************** */ else &#123; Log.e(TAG, &quot;Command unknown: &quot; + request); response.status = Response.STATUS_BAD_REQUEST; &#125; &#125; return response; &#125; /** * Check if the request is authorized * @param request * @return true or false */ private boolean isAuthorized(Request request) &#123; String auth = request.headers.get(&quot;authorization&quot;); if(mUsername == null || mPassword == null || mUsername.isEmpty()) return true; if(auth != null &amp;&amp; !auth.isEmpty()) &#123; String received = auth.substring(auth.lastIndexOf(&quot; &quot;)+1); String local = mUsername+&quot;:&quot;+mPassword; String localEncoded = Base64.encodeToString(local.getBytes(),Base64.NO_WRAP); if(localEncoded.equals(received)) return true; &#125; return false; &#125;&#125; 这个类比较长，但是我只需关注采集。看到processRequest方法，当有Client连接后，便会有session了，然后打印一些配置之类的信息，最后看到mSession.syncStart(trackId)，可以猜测这个方法便是开始采集、推流了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Starts a stream in a synchronous manner. &lt;br /&gt; * Throws exceptions in addition to calling a callback. * @param id The id of the stream to start **/public void syncStart(int id) throws CameraInUseException, StorageUnavailableException, ConfNotSupportedException, InvalidSurfaceException, UnknownHostException, IOException &#123; Stream stream = id==0 ? mAudioStream : mVideoStream; if (stream!=null &amp;&amp; !stream.isStreaming()) &#123; try &#123; InetAddress destination = InetAddress.getByName(mDestination); stream.setTimeToLive(mTimeToLive); stream.setDestinationAddress(destination); stream.start(); if (getTrack(1-id) == null || getTrack(1-id).isStreaming()) &#123; postSessionStarted(); &#125; if (getTrack(1-id) == null || !getTrack(1-id).isStreaming()) &#123; mHandler.post(mUpdateBitrate); &#125; &#125; catch (UnknownHostException e) &#123; postError(ERROR_UNKNOWN_HOST, id, e); throw e; &#125; catch (CameraInUseException e) &#123; postError(ERROR_CAMERA_ALREADY_IN_USE , id, e); throw e; &#125; catch (StorageUnavailableException e) &#123; postError(ERROR_STORAGE_NOT_READY , id, e); throw e; &#125; catch (ConfNotSupportedException e) &#123; postError(ERROR_CONFIGURATION_NOT_SUPPORTED , id, e); throw e; &#125; catch (InvalidSurfaceException e) &#123; postError(ERROR_INVALID_SURFACE , id, e); throw e; &#125; catch (IOException e) &#123; postError(ERROR_OTHER, id, e); throw e; &#125; catch (RuntimeException e) &#123; postError(ERROR_OTHER, id, e); throw e; &#125; &#125;&#125; 参数id用来标识是音频，还是视频，最后执行到stream.start()，其调用的是最顶层的Stream实现类MediaStream的start方法。 123456789101112131415161718/** Starts the stream. */public synchronized void start() throws IllegalStateException, IOException &#123; if (mDestination==null) throw new IllegalStateException(&quot;No destination ip address set for the stream !&quot;); if (mRtpPort&lt;=0 || mRtcpPort&lt;=0) throw new IllegalStateException(&quot;No destination ports set for the stream !&quot;); mPacketizer.setTimeToLive(mTTL); if (mMode != MODE_MEDIARECORDER_API) &#123; encodeWithMediaCodec(); &#125; else &#123; encodeWithMediaRecorder(); &#125;&#125; 可以看到，根据Mode选择encodeWithMediaCodec或是encodeWithMediaRecorder。然后看到其继承类的实现方法，这里我只关注了VideoStream的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/** * Video encoding is done by a MediaRecorder. */protected void encodeWithMediaRecorder() throws IOException &#123; Log.d(TAG,&quot;Video encoded using the MediaRecorder API&quot;); // We need a local socket to forward data output by the camera to the packetizer createSockets(); // Reopens the camera if needed destroyCamera(); createCamera(); // The camera must be unlocked before the MediaRecorder can use it unlockCamera(); try &#123; mMediaRecorder = new MediaRecorder(); mMediaRecorder.setCamera(mCamera); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mMediaRecorder.setVideoEncoder(mVideoEncoder); mMediaRecorder.setPreviewDisplay(mSurfaceView.getHolder().getSurface()); mMediaRecorder.setVideoSize(mRequestedQuality.resX,mRequestedQuality.resY); mMediaRecorder.setVideoFrameRate(mRequestedQuality.framerate); // The bandwidth actually consumed is often above what was requested mMediaRecorder.setVideoEncodingBitRate((int)(mRequestedQuality.bitrate*0.8)); // We write the ouput of the camera in a local socket instead of a file ! // This one little trick makes streaming feasible quiet simply: data from the camera // can then be manipulated at the other end of the socket mMediaRecorder.setOutputFile(mSender.getFileDescriptor()); mMediaRecorder.prepare(); mMediaRecorder.start(); &#125; catch (Exception e) &#123; throw new ConfNotSupportedException(e.getMessage()); &#125; // This will skip the MPEG4 header if this step fails we can&#x27;t stream anything :( InputStream is = mReceiver.getInputStream(); try &#123; byte buffer[] = new byte[4]; // Skip all atoms preceding mdat atom while (!Thread.interrupted()) &#123; while (is.read() != &#x27;m&#x27;); is.read(buffer,0,3); if (buffer[0] == &#x27;d&#x27; &amp;&amp; buffer[1] == &#x27;a&#x27; &amp;&amp; buffer[2] == &#x27;t&#x27;) break; &#125; &#125; catch (IOException e) &#123; Log.e(TAG,&quot;Couldn&#x27;t skip mp4 header :/&quot;); stop(); throw e; &#125; // The packetizer encapsulates the bit stream in an RTP stream and send it over the network mPacketizer.setDestination(mDestination, mRtpPort, mRtcpPort); mPacketizer.setInputStream(mReceiver.getInputStream()); mPacketizer.start(); mStreaming = true;&#125;/** * Video encoding is done by a MediaCodec. */protected void encodeWithMediaCodec() throws RuntimeException, IOException &#123; if (mMode == MODE_MEDIACODEC_API_2) &#123; // Uses the method MediaCodec.createInputSurface to feed the encoder encodeWithMediaCodecMethod2(); &#125; else &#123; // Uses dequeueInputBuffer to feed the encoder encodeWithMediaCodecMethod1(); &#125;&#125;/** * Video encoding is done by a MediaCodec. */@SuppressLint(&quot;NewApi&quot;)protected void encodeWithMediaCodecMethod1() throws RuntimeException, IOException &#123; Log.d(TAG,&quot;Video encoded using the MediaCodec API with a buffer&quot;); // Updates the parameters of the camera if needed createCamera(); updateCamera(); // Estimates the framerate of the camera measureFramerate(); // Starts the preview if needed if (!mPreviewStarted) &#123; try &#123; mCamera.startPreview(); mPreviewStarted = true; &#125; catch (RuntimeException e) &#123; destroyCamera(); throw e; &#125; &#125; EncoderDebugger debugger = EncoderDebugger.debug(mSettings, mQuality.resX, mQuality.resY); final NV21Convertor convertor = debugger.getNV21Convertor(); mMediaCodec = MediaCodec.createByCodecName(debugger.getEncoderName()); MediaFormat mediaFormat = MediaFormat.createVideoFormat(&quot;video/avc&quot;, mQuality.resX, mQuality.resY); mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, mQuality.bitrate); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mQuality.framerate); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,debugger.getEncoderColorFormat()); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mMediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mMediaCodec.start(); Camera.PreviewCallback callback = new Camera.PreviewCallback() &#123; long now = System.nanoTime()/1000, oldnow = now, i=0; ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers(); @Override public void onPreviewFrame(byte[] data, Camera camera) &#123; oldnow = now; now = System.nanoTime()/1000; if (i++&gt;3) &#123; i = 0; //Log.d(TAG,&quot;Measured: &quot;+1000000L/(now-oldnow)+&quot; fps.&quot;); &#125; try &#123; int bufferIndex = mMediaCodec.dequeueInputBuffer(500000); if (bufferIndex&gt;=0) &#123; inputBuffers[bufferIndex].clear(); convertor.convert(data, inputBuffers[bufferIndex]); mMediaCodec.queueInputBuffer(bufferIndex, 0, inputBuffers[bufferIndex].position(), now, 0); &#125; else &#123; Log.e(TAG,&quot;No buffer available !&quot;); &#125; &#125; finally &#123; mCamera.addCallbackBuffer(data); &#125; &#125; &#125;; for (int i=0;i&lt;10;i++) mCamera.addCallbackBuffer(new byte[convertor.getBufferSize()]); mCamera.setPreviewCallbackWithBuffer(callback); // The packetizer encapsulates the bit stream in an RTP stream and send it over the network mPacketizer.setDestination(mDestination, mRtpPort, mRtcpPort); mPacketizer.setInputStream(new MediaCodecInputStream(mMediaCodec)); mPacketizer.start(); mStreaming = true;&#125;/** * Video encoding is done by a MediaCodec. * But here we will use the buffer-to-surface methode */@SuppressLint(&#123; &quot;InlinedApi&quot;, &quot;NewApi&quot; &#125;)protected void encodeWithMediaCodecMethod2() throws RuntimeException, IOException &#123; Log.d(TAG,&quot;Video encoded using the MediaCodec API with a surface&quot;); // Updates the parameters of the camera if needed createCamera(); updateCamera(); // Estimates the framerate of the camera measureFramerate(); EncoderDebugger debugger = EncoderDebugger.debug(mSettings, mQuality.resX, mQuality.resY); mMediaCodec = MediaCodec.createByCodecName(debugger.getEncoderName()); MediaFormat mediaFormat = MediaFormat.createVideoFormat(&quot;video/avc&quot;, mQuality.resX, mQuality.resY); mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, mQuality.bitrate); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mQuality.framerate); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mMediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); Surface surface = mMediaCodec.createInputSurface(); ((SurfaceView)mSurfaceView).addMediaCodecSurface(surface); mMediaCodec.start(); // The packetizer encapsulates the bit stream in an RTP stream and send it over the network mPacketizer.setDestination(mDestination, mRtpPort, mRtcpPort); mPacketizer.setInputStream(new MediaCodecInputStream(mMediaCodec)); mPacketizer.start(); mStreaming = true;&#125; 可以看到，整体实现有2个方式： MediaRecorder采集数据，通过绑定LocalSocket来获取数据 利用Camera又分了2种方式：回调onPreviewFrame获取数据进行处理，或者直接输出到Surface 这与之前说到的不谋而合。 问题通过绑定LocalSocket的方式，我在运行（MI 4LTE Android 6.0.1）的时候出现了MediaRecorder: start failed -38的错误。经过Google，后面找到解决方案，setOutputFile时使用ParcelFileDescriptor。作者也在spydroid libstreaming中提到了，并进行了修正。于是我拷贝最新的libstreaming到工程中，运行的依然出错：MediaRecorder: start failed -2147483648，这下我没招了QAQ。后面想到github issues或许也有别人用的时候有这个问题呢，于是我便去看看。但是很不幸，说是在Android 5.0之后不能用MediaRecorder绑定LocalSocket的方式了&#x3D;&#x3D;&gt;issues#227、issues208、issues#155。毕竟是好几年前的库了，之前Android都没出到5、6呢，后面作者也没有进行维护了，不过我在OPPA A31（Android 4.4.4）的环境下通过此种方式确实可以运行。 参考Android 实时视频采集&#x2F;编码&#x2F;传输&#x2F;解码&#x2F;播放—方案调研（初）Android 实时视频采集—MediaRecoder录制libstreamingspydroid-ipcameralibstreaming-examples","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"【Android音视频开发】- 直播","date":"2016-10-19T10:05:45.000Z","path":"2016/10/19/live/","text":"前言2015 ~ 1016是直播大火的年代，最近公司也是在着手直播这块，作为Android开发，自然也要懂得一些知识，经过一段时间的调研，学习，作了一下自我总结，写了一个【Android音视频开发】系列，此文便是开篇了！PS：关于这块的文章着实太少，点开10个链接，有7、8个链接的内容是一样的，各种转来转去，也是耗费了很大的功夫才了解到音视频的一点皮毛。而且很多文章都是12年、13年的，拿到现在可能根本就不适用，我通过实例验证，做下此总结。最近一直在看这一块的东西，今天抽空，趁着记忆的知识还比较新鲜记下来，好记性不如烂笔头，也希望能帮助到其他的人。 直播从技术层面上来，直播大致分为：音视频采集、美颜&#x2F;滤镜&#x2F;特效处理、编码、封包、推流、分发、解码&#x2F;渲染&#x2F;播放。对应到具体的Android层面，便会有如下几个重要环节： 视频实时采集：Camera预览&#x2F;MediaRecorder绑定LocalSocket 音频实时采集：MediaRecorder&#x2F;AudioRecord&#x2F;OpenSL ES 特效处理：视频磨皮美颜，音频降噪去回声等算法 编解码：H264&amp;AAC，MediaCodec(API &gt;&#x3D; 16)硬解，ffmpeg等三方库软解 流媒体传输：rtmp rtsp hls等 渲染播放：MediaPlayer，ijkplayer等三方库 科普编解码采集到的原始音视频数据是非常大的，不利于传输，所以就需要对这些数据进行压缩，这个过程就是编码。解码则是编码的逆向过程。编码分为硬编码、软编码，解码也是如此。 硬编码：使用非CPU进行编码，如显卡GPU、专用的DSP、FPGA、ASIC芯片等。性能高，低码率下通常质量低于硬编码器，但部分产品在GPU硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。 软编码：使用CPU进行编码。性能高，低码率下通常质量低于硬编码器，但部分产品在GPU硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。 关于音视频压缩编码的基本原理可以参见雷神的这篇文章。 视频编码视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。主要视频编码一览： 名称 推出即构 退出时间 目前使用领域 HEVC(H.265) MPEG&#x2F;ITU-T 2013 研发中 H.264 MPEG&#x2F;ITU-T 2003 各个领域 MPEG4 MPEG 2001 不温不火 MPEG2 MPEG 1994 研发中 VP9 Google 2013 研发中 VP8 Google 2008 不普及 VC-1 Microsoft Inc. 2006 微软平台 不难看出，目前主流的视频编码便是H264了，我们项目中选取的也是此编码标准。 音频编码音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。主要音频编码一览： 名称 推出即构 退出时间 目前使用领域 AAC MPEG 1997 各个领域（新） AC-3 Dolby Inc. 1992 电影 MP3 MPEG 1993 各个领域（旧） WMA Microsoft Inc. 1999 微软平台 那么主流的音频编码便是AAC了，项目选取的也是此编码标准。 参考如何搭建一个完整的视频直播系统？android音视频点&#x2F;直播模块开发视音频编解码技术零基础学习方法移动直播技术秒开优化经验从0到1打造直播 App","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android状态栏、虚拟按键小记","date":"2016-09-20T08:05:23.000Z","path":"2016/09/20/system-ui/","text":"之前写过一篇状态栏小记，这里加入虚拟按键重新做一下总结。 前言Android 4.0之后，我们可以通过setSystemUiVisibility(int)方法，结合各种flag来设置系统组件（状态栏、虚拟按键）的显示或隐藏。那么有哪些Flag呢？Android官方文档有以下flag： View.SYSTEM_UI_FLAG_FULLSCREEN View has requested to go into the normal fullscreen mode so that its content can take over the screen while still allowing the user to interact with the application. View.SYSTEM_UI_FLAG_HIDE_NAVIGATION View has requested that the system navigation be temporarily hidden. View.SYSTEM_UI_FLAG_IMMERSIVE View would like to remain interactive when hiding the navigation bar with SYSTEM_UI_FLAG_HIDE_NAVIGATION. View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY View would like to remain interactive when hiding the status bar with SYSTEM_UI_FLAG_FULLSCREEN and&#x2F;or hiding the navigation bar with SYSTEM_UI_FLAG_HIDE_NAVIGATION. View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN View would like its window to be laid out as if it has requested SYSTEM_UI_FLAG_FULLSCREEN, even if it currently hasn’t. View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION View would like its window to be laid out as if it has requested SYSTEM_UI_FLAG_HIDE_NAVIGATION, even if it currently hasn’t. View.SYSTEM_UI_FLAG_LAYOUT_STABLE When using other layout flags, we would like a stable view of the content insets given to fitSystemWindows(Rect). SYSTEM_UI_FLAG_LIGHT_STATUS_BAR Requests the status bar to draw in a mode that is compatible with light status bar backgrounds. View.SYSTEM_UI_FLAG_LOW_PROFILE View has requested the system UI to enter an unobtrusive “low profile” mode. SYSTEM_UI_FLAG_VISIBLE View has requested the system UI (status bar) to be visible (the default). SYSTEM_UI_LAYOUT_FLAGS Flags that can impact the layout in relation to system UI. 实用代码在做与状态栏、虚拟按键相关的工作时，有些代码亲测比较实用。获取状态栏高度： 12345678910111213/** * 获取状态栏高度 * * @return */public int getStatusBarHeight() &#123; int result = 0; int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; result = getResources().getDimensionPixelSize(resourceId); &#125; return result;&#125; 判断是否有虚拟按键： 1234567891011121314151617181920212223242526/** * 是否有虚拟按键 * * @return */public static boolean checkDeviceHasNavigationBar(Context context) &#123; boolean hasNavigationBar = false; Resources rs = context.getResources(); int id = rs.getIdentifier(&quot;config_showNavigationBar&quot;, &quot;bool&quot;, &quot;android&quot;); if (id &gt; 0) &#123; hasNavigationBar = rs.getBoolean(id); &#125; try &#123; Class systemPropertiesClass = Class.forName(&quot;android.os.SystemProperties&quot;); Method m = systemPropertiesClass.getMethod(&quot;get&quot;, String.class); String navBarOverride = (String) m.invoke(systemPropertiesClass, &quot;qemu.hw.mainkeys&quot;); if (&quot;1&quot;.equals(navBarOverride)) &#123; hasNavigationBar = false; &#125; else if (&quot;0&quot;.equals(navBarOverride)) &#123; hasNavigationBar = true; &#125; &#125; catch (Exception e) &#123; &#125; return hasNavigationBar;&#125; 获取虚拟按键的高度： 12345678910111213/** * 获取虚拟按键的高度 * * @return */public int getNavigationBarHeight() &#123; Resources resources = context.getResources(); int resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; return resources.getDimensionPixelSize(resourceId); &#125; return 0;&#125; 显示状态栏： 1234WindowManager.LayoutParams attr = getWindow().getAttributes();attr.flags &amp;= (~WindowManager.LayoutParams.FLAG_FULLSCREEN);getWindow().setAttributes(attr);getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); 隐藏状态栏： 1234WindowManager.LayoutParams lp = getWindow().getAttributes(); lp.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN; getWindow().setAttributes(lp); getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); 关于隐藏状态栏以及虚拟按键的显示、隐藏，目前知道的只有通过setSystemUiVisibility方法结合flag来实现。隐藏虚拟按键： 1getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION); 下面来做一个示例。 示例前言中11种flag，真正用到的也就几种，下面结合示例来说。新建一个应用，将Activity设置为全屏，并且横屏（模拟直播、播放视频类似的环境）。先贴一下示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity &#123; private boolean isShowing; private TextView hello; private Button dialog; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dialog = (Button) findViewById(R.id.dialog_button); hello = (TextView) findViewById(R.id.hello_world); hello.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (isShowing) &#123; hideOperation(); &#125; else &#123; showOperation(); &#125; &#125; &#125;); dialog.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setMessage(&quot;Hello World!&quot;); builder.setTitle(&quot;Title&quot;); builder.create().show(); hideOperation(); &#125; &#125;); &#125; private void showOperation() &#123; isShowing = true; WindowManager.LayoutParams attr = getWindow().getAttributes(); attr.flags &amp;= (~WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().setAttributes(attr); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); &#125; private void hideOperation() &#123; isShowing = false; int options = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options |= View.SYSTEM_UI_FLAG_IMMERSIVE; &#125; getWindow().getDecorView().setSystemUiVisibility(options); &#125; @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus);// int options = View.SYSTEM_UI_FLAG_LAYOUT_STABLE// | View.SYSTEM_UI_LAYOUT_FLAGS// | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN// | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION// | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION// | View.SYSTEM_UI_FLAG_FULLSCREEN;// if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;// options |= View.SYSTEM_UI_FLAG_IMMERSIVE;// &#125;// getWindow().getDecorView().setSystemUiVisibility(options); &#125;&#125; 运行效果如下图： 可以看到，在我点击依次”Hello World”之后，button往下移了一点点，同时状态栏也显示了。（初始的时候虚拟按键就已经显示） 再点击一下，进行隐藏操作，状态栏、虚拟按键同时消失。当点击中间的button弹出dialog时，虚拟按键与状态栏会同时出来。然后关掉dialog后要连着点2次，状态栏、虚拟按键才会消失。 针对第一点，是初始的时候，虚拟按键在App布局之外，当执行SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN（根据说明：按全屏模式来表现，尽管当前没有设置全屏模式）之后，App布局占据手机整个显示框，所以会“变高”了些，button会下移。针对第二点，目前也不知道是什么原因导致必须点2次才会执行消失操作。姑且以为是虚拟按键抢占焦点，第一次的点击被它消费了，第二次才是我们App进行消费。另外，当弹出dialog时，我们也可以控制状态栏不显示，将hideOperation改为如下： 12345678910111213141516171819private void hideOperation() &#123; isShowing = false; WindowManager.LayoutParams lp = getWindow().getAttributes(); lp.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN; getWindow().setAttributes(lp); getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); int options = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;// | View.SYSTEM_UI_FLAG_FULLSCREEN; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options |= View.SYSTEM_UI_FLAG_IMMERSIVE; &#125; getWindow().getDecorView().setSystemUiVisibility(options);&#125; 如此，当弹出dialog时，状态栏便不会显示了，但是虚拟按键是一定会显示的。可以认为：SYSTEM_UI_FLAG_FULLSCREEN flag的意思就是全屏显示，在此flag下，不会显示状态栏。 至于点击2次才消失的解决方案，便是取消onWindowFocusChanged中的注释，如此，1、2中描述的问题都不会出现了。 通过SYSTEM_UI_FLAG_HIDE_NAVIGATION来隐藏虚拟按键，会导致一个问题：界面有交互时虚拟按键会自动显示。要解决这个问题，便要用到SYSTEM_UI_FLAG_IMMERSIVE了，它的意思是当虚拟按键隐藏时仍然保留交互，可以理解为虚拟按键只是隐藏，但仍然还在，所以发生交互的时候便不会再自动显示了。 总结 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN：按照全屏模式来显示，尽管当前没有设置为全屏模式，设置此flag便会抢占虚拟按键的空间，使应用真正的全屏，虚拟按键若要显示，则只是覆盖在应用的View上了。 SYSTEM_UI_FLAG_FULLSCREEN：全屏显示，此模式下不会显示状态栏。 SYSTEM_UI_FLAG_HIDE_NAVIGATION：隐藏虚拟按键。 SYSTEM_UI_FLAG_IMMERSIVE：当虚拟按键隐藏时，仍然保留交互。解决隐藏后界面发生交互又自动显示的问题。 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION：按照隐藏虚拟按键模式显示，尽管当前没有设置为隐藏虚拟按键模式。针对示例中的第一点，将SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN改为此flag或者SYSTEM_UI_FLAG_HIDE_NAVIGATION都会使App充满显示框，导致button下移。 大致就说这些了，还有一些flag没弄明白，后面继续努力，写得有点乱~ 示例代码","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android Studio发布项目到JCenter","date":"2016-09-12T08:40:48.000Z","path":"2016/09/12/jcenter/","text":"在我的上一篇文章中，尝试将弧形seekbar抽成了一个三方库，这篇文章便以该库为例，将其上传至JCenter。 注册Binatry到Binatry官网注册账号。然后到Your Profile点击Edit，在下面会看到API Key，记录下这个Key备用。 配置gradle我是使用的gradle-bintray-plugin插件来上传项目的，在项目的build.gradle下添加如下配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108apply plugin: &#x27;com.android.library&#x27;apply plugin: &#x27;com.github.dcendents.android-maven&#x27;apply plugin: &#x27;com.jfrog.bintray&#x27;//提交到仓库中的版本号version = &quot;1.0.0&quot;android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.3&quot; defaultConfig &#123; minSdkVersion 16 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;]) testCompile &#x27;junit:junit:4.12&#x27; compile &#x27;com.android.support:appcompat-v7:23.2.1&#x27;&#125;def siteUrl = &#x27;https://github.com/LiJia92/CustomArcSeekBar&#x27; // 项目的主页def gitUrl = &#x27;https://github.com/LiJia92/CustomArcSeekBar&#x27; // Git仓库的urlgroup = &quot;com.android.lovesixgod.customarcseekbar&quot; // Maven Group ID for the artifact，一般填你唯一的包名install &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging &#x27;aar&#x27; // Add your description here name &#x27;Custom arc seek bar&#x27; //项目描述 url siteUrl // Set your license licenses &#123; license &#123; name &#x27;The Apache Software License, Version 2.0&#x27; url &#x27;http://www.apache.org/licenses/LICENSE-2.0.txt&#x27; &#125; &#125; developers &#123; developer &#123; id &#x27;lijia92&#x27; //填写的一些基本信息 name &#x27;lastwarmth&#x27; email &#x27;243244898@qq.com&#x27; &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &#x27;sources&#x27;&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = &#x27;javadoc&#x27; from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file(&#x27;local.properties&#x27;).newDataInputStream())bintray &#123; user = properties.getProperty(&quot;bintray.user&quot;) key = properties.getProperty(&quot;bintray.apikey&quot;) configurations = [&#x27;archives&#x27;] pkg &#123; repo = &quot;maven&quot; name = &quot;arcseekbar&quot; //发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [&quot;Apache-2.0&quot;] publish = true &#125;&#125;// 解决GBK乱码javadoc &#123; options&#123; encoding &quot;UTF-8&quot; charSet &#x27;UTF-8&#x27; author true version true links &quot;http://docs.oracle.com/javase/7/docs/api&quot; &#125;&#125; 配置name&amp;key在local.propertis里配置binatry的名称与api key： 12bintray.user=usernamebintray.apikey=key user即是你注册的名称，key则是第一步中保存的值。 上传首先Sync Gradle File，当build成功后，打开Terminal，执行指令： 1gradlew install build成功后在执行指令： 1gradlew bintrayUpload 成功后便能在binatry上看到自己上传的项目了。 同步到JCenter点开自己的项目，有一个Add to JCenter，点击后填写描述即可提交申请给binatry了。最后便是等待审核了，审核通过后会收到如下的消息：然后我们进入到项目详情页，会看到Add to JCenter按钮消失了，说明审核已经通过。点到Gradle便能看到gradle依赖的代码：迫不及待的在AS中试了一下，真的可以用了，成就感十足，哈哈。 问题 看Hongyang大神的博客，打算使用bintray-release插件来进行上传的，但是出现了GBK中文编码乱码的问题，除了将代码中的中文全部换成英文之外，没找到其他好的方法，便放弃了这个方法，采用的gradle-bintray-plugin插件可通过配置javadoc的编码来解决这个问题。 包名非常不好看，以后得起个好点的包名。而且不能瞎用“com.android….”，这是google android团队的。 出现如下的错误：12Execution failed for task &#x27;:library:bintrayUpload&#x27;.&gt; Could not create package &#x27;lijia92/maven/CustomArcSeekBar&#x27;: HTTP/1.1 404 Not Found [message:Repo &#x27;maven&#x27; was not found] 说是maven不存在，于是我在binatry下创建了一个名为maven的仓库，然后重新上传便成功了。（非常坑，找了半天的原因，看的好多博客都没说这个，可能是他们账号下面本身就已经存在maven仓库了）","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Android感悟之造轮子","date":"2016-09-12T03:17:11.000Z","path":"2016/09/12/make-wheel/","text":"最近项目要添加一个点赞的效果，类似这篇文章所说，其实效果是差不多的，便打算直接拿来用了，感谢这位大大制作的轮子~ 而后自己思考了一下，怎么样的轮子别人用起来才方便呢？为了实现方便，其实我们能做的事情有很多，这里说一下自己的感悟。 下面我便拿着我之前写的一个自定义弧形SeekBar来说明，将其抽成一个三方库要做哪些事。 之前的代码结构是这样的：引用的时候是这样的：这显然是非常笨重的引用方式，那么改如何改进呢？ Library第一个最先想到的自然是将代码抽成一个library。然后项目要引用时候，直接gradle添加依赖即可。选择New Module，选择Android Library即可，然后将代码放在src/main/java/包名文件夹下，添加compile project(&#39;:library&#39;)依赖即可。 精简引用方式之前的代码要用，我需要xml中引入三个自定义View，显得很繁杂。站在使用者的角度，若是只用引入一个自定义View，便简单多了。至于球的大小，球的颜色等独立的属性，通过自定义属性来进行设置即可。 下面上一下修改后的代码，ArcSeekBarParent类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class ArcSeekBarParent extends FrameLayout implements SeekBarBallView.OnSmoothScrollListener &#123; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private PointF circleCenter; // 球的坐标 private int top; private int right; private int bottom; private int left; private float currentX; // 当前x坐标，用于控制圆球位置 private final static float LEVEL = 6f; // 设置档次 private int currentLevel = 1; // 当前档次 private OnProgressChangedListener listener; // 档次改变的监听 private Context context; private SeekBarBallView ball; // 球 private SeekBarArcView arc; // 弧 private int ballSize; // 球的大小 private String ballColor; // 球的颜色 private int arcWidth; // 弧的宽度 private String arcColor; // 弧的颜色 public ArcSeekBarParent(Context context) &#123; super(context); init(); &#125; public ArcSeekBarParent(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.ArcSeekBarParent); ballSize = array.getDimensionPixelSize(R.styleable.ArcSeekBarParent_ballSize, 30); arcWidth = array.getDimensionPixelSize(R.styleable.ArcSeekBarParent_arcWidth, 10); ballColor = array.getString(R.styleable.ArcSeekBarParent_ballColor); arcColor = array.getString(R.styleable.ArcSeekBarParent_arcColor); array.recycle(); init(); &#125; private void init() &#123; pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); circleCenter = new PointF(); // 添加弧线View if (arcColor == null) &#123; arcColor = &quot;#000000&quot;; // 当没有设置颜色时候，默认使用黑色 &#125; arc = new SeekBarArcView(context, arcColor, arcWidth); arc.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); addView(arc); // 添加球View if (ballColor == null) &#123; ballColor = &quot;#FFFFFF&quot;; // 当没有设置颜色时候，默认使用白色 &#125; ball = new SeekBarBallView(context, ballColor, ballSize); ball.setListener(this); addView(ball); &#125; public void setListener(OnProgressChangedListener listener) &#123; this.listener = listener; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); this.left = left; this.top = top; this.right = right; this.bottom = bottom; pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); currentX = (right - left) / LEVEL; changeBallLayout(currentX); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: float downX = event.getX(); float downY = event.getY(); float distance = (downX - circleCenter.x) * (downX - circleCenter.x) + (downY - circleCenter.y) * (downY - circleCenter.y); // 计算到圆球中心的距离，考虑20的误差 return !(distance - (ball.getMeasuredWidth() / 2 + 20) * (ball.getMeasuredWidth() / 2 + 20) &gt; 0); case MotionEvent.ACTION_MOVE: float moveX = event.getX(); currentX = moveX; // 通过x坐标改变圆球的位置 changeBallLayout(currentX); currentLevel = getLevel(moveX); if (listener != null) &#123; listener.OnProgressChanged(currentLevel); &#125; break; default: // 当手指移出或者离开View时，圆球平滑滑到最近的档次 ball.smoothScrollLevel((int) currentX, (int) ((right - left) / LEVEL * currentLevel - currentX)); break; &#125; return super.onTouchEvent(event); &#125; /** * 改变球的位置 * * @param currentX 横坐标 */ private void changeBallLayout(float currentX) &#123; float t = (currentX / (right - left)); float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x; float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y; circleCenter.set(x, y); ball.layout((int) (circleCenter.x - ball.getMeasuredWidth() / 2), (int) (circleCenter.y - ball.getMeasuredWidth() / 2), (int) (circleCenter.x + ball.getMeasuredWidth() / 2), (int) (circleCenter.y + ball.getMeasuredWidth() / 2)); &#125; /** * 计算档次 * * @param x 横坐标 * @return 档次 */ private int getLevel(float x) &#123; float ratio = (x / (right - left)) * LEVEL; // 计算距离哪个档次最近 int result = new BigDecimal(ratio).setScale(0, BigDecimal.ROUND_HALF_UP).intValue(); if (result &lt; 1) &#123; result = 1; &#125; else if (result &gt; (LEVEL - 1)) &#123; result = (int) (LEVEL - 1); &#125; return result; &#125; @Override public void onSmoothScroll(int currentX) &#123; changeBallLayout(currentX); &#125; /** * 滑动接口 */ public interface OnProgressChangedListener &#123; void OnProgressChanged(int level); &#125;&#125; SeekBarArcView类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class SeekBarArcView extends View &#123; private Paint paint; private Path path; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private String arcColor; // 弧的颜色 private int arcWidth; // 弧的宽度 public SeekBarArcView(Context context, String arcColor, int arcWidth) &#123; super(context); this.arcColor = arcColor; this.arcWidth = arcWidth; init(); &#125; private void init() &#123; paint = new Paint(); path = new Path(); pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); // 初始化画笔 paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.parseColor(arcColor)); paint.setStrokeWidth(arcWidth); paint.setStyle(Paint.Style.STROKE); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画2阶贝塞尔曲线 path.moveTo(pointF1.x, pointF1.y); path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y); canvas.drawPath(path, paint); &#125;&#125; SeekBarBallView类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SeekBarBallView extends View &#123; private Paint paint; private Scroller scroller; private int ballSize; private String ballColor; private OnSmoothScrollListener listener; public SeekBarBallView(Context context, String ballColor, int ballSize) &#123; super(context); this.ballColor = ballColor; this.ballSize = ballSize; init(context); &#125; private void init(Context context) &#123; scroller = new Scroller(context); paint = new Paint(); paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.parseColor(ballColor)); paint.setStyle(Paint.Style.FILL); &#125; public void setListener(OnSmoothScrollListener listener) &#123; this.listener = listener; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int spec = MeasureSpec.makeMeasureSpec(ballSize, MeasureSpec.EXACTLY); setMeasuredDimension(spec, spec); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; if (listener != null) &#123; listener.onSmoothScroll(scroller.getCurrX()); postInvalidate(); &#125; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredWidth() / 2, getMeasuredWidth() / 2, paint); &#125; /** * 平滑滑动 * * @param start 起始值 * @param distance 滑动距离 */ public void smoothScrollLevel(int start, int distance) &#123; scroller.startScroll(start, 0, distance, 0, 200); postInvalidate(); &#125; public interface OnSmoothScrollListener &#123; void onSmoothScroll(int currentX); &#125;&#125; 以及自定义属性attr.xml： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;ArcSeekBarParent&quot;&gt; &lt;attr name=&quot;ballColor&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;ballSize&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;arcWidth&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;arcColor&quot; format=&quot;string&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 修改后，在使用的时候只用这样： 12345678910&lt;com.android.lovesixgod.library.ArcSeekBarParent android:id=&quot;@+id/seek_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;40dp&quot; android:background=&quot;@color/colorAccent&quot; app:arcColor=&quot;#000000&quot; app:arcWidth=&quot;3dp&quot; app:ballColor=&quot;#00ffff&quot; app:ballSize=&quot;30dp&quot; /&gt; 相比之前简单了不少。代码中再设置档次改变的监听响应即可直接使用了： 1234567ArcSeekBarParent seekBar = (ArcSeekBarParent) findViewById(R.id.seek_bar);seekBar.setListener(new ArcSeekBarParent.OnProgressChangedListener() &#123; @Override public void OnProgressChanged(int level) &#123; textView.setText(String.valueOf(level)); &#125;&#125;); 代码已更新至Github。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android AlarmManager使用小记","date":"2016-08-18T08:20:03.000Z","path":"2016/08/18/alarm/","text":"现在应用大多数都会使用一些三方推送的服务，例如极光、个推等，但是其到达率并不是很高，尤其是Android机型，各大手机厂商定制rom，系统拦截。那么要如何提高消息达到率呢？ Android中提供了AlarmManager可以用来做这个事情。顾名思义，它是一个闹钟管理类，它向系统注册一个事件，时间到了之后，便会触发事件，然后我们便能做一些事情了。 定义接收器首先定义一个BroadcastReceiver，在收到消息后，在onReceive里弹出一个Notification，示例代码如下： 12345678910111213141516public class OneShotAlarm extends BroadcastReceiver &#123; private final static int NOTIFICATION_ID = 1001; @Override public void onReceive(Context context, Intent intent) &#123; NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(&quot;title&quot;) .setContentText(&quot;context&quot;); NotificationManager mNotifyMgr = (NotificationManager) context.getSystemService(Activity.NOTIFICATION_SERVICE); mNotifyMgr.notify(NOTIFICATION_ID, mBuilder.build()); Toast.makeText(context, &quot;OneShotAlarm onReceive&quot;, Toast.LENGTH_SHORT).show(); Log.e(&quot;TAG&quot;, &quot;OneShotAlarm onReceive&quot;); &#125;&#125; 记得在AndroidManifest.xml中注册： 1234&lt;receiver android:name=&quot;.OneShotAlarm&quot; android:process=&quot;:remote&quot; /&gt;&lt;receiver 在此讨论一下process属性，它规定了组件(activity, service, receiver等)所在的进程。通常情况下，没有指定这个属性，一个应用所有的组件都运行在应用的默认进程中，进程的名字和应用的包名一致，比如manifest的package&#x3D;”com.example.helloalarm”，则默认进程名就是com.example.helloalarm。process属性可以为全部的组件设置一个不同的默认进程，组件可以override这个默认的进程设置，这样你的应用就可以是多进程的。如果你的process属性以一个冒号开头，进程名会在原来的进程名之后附加冒号之后的字符串作为新的进程名。当组件需要时，会自动创建这个进程，这个进程是应用私有的进程。如果process属性以小写字母开头，将会直接以属性中的这个名字作为进程名，这是一个全局进程，这样的进程可以被多个不同应用中的组件共享。 开启闹钟1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MainActivity.this, OneShotAlarm.class); PendingIntent sender = PendingIntent.getBroadcast( MainActivity.this, 0, intent, 0); // We want the alarm to go off 10 seconds from now. Calendar calendar = Calendar.getInstance(); calendar.setTimeInMillis(System.currentTimeMillis()); calendar.add(Calendar.SECOND, 30); AlarmManager am = (AlarmManager) getSystemService(ALARM_SERVICE); am.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), sender); &#125;&#125; 启动Activity之后30秒我们便能看到Toast，以及打出的Log和Notification了。通过这种方式，我们可以定时的发送通知，这样应该能改善推送到达率低的问题。 AlarmManager常用方法有三个： set(int type，long startTime，PendingIntent pi)；该方法用于设置一次性闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟执行时间，第三个参数表示闹钟响应动作。 setRepeating(int type，long startTime，long intervalTime，PendingIntent pi)；该方法用于设置重复闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟首次执行时间，第三个参数表示闹钟两次执行的间隔时间，第三个参数表示闹钟响应动作。 setInexactRepeating（int type，long startTime，long intervalTime，PendingIntent pi）；该方法也用于设置重复闹钟，与第二个方法相似，不过其两个闹钟执行的间隔时间不是固定的而已。 三个方法中都有type、PendingIntent参数，type分为以下几类： AlarmManager.ELAPSED_REALTIME：表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3 AlarmManager.ELAPSED_REALTIME_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2 AlarmManager.RTC：表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1 AlarmManager.RTC_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0 AlarmManager.POWER_OFF_WAKEUP：表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持 PendingIntent为设置接收消息类的参数，一般通过如下代码生成： 1PendingIntent sender = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0); 注意第二个参数为requestCode，该参数是闹钟的标识，如果不停设置闹钟，这个参数都一样，那么后设置的闹钟会覆盖之前的闹钟。所以如果需要多个闹钟，则需要将这个参数设为唯一。 若要取消闹钟，则直接调用cancel即可，官方是这样说的： void cancel (PendingIntent operation)Remove any alarms with a matching Intent. Any alarm, of any type, whose Intent matches this one (as defined by filterEquals(Intent)), will be canceled. 只有符合filterEquals的intent才会被取消。 12345678910111213public boolean filterEquals(Intent other) &#123; if (other == null) &#123; return false; &#125; if (!Objects.equals(this.mAction, other.mAction)) return false; if (!Objects.equals(this.mData, other.mData)) return false; if (!Objects.equals(this.mType, other.mType)) return false; if (!Objects.equals(this.mPackage, other.mPackage)) return false; if (!Objects.equals(this.mComponent, other.mComponent)) return false; if (!Objects.equals(this.mCategories, other.mCategories)) return false; return true;&#125; 问题对于即时性比较强的应用，比如直播类，闹钟定的时间要与正在直播的推送分开，不然用户就有可能收到2次通知了，所以闹钟就要定提前一点：XXX即将开始直播，类似这样。那么就会有一个问题：用户看到闹钟的这个通知后，进入应用，但是XXX是没有直播的（即将开始直播），所以对于用户当前是没有正确信息来显示的，这种体验可能不太好。如果将闹钟设置退后，XXX已经开始直播，又会显得非常怪异。我的心情：求同学们支招~","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android开发事件分发小记","date":"2016-08-05T07:39:32.000Z","path":"2016/08/05/touchevent/","text":"项目开发中，碰到这样一个情形：在点击页面空白处时会弹出状态栏，效果就如我上一篇博客一样。那么何为空白处呢？我的理解是：若是你这个点击事件没有其他View消费，那么便算是点击空白处了。大致画一下页面布局：那么在点击图中画框的其他地方，应该都能算上是空白处了，也就是在点击这些地方的时候，需要执行状态栏弹出的操作。 大致说一下页面布局的层次结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.miamusic.android.live.ui.RoomActivity&quot;&gt; &lt;!-- 最底层的摄像画面 --&gt; &lt;SurfaceView android:id=&quot;@+id/surfaceview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;HorizontalFrameLayout android:id=&quot;@+id/parent_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!-- 弹幕 --&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/barrage_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;140dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_marginBottom=&quot;40dp&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/bottom_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot;&gt; &lt;!-- 底部操作栏 --&gt; &lt;/RelativeLayout&gt; &lt;/HorizontalFrameLayout&gt; &lt;RelativeLayout android:id=&quot;@+id/top_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--顶部主播信息与删除的布局--&gt; &lt;/RelativeLayout&gt;&lt;/FrameLayout&gt; 下面便来逐渐分析事件的分发。 清屏操作与RecyclerView的滑动冲突需求中有向右滑动清屏的操作，向左滑动的时候恢复。我给整个布局parent_layout设置了OnTouchListener，图中弹幕是使用的RecyclerView，RecyclerView本身就会处理滑动，那么就只能滑动RecyclerView之外的地方才能进行清屏。但是这样的体验不好，因为清屏必须要滑动空白地方，因为弹幕的原因可能导致空白地方很小。如何处理好与RecyclerView的滑动冲突呢？项目中，弹幕只具有上下滑动的功能，是不具备左右滑动的，所以事件分发给RecyclerView实际上是没有任何作用的，那么便可以在左右滑动的时候拦截掉事件，从而不分发给RecyclerView，拦截掉之后，若便会执行parent_layout自身的OnTouchListener中的onTouch事件，在这个事件中做清屏的功能。拦截横滑代码： 123456789101112131415161718192021@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = ev.getRawX(); downY = ev.getRawY(); break; case MotionEvent.ACTION_MOVE: float moveX = ev.getRawX(); float moveY = ev.getRawY(); /** * 如果是横滑，则拦截，用于清屏 * 如果不是则直接将事件传递 */ if (Math.abs(moveX - downX) &gt; Math.abs(moveY - downY)) &#123; return true; &#125; break; &#125; return super.onInterceptTouchEvent(ev);&#125; 设置的OnTouchListener： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class LiveGestureListener extends GestureDetector.SimpleOnGestureListener implements View.OnTouchListener &#123; Context context; GestureDetector gestureDetector; public LiveGestureListener(Context context) &#123; this(context, null); &#125; public LiveGestureListener(Context context, GestureDetector detector) &#123; if (detector == null) &#123; detector = new GestureDetector(context, this); &#125; this.context = context; this.gestureDetector = detector; &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; if (velocityX &gt;= 0) &#123; hideInteractLayout(); &#125; else if (velocityX &lt; 0) &#123; showInteractLayout(); &#125; return super.onFling(e1, e2, velocityX, velocityY); &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return super.onScroll(e1, e2, distanceX, distanceY); &#125; @Override public boolean onSingleTapConfirmed(MotionEvent e) &#123; return super.onSingleTapConfirmed(e); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; // Within the MyGestureListener class you can now manage the event.getAction() codes. // Note that we are now calling the gesture Detectors onTouchEvent. And given we&#x27;ve set this class as the GestureDetectors listener // the onFling, onSingleTap etc methods will be executed. return gestureDetector.onTouchEvent(event); &#125; public GestureDetector getGestureDetector() &#123; return gestureDetector; &#125;&#125; 结合手势在onFling中做了清屏与恢复的功能。 整个页面的空白处布局层次中可以看到top_layout是单独出来的，并且在FrameLayout的顶层。详细说明一下：1、清屏只清屏parent_layout中的内容，top_layout是不需要隐藏的，所以单独提了出来。2、在顶层是为了提前消费事件，FrameLayout接到事件后会优先分发给顶层的孩子，即top_layout，若top_layout消费了，即点击了关闭或者主播信息等有消费事件的View，那么就不算是点击空白处了，事件便不会分发给parent_layout；若top_layout没消费，即点击了空白处，则会将事件分发给parent_layout，parent_layout便是我们自定义的FrameLayout，重写onTouchEvent，执行弹出状态栏的操作便可实现需求。 1234567891011121314151617181920212223242526@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; /** * 若是单纯的点击，并且没有其他View消费事件，则调用onClickEvent（用于显示或隐藏状态栏） */ switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: interceptX = event.getRawX(); interceptY = event.getRawY(); return true; case MotionEvent.ACTION_UP: float moveX = event.getRawX(); float moveY = event.getRawY(); if ((Math.abs(moveX - interceptX) &lt; 20) &amp;&amp; (Math.abs(moveY - interceptY) &lt; 20)) &#123; if (listener != null) &#123; listener.onClickEvent(event); &#125; &#125; break; &#125; return super.onTouchEvent(event);&#125;public interface DealClickEventListener &#123; void onClickEvent(MotionEvent event);&#125; 我们必须在ACTION_DOWN的时候返回true，才会继续收到ACTION_MOVE、ACTION_UP等事件，否则是收不到的。至于为什么，可以参考我之前的一篇博客Android事件分发机制学习小记。我们再ACTION_UP的时候执行我们弹出状态栏的操作即可。 1234567891011holder.interactLayout.setListener(new HorizontalFrameLayout.DealClickEventListener() &#123; @Override public void onClickEvent(MotionEvent event) &#123; if (!isShowing) &#123; showOperation(); &#125; else &#123; handler.removeCallbacks(showOrHide); handler.postDelayed(showOrHide, 5000); &#125; &#125;&#125;); 最后上一下HorizontalFrameLayout的完整代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class HorizontalFrameLayout extends FrameLayout &#123; private float downX; private float downY; private float interceptX; private float interceptY; private DealClickEventListener listener; public HorizontalFrameLayout(Context context) &#123; super(context); &#125; public HorizontalFrameLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public HorizontalFrameLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setListener(DealClickEventListener listener) &#123; this.listener = listener; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = ev.getRawX(); downY = ev.getRawY(); break; case MotionEvent.ACTION_MOVE: float moveX = ev.getRawX(); float moveY = ev.getRawY(); /** * 如果是横滑，则拦截，用于清屏 * 如果不是则直接将事件传递 */ if (Math.abs(moveX - downX) &gt; Math.abs(moveY - downY)) &#123; return true; &#125; break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; /** * 若是单纯的点击，并且没有其他View消费事件，则调用onClickEvent（用于显示或隐藏状态栏） */ switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: interceptX = event.getRawX(); interceptY = event.getRawY(); return true; case MotionEvent.ACTION_UP: float moveX = event.getRawX(); float moveY = event.getRawY(); if ((Math.abs(moveX - interceptX) &lt; 20) &amp;&amp; (Math.abs(moveY - interceptY) &lt; 20)) &#123; if (listener != null) &#123; listener.onClickEvent(event); &#125; &#125; break; &#125; return super.onTouchEvent(event); &#125; public interface DealClickEventListener &#123; void onClickEvent(MotionEvent event); &#125;&#125; 题外话在我的另一篇博客一个关于Android滑动“因缺斯厅”的想法中说到一个点，顶部布局采用透明的，那么便会引发一个问题：需要透传关注按钮的点击事件，因为透明布局是在顶部，会拦截掉点击事件，需要透传才能执行关注的响应事件。 123456789101112131415161718192021222324252627282930313233343536373839public class CustomRecyclerView extends RecyclerView &#123; private View view; public CustomRecyclerView(Context context) &#123; super(context); &#125; public CustomRecyclerView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public void setView(View view) &#123; this.view = view; &#125; @Override public boolean onTouchEvent(MotionEvent e) &#123; if (view != null) &#123; final float downX = e.getX(); final float downY = e.getY(); int firstVisiblePosition = ((LinearLayoutManager) getLayoutManager()).findFirstVisibleItemPosition(); if (firstVisiblePosition &gt; 0) &#123; return super.onTouchEvent(e); &#125; else &#123; View c = getLayoutManager().findViewByPosition(0); int top = c.getTop(); float scrollY = -top; if (downX &gt;= view.getLeft() &amp;&amp; downX &lt;= view.getRight() &amp;&amp; downY &lt;= view.getBottom() &amp;&amp; downY &gt;= view.getTop() &amp;&amp; scrollY &lt; view.getHeight()) &#123; return false; &#125; else &#123; return super.onTouchEvent(e); &#125; &#125; &#125; return super.onTouchEvent(e); &#125;&#125; 通过调用setView设置需要透传的View，通过判断点击的位置是否在View的范围内，以及RecyclerView滑动的高度是否已经高过关注按钮的高度，通过返回false，便可以将事件透传下去了。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android状态栏小记","date":"2016-08-04T06:29:46.000Z","path":"2016/08/04/statusbar/","text":"最近做了一个需求：在全屏看视频的时候，点击空白处，显示状态栏。距离最后一次点击5秒后，自动收起状态栏。最后做出的效果如下图： 状态栏显示与隐藏首先状态栏的显示与隐藏代码如下： 1234567891011121314151617181920212223242526272829303132333435363738private void showOperation() &#123; isShowing = true; handler.removeCallbacks(showOrHide); handler.postDelayed(showOrHide, 5000); // 显示状态栏 WindowManager.LayoutParams attr = getWindow().getAttributes(); attr.flags &amp;= (~WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().setAttributes(attr); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); top.setTranslationY(getStatusBarHeight());&#125;/** * 获取状态栏高度 */public int getStatusBarHeight() &#123; int result = 0; int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; result = getResources().getDimensionPixelSize(resourceId); &#125; return result;&#125;/** * 隐藏状态栏 */private void hideOperation() &#123; isShowing = false; // 隐藏状态栏 WindowManager.LayoutParams lp = getWindow().getAttributes(); lp.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN; getWindow().setAttributes(lp); getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS); top.setTranslationY(0);&#125; 使用handler来进行自动收起，在每次有效操作时，刷新时间重新数5秒。 123456789private Runnable showOrHide = new Runnable() &#123; @Override public void run() &#123; hideOperation(); &#125;&#125;;handler.removeCallbacks(showOrHide);handler.postDelayed(showOrHide, 5000); 全屏透明状态栏首先在Application的Theme里，我进行的如下配置： 123456789&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/live_gray_bg&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 整个App所有界面都是FullScreen的，colorPrimaryDark是状态栏的颜色，我这里设置的是#4d000000，一个带透明度的黑色,该属性只在android5.0及以上有效。然后在activity的onCreate里，在setContentView()之前，调用如下代码： 12345if (Build.VERSION.SDK_INT &gt; 16) &#123; getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_LAYOUT_FLAGS | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);&#125; 针对View的各种FLAG这里列一下说明： View.SYSTEM_UI_FLAG_VISIBLE：显示状态栏，Activity不全屏显示(恢复到有状态的正常情况)； View.INVISIBLE：隐藏状态栏，同时Activity会伸展全屏显示； View.SYSTEM_UI_FLAG_FULLSCREEN：Activity全屏显示，且状态栏被隐藏覆盖掉； View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN：Activity全屏显示，但状态栏不会被隐藏覆盖，状态栏依然可见，Activity顶端布局部分会被状态遮住； View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION：效果同View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN； View.SYSTEM_UI_LAYOUT_FLAGS：效果同View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN； View.SYSTEM_UI_FLAG_HIDE_NAVIGATION：隐藏虚拟按键(导航栏)。有些手机会用虚拟按键来代替物理按键； View.SYSTEM_UI_FLAG_LOW_PROFILE：状态栏显示处于低能显示状态(low profile模式)，状态栏上一些图标显示会被隐藏。 状态栏显示时布局调整通过上面的代码，这样整个状态栏就是按照我设置的颜色来显示了，他会直接覆盖在我们的布局上。那么问题来了，当状态栏显示的时候，他会盖在我们的布局上，那么如果布局顶部有View，那么就会被遮盖住，要如何解决呢？网上查了很多，说是在activity的根布局设置属性android:fitsSystemWindows=&quot;true&quot;，确实，设置后就不会遮盖在布局了，但是它会单独占据空间，设置的半透明的黑色背景也无作用了，另外界面会被压缩，然后屏幕会跳一下。发个图感受一下：可以看到界面会跳，而且视频这种具有一定长宽比的可能会自适应，导致黑边，所以这不是一个解决方案，所以我没有添加这个属性。那么到底要怎么解决呢？其实是一个很笨的方法，上面的代码已经写到了：在状态栏显示的时候，直接将被挡住的View下移。即上面代码中的： 12top.setTranslationY(getStatusBarHeight());top.setTranslationY(0); 在这里也可以添加动画，使效果更柔和一点。 疑问在android4.4上达不到半透明这样的效果，设置的colorPrimaryDark是不起作用的，他会是一整个黑条（黑色和rom有关吧），看起来效果就会差一些了，不知道该要怎么解决，望了解的朋友可以指导一下~Tip：找到很多修改颜色的文章，但是都是用到了android:fitsSystemWindows=&quot;true&quot;属性，故不是我的解决方案~","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"TextView使用小记","date":"2016-07-26T02:46:16.000Z","path":"2016/07/26/textview/","text":"相信TextView是Android最常见的控件了，在日常使用中也有一些“心得”，这里记录一下。 格式化有些时候需要在一个TextView上显示不同字体格式的内容，比如说一段黑色，一段灰色的内容，又或者字体一大一小的内容，要实现这样的效果有2种方式： 使用SpannableString123SpannableString spanString = new SpannableString(&quot;Hello world!&quot;);ForegroundColorSpan span = new ForegroundColorSpan(getResources().getColor(R.color.black));spanString.setSpan(span, 0, 5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); 使用Html format12String text = &quot;&lt;font color=&#x27;black&#x27;&gt;Hello:&lt;/font&gt;&quot; + &quot;world!&quot;;content.setText(Html.fromHtml(text), TextView.BufferType.SPANNABLE); 两种方式都是可以的，但是第2种方式会导致TextView设置maxLines=&quot;3&quot;、ellipsize=&quot;end&quot;的情况下，文本超过3行的时候不显示...提示符了。所以在有...的需求的时候建议还是使用第一种。 字的行间距如果内容过多是会换行的，要设置行间距可以如下设置： android:lineSpacingExtra设置行间距，如”3dp”。 android:lineSpacingMultiplier设置行间距的倍数，如”1.2”。 占位符有些时候一段字符大部分是固定的，只有一两位是变化的，那么可以在strings.xml中进行如下配置： 12&lt;string name=&quot;barrage_reward&quot;&gt;%1$s打赏了主播的专辑&lt;/string&gt;&lt;string name=&quot;living_view_count&quot;&gt;%1$d人观看&lt;/string&gt; 1%代表第一个占位符，$s代表字符占位，$d代表数字占位。然后在设置的时候，用真实的数据替换掉占位符即可。 12textView.setText(getResources().getString(R.string.barrage_reward, &quot;Jay&quot;));textView.setText(getResources().getString(R.string.living_view_count, 10)); FontMetricsFontMetrics意为字体测量。 123456789101112131415161718192021222324public static class FontMetrics &#123; /** * The maximum distance above the baseline for the tallest glyph in * the font at a given text size. */ public float top; /** * The recommended distance above the baseline for singled spaced text. */ public float ascent; /** * The recommended distance below the baseline for singled spaced text. */ public float descent; /** * The maximum distance below the baseline for the lowest glyph in * the font at a given text size. */ public float bottom; /** * The recommended additional space to add between lines of text. */ public float leading; &#125; 这五个属性分别是什么呢？看如下的图便能一目了然了：","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android高斯模糊","date":"2016-07-21T02:49:43.000Z","path":"2016/07/21/blur/","text":"高斯模糊的工具类，摘录下来，免得以后找不着了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254/** * 高斯模糊 * @param context * @param sentBitmap * @param radius 0 &lt; radius &lt;= 25 * @return */@SuppressLint(&quot;NewApi&quot;)public static Bitmap fastBlur(Context context, Bitmap sentBitmap, int radius) &#123; if (Build.VERSION.SDK_INT &gt; 16) &#123; Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true); final RenderScript rs = RenderScript.create(context); final Allocation input = Allocation.createFromBitmap(rs, sentBitmap, Allocation.MipmapControl.MIPMAP_NONE, Allocation.USAGE_SCRIPT); final Allocation output = Allocation.createTyped(rs, input.getType()); final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); script.setRadius(radius); script.setInput(input); script.forEach(output); output.copyTo(bitmap); return bitmap; &#125; // Stack Blur v1.0 from // http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html // // Java Author: Mario Klingemann &lt;mario at quasimondo.com&gt; // http://incubator.quasimondo.com // created Feburary 29, 2004 // Android port : Yahel Bouaziz &lt;yahel at kayenko.com&gt; // http://www.kayenko.com // ported april 5th, 2012 // This is a compromise between Gaussian Blur and Box blur // It creates much better looking blurs than Box Blur, but is // 7x faster than my Gaussian Blur implementation. // // I called it Stack Blur because this describes best how this // filter works internally: it creates a kind of moving stack // of colors whilst scanning through the image. Thereby it // just has to add one new block of color to the right side // of the stack and remove the leftmost color. The remaining // colors on the topmost layer of the stack are either added on // or reduced by one, depending on if they are on the right or // on the left side of the stack. // // If you are using this algorithm in your code please add // the following line: // // Stack Blur Algorithm by Mario Klingemann &lt;mario@quasimondo.com&gt; Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true); if (radius &lt; 1) &#123; return (null); &#125; int w = bitmap.getWidth(); int h = bitmap.getHeight(); int[] pix = new int[w * h]; bitmap.getPixels(pix, 0, w, 0, 0, w, h); int wm = w - 1; int hm = h - 1; int wh = w * h; int div = radius + radius + 1; int r[] = new int[wh]; int g[] = new int[wh]; int b[] = new int[wh]; int rsum, gsum, bsum, x, y, i, p, yp, yi, yw; int vmin[] = new int[Math.max(w, h)]; int divsum = (div + 1) &gt;&gt; 1; divsum *= divsum; int dv[] = new int[256 * divsum]; for (i = 0; i &lt; 256 * divsum; i++) &#123; dv[i] = (i / divsum); &#125; yw = yi = 0; int[][] stack = new int[div][3]; int stackpointer; int stackstart; int[] sir; int rbs; int r1 = radius + 1; int routsum, goutsum, boutsum; int rinsum, ginsum, binsum; for (y = 0; y &lt; h; y++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; for (i = -radius; i &lt;= radius; i++) &#123; p = pix[yi + Math.min(wm, Math.max(i, 0))]; sir = stack[i + radius]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rbs = r1 - Math.abs(i); rsum += sir[0] * rbs; gsum += sir[1] * rbs; bsum += sir[2] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; &#125; stackpointer = radius; for (x = 0; x &lt; w; x++) &#123; r[yi] = dv[rsum]; g[yi] = dv[gsum]; b[yi] = dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (y == 0) &#123; vmin[x] = Math.min(x + radius + 1, wm); &#125; p = pix[yw + vmin[x]]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[(stackpointer) % div]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi++; &#125; yw += w; &#125; for (x = 0; x &lt; w; x++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; yp = -radius * w; for (i = -radius; i &lt;= radius; i++) &#123; yi = Math.max(0, yp) + x; sir = stack[i + radius]; sir[0] = r[yi]; sir[1] = g[yi]; sir[2] = b[yi]; rbs = r1 - Math.abs(i); rsum += r[yi] * rbs; gsum += g[yi] * rbs; bsum += b[yi] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; if (i &lt; hm) &#123; yp += w; &#125; &#125; yi = x; stackpointer = radius; for (y = 0; y &lt; h; y++) &#123; // Preserve alpha channel: ( 0xff000000 &amp; pix[yi] ) pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (x == 0) &#123; vmin[y] = Math.min(y + r1, hm) * w; &#125; p = x + vmin[y]; sir[0] = r[p]; sir[1] = g[p]; sir[2] = b[p]; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[stackpointer]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi += w; &#125; &#125; bitmap.setPixels(pix, 0, w, 0, 0, w, h); return (bitmap);&#125;","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Andoird开发中适配小记","date":"2016-07-21T01:59:06.000Z","path":"2016/07/21/android-adapter/","text":"Android也做了一段时间了，做的项目也经历过大大小小的测试，这里把一些适配的实际情形写下来，方便日后查阅，后面会持续更新。主要记录一些适配的实际情形，至于使用.9图、dp单位这类适配就不说了。 适配虚拟按键部分手机会有虚拟按键，会占用屏幕的一定空间，当我们的界面布局存在“硬编码”的时候（固定写死多少dp），就可能导致界面显示出问题。可以通过如下方法来判断是否有虚拟按键： 1234567891011121314151617181920212223242526/** * 是否有虚拟按键 * * @return */public static boolean checkDeviceHasNavigationBar(Context context) &#123; boolean hasNavigationBar = false; Resources rs = context.getResources(); int id = rs.getIdentifier(&quot;config_showNavigationBar&quot;, &quot;bool&quot;, &quot;android&quot;); if (id &gt; 0) &#123; hasNavigationBar = rs.getBoolean(id); &#125; try &#123; Class systemPropertiesClass = Class.forName(&quot;android.os.SystemProperties&quot;); Method m = systemPropertiesClass.getMethod(&quot;get&quot;, String.class); String navBarOverride = (String) m.invoke(systemPropertiesClass, &quot;qemu.hw.mainkeys&quot;); if (&quot;1&quot;.equals(navBarOverride)) &#123; hasNavigationBar = false; &#125; else if (&quot;0&quot;.equals(navBarOverride)) &#123; hasNavigationBar = true; &#125; &#125; catch (Exception e) &#123; &#125; return hasNavigationBar;&#125; 然后通过如下方法获取虚拟按键的高度： 12345678910111213/** * 获取虚拟按键的高度 * * @return */public int getNavigationBarHeight() &#123; Resources resources = context.getResources(); int resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; return resources.getDimensionPixelSize(resourceId); &#125; return 0;&#125; 获得到高度之后，便能代码控制之前的“硬编码”了，依情况减去或者加上虚拟按键的高度便可以解决这类问题的适配的。示例如下： 1234567// 如果有虚拟按键，则加上虚拟按键的高度if (checkDeviceHasNavigationBar(context)) &#123; int navigationBarHeight = getNavigationBarHeight(); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) holder.root.getLayoutParams(); params.bottomMargin = (int) (context.getResources().getDimension(R.dimen.minus_living_card_height) - navigationBarHeight); holder.root.setLayoutParams(params);&#125; 当然你也可以简单粗暴的隐藏掉虚拟按键。代码如下： 12345678View decorView = getWindow().getDecorView();decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar | View.SYSTEM_UI_FLAG_IMMERSIVE); Android4.4横屏弹出的对话框顶部被状态栏遮盖效果就像这样：初步感觉是Android4.4的一个BUG，可以在Dialog创建的时候，添加如下代码来解决问题： 123456789/** * 针对Android 4.4在横屏下顶部被状态栏遮挡的问题 * 暂没有4.4以下的手机进行测试 */if (Build.VERSION.SDK_INT == 19) &#123; mWindow.setFlags( WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);&#125; 联想K3 Note中GridView自带分隔线效果就像这样：在GridViewz中添加horizontalSpacing、verticalSpacing2条属性来解决问题： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;CustomGridView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:horizontalSpacing=&quot;0dp&quot; android:listSelector=&quot;@color/transparent&quot; android:numColumns=&quot;3&quot; android:scrollbars=&quot;none&quot; android:verticalSpacing=&quot;0dp&quot; /&gt; VideoView切换横竖屏VideoView在切换横竖屏，如果是Activity跳转，那么就会重新加载，导致切换前后不连贯。所以我的做法是：只有一个Activity，点击全屏按钮将其置为横屏状态，每次切换的时候，显示一套布局，隐藏一套布局。配置activity的android:configChanges=&quot;orientation|screenSize&quot;，这样在切换的时候就不会重新布局，然后在onConfigurationChanged中进行相关操作： 12345678910111213@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; /** * 适配部分机型在旋转的时候，视频尺寸没有自适应的问题 */ videoView.getHolder().setFixedSize(videoView.getWidth(), videoView.getHeight()); if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; // 横屏时隐藏竖屏布局 &#125; else &#123; // 竖屏时隐藏横屏布局 &#125; super.onConfigurationChanged(newConfig);&#125; 但是在部分机型会导致切换后视屏尺寸没有自适应，如图：利用如上代码videoView.getHolder().setFixedSize(videoView.getWidth(), videoView.getHeight());即可解决问题。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android屏幕横竖屏切换小记","date":"2016-07-01T09:22:25.000Z","path":"2016/07/01/about-screen/","text":"最后做的项目中，有用到横竖屏切换，碰到个小坑，在这里记录一下。 背景：用户在进入直播页面（姑且称之为RoomActivity），进入页面的时候会传入横竖屏的参数，在RoomActivity中拿到参数通过setRequestedOrientation来进行设置横竖屏。 众所周知，android在横竖屏切换的时候，会销毁当前的页面，然后重建，导致的便是activity的生命周期会执行2次，那么写在其中的方法也会执行2次。在onStart()中我写了进入直播间的方法(enterRoom())，在onStop()中写了离开直播间的方法(exitRoom())，那么在切换屏幕的时候，会调用2次enterRoom，1次exitRoom，因为都是网络请求，不能保证后请求的一定后完成，那么就有可能导致2次enterRoom执行完成之后，exitRoom才执行完成，即用户发了2次进入直播间的请求，1次离开直播间的请求，离开的请求是最后完成，导致的最终结果便是用户不在直播间了，但他依然能看到画面，只不过看不到弹幕相关的一些东西了。 这显然是个问题，需要解决。 方案一：起初，我的想法是在切换的时候保存状态，在新建的时候取出状态，根据状态来判断要不要执行第二次方法，这种想法应该是可行的，但是我找不到保存状态的方法。网上查的是onSaveInstanceState()方法可用来保存，但是它只会在activity意外关闭的时候才会调用，何为意外就不得知了，有点不可控，所以我便放弃了这种做法。 方案二：设置activty参数，避免销毁当前页面重建。在设置configChanges参数后，在切换横竖屏时候便不会重建页面了，那么当前页面或得到的业务数据也自然就还在，只是要强调一点：切换横竖屏后，所有的View需要重新进行初始化。在AndroidManifest.xml中给activity设置如下configChanges参数： 123456&lt;activity android:name=&quot;.RoomActivity&quot; android:screenOrientation=&quot;portrait&quot; android:keepScreenOn=&quot;true&quot; android:configChanges=&quot;orientation|screenSize&quot; android:windowSoftInputMode=&quot;adjustNothing&quot;/&gt; 然后在activity的onConfigurationChanged中进行view的初始化。 1234567@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; setContentView(R.layout.activity_room); initViewHolder(); initBarrageView(); super.onConfigurationChanged(newConfig);&#125; 之所以会重新调用setContentView(R.layout.activity_room);是因为我的RoomActivity有横、竖两套布局，需要重新设置一下（布局名称名字一样，横屏的布局文件写在land文件下即可）。 如此便解决了横竖屏切换导致的问题了，特此小记一下。 补充：Android横屏切换可能有2种：90度和270度。这两种都是横屏。现在做直播产品，需要设置摄像头的角度，所以不仅仅需要知道横竖屏，也需要知道横屏是90度的那种还是270度的那种。如果仅仅依靠重力感应，部分安卓手机会不支持180度转屏，以致于从90度转到270度或者从270度转到90度时，系统认为界面没有发生变化，所以没有合适的机会来设置摄像头的角度。采用DisplayManager.DisplayListener可以达到目的，但是必须是Android 17以上，这就需要依据项目情况来做些取舍了。 1234567891011121314151617181920212223242526272829303132333435363738394041private void initDisplayListener() &#123; /** * 部分安卓手机不支持180度转屏，以致于从90度转到270度或者从270度转到90度时，系统认为界面没有发生变化 * Android 17及以上可以通过DisplayManager.DisplayListener来监听手机旋转，以解决这个问题 */ if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; mDisplayListener = new DisplayManager.DisplayListener() &#123; @Override public void onDisplayAdded(int displayId) &#123; &#125; @Override public void onDisplayChanged(int displayId) &#123; changeRotation(); &#125; @Override public void onDisplayRemoved(int displayId) &#123; &#125; &#125;; DisplayManager displayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE); displayManager.registerDisplayListener(mDisplayListener, null); &#125;&#125;private void changeRotation() &#123; switch (getWindowManager().getDefaultDisplay().getRotation()) &#123; case Surface.ROTATION_0: // 0度 break; case Surface.ROTATION_90: // 90度 break; case Surface.ROTATION_180: // 180度 break; case Surface.ROTATION_270: // 270度 break; &#125;&#125; 参考： Activity 横竖屏切换 Android 横竖屏切换小结","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"从谷歌官方TODO-MVP看MVP模式","date":"2016-06-27T07:47:01.000Z","path":"2016/06/27/mvp/","text":"前言很早之前就听说过android MVP的模式，也看过许许多多的文章，但是众说纷纭，每个人有每个人的理解，如果光看，可能并不能很深刻的理解。但是作为android界的权威，Google出了一个MVP的官方例子。若是从这个例子来看MVP模式，或许会有不一样的感悟呢？多说无益，下面开始。 代码准备Github上打开googlesamples&#x2F;android-architecture，打开分支，选择todo-mvp（Basic Model-View-Presenter architecture），然后下载zip，解压后导入到AS中。 代码分析首先贴一张官方的MVP示意图：在分析代码之前，我们先简单的运行一下App，大致有一个感觉，App里有哪些功能。ok，下面进入到代码里，先上一下代码结构图：可以看到分包是根据模块进行的分包，通过gif图大概可以知道分为添加（编辑）、统计、详情、主页List。本文只为了分析mvp的使用，所以我选取最简单的AddEditTask来进行分析。 MM主要是位于data包下面的类，Task是基本的bean，涉及到数据的相关操作由接口TasksDataSource体现。 1234567891011121314151617181920212223242526272829303132333435363738public interface TasksDataSource &#123; interface LoadTasksCallback &#123; void onTasksLoaded(List&lt;Task&gt; tasks); void onDataNotAvailable(); &#125; interface GetTaskCallback &#123; void onTaskLoaded(Task task); void onDataNotAvailable(); &#125; void getTasks(@NonNull LoadTasksCallback callback); void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback); void saveTask(@NonNull Task task); void completeTask(@NonNull Task task); void completeTask(@NonNull String taskId); void activateTask(@NonNull Task task); void activateTask(@NonNull String taskId); void clearCompletedTasks(); void refreshTasks(); void deleteAllTasks(); void deleteTask(@NonNull String taskId);&#125; V首先是V的基类： 12345public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; 然后看到AddEditTaskContract: 12345678910111213141516171819202122public interface AddEditTaskContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void showEmptyTaskError(); void showTasksList(); void setTitle(String title); void setDescription(String description); boolean isActive(); &#125; interface Presenter extends BasePresenter &#123; void saveTask(String title, String description); void populateTask(); &#125;&#125; 这个类将V、P整合在了一起，这样做的好处是可以很方便的看到V、P都有哪些方法，方便后面修改。其中的View则是BaseView的下一层接口，它定义了View相关的一些方法。 PP的基类： 12345public interface BasePresenter &#123; void start();&#125; 然后在AddEditTaskContract中我们也可以看到P的具体声明。 MVP综合分析MVP大致的代码便是如此了，下面来看具体的实现。在AddEditTaskActivity的onCreate()方法中，我们重点看到这一句代码： 1234new AddEditTaskPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment); 可以知道，这句代码便是创建具体的P了。来看下一下AddEditTaskPresenter的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * Listens to user actions from the UI (&#123;@link AddEditTaskFragment&#125;), retrieves the data and updates * the UI as required. */public class AddEditTaskPresenter implements AddEditTaskContract.Presenter, TasksDataSource.GetTaskCallback &#123; @NonNull private final TasksDataSource mTasksRepository; @NonNull private final AddEditTaskContract.View mAddTaskView; @Nullable private String mTaskId; /** * Creates a presenter for the add/edit view. * * @param taskId ID of the task to edit or null for a new task * @param tasksRepository a repository of data for tasks * @param addTaskView the add/edit view */ public AddEditTaskPresenter(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView) &#123; mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository); mAddTaskView = checkNotNull(addTaskView); mAddTaskView.setPresenter(this); &#125; @Override public void start() &#123; if (!isNewTask()) &#123; populateTask(); &#125; &#125; @Override public void saveTask(String title, String description) &#123; if (isNewTask()) &#123; createTask(title, description); &#125; else &#123; updateTask(title, description); &#125; &#125; @Override public void populateTask() &#123; if (isNewTask()) &#123; throw new RuntimeException(&quot;populateTask() was called but task is new.&quot;); &#125; mTasksRepository.getTask(mTaskId, this); &#125; @Override public void onTaskLoaded(Task task) &#123; // The view may not be able to handle UI updates anymore if (mAddTaskView.isActive()) &#123; mAddTaskView.setTitle(task.getTitle()); mAddTaskView.setDescription(task.getDescription()); &#125; &#125; @Override public void onDataNotAvailable() &#123; // The view may not be able to handle UI updates anymore if (mAddTaskView.isActive()) &#123; mAddTaskView.showEmptyTaskError(); &#125; &#125; private boolean isNewTask() &#123; return mTaskId == null; &#125; private void createTask(String title, String description) &#123; Task newTask = new Task(title, description); if (newTask.isEmpty()) &#123; mAddTaskView.showEmptyTaskError(); &#125; else &#123; mTasksRepository.saveTask(newTask); mAddTaskView.showTasksList(); &#125; &#125; private void updateTask(String title, String description) &#123; if (isNewTask()) &#123; throw new RuntimeException(&quot;updateTask() was called but task is new.&quot;); &#125; mTasksRepository.saveTask(new Task(title, description, mTaskId)); mAddTaskView.showTasksList(); // After an edit, go back to the list. &#125;&#125; 我们通过其构造函数，传入了一个addEditTaskFragment对象，通过其构造函数的方法，我们可以猜测：AddEditTaskFragment便是具体的V了。并且注意mAddTaskView.setPresenter(this);这句代码，即是在P创建的时候，V、P便实现了绑定。看到AddEditTaskFragment代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class AddEditTaskFragment extends Fragment implements AddEditTaskContract.View &#123; public static final String ARGUMENT_EDIT_TASK_ID = &quot;EDIT_TASK_ID&quot;; private AddEditTaskContract.Presenter mPresenter; private TextView mTitle; private TextView mDescription; public static AddEditTaskFragment newInstance() &#123; return new AddEditTaskFragment(); &#125; public AddEditTaskFragment() &#123; // Required empty public constructor &#125; @Override public void onResume() &#123; super.onResume(); mPresenter.start(); &#125; @Override public void setPresenter(@NonNull AddEditTaskContract.Presenter presenter) &#123; mPresenter = checkNotNull(presenter); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); FloatingActionButton fab = (FloatingActionButton) getActivity().findViewById(R.id.fab_edit_task_done); fab.setImageResource(R.drawable.ic_done); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mPresenter.saveTask(mTitle.getText().toString(), mDescription.getText().toString()); &#125; &#125;); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View root = inflater.inflate(R.layout.addtask_frag, container, false); mTitle = (TextView) root.findViewById(R.id.add_task_title); mDescription = (TextView) root.findViewById(R.id.add_task_description); setHasOptionsMenu(true); setRetainInstance(true); return root; &#125; @Override public void showEmptyTaskError() &#123; Snackbar.make(mTitle, getString(R.string.empty_task_message), Snackbar.LENGTH_LONG).show(); &#125; @Override public void showTasksList() &#123; getActivity().setResult(Activity.RESULT_OK); getActivity().finish(); &#125; @Override public void setTitle(String title) &#123; mTitle.setText(title); &#125; @Override public void setDescription(String description) &#123; mDescription.setText(description); &#125; @Override public boolean isActive() &#123; return isAdded(); &#125;&#125; 通过前面的gif图，可以猜测P中必定是有一个保存Task的方法，即saveTask方法，在我们点击悬浮按钮的时候会触发。即我们的操作（业务逻辑相关）会由P来执行。看到P中saveTask的具体实现，他会判断当前是否是一个新任务，若是则调用createTask创建新的Task，若标题与内容都为空，则会回调V的showEmptyTaskError方法来显示相关的UI，若不为空，则执行M的操作：mTasksRepository.saveTask(newTask);保存相应的数据，然后回调V的showTasksList方法来显示相关UI。若不是一个新的Task（编辑），则调用updateTask，执行M操作mTasksRepository.saveTask来操作数据。至此，一个完整的业务操作（新建或编辑一个新的Task）分析完毕。可以看到在V中，我们只调用P的相关的接口，然后实现上层V的接口就可以了。由P来调用M中的方法，来操作数据，然后通过回调来使V展示相应的界面。V与M完全分离，整套业务都由P来执行。最后上一张分析图： MVP的优缺点优点： 解耦。实现了Model和View真正的完全分离，再也不是Activity中一大坨代码了。 清晰。模块职责划分明显，层次清晰。 测试。在使用MVP的项目中Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过模拟一个View对象，这个对象只需要实现了View的接口即可。然后注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。 组件化。在MVP当中，View不依赖Model，这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知，它只需要提供一系列接口提供给上层操作，这样就可以做到高度可复用的View组件。 缺点： 新增很多接口类，额外的代码复杂度及学习成本。 Presenter中除了业务逻辑以外，可能还有大量的与业务无关的数据操作逻辑，会导致Presenter比较臃肿。 测试在代码中，Google已经写好了测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class AddEditTaskPresenterTest &#123; @Mock private TasksRepository mTasksRepository; @Mock private AddEditTaskContract.View mAddEditTaskView; /** * &#123;@link ArgumentCaptor&#125; is a powerful Mockito API to capture argument values and use them to * perform further actions or assertions on them. */ @Captor private ArgumentCaptor&lt;TasksDataSource.GetTaskCallback&gt; mGetTaskCallbackCaptor; private AddEditTaskPresenter mAddEditTaskPresenter; @Before public void setupMocksAndView() &#123; // Mockito has a very convenient way to inject mocks by using the @Mock annotation. To // inject the mocks in the test the initMocks method needs to be called. MockitoAnnotations.initMocks(this); // The presenter wont&#x27;t update the view unless it&#x27;s active. when(mAddEditTaskView.isActive()).thenReturn(true); &#125; @Test public void saveNewTaskToRepository_showsSuccessMessageUi() &#123; // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(&quot;1&quot;, mTasksRepository, mAddEditTaskView); // When the presenter is asked to save a task mAddEditTaskPresenter.saveTask(&quot;New Task Title&quot;, &quot;Some Task Description&quot;); // Then a task is saved in the repository and the view updated verify(mTasksRepository).saveTask(any(Task.class)); // saved to the model verify(mAddEditTaskView).showTasksList(); // shown in the UI &#125; @Test public void saveTask_emptyTaskShowsErrorUi() &#123; // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(null, mTasksRepository, mAddEditTaskView); // When the presenter is asked to save an empty task mAddEditTaskPresenter.saveTask(&quot;&quot;, &quot;&quot;); // Then an empty not error is shown in the UI verify(mAddEditTaskView).showEmptyTaskError(); &#125; @Test public void saveExistingTaskToRepository_showsSuccessMessageUi() &#123; // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(&quot;1&quot;, mTasksRepository, mAddEditTaskView); // When the presenter is asked to save an existing task mAddEditTaskPresenter.saveTask(&quot;New Task Title&quot;, &quot;Some Task Description&quot;); // Then a task is saved in the repository and the view updated verify(mTasksRepository).saveTask(any(Task.class)); // saved to the model verify(mAddEditTaskView).showTasksList(); // shown in the UI &#125; @Test public void populateTask_callsRepoAndUpdatesView() &#123; Task testTask = new Task(&quot;TITLE&quot;, &quot;DESCRIPTION&quot;); // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(testTask.getId(), mTasksRepository, mAddEditTaskView); // When the presenter is asked to populate an existing task mAddEditTaskPresenter.populateTask(); // Then the task repository is queried and the view updated verify(mTasksRepository).getTask(eq(testTask.getId()), mGetTaskCallbackCaptor.capture()); // Simulate callback mGetTaskCallbackCaptor.getValue().onTaskLoaded(testTask); verify(mAddEditTaskView).setTitle(testTask.getTitle()); verify(mAddEditTaskView).setDescription(testTask.getDescription()); &#125;&#125; 来执行一下吧：可以看到测试成功。那么假设我们采用传统的开发模式，代码全在Activity里，要怎么样测试呢？噢，想想就觉得头大了，是吗？ 总结通过此次Google官方例子的学习分析，让我对MVP模式有了更清晰的认识，并且我认为MVP模式的实用性很高。虽然它增加了额外的代码，但是它带来的好处是不言而喻的。在今后的开发中，我想我会尝试着使用它。","tags":[{"name":"技术思路","slug":"技术思路","permalink":"http://lijia92.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%B7%AF/"}]},{"title":"Retrofit初识","date":"2016-06-23T07:33:45.000Z","path":"2016/06/23/retrofit/","text":"前言在这个技术日新月累的今天，各种新的轮子层出不穷。网络这块，从HttpClient到android-async-http，再到Volley。当下比较火的网络框架Retrofit也是受到了很多开发者的热爱。虽然项目中并没有使用到Retrofit，但抱着学习的态度，我还是打算接触一下，算是有个了解。说不定后面的开发中会用到呢？ Retrofit概述Retrofit是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是Retrofit来完成的。Retrofit 2.0开始内置OkHttp，前者专注于接口的封装，后者专注于网络请求的高效，二者分工协作。我们的应用程序通过Retrofit请求网络，实际上是使用Retrofit接口层封装请求参数、Header、Url等信息，之后由OkHttp完成后续的请求操作，在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，后者根据用户的需求对结果进行解析的过程。所谓Retrofit，其实就是Retrofitting OkHttp了。 Hello Retrofit废话不多说，直接撸代码。 新建项目，添加依赖： 12compile &#x27;com.squareup.retrofit2:retrofit:2.1.0&#x27; //Retrofit2所需要的包compile &#x27;com.squareup.retrofit2:converter-scalars:2.1.0&#x27; //ConverterFactory的String依赖包 我找了一个天气API，用作示例中的网络请求。 1http://weatherapi.market.xiaomi.com/wtr-v2/temp/realtime?cityId=101010100 101010100代表的是北京市，这个接口会返回北京的实时天气。 OK，下面开始写请求的API了。 定义如下接口： 1234public interface RequestService &#123; @GET(&quot;realtime&quot;) Call&lt;String&gt; getString(@Query(&quot;cityId&quot;) String cityId);&#125; 然后在Activity中添加代码： 1234567891011121314151617181920212223button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://weatherapi.market.xiaomi.com/wtr-v2/temp/&quot;) .addConverterFactory(ScalarsConverterFactory.create()) .build(); RequestService requestService = retrofit.create(RequestService.class); Call&lt;String&gt; call = requestService.getString(&quot;101010100&quot;); call.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; Log.e(&quot;TAG&quot;, &quot;成功：&quot; + response.body().toString()); &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; Log.e(&quot;TAG&quot;, &quot;失败&quot;); &#125; &#125;); &#125;&#125;); 运行代码，点击按钮。会发现Log中有如下的Log： 可见，网络请求成功。 相关说明 Retrofit支持的协议包括GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;HEAD&#x2F;PATCH，当然你也可以直接用HTTP来自定义请求,这些协议均以注解的形式进行配置。 使用ScalarsConverterFactory可使返回值转化成String。 Retrofit使用@Query来添加请求参数，示例中发送的请求实际就是http://weatherapi.market.xiaomi.com/wtr-v2/temp/realtime?cityId=101010100，通过@Query添加了cityId参数。 Retrofit还有@path注解，直接与baseUrl整合成一个完整的请求。举个例子，采用相对路径：12path = &quot;apath&quot;，baseUrl = &quot;http://host:port/a/b/&quot;那么最后发送的请求 url = &quot;http://host:port/a/b/apath&quot; 当然，Retrofit还有很多功能以及用法，以及背后它为什么如此受宠的原因，都有待慢慢学习。It’s just the beginning！","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"android PopupWindow在控件上方显示","date":"2016-06-02T08:26:54.000Z","path":"2016/06/02/popupwindow/","text":"项目中有这样一个需求： 用户点击送礼物，会弹出一个礼物选择对话框，然后在选择一个礼物之后，可以选择礼物数量，按照图中的意思，选择数量很自然的想到了用PopupWindow来做了。但是这里有一个问题就是：弹出来的数量选择框是需要在数量显示栏的上方的。 如果是在下方，那很简单，直接popupWindow.showAsDropDown(v);即可。但若是在上方，则需要自己计算坐标了，然后通过showAtLocation()方法来显示。 首先贴一下大致的布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;com.miamusic.android.live.ui.widget.CertainScaleImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/gift_background&quot; android:visibility=&quot;visible&quot; app:radio=&quot;0.667&quot; /&gt; &lt;com.miamusic.android.live.ui.widget.WrapContentViewPager android:id=&quot;@+id/gift_view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:id=&quot;@+id/gift_recharge_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#000000&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot; android:paddingBottom=&quot;24dp&quot; android:paddingLeft=&quot;16dp&quot; android:paddingRight=&quot;16dp&quot; android:paddingTop=&quot;24dp&quot;&gt; &lt;TextView android:id=&quot;@+id/gift_remain_coin&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:drawablePadding=&quot;2dp&quot; android:drawableRight=&quot;@drawable/m_coin_small&quot; android:minWidth=&quot;24dp&quot; android:textColor=&quot;#C4AF94&quot; android:textSize=&quot;15sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/gift_recharge&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:paddingBottom=&quot;4dp&quot; android:paddingLeft=&quot;8dp&quot; android:paddingTop=&quot;4dp&quot; android:text=&quot;充值 &gt;&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;android.support.v4.widget.Space android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/choose_gift_count&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/follow_button_background&quot; android:gravity=&quot;center&quot; android:paddingBottom=&quot;8dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:paddingTop=&quot;8dp&quot; android:visibility=&quot;visible&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:text=&quot;数量&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/send_gift_count&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:gravity=&quot;left&quot; android:text=&quot;1&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;16dp&quot; android:layout_height=&quot;16dp&quot; android:src=&quot;@drawable/btn_up_white&quot; /&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/gift_send&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;16dp&quot; android:background=&quot;@drawable/reward_album&quot; android:gravity=&quot;center&quot; android:paddingBottom=&quot;8dp&quot; android:paddingTop=&quot;8dp&quot; android:text=&quot;送礼物&quot; android:textColor=&quot;@color/black&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 对应界面的预览如下图： 这里贴一下Android中的坐标体系：根据这个图，再来计算坐标值。 这里我在图中做了一下标注：popupwindow的y坐标应该是1的高度 + 2的高度 - popupwindow的高度。 1的高度即是gift_recharge_layout对应view.getTop()，2的高度即是choose_gift_count对应view.getTop()。 popupwindow的高度，我们通过调用一次measure()方法然后通过getMeasuredHeight()获取。 那么最终popupwindow的y坐标便计算出来了，横坐标的计算比较简单，就不多说了。x、y计算完之后通过showAtLocation进行设置即可。 下面给下示例的片段代码： 1234567891011121314151617181920212223242526272829303132popupParent = (LinearLayout) findViewById(R.id.gift_recharge_layout);chooseCount.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; final View convertView = LayoutInflater.from(mContext).inflate(R.layout.choose_count_popup_window, null); ListView listView = (ListView) convertView.findViewById(R.id.count_list); listView.setAdapter(new CountAdapter()); // 弹出PopupWindow final PopupWindow popupWindow = new PopupWindow(convertView, LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT, true); popupWindow.setTouchable(true); popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable( android.R.color.transparent)); // 执行measure操作，以便后面获取高宽 convertView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED); int x = v.getLeft(); // 对应2的高度 int y1 = v.getTop(); // 对应1的高度 int y2 = popupParent.getTop(); // 设置PopupWindow显示的位置， popupWindow.showAsDropDown(v); popupWindow.showAtLocation(v, Gravity.NO_GRAVITY, x + v.getMeasuredWidth() / 2 - convertView.getMeasuredWidth() / 2, (y1 + y2 - 10) - convertView.getMeasuredHeight()); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; popupWindow.dismiss(); sendCount.setText(counts[position]); &#125; &#125;); &#125;&#125;);","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android实现任务队列：一个入口一个出口、一个入口两个出口","date":"2016-05-27T07:11:25.000Z","path":"2016/05/27/task-queue/","text":"前言在我的Android实现简易轻量下载器：单线程任务队列文章中，有提到过任务队列。当时是需要下载，实现一个简单的单线程任务队列即可。最近项目中也需要用到任务队列，并且有2种需求： 动态礼物动画：在用户送完动态礼物之后，会在界面上展现一个动画。界面上一次最多能执行1个动画，动画按顺序执行。即：一个入口一个出口。 静态礼物动画：在用户送完静态礼物之后，会在界面上展现一个动画。界面上一次最多能并列执行2个动画，动画按顺序执行。即：一个入口两个出口。同样都是任务队列，只不过一个是只有一个出口，另一个有两个出口。 动态礼物动画参照着之前那篇文章，很快就写出来了。动态礼物单体类DynamicGiftModel： 123456789101112131415161718192021222324252627282930313233343536373839404142public class DynamicGiftModel implements GiftModel &#123; private GifImageView gifImageView; private GifDrawable gifDrawable; private DynamicGiftListener listener; public DynamicGiftModel(GifDrawable gifDrawable, GifImageView gifImageView, DynamicGiftListener listener) &#123; this.gifDrawable = gifDrawable; this.gifImageView = gifImageView; this.listener = listener; &#125; @Override public void startAnimation(final GiftAnimationEndListener nextListener) &#123; if (listener != null) &#123; listener.beforeDynamicAnimation(); &#125; gifImageView.setImageDrawable(gifDrawable); gifDrawable.addAnimationListener(new AnimationListener() &#123; @Override public void onAnimationCompleted(int loopNumber) &#123; if (loopNumber == (gifDrawable.getLoopCount() - 1)) &#123; if (listener != null) &#123; listener.afterDynamicAnimation(); &#125; gifDrawable.recycle(); if (nextListener != null) &#123; nextListener.onGiftAnimationEnd(); &#125; &#125; &#125; &#125;); &#125; public interface DynamicGiftListener &#123; void beforeDynamicAnimation(); void afterDynamicAnimation(); &#125;&#125; 动态礼物队列类DynamicGift: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DynamicGift &#123; private static DynamicGift instance = new DynamicGift(); private DynamicGiftExecutor executor; public static DynamicGift getInstance() &#123; if (instance == null) &#123; instance = new DynamicGift(); &#125; return instance; &#125; private DynamicGift() &#123; executor = new DynamicGiftExecutor(); &#125; /** * 动画队列，顺序执行 */ class DynamicGiftExecutor implements GiftAnimationEndListener &#123; final ArrayDeque&lt;DynamicGiftModel&gt; mTasks = new ArrayDeque&lt;&gt;(); DynamicGiftModel mActive; public void execute(final DynamicGiftModel model) &#123; mTasks.offer(model); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; mActive.startAnimation(this); &#125; &#125; @Override public void onGiftAnimationEnd() &#123; scheduleNext(); &#125; &#125; /** * 往队列中添加动画对象 * * @param gifImageView imageView * @param gifDrawable gif图 * @param listener 监听 */ public void addGifAnimation(GifImageView gifImageView, GifDrawable gifDrawable, DynamicGiftModel.DynamicGiftListener listener) &#123; executor.execute(new DynamicGiftModel(gifDrawable, gifImageView, listener)); &#125;&#125; 说明一下：GifImageView就是用来播放gif的ImageView，GifDrawable就是gif对应的drawable，DynamicGiftListener就是动画执行前后的回调。可以看到，我们通过execute()将一个DynamicGiftModel任务放入到队列中，DynamicGiftModel调用startAnimation()便能开始动画了。DynamicGiftExecutor与那篇博客中的类似。只不过我这里做了一些修改：下载中使用的Runnable，他是同步的，在执行完之后会自动去取一下。但是在这里，动画执行是异步的，我在调用完startAnimation()之后就会立即返回，所以需要一个监听（GiftAnimationEndListener）在动画执行完毕之后才去执行scheduleNext()操作，即取下一个任务。GiftAnimationEndListener代码很简单： 123public interface GiftAnimationEndListener &#123; void onGiftAnimationEnd();&#125; 调用如下代码将任务添加到队列便能顺序播放动画了。 1DynamicGift.getInstance().addGifAnimation(gifImageView, gifDrawable, listener); 静态礼物动画静态礼物因为有两个出口，之前没思考过，所以花了一些时间。静态礼物单体类DynamicGiftModel: 123456789101112131415161718192021222324252627282930public class StaticGiftModel implements GiftModel &#123; private StaticGiftListener listener; private PushGift gift; private boolean over; public StaticGiftModel(PushGift gift, StaticGiftListener listener) &#123; this.gift = gift; this.listener = listener; &#125; public boolean isOver() &#123; return over; &#125; public void setOver(boolean over) &#123; this.over = over; &#125; @Override public void startAnimation(final GiftAnimationEndListener nextListener) &#123; if (listener != null) &#123; listener.startStaticAnimation(this, gift, nextListener); &#125; &#125; public interface StaticGiftListener &#123; void startStaticAnimation(StaticGiftModel giftModel, PushGift gift, GiftAnimationEndListener nextListener); &#125;&#125; 静态礼物队列类StaticGift： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class StaticGift &#123; private static StaticGift instance = new StaticGift(); private StaticGiftExecutor executor; public static StaticGift getInstance() &#123; if (instance == null) &#123; instance = new StaticGift(); &#125; return instance; &#125; private StaticGift() &#123; executor = new StaticGiftExecutor(); &#125; /** * 动画队列，2个出口，顺序执行 */ class StaticGiftExecutor implements GiftAnimationEndListener &#123; final ArrayDeque&lt;StaticGiftModel&gt; mTasks = new ArrayDeque&lt;&gt;(); StaticGiftModel mActive1; StaticGiftModel mActive2; public void execute(final StaticGiftModel model) &#123; mTasks.offer(model); if (mActive1 == null) &#123; mActive1 = mTasks.poll(); if (mActive1 != null) &#123; mActive1.startAnimation(this); &#125; &#125; else if (mActive2 == null) &#123; mActive2 = mTasks.poll(); if (mActive2 != null) &#123; mActive2.startAnimation(this); &#125; &#125; &#125; @Override public void onGiftAnimationEnd() &#123; if (mActive1 != null &amp;&amp; mActive1.isOver()) &#123; mActive1 = mTasks.poll(); if (mActive1 != null) &#123; mActive1.startAnimation(this); &#125; &#125; if (mActive2 != null &amp;&amp; mActive2.isOver()) &#123; mActive2 = mTasks.poll(); if (mActive2 != null) &#123; mActive2.startAnimation(this); &#125; &#125; &#125; &#125; /** * 添加任务 * * @param gift 推送的Gift内容 * @param listener 回调 */ public void addNumAnimation(PushGift gift, StaticGiftModel.StaticGiftListener listener) &#123; executor.execute(new StaticGiftModel(gift, listener)); &#125;&#125; 可以看到，我在StaticGiftExecutor中定义了2个变量mActive1、mActive2，他们即代表两个出口。在execute中先判断mActive1是否为空，是则取出元素给它，让它执行动画。否则判断mActive2是否为空，是则取出元素给它，让它执行动画。因为有两个出口，队列并不知道我的下一个任务要在哪个出口执行，所以具体的播放逻辑不能写在其中，所以我将具体的播放逻辑设计在StaticGiftListener.startStaticAnimation()的中，由调用的用户自行实现，并且在动画结束时，我需要回调队列的接口，来通知队列某某出口的动画执行完毕了。实现片段代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 执行静态礼物动画 * * @param gift * @param nextListener */ @Override public void startStaticAnimation(final StaticGiftModel giftModel, PushGift gift, final GiftAnimationEndListener nextListener) &#123; if (holder.staticLayout1.getVisibility() == View.GONE) &#123; holder.staticLayout1.setVisibility(View.VISIBLE); holder.staticGiftUserNick1.setText(gift.getUserNick()); holder.staticGiftDesc1.setText(gift.getDescription()); showIcon(gift.getUserIcon(), holder.staticGiftUserIcon1); // 获取对应礼物的本地下载路径 String fileName = CommonUtils.MD5(gift.getGiftIcon()); File savePath = new File(GiftManager.getInstance().getDownloadDir(), fileName); String path = &quot;file://&quot; + savePath.getAbsolutePath(); ImageLoader.getInstance().displayImage(path, holder.staticGiftIcon1); holder.staticGiftView1.setListener(new StaticGiftView.StaticGiftAnimationListener() &#123; @Override public void onAnimationEnd() &#123; holder.staticLayout1.setVisibility(View.GONE); giftModel.setOver(true); nextListener.onGiftAnimationEnd(); &#125; &#125;); holder.staticGiftView1.setNum(Integer.valueOf(gift.getNum())); &#125; else if (holder.staticLayout2.getVisibility() == View.GONE) &#123; holder.staticLayout2.setVisibility(View.VISIBLE); holder.staticGiftUserNick2.setText(gift.getUserNick()); holder.staticGiftDesc2.setText(gift.getDescription()); showIcon(gift.getUserIcon(), holder.staticGiftUserIcon2); // 获取对应礼物的本地下载路径 String fileName = CommonUtils.MD5(gift.getGiftIcon()); File savePath = new File(GiftManager.getInstance().getDownloadDir(), fileName); String path = &quot;file://&quot; + savePath.getAbsolutePath(); ImageLoader.getInstance().displayImage(path, holder.staticGiftIcon2); holder.staticGiftView2.setListener(new StaticGiftView.StaticGiftAnimationListener() &#123; @Override public void onAnimationEnd() &#123; holder.staticLayout2.setVisibility(View.GONE); giftModel.setOver(true); nextListener.onGiftAnimationEnd(); &#125; &#125;); holder.staticGiftView2.setNum(Integer.valueOf(gift.getNum())); &#125; &#125; 静态礼物动画实现类StaticGiftView： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StaticGiftView extends TextView &#123; private int current = 1; private int num; private StaticGiftAnimationListener listener; private Animation scaleAnimation = AnimationUtils.loadAnimation(getContext(), R.anim.gift_scale); public StaticGiftView(Context context) &#123; super(context); &#125; public StaticGiftView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public StaticGiftView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setListener(StaticGiftAnimationListener listener) &#123; this.listener = listener; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125; public void setNum(int num) &#123; this.num = num; startAnimation(scaleAnimation); &#125; @Override protected void onAnimationEnd() &#123; super.onAnimationEnd(); current++; if (current &lt;= num) &#123; setText(&quot;X &quot; + current); startAnimation(scaleAnimation); &#125; else &#123; current = 1; if (listener != null) &#123; listener.onAnimationEnd(); &#125; &#125; &#125; public interface StaticGiftAnimationListener &#123; void onAnimationEnd(); &#125;&#125; 静态礼物是通过StaticGiftView的setNum()方法来显示动画的，就是显示一个数量递增，同时伴随着缩放的动画。页面布局中有staticLayout1和staticLayout2，分别代表两个执行动画的布局，通过判断getVisibility()是否为GONE来决定是否将动画分发给这个布局。在动画开始时，将布局设置成VISIBLE，在动画结束后，再将布局设置成GONE。我通过setOver(true)来告知队列某某出口的动画执行完毕，然后队列回调到onGiftAnimationEnd()中，继续取出任务分配给有空的出口。 调用如下代码将任务添加到队列便能顺序播放动画了。 1StaticGift.getInstance().addNumAnimation(pushGift, listener); 待优化 代码之间的依赖很重，任务队列直接依赖到了前端的UI组件，需要解耦。 若是增加至三个、四个或是更多个出口，代码就得一直添加mActive了，不利于拓展。","tags":[{"name":"Java","slug":"Java","permalink":"http://lijia92.github.io/tags/Java/"}]},{"title":"Android接入支付宝移动支付","date":"2016-05-18T07:01:25.000Z","path":"2016/05/18/alipay/","text":"项目组支付宝商户审核通过，要准备接入支付宝移动支付的能力，本文主要讲述一下android接入支付宝移动支付SDK的步骤。 前期准备 支付宝商户网站注册支付宝商户账号。 签约移动支付产品，等到审核通过。 秘钥的生成与上传。注册和签约没什么好说的，由公司相关部门或人员进行操作就好了。这里重点讲一下密钥。 秘钥的生成：下载SDK资源压缩包，解压后，里面会有openssl的文件夹，里面有个openssl.exe，双击运行。输入如下指令生成私钥: 1genrsa -out rsa_private_key.pem 1024 java开发者（否则跳过此步骤）需要转换成PKCS8格式，再输入如下指令进行转换： 1pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt 可以看到下面的界面：右键点击openssl窗口上边边缘，选择“编辑→标记”，选中要复制的文字，将PKCS8格式私钥复制下来，保存到一个文本中，后面会用到。继续执行指令： 1rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 会得到公钥文本。 秘钥的上传：登录支付宝商户账户，进入到我的商家服务。点击查询PID、KEY，输入支付密码，进入到下面的页面：记录下PID。点击RSA加密后面的添加密码，这里我已经添加过，所以显示的查看秘钥。将生成步骤中生成的公钥文本粘贴进编辑框，点击保存，若显示上传成功则代表成功。 接入SDK 将alipaySDK-20160223.jarjar包添加至项目中。 修改AndroidManifest.xml：1234567891011121314151617181920&lt;!-- 权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 当用户手机没有安装支付宝App时，会调用H5的页面进行支付，若不进行声明，则直接返回支付失败 --&gt;&lt;activity android:name=&quot;com.alipay.sdk.app.H5PayActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt;&lt;/activity&gt;&lt;activity android:name=&quot;com.alipay.sdk.auth.AuthActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt; &lt;/activity&gt; 至此，SDK接入已完成。 调用支付在支付宝Demo中，已经有了很详细的说明了。我们只需要填入3个字段：PARTNER、SELLER、RSA_PRIVATE。PARTNER就是上面步骤记录的PID，SELLER即是支付宝账号，RSA_PRIVATE就是记录的PKCS8格式私钥。这里贴一下Demo代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229public class PayDemoActivity extends FragmentActivity &#123; // 商户PID public static final String PARTNER = &quot;&quot;; // 商户收款账号 public static final String SELLER = &quot;&quot;; // 商户私钥，pkcs8格式 public static final String RSA_PRIVATE = &quot;&quot;; // 支付宝公钥 public static final String RSA_PUBLIC = &quot;&quot;; private static final int SDK_PAY_FLAG = 1; @SuppressLint(&quot;HandlerLeak&quot;) private Handler mHandler = new Handler() &#123; @SuppressWarnings(&quot;unused&quot;) public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SDK_PAY_FLAG: &#123; PayResult payResult = new PayResult((String) msg.obj); /** * 同步返回的结果必须放置到服务端进行验证（验证的规则请看https://doc.open.alipay.com/doc2/ * detail.htm?spm=0.0.0.0.xdvAU6&amp;treeId=59&amp;articleId=103665&amp; * docType=1) 建议商户依赖异步通知 */ String resultInfo = payResult.getResult();// 同步返回需要验证的信息 String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档 if (TextUtils.equals(resultStatus, &quot;9000&quot;)) &#123; Toast.makeText(PayDemoActivity.this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; // 判断resultStatus 为非&quot;9000&quot;则代表可能支付失败 // &quot;8000&quot;代表支付结果因为支付渠道原因或者系统原因还在等待支付结果确认，最终交易是否成功以服务端异步通知为准（小概率状态） if (TextUtils.equals(resultStatus, &quot;8000&quot;)) &#123; Toast.makeText(PayDemoActivity.this, &quot;支付结果确认中&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; // 其他值就可以判断为支付失败，包括用户主动取消支付，或者系统返回的错误 Toast.makeText(PayDemoActivity.this, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; break; &#125; default: break; &#125; &#125; ; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.pay_main); &#125; /** * call alipay sdk pay. 调用SDK支付 */ public void pay(View v) &#123; if (TextUtils.isEmpty(PARTNER) || TextUtils.isEmpty(RSA_PRIVATE) || TextUtils.isEmpty(SELLER)) &#123; new AlertDialog.Builder(this).setTitle(&quot;警告&quot;).setMessage(&quot;需要配置PARTNER | RSA_PRIVATE| SELLER&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialoginterface, int i) &#123; // finish(); &#125; &#125;).show(); return; &#125; String orderInfo = getOrderInfo(&quot;测试的商品&quot;, &quot;该测试商品的详细描述&quot;, &quot;0.01&quot;); /** * 特别注意，这里的签名逻辑需要放在服务端，切勿将私钥泄露在代码中！ */ String sign = sign(orderInfo); try &#123; /** * 仅需对sign 做URL编码 */ sign = URLEncoder.encode(sign, &quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; /** * 完整的符合支付宝参数规范的订单信息 */ final String payInfo = orderInfo + &quot;&amp;sign=\\&quot;&quot; + sign + &quot;\\&quot;&amp;&quot; + getSignType(); Runnable payRunnable = new Runnable() &#123; @Override public void run() &#123; // 构造PayTask 对象 PayTask alipay = new PayTask(PayDemoActivity.this); // 调用支付接口，获取支付结果 String result = alipay.pay(payInfo, true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); &#125; &#125;; // 必须异步调用 Thread payThread = new Thread(payRunnable); payThread.start(); &#125; /** * get the sdk version. 获取SDK版本号 */ public void getSDKVersion() &#123; PayTask payTask = new PayTask(this); String version = payTask.getVersion(); Toast.makeText(this, version, Toast.LENGTH_SHORT).show(); &#125; /** * 原生的H5（手机网页版支付切natvie支付） 【对应页面网页支付按钮】 * * @param v */ public void h5Pay(View v) &#123; Intent intent = new Intent(this, H5PayDemoActivity.class); Bundle extras = new Bundle(); /** * url是测试的网站，在app内部打开页面是基于webview打开的，demo中的webview是H5PayDemoActivity， * demo中拦截url进行支付的逻辑是在H5PayDemoActivity中shouldOverrideUrlLoading方法实现， * 商户可以根据自己的需求来实现 */ String url = &quot;http://m.meituan.com&quot;; // url可以是一号店或者美团等第三方的购物wap站点，在该网站的支付过程中，支付宝sdk完成拦截支付 extras.putString(&quot;url&quot;, url); intent.putExtras(extras); startActivity(intent); &#125; /** * create the order info. 创建订单信息 */ private String getOrderInfo(String subject, String body, String price) &#123; // 签约合作者身份ID String orderInfo = &quot;partner=&quot; + &quot;\\&quot;&quot; + PARTNER + &quot;\\&quot;&quot;; // 签约卖家支付宝账号 orderInfo += &quot;&amp;seller_id=&quot; + &quot;\\&quot;&quot; + SELLER + &quot;\\&quot;&quot;; // 商户网站唯一订单号 orderInfo += &quot;&amp;out_trade_no=&quot; + &quot;\\&quot;&quot; + getOutTradeNo() + &quot;\\&quot;&quot;; // 商品名称 orderInfo += &quot;&amp;subject=&quot; + &quot;\\&quot;&quot; + subject + &quot;\\&quot;&quot;; // 商品详情 orderInfo += &quot;&amp;body=&quot; + &quot;\\&quot;&quot; + body + &quot;\\&quot;&quot;; // 商品金额 orderInfo += &quot;&amp;total_fee=&quot; + &quot;\\&quot;&quot; + price + &quot;\\&quot;&quot;; // 服务器异步通知页面路径 orderInfo += &quot;&amp;notify_url=&quot; + &quot;\\&quot;&quot; + &quot;http://notify.msp.hk/notify.htm&quot; + &quot;\\&quot;&quot;; // 服务接口名称， 固定值 orderInfo += &quot;&amp;service=\\&quot;mobile.securitypay.pay\\&quot;&quot;; // 支付类型， 固定值 orderInfo += &quot;&amp;payment_type=\\&quot;1\\&quot;&quot;; // 参数编码， 固定值 orderInfo += &quot;&amp;_input_charset=\\&quot;utf-8\\&quot;&quot;; // 设置未付款交易的超时时间 // 默认30分钟，一旦超时，该笔交易就会自动被关闭。 // 取值范围：1m～15d。 // m-分钟，h-小时，d-天，1c-当天（无论交易何时创建，都在0点关闭）。 // 该参数数值不接受小数点，如1.5h，可转换为90m。 orderInfo += &quot;&amp;it_b_pay=\\&quot;30m\\&quot;&quot;; // extern_token为经过快登授权获取到的alipay_open_id,带上此参数用户将使用授权的账户进行支付 // orderInfo += &quot;&amp;extern_token=&quot; + &quot;\\&quot;&quot; + extern_token + &quot;\\&quot;&quot;; // 支付宝处理完请求后，当前页面跳转到商户指定页面的路径，可空 orderInfo += &quot;&amp;return_url=\\&quot;m.alipay.com\\&quot;&quot;; // 调用银行卡支付，需配置此参数，参与签名， 固定值 （需要签约《无线银行卡快捷支付》才能使用） // orderInfo += &quot;&amp;paymethod=\\&quot;expressGateway\\&quot;&quot;; return orderInfo; &#125; /** * get the out_trade_no for an order. 生成商户订单号，该值在商户端应保持唯一（可自定义格式规范） */ private String getOutTradeNo() &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;MMddHHmmss&quot;, Locale.getDefault()); Date date = new Date(); String key = format.format(date); Random r = new Random(); key = key + r.nextInt(); key = key.substring(0, 15); return key; &#125; /** * sign the order info. 对订单信息进行签名 * * @param content 待签名订单信息 */ private String sign(String content) &#123; return SignUtils.sign(content, RSA_PRIVATE); &#125; /** * get the sign type we use. 获取签名方式 */ private String getSignType() &#123; return &quot;sign_type=\\&quot;RSA\\&quot;&quot;; &#125;&#125; 代码中有个注释需要特别注意：特别注意，这里的签名逻辑需要放在服务端，切勿将私钥泄露在代码中！ 至此，整个集成就已经结束了，不得不说，支付宝的官方文档比微信好多了，哈哈~ 补充正式项目中需要将签名逻辑放在服务端，在我与服务端进行联调时，出现了很多问题，这里说几点： 服务端若是使用的是java，则使用PKCS8格式的秘钥，否则使用非PKCS8格式的秘钥。 请求参数可以无序，但是必须保证请求的参数与待签名参数的顺序一致。（非常坑，花了半天时间跟服务端联调才找到这个问题）","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android自定义View实现仪表盘效果","date":"2016-05-16T06:41:26.000Z","path":"2016/05/16/dashboard/","text":"本篇博客主要介绍如何实现一个仪表盘动态显示的效果，此效果来源于买卖人这个应用，3个室友有2个做安卓，而且都在买卖人，所以我也跟着实现了一波。效果如下： 实现思路涉及到动画效果，首先将其拆分成变化的部分，和不变的部分。变化的部分有：颜色渐变的进度条、以及数字。不变的部分：指针刻度、灰色圆弧背景。拆分开来后，再来单独实现就非常简单了。 渐变的进度条：通过shader，设置起点和终点的颜色，便能达到颜色渐变的一个效果了。1mShader = new RadialGradient(0, 0, (1080 - 300) / 2, 0xffde5669, 0xffe79950, Shader.TileMode.MIRROR); 数字：直接调用drawText即可。 指针刻度：先选取最好画的一个刻度，然后通过旋转画布重新绘制，就能画出所有的刻度了。（记得在画完之后要把画布归位） 灰色圆弧背景：设置好参数，调用drawArc即可。 动画效果：通过handler发送消息，改变变量值然后重绘就能实现了。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class DashboardView extends View &#123; private Paint mPaint; private RectF rectF; private Shader mShader; private int targetDegree; // 目标角度 private int currentDegree; // 当前角度 private int currentNum; // 当前数值 private int targetNum; // 目标数值 public DashboardView(Context context) &#123; super(context); init(); &#125; public DashboardView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public DashboardView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint = new Paint(); rectF = new RectF(); // 颜色渐变的shader mShader = new RadialGradient(0, 0, (1080 - 300) / 2, 0xffde5669, 0xffe79950, Shader.TileMode.MIRROR); &#125; /** * 通过Handler发送消息，改变变量，重绘View */ private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; currentDegree += 5; currentNum += currentDegree / 1000f * 259; if (currentDegree &lt; targetDegree) &#123; handler.sendEmptyMessageDelayed(0, 5); &#125; else &#123; currentDegree = targetDegree; currentNum = targetNum; &#125; invalidate(); &#125; &#125;; public void setNum(int num) &#123; targetNum = num; targetDegree = (int) (targetNum / 1000f * 259); handler.sendEmptyMessageDelayed(0, 400); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画大圆弧灰色背景 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.GRAY); mPaint.setStrokeWidth(40); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeCap(Paint.Cap.ROUND); rectF.top = getMeasuredHeight() / 2 - getMeasuredWidth() / 4; rectF.left = getMeasuredWidth() / 4; rectF.right = getWidth() / 4 * 3; rectF.bottom = getMeasuredHeight() / 2 + getMeasuredWidth() / 4; canvas.drawArc(rectF, 140, 260, false, mPaint); // 通过旋转画布画指针刻度 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.GRAY); mPaint.setStrokeWidth(3); canvas.drawLine(getMeasuredWidth() / 2, rectF.top + 40, getMeasuredWidth() / 2, rectF.top + 60, mPaint); for (int i = 0; i &lt; 26; i++) &#123; int degrees = (int) (10 * (i + 1) * Math.pow(-1, i)); canvas.rotate(degrees, getWidth() / 2, getHeight() / 2); canvas.drawLine(getMeasuredWidth() / 2, rectF.top + 40, getMeasuredWidth() / 2, rectF.top + 60, mPaint); &#125; canvas.rotate(130, getWidth() / 2, getHeight() / 2); // 画中间的小圆 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.DKGRAY); canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, 80, mPaint); // 画带颜色的进度条 mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setShader(mShader); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(40); mPaint.setStrokeCap(Paint.Cap.ROUND); canvas.drawArc(rectF, 140, currentDegree, false, mPaint); // 画Text mPaint.reset(); mPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.parseColor(&quot;#ffde5669&quot;)); mPaint.setTextSize(70); canvas.drawText(String.valueOf(currentNum), getMeasuredWidth() / 2 - 55, getMeasuredHeight() / 2 + 25, mPaint); &#125;&#125; 画笔相关Style有三种。STROKE：FILL：FILL_AND_STROKE：StrokeCap也有三种。BUTT：SQUARE:ROUND： 最后代码比较简单，在实现带动画的View时，最好先进行拆分，找出变化的部分和不变的部分，然后各自实现，将大问题拆分成若干个小问题，逐个击破。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android自定义属性","date":"2016-05-10T07:42:43.000Z","path":"2016/05/10/custom-attr/","text":"前言项目中对于图片的长宽比有很严格的需求，如果比例不一致，那么在App上显示会影响体验，于是要求长宽比一致。但是比例并不是固定的，有的图需要1:1比例，有的图需要14:9比例，有的图又需要9:16的比例。 起初我的想法是，自定义View在onMeasure里利用比例，将计算后的宽高设置给View就好了。但是这么一想，比例不一致啊。现在需要3种比例，我要自定义3个View，那如果后面有其他的一些比例呢？我不是又得写啦~ 抱着偷懒的态度，我设想用自定义属性来解决这个问题，自己设置比例，这样只用自定义一个View，然后根据传入的比例再行计算即可。 自定义属性添加属性在res/value文件夹下定义一个attr.xml文件，添加如下代码： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;declare-styleable name=&quot;CertainScaleImageView&quot;&gt; &lt;attr name=&quot;radio&quot; format=&quot;float&quot; /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; radio即是代表比例，这里是高比宽。我是先获取宽，然后根据比例计算高。 设置属性在xml顶层布局中添加xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;，然后利用app:radio设置属性，示例代码如下： 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;8dp&quot; android:background=&quot;#ffffff&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot;&gt; &lt;com.miamusic.android.live.ui.widget.CertainScaleImageView android:id=&quot;@+id/anchor_profile_background&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;centerCrop&quot; android:transitionName=&quot;cover&quot; app:radio=&quot;1.779&quot; /&gt;... 这里我设置的1.779，即高是宽的1.779倍，显示一个瘦窄的长方形。 获取属性在自定义View中通过如下代码获取radio属性： 123456public CertainScaleImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CertainScaleImageView); radio = typedArray.getFloat(R.styleable.CertainScaleImageView_radio, 1f); typedArray.recycle();&#125; radio自定义View的一个属性，通过TypedArray获取相应的值并保存起来，TypedArray用完需要调用recycle()。 计算宽高获取属性之后，我们需要通过这个比例来计算宽高，代码如下： 1234567@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = MeasureSpec.getSize(widthMeasureSpec); int widthSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); int heightSpec = MeasureSpec.makeMeasureSpec((int) (width * radio), MeasureSpec.EXACTLY); setMeasuredDimension(widthSpec, heightSpec);&#125; 获得宽度值，然后根据radio计算高度，然后调用setMeasuredDimension即可。 总结通过onMeasure，我们可以自行控制View要显示的区域。在调用setMeasuredDimension时，我们不仅需要计算它确切的高宽，还要给他设置一个MODE。MODE有三类： MeasureSpec.EXACTLY：精确尺寸，当我们将控件的layout_width或layout_height指定为具体数值时如andorid:layout_width&#x3D;”50dp”，或者为match_parent是，都是控件大小已经确定的情况，都是精确尺寸。 MeasureSpec.AT_MOST：最大尺寸，当控件的layout_width或layout_height指定为wrap_content时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。因此，此时的mode是AT_MOST，size给出了父控件允许的最大尺寸。 MeasureSpec.UNSPECIFIED：未指定尺寸，这种情况不多，一般都是父控件是AdapterView，通过measure方法传入的模式。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android自定义View实现弧形SeekBar（续）","date":"2016-04-28T08:13:36.000Z","path":"2016/04/28/new-seekbar/","text":"问题在我的上一篇文章中，写了自定义弧形SeekBar，效果达到了自己的预期，于是高高兴兴回家了。但是后面手贱，在家里自己随意玩了玩，发现SeekBar滑动几下之后再滑动就会变得特别卡。然后查看代码，短时间内没什么头绪。 没错，这个时候又要祭出我的室友了。室友之前是做rom相关的，对于android系统工具用得很熟。然后他拿着我的手机打开开发者选项中的GPU呈现模式分析，运行了一下程序，滑了一会之后就这样了： 我们可以看到一条绿线，这条绿线代表的是60帧，超过这条线就代表不足60帧，那么人眼看起来就会感觉卡顿，可以看到超出了好多了，难怪会很卡~。 那么问题可以大致定位到绘制View的方法不够科学。 那么怎样才能科学呢？其实我也没答案。但是大致有了一个思路：绘制好弧线和圆球之后，在滑动的时候不再重绘弧线和圆球，仅仅改变圆球的位置，这样就会少了很多的绘制操作。如此实现的话或许便能解决问题了。但也只是假设，下面开始实战。 解决方案我将代码拆分成3个类：继承自FrameLayout的ArcSeekBarParent，SeekBarArcView以及SeekBarBallView。ArcSeekBarParent代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class ArcSeekBarParent extends FrameLayout implements SeekBarBallView.OnSmoothScrollListener &#123; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private PointF circleCenter; // 球的坐标 private int top; private int right; private int bottom; private int left; private float currentX; // 当前x坐标，用于控制圆球位置 private final static float LEVEL = 6f; // 设置档次 private int currentLevel = 1; // 当前档次 private OnProgressChangedListener listener; private SeekBarBallView ball; public ArcSeekBarParent(Context context) &#123; super(context); init(); &#125; public ArcSeekBarParent(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ArcSeekBarParent(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); circleCenter = new PointF(); &#125; public void setListener(OnProgressChangedListener listener) &#123; this.listener = listener; &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); ball = (SeekBarBallView) getChildAt(1); ball.setListener(this); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); this.left = left; this.top = top; this.right = right; this.bottom = bottom; pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); currentX = (right - left) / LEVEL; changeBallLayout(currentX); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: float downX = event.getX(); float downY = event.getY(); float distance = (downX - circleCenter.x) * (downX - circleCenter.x) + (downY - circleCenter.y) * (downY - circleCenter.y); // 计算到圆球中心的距离，考虑20的误差 return !(distance - (ball.getMeasuredWidth() / 2 + 20) * (ball.getMeasuredWidth() / 2 + 20) &gt; 0); case MotionEvent.ACTION_MOVE: float moveX = event.getX(); currentX = moveX; // 通过x坐标改变圆球的位置 changeBallLayout(currentX); currentLevel = getLevel(moveX); if (listener != null) &#123; listener.OnProgressChanged(currentLevel); &#125; break; default: // 当手指移出或者离开View时，圆球平滑滑到最近的档次 ball.smoothScrollLevel((int) currentX, (int) ((right - left) / LEVEL * currentLevel - currentX)); break; &#125; return super.onTouchEvent(event); &#125; /** * 改变球的位置 * * @param currentX 横坐标 */ private void changeBallLayout(float currentX) &#123; float t = (currentX / (right - left)); float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x; float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y; circleCenter.set(x, y); ball.layout((int) (circleCenter.x - ball.getMeasuredWidth() / 2), (int) (circleCenter.y - ball.getMeasuredWidth() / 2), (int) (circleCenter.x + ball.getMeasuredWidth() / 2), (int) (circleCenter.y + ball.getMeasuredWidth() / 2)); &#125; /** * 计算档次 * * @param x 横坐标 * @return 档次 */ private int getLevel(float x) &#123; float ratio = (x / (right - left)) * LEVEL; // 计算距离哪个档次最近 int result = new BigDecimal(ratio).setScale(0, BigDecimal.ROUND_HALF_UP).intValue(); if (result &lt; 1) &#123; result = 1; &#125; else if (result &gt; (LEVEL - 1)) &#123; result = (int) (LEVEL - 1); &#125; return result; &#125; @Override public void onSmoothScroll(int currentX) &#123; changeBallLayout(currentX); &#125; /** * 滑动接口 */ public interface OnProgressChangedListener &#123; void OnProgressChanged(int level); &#125;&#125; SeekBarArcView代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class SeekBarArcView extends View &#123; private Paint paint; private Path path; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 public SeekBarArcView(Context context) &#123; super(context); init(); &#125; public SeekBarArcView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public SeekBarArcView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; paint = new Paint(); path = new Path(); pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); pointF1.set(0, bottom - top - 30); pointF2.set((right - left) / 2, -(bottom - top) / 4); pointF3.set(right, bottom - top - 30); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画2阶贝塞尔曲线 paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.GRAY); paint.setStrokeWidth(10); paint.setStyle(Paint.Style.STROKE); path.moveTo(pointF1.x, pointF1.y); path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y); canvas.drawPath(path, paint); &#125;&#125; SeekBarBallView代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class SeekBarBallView extends View &#123; private Paint paint; private Scroller scroller; private OnSmoothScrollListener listener; public SeekBarBallView(Context context) &#123; super(context); init(context); &#125; public SeekBarBallView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public SeekBarBallView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; paint = new Paint(); scroller = new Scroller(context); &#125; public void setListener(OnSmoothScrollListener listener) &#123; this.listener = listener; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(widthMeasureSpec, widthMeasureSpec); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; if (listener != null) &#123; listener.onSmoothScroll(scroller.getCurrX()); postInvalidate(); &#125; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); paint.reset(); paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.WHITE); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredWidth() / 2, getMeasuredWidth() / 2, paint); &#125; /** * 平滑滑动 * * @param start 起始值 * @param distance 滑动距离 */ public void smoothScrollLevel(int start, int distance) &#123; scroller.startScroll(start, 0, distance, 0, 200); postInvalidate(); &#125; public interface OnSmoothScrollListener &#123; void onSmoothScroll(int currentX); &#125;&#125; 可以看到代码基本都是差不多的，只不过我将之前的View拆分成一个ViewGroup，绘制弧线的SeekBarArcView和绘制圆球的SeekBarBallView。在ACTION_MOVE的时候，我只是使用ball.layout()方法，即只改变圆球的layout，而没有重绘整个SeekBar。 添加xml引用： 12345678910111213141516&lt;com.android.lovesixgod.customarcseekbar.seekbar.ArcSeekBarParent android:id=&quot;@+id/seek_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;40dp&quot; android:background=&quot;@color/colorAccent&quot;&gt; &lt;com.android.lovesixgod.customarcseekbar.seekbar.SeekBarArcView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;com.android.lovesixgod.customarcseekbar.seekbar.SeekBarBallView android:layout_width=&quot;20dp&quot; android:layout_height=&quot;100dp&quot; /&gt;&lt;/com.android.lovesixgod.customarcseekbar.seekbar.ArcSeekBarParent&gt; 然后运行，进行滑动。可以看到GPU分析显示的线条基本不会超过绿线，滑起来也没有明显的卡顿，问题应该算是解决了~ 代码已更新至Github。 小结 自定义View的时候尽量避免不变View的重绘。因为弧形线这个View是没有任何改变的，但是还不停地重绘，可能就会导致这样的性能问题了。 Scroller的使用是针对View的，对于ViewGroup好像是无效的，所以我将Scroller写在了SeekBarBallView中。另外Scroller要能正常使用，在startScroll()以及computeScroll()需要invalidate()或者postInvalidate。 多使用相关工具，来观察代码的性能。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android自定义View实现弧形SeekBar","date":"2016-04-27T05:53:19.000Z","path":"2016/04/27/seekbar/","text":"前言项目开发中有这样一个需求：通过滑动SeekBar来控制打赏金额，金额设置5个档次。 看到设计稿的时候，除了自定义View想不到什么更好的方法了。自定义View一直是我的短板，内心总会有点抗拒，总感觉自己做不出来。最近一段时间，也是有意无意的练习自定义View。最后决定还是用自定义View来实现这次的需求。 根据设计图，我分为3个步骤： 画弧线。 画圆球。 触摸事件的处理，并提供对外接口。 画弧线圆弧起初的想法是根据自定义View的宽高，创建一个正方形，然后画一个内切圆，截取其中的一段圆弧。大致就是这样的：假设这样的圆存在，那么对于View的宽高有一个要求:假定宽为a，高为b，x为半径。取一个直角三角形，勾股定理能得出这样的公式： 1(a/2)*(a/2) + (x-b)*(x-b) = x*x; 化简得到: 1x = b/2 + (a*a) / (8*b) 假设若成立，那么x-b&gt;0,得到 1a &gt; 2b 即对View的宽高有一个这样的硬性要求，才能符合预期。 另外，后续还需要画圆球，圆球的圆心肯定是需要在弧线上的，那么我每次画圆球时，圆心的坐标都需要通过三角函数来获得，会显得比较麻烦。考虑再三便放弃这种做法了。 抛物线晚上下班回家，跟室友讨论了一波这个问题，我室友当场来了个：抛物线。后面一想：卧槽？确实可以啊。直接确定3个点，就能确定抛物线的公式了，这样对于后续画圆球，求圆心的坐标也非常简单。于是打算第二天来做一波。 第二天。 网上一查，没查到android关于画抛物线的方法。我的内心：于是便也放弃了这种做法。 贝塞尔网上查阅资料的时候，关于弧线说的最多的就是利用贝塞尔曲线。关于贝塞尔曲线的更多介绍可以参考这篇文章。 二阶贝塞尔曲线符合我的情况，于是选取的二阶贝塞尔曲线。贝塞尔曲线的关键代码如下： 123path.moveTo(pointF1.x, pointF1.y);path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y);canvas.drawPath(path, paint); pointF1是起始点，pointF2是控制点，pointF3是终止点。采用贝塞尔曲线实现的效果还不错，只是控制点是不在曲线上的，曲线无法与View的顶部相切，但也无伤大雅了。 画圆球画圆球就比较简单了，计算出圆心坐标直接画圆即可。 12345678910// 二阶贝塞尔曲线公式计算坐标float t = (currentX / (right - left));float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x;float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y;circleCenter.set(x, y);paint.reset();paint.setFlags(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.WHITE);paint.setStyle(Paint.Style.FILL);canvas.drawCircle(x, y, RADIUS, paint); 二阶贝塞尔曲线的公式是这样的：我们把当前的横坐标currentX对于View宽度的比例作为t。 触摸事件处理&amp;对外接口触摸事件无非就是重写onTouchEvent，这里我只对横坐标做了处理，只要横着滑，就能滑动圆球了，并没有处理纵坐标。 ACTION_DOWN：判断点下的坐标是否在圆球返回内（我设置了20的误差），若不在圆球内，则直接返回false，那么后续就不会接收ACTION_MOVE等其他事件了。若在则返回true，接收后续的ACTION_MOVE等事件。 ACTION_MOVE：获取x坐标，然后设置currentX，重绘。对外的接口也是在这里调用。 default：当手指移出或者离开View时，利用Scroller使圆球平滑滑到距离最近的档次。 下面上完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public class CustomArcSeekBar extends View &#123; private Scroller scroller; private Paint paint; private Path path; private PointF pointF1; // 起始点 private PointF pointF2; // 控制点 private PointF pointF3; // 终止点 private PointF circleCenter; // 圆心的坐标 private int top; private int right; private int bottom; private int left; private float currentX; // 当前x坐标，用于控制圆球位置 private int currentLevel; // 当前档次 private OnProgressChangedListener listener; private final static float RADIUS = 30f; // 圆球半径 private final static float LEVEL = 6f; // 设置档次 public CustomArcSeekBar(Context context) &#123; super(context); init(context); &#125; public CustomArcSeekBar(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public CustomArcSeekBar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; paint = new Paint(); path = new Path(); pointF1 = new PointF(); pointF2 = new PointF(); pointF3 = new PointF(); circleCenter = new PointF(); scroller = new Scroller(context); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; currentX = scroller.getCurrX(); postInvalidate(); &#125; &#125; public void setListener(OnProgressChangedListener listener) &#123; this.listener = listener; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); this.left = left; this.top = top; this.right = right; this.bottom = bottom; pointF1.set(0, bottom - top); pointF2.set((right - left) / 2, -(bottom - top) / 2); pointF3.set(right, bottom - top); currentX = (right - left) / LEVEL; currentLevel = 1; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 画2阶贝塞尔曲线 paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.GRAY); paint.setStrokeWidth(10); paint.setStyle(Paint.Style.STROKE); path.moveTo(pointF1.x, pointF1.y); path.quadTo(pointF2.x, pointF2.y, pointF3.x, pointF3.y); canvas.drawPath(path, paint); // 通过x坐标，计算圆心的坐标，画圆 float t = (currentX / (right - left)); float x = (1 - t) * (1 - t) * pointF1.x + 2 * (t) * (1 - t) * pointF2.x + t * t * pointF3.x; float y = (1 - t) * (1 - t) * pointF1.y + 2 * (t) * (1 - t) * pointF2.y + t * t * pointF3.y; circleCenter.set(x, y); paint.reset(); paint.setFlags(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.WHITE); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(x, y, RADIUS, paint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: float downX = event.getX(); float downY = event.getY(); float distance = (downX - circleCenter.x) * (downX - circleCenter.x) + (downY - circleCenter.y) * (downY - circleCenter.y); // 计算到圆球中心的距离，考虑20的误差 return !(distance - (RADIUS + 20) * (RADIUS + 20) &gt; 0); case MotionEvent.ACTION_MOVE: float moveX = event.getX(); currentX = moveX; // 通过x坐标重绘圆球 invalidate(); currentLevel = getLevel(moveX); if (listener != null) &#123; listener.OnProgressChanged(currentLevel); &#125; break; default: // 当手指移出或者离开View时，圆球平滑滑到最近的档次 scroller.startScroll((int) currentX, 0, (int) ((right - left) / LEVEL * currentLevel - currentX), 0, 200); postInvalidate(); break; &#125; return super.onTouchEvent(event); &#125; /** * 计算档次 * * @param x 横坐标 * @return 档次 */ private int getLevel(float x) &#123; float ratio = (x / (right - left)) * LEVEL; // 计算距离哪个档次最近 int result = new BigDecimal(ratio).setScale(0, BigDecimal.ROUND_HALF_UP).intValue(); if (result &lt; 1) &#123; result = 1; &#125; else if (result &gt; (LEVEL - 1)) &#123; result = (int) (LEVEL - 1); &#125; return result; &#125; /** * 滑动接口 */ public interface OnProgressChangedListener &#123; void OnProgressChanged(int level); &#125;&#125; 使用在代码中使用，非常简单，在布局文件中引用： 1234567891011121314&lt;com.lastwarmth.viewstudy.CustomArcSeekBar android:id=&quot;@+id/seek_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;40dp&quot; android:background=&quot;@color/colorAccent&quot; /&gt;&lt;TextView android:id=&quot;@+id/seek_bar_progress&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;1&quot; android:textSize=&quot;30sp&quot; /&gt; 代码中： 12345678final TextView textView = (TextView) findViewById(R.id.seek_bar_progress);CustomArcSeekBar seekBar = (CustomArcSeekBar) findViewById(R.id.seek_bar);seekBar.setListener(new CustomArcSeekBar.OnProgressChangedListener() &#123; @Override public void OnProgressChanged(int level) &#123; textView.setText(String.valueOf(level)); &#125;&#125;); 最终效果：算是达到我的预期。 源码链接 小结 自定义View在绘制矩形、圆等图形时，使用的坐标是要相对于View本身的，而不是相对于屏幕的坐标。 使用贝塞尔曲线能获得不错的曲线效果。 Paint在画完1个东西之后记得reset，然后重新设置值，不然画笔的属性一样，得到的效果就不对。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"一个关于Android滑动“因缺斯厅”的想法","date":"2016-04-22T06:07:10.000Z","path":"2016/04/22/android-scroll/","text":"前言在项目实际开发过程中，需要实现一个这样的需求：在屏幕上进行上滑时，顶端大图背景不动，下面的正在直播、数字专辑等模块进行滑动，并且大图背景慢慢模糊。 起初想着是自定义View，重写onTouchEvent来进行滑动事件的处理，如果是手指滑一点，界面跟着滑一点还好。如果还要计算加速度、阻尼效果等这些因素，就会显得非常复杂了。于是跟基友讨论了一下，有个因缺斯厅的idea，先上一下最后实现的一个效果图。 擦，好端端的妹子录Gif被录得完全看不清… 方案通过FrameLayout叠加2个布局，第1个布局就是大图背景，第2个布局就是原生ScrollView，ScrollView顶部使用一个透明的View，与第2个布局完全重叠，因为是透明的，所以尽管是叠加上去的，大图背景依然能正常显示，底部的正在直播、数字专辑等模块也能正常显示。FrameLayout的特性是后面的View叠加在前面的View之上。所以ScrollView处于界面的顶端，能够全屏接收触摸事件，然后进行滑动即可。并且ScrollView是android原生用来滑动的View，滑动起来会比较流畅。特意整了一个示意图： 实现布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;480dp&quot; android:layout_marginBottom=&quot;8dp&quot; android:background=&quot;#ffffff&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot;&gt; &lt;!-- 大图背景布局 --&gt; &lt;!-- 大图背景中的关注按钮 --&gt; &lt;TextView android:id=&quot;@+id/follow_text&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;64dp&quot; android:layout_gravity=&quot;right|bottom&quot; android:gravity=&quot;center&quot; android:text=&quot;关注&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;/FrameLayout&gt; &lt;com.example.CustomScrollView android:id=&quot;@+id/scroll_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scrollbars=&quot;none&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!-- 这个FrameLayout与大图背景的属性要完全一致，才能完全覆盖，并且设置alpha为0，使其透明 --&gt; &lt;FrameLayout android:id=&quot;@+id/shade&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;480dp&quot; android:alpha=&quot;0&quot; android:background=&quot;#000000&quot;&gt; &lt;!-- 用于覆盖大图背景中的点击事件，相对位置、大小也必须一致 --&gt; &lt;TextView android:id=&quot;@+id/follow&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;64dp&quot; android:layout_gravity=&quot;right|bottom&quot; android:gravity=&quot;center&quot; android:text=&quot;&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#000000&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!-- 布局代码 --&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/com.example.CustomScrollView&gt;&lt;/FrameLayout&gt; 这里重点说明一点，因为是覆盖上去的，所以长宽的属性必须要一致，才能完全覆盖。另外，大图背景中的点击事件，可以在ScrollView顶部布局使用相对位置一致的View来进行响应，注意相对位置，长宽也最好一致。 监听ScrollView滑动上面的布局大致已经能实现滑动的功能了。接下来就是要监听ScrollView滑动，来慢慢模糊大图背景。Android SDK并没有提供能够直接监听滑动的方法，但是提供了一个protected void onScrollChanged(int x, int y, int oldx, int oldy)方法，是protectd的，所以不能被外界调用。因此写一个接口，然后把它暴露出去。 12345678910111213141516171819202122232425262728293031323334public class CustomScrollView extends ScrollView &#123; private OnScrollListener listener; public CustomScrollView(Context context) &#123; super(context); &#125; public CustomScrollView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public CustomScrollView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public interface OnScrollListener &#123; void onScrollChanged(CustomScrollView scrollView, int x, int y, int oldx, int oldy); &#125; public void setListener(OnScrollListener listener) &#123; this.listener = listener; &#125; @Override protected void onScrollChanged(int x, int y, int oldx, int oldy) &#123; super.onScrollChanged(x, y, oldx, oldy); if (listener != null) &#123; listener.onScrollChanged(this, x, y, oldx, oldy); &#125; &#125;&#125; 然后定义自己的Listener即可。 12345678910111213141516171819202122232425262728293031scrollView.setListener(new CustomScrollView.OnScrollListener() &#123; @Override public void onScrollChanged(CustomScrollView scrollView, int x, int y, int oldx, int oldy) &#123; int scrollY = scrollView.getScrollY(); if (scrollY == 0) &#123; followToggle.setClickable(true); &#125; else &#123; followToggle.setClickable(false); &#125; if (scrollY &gt; 0) &#123; if (scrollY &gt; background.getHeight()) &#123; scrollY = background.getHeight(); &#125; if (bitmap != null) &#123; int radius = (int) (scrollY * 25f / background.getHeight() * 1.5f); if (radius &lt;= 0) &#123; radius = 1; &#125; else if (radius &gt; 25) &#123; radius = 25; &#125; if (lastRadius != radius) &#123; lastRadius = radius; Bitmap blurBitmap = AndroidUtils.fastBlur(MainActivity.this, bitmap, radius); background.setImageBitmap(blurBitmap); &#125; float alpha = (float) scrollY / background.getHeight() / 1.5f; shade.setAlpha(alpha); &#125; &#125; &#125;&#125;); 在Listener中通过getScrollY()来获得滑动距离，来设置响应的模糊radius，以及alpha值，即可实现想要的效果了。 小结虽然并不一定是最好的实现方法，但是这个方法我个人觉得是比较取巧，比较因缺斯厅的方法。其实之前就想到了这样的方法，只不过当时脑袋短路，一直纠结自定义View，导致想不清楚，后面再仔细想一想就没什么大问题了。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android仿美团下拉刷新","date":"2016-04-18T08:07:15.000Z","path":"2016/04/18/refresh-listview/","text":"在之前看过一篇文章Android自定义控件之仿美团下拉刷新，就是实现仿美团下拉刷新。一直对ListView等控件的下拉刷新的了解程度，可能也就停留在用HeaderView来实现，然后重写onTouchEvent，但是具体应该是怎样的呢？一直没有实际动手自己写过，于是抽空自己照着这篇博客自己写了一遍，以加深自己的理解。我对原博客进行摘录，重点写出一些对自己帮助大的内容。 刷新状态一般下拉刷新应该都是会有三种状态：下拉刷新、松开刷新、正在刷新。 下拉刷新实现思路：自定义View，通过设置进度值进行缩放。用SeekBar来模仿一下下拉距离的进度。 自定义View代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class RefreshFirstView extends View &#123; private Bitmap firstBitmap; private Bitmap endBitmap; private float mCurrentProgress; private int measuredWidth; private int measuredHeight; private Bitmap scaledBitmap; public RefreshFirstView(Context context) &#123; super(context); init(context); &#125; public RefreshFirstView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public RefreshFirstView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; firstBitmap = Bitmap.createBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.pull_image)); endBitmap = Bitmap.createBitmap(BitmapFactory.decodeResource(getResources(), R.drawable.pull_end_image_frame_05)); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureWidth(widthMeasureSpec), measureWidth(widthMeasureSpec) * endBitmap.getHeight() / endBitmap.getWidth()); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); measuredWidth = getMeasuredWidth(); measuredHeight = getMeasuredHeight(); //根据第二阶段娃娃宽高 给椭圆形图片进行等比例的缩放 scaledBitmap = Bitmap.createScaledBitmap(firstBitmap, measuredWidth, measuredWidth * firstBitmap.getHeight() / firstBitmap.getWidth(), true); &#125; private int measureWidth(int widMeasureSpec) &#123; int result; int size = MeasureSpec.getSize(widMeasureSpec); int mode = MeasureSpec.getMode(widMeasureSpec); if (mode == MeasureSpec.EXACTLY) &#123; result = size; &#125; else &#123; result = endBitmap.getWidth(); if (mode == MeasureSpec.AT_MOST) &#123; result = Math.min(result, size); &#125; &#125; return result; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 通过画布缩放，控制View缩放 canvas.scale(mCurrentProgress, mCurrentProgress, measuredWidth / 2, measuredHeight / 2); canvas.drawBitmap(scaledBitmap, 0, measuredHeight / 4, null); &#125; public void setCurrentProgress(float currentProgress) &#123; this.mCurrentProgress = currentProgress; &#125;&#125; 松开刷新这里主要是一个帧动画。 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true&quot;&gt; &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_01&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_02&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_03&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_04&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_05&quot; android:duration=&quot;100&quot; /&gt;&lt;/animation-list&gt; 正在刷新与松开刷新一样，也是一个帧动画，这里便不做赘述。 三种状态通过自定义View，重写onMeasure来确保三个状态的View的宽高保持一致。 下拉刷新的实现先贴一下原博客的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318public class MeiTuanListView extends ListView implements AbsListView.OnScrollListener&#123; private static final int DONE = 0; private static final int PULL_TO_REFRESH = 1; private static final int RELEASE_TO_REFRESH = 2; private static final int REFRESHING = 3; private static final int RATIO = 3; private LinearLayout headerView; private int headerViewHeight; private float startY; private float offsetY; private TextView tv_pull_to_refresh; private OnMeiTuanRefreshListener mOnRefreshListener; private int state; private int mFirstVisibleItem; private boolean isRecord; private boolean isEnd; private boolean isRefreable; private FrameLayout mAnimContainer; private Animation animation; private SimpleDateFormat format; private MeiTuanRefreshFirstStepView mFirstView; private MeiTuanRefreshSecondStepView mSecondView; private AnimationDrawable secondAnim; private MeiTuanRefreshThirdStepView mThirdView; private AnimationDrawable thirdAnim; public MeiTuanListView(Context context) &#123; super(context); init(context); &#125; public MeiTuanListView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public MeiTuanListView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; public interface OnMeiTuanRefreshListener&#123; void onRefresh(); &#125; /** * 回调接口，想实现下拉刷新的listview实现此接口 * @param onRefreshListener */ public void setOnMeiTuanRefreshListener(OnMeiTuanRefreshListener onRefreshListener)&#123; mOnRefreshListener = onRefreshListener; isRefreable = true; &#125; /** * 刷新完毕，从主线程发送过来，并且改变headerView的状态和文字动画信息 */ public void setOnRefreshComplete()&#123; //一定要将isEnd设置为true，以便于下次的下拉刷新 isEnd = true; state = DONE; changeHeaderByState(state); &#125; private void init(Context context) &#123; setOverScrollMode(View.OVER_SCROLL_NEVER); setOnScrollListener(this); headerView = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.meituan_item, null, false); mFirstView = (MeiTuanRefreshFirstStepView) headerView.findViewById(R.id.first_view); tv_pull_to_refresh = (TextView) headerView.findViewById(R.id.tv_pull_to_refresh); mSecondView = (MeiTuanRefreshSecondStepView) headerView.findViewById(R.id.second_view); mSecondView.setBackgroundResource(R.drawable.pull_to_refresh_second_anim); secondAnim = (AnimationDrawable) mSecondView.getBackground(); mThirdView = (MeiTuanRefreshThirdStepView) headerView.findViewById(R.id.third_view); mThirdView.setBackgroundResource(R.drawable.pull_to_refresh_third_anim); thirdAnim = (AnimationDrawable) mThirdView.getBackground(); measureView(headerView); addHeaderView(headerView); headerViewHeight = headerView.getMeasuredHeight(); headerView.setPadding(0, -headerViewHeight, 0, 0); Log.i(&quot;zhangqi&quot;,&quot;headerViewHeight=&quot;+headerViewHeight); state = DONE; isEnd = true; isRefreable = false; &#125; @Override public void onScrollStateChanged(AbsListView absListView, int i) &#123; &#125; @Override public void onScroll(AbsListView absListView, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; mFirstVisibleItem = firstVisibleItem; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isEnd) &#123;//如果现在时结束的状态，即刷新完毕了，可以再次刷新了，在onRefreshComplete中设置 if (isRefreable) &#123;//如果现在是可刷新状态 在setOnMeiTuanListener中设置为true switch (ev.getAction())&#123; //用户按下 case MotionEvent.ACTION_DOWN: //如果当前是在listview顶部并且没有记录y坐标 if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; //将isRecord置为true，说明现在已记录y坐标 isRecord = true; //将当前y坐标赋值给startY起始y坐标 startY = ev.getY(); &#125; break; //用户滑动 case MotionEvent.ACTION_MOVE: //再次得到y坐标，用来和startY相减来计算offsetY位移值 float tempY = ev.getY(); //再起判断一下是否为listview顶部并且没有记录y坐标 if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; isRecord = true; startY = tempY; &#125; //如果当前状态不是正在刷新的状态，并且已经记录了y坐标 if (state!=REFRESHING &amp;&amp; isRecord ) &#123; //计算y的偏移量 offsetY = tempY - startY; //计算当前滑动的高度 float currentHeight = (-headerViewHeight+offsetY/3); //用当前滑动的高度和头部headerView的总高度进行比 计算出当前滑动的百分比 0到1 float currentProgress = 1+currentHeight/headerViewHeight; //如果当前百分比大于1了，将其设置为1，目的是让第一个状态的椭圆不再继续变大 if (currentProgress&gt;=1) &#123; currentProgress = 1; &#125; //如果当前的状态是放开刷新，并且已经记录y坐标 if (state == RELEASE_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果当前滑动的距离小于headerView的总高度 if (-headerViewHeight+offsetY/RATIO&lt;0) &#123; //将状态置为下拉刷新状态 state = PULL_TO_REFRESH; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125;else if (offsetY&lt;=0) &#123; //将状态变为done state = DONE; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); &#125; &#125; //如果当前状态为下拉刷新并且已经记录y坐标 if (state == PULL_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果下拉距离大于等于headerView的总高度 if (-headerViewHeight+offsetY/RATIO&gt;=0) &#123; //将状态变为放开刷新 state = RELEASE_TO_REFRESH; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125;else if (offsetY&lt;=0) &#123; //将状态变为done state = DONE; //根据状态改变headerView，主要是更新动画和文字等信息 changeHeaderByState(state); &#125; &#125; //如果当前状态为done并且已经记录y坐标 if (state == DONE &amp;&amp; isRecord) &#123; //如果位移值大于0 if (offsetY&gt;=0) &#123; //将状态改为下拉刷新状态 state = PULL_TO_REFRESH; &#125; &#125; //如果为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //则改变headerView的padding来实现下拉的效果 headerView.setPadding(0,(int)(-headerViewHeight+offsetY/RATIO) ,0,0); //给第一个状态的View设置当前进度值 mFirstView.setCurrentProgress(currentProgress); //重画 mFirstView.postInvalidate(); &#125; //如果为放开刷新状态 if (state == RELEASE_TO_REFRESH) &#123; //改变headerView的padding值 headerView.setPadding(0,(int)(-headerViewHeight+offsetY/RATIO) ,0, 0); //给第一个状态的View设置当前进度值 mFirstView.setCurrentProgress(currentProgress); //重画 mFirstView.postInvalidate(); &#125; &#125; break; //当用户手指抬起时 case MotionEvent.ACTION_UP: //如果当前状态为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //平滑的隐藏headerView this.smoothScrollBy((int)(-headerViewHeight+offsetY/RATIO)+headerViewHeight, 500); //根据状态改变headerView changeHeaderByState(state); &#125; //如果当前状态为放开刷新 if (state == RELEASE_TO_REFRESH) &#123; //平滑的滑到正好显示headerView this.smoothScrollBy((int)(-headerViewHeight+offsetY/RATIO), 500); //将当前状态设置为正在刷新 state = REFRESHING; //回调接口的onRefresh方法 mOnRefreshListener.onRefresh(); //根据状态改变headerView changeHeaderByState(state); &#125; //这一套手势执行完，一定别忘了将记录y坐标的isRecord改为false，以便于下一次手势的执行 isRecord = false; break; &#125; &#125; &#125; return super.onTouchEvent(ev); &#125; /** * 根据状态改变headerView的动画和文字显示 * @param state */ private void changeHeaderByState(int state)&#123; switch (state) &#123; case DONE://如果的隐藏的状态 //设置headerView的padding为隐藏 headerView.setPadding(0, -headerViewHeight, 0, 0); //第一状态的view显示出来 mFirstView.setVisibility(View.VISIBLE); //第二状态的view隐藏起来 mSecondView.setVisibility(View.GONE); //停止第二状态的动画 secondAnim.stop(); //第三状态的view隐藏起来 mThirdView.setVisibility(View.GONE); //停止第三状态的动画 thirdAnim.stop(); break; case RELEASE_TO_REFRESH://当前状态为放开刷新 //文字显示为放开刷新 tv_pull_to_refresh.setText(&quot;放开刷新&quot;); //第一状态view隐藏起来 mFirstView.setVisibility(View.GONE); //第二状态view显示出来 mSecondView.setVisibility(View.VISIBLE); //播放第二状态的动画 secondAnim.start(); //第三状态view隐藏起来 mThirdView.setVisibility(View.GONE); //停止第三状态的动画 thirdAnim.stop(); break; case PULL_TO_REFRESH://当前状态为下拉刷新 //设置文字为下拉刷新 tv_pull_to_refresh.setText(&quot;下拉刷新&quot;); //第一状态view显示出来 mFirstView.setVisibility(View.VISIBLE); //第二状态view隐藏起来 mSecondView.setVisibility(View.GONE); //第二状态动画停止 secondAnim.stop(); //第三状态view隐藏起来 mThirdView.setVisibility(View.GONE); //第三状态动画停止 thirdAnim.stop(); break; case REFRESHING://当前状态为正在刷新 //文字设置为正在刷新 tv_pull_to_refresh.setText(&quot;正在刷新&quot;); //第一状态view隐藏起来 mFirstView.setVisibility(View.GONE); //第三状态view显示出来 mThirdView.setVisibility(View.VISIBLE); //第二状态view隐藏起来 mSecondView.setVisibility(View.GONE); //停止第二状态动画 secondAnim.stop(); //启动第三状态view thirdAnim.start(); break; default: break; &#125; &#125; private void measureView(View child) &#123; ViewGroup.LayoutParams p = child.getLayoutParams(); if (p == null) &#123; p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125;&#125; 代码中已经有了很详细的注释了，看起来应该会比较轻松。 改进写完之后运行，发现有2个地方可以改进。 下拉白块在下拉刷新的时候，若下拉的高度很高，那么松开刷新后，再次下拉，会出现很大的一个空白块，影响视觉。导致该问题的原因是在RELEASE_TO_REFRESH状态下ACTION_UP时，只是利用smoothScrollBy滑动到headerView的显示位置。但是此时，headerView的paddingTop属性依然是ACTION_MOVE中设置的headerView.setPadding(0,(int)(-headerViewHeight+offsetY/RATIO) ,0, 0);，其值跟offsetY有关，offsetY越大，那么paddingTop值就会越大，导致再次下拉会出现很大的空白块。 改进办法：利用Scroller滑动辅助类替换smoothScrollBy，在滑动的过程中不停设置headerView的paddingTop值。当滑动结束时，headerView的paddingTop正好等于0，即刚刚好显示。 刷新结束后立刻消失刷新结束后，会直接设置headerView的paddingTop为-headerViewHeight，导致headerView立刻不可见，会显得比较突兀。 改进办法：依然是利用Scroller类滑动辅助类，通过滑动动画使headerView不可见。改进后，我的代码是这样的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310public class RefreshListView extends ListView implements ListView.OnScrollListener &#123; /** * 刷新四种状态 */ public final static int DONE = 0; // 刷新完成 public final static int PULL_TO_REFRESH = 1; // 下拉刷新 public final static int RELEASE_TO_REFRESH = 2; // 松开刷新 public final static int REFRESHING = 3; // 正在刷新 private static final int RATIO = 3; // 滑动的比例值 private int state; // 当前的状态 private boolean isRefreshable; // 是否可刷新 private boolean isRecord; // 是否开始准备下拉刷新 private boolean refreshEnd; // 是否刷新结束 private int mFirstVisibleItem; // 当前第一个可见Item private LinearLayout headerView; // 头布局 private TextView refreshText; // 刷新文字说明 private RefreshFirstView firstView; // 下拉刷新 private RefreshSecondView secondView; // 松开刷新 private RefreshThirdView thirdView; // 正在刷新 private AnimationDrawable secondAnim; // secondView对应的动画 private AnimationDrawable thirdAnim; // thirdView对应的动画 private int headerViewHeight; // 头布局的高度 private float startY; // 起始Y坐标 private float offsetY; // Y坐标上的偏移量 private OnRefreshListener refreshListener; // 回调接口 // 滑动类 private Scroller mScroller = null; public RefreshListView(Context context) &#123; super(context); init(context); &#125; public RefreshListView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public RefreshListView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; public void setRefreshListener(OnRefreshListener refreshListener) &#123; this.refreshListener = refreshListener; isRefreshable = true; &#125; /** * 初始化 * * @param context */ private void init(Context context) &#123; setOverScrollMode(View.OVER_SCROLL_NEVER); setOnScrollListener(this); mScroller = new Scroller(context); headerView = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.list_header, this, false); refreshText = (TextView) headerView.findViewById(R.id.pull_to_refresh); firstView = (RefreshFirstView) headerView.findViewById(R.id.first_view); secondView = (RefreshSecondView) headerView.findViewById(R.id.second_view); thirdView = (RefreshThirdView) headerView.findViewById(R.id.third_view); secondAnim = (AnimationDrawable) secondView.getBackground(); thirdAnim = (AnimationDrawable) thirdView.getBackground(); measureView(headerView); addHeaderView(headerView); headerViewHeight = headerView.getMeasuredHeight(); headerView.setPadding(0, -headerViewHeight, 0, 0); // 全局通过设置headerView的paddingTop来控制内部View的显示 state = DONE; isRefreshable = false; isRecord = false; &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; setPaddingTop(mScroller.getCurrY()); &#125; &#125; private void setPaddingTop(int paddingTop) &#123; headerView.setPadding(0, paddingTop, 0, 0); headerView.postInvalidate(); &#125; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; mFirstVisibleItem = firstVisibleItem; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isRefreshable) &#123;//如果现在是可刷新状态 在setOnMeiTuanListener中设置为true switch (ev.getAction()) &#123; //用户按下 case MotionEvent.ACTION_DOWN: if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; //将isRecord置为true，说明现在已记录y坐标 isRecord = true; startY = ev.getY(); &#125; break; //用户滑动 case MotionEvent.ACTION_MOVE: //再次得到y坐标，用来和startY相减来计算offsetY位移值 float tempY = ev.getY(); //再判断一次 if (mFirstVisibleItem == 0 &amp;&amp; !isRecord) &#123; isRecord = true; startY = tempY; &#125; //如果当前状态不是正在刷新的状态，并且已经记录了y坐标 if (state != REFRESHING &amp;&amp; isRecord) &#123; //计算y的偏移量 offsetY = tempY - startY; //计算当前滑动的高度 float currentHeight = (-headerViewHeight + offsetY / 3); //用当前滑动的高度和头部headerView的总高度进行比 计算出当前滑动的百分比 0到1 float currentProgress = 1 + currentHeight / headerViewHeight; //如果当前百分比大于1了，将其设置为1，目的是让第一个状态的椭圆不再继续变大 if (currentProgress &gt;= 1) &#123; currentProgress = 1; &#125; //如果当前的状态是放开刷新，并且已经记录y坐标 if (state == RELEASE_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果当前滑动的距离小于headerView的总高度 if (-headerViewHeight + offsetY / RATIO &lt; 0) &#123; //将状态置为下拉刷新状态 state = PULL_TO_REFRESH; changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125; else if (offsetY &lt;= 0) &#123; //将状态变为done state = DONE; changeHeaderByState(state); &#125; &#125; //如果当前状态为下拉刷新并且已经记录y坐标 if (state == PULL_TO_REFRESH &amp;&amp; isRecord) &#123; setSelection(0); //如果下拉距离大于等于headerView的总高度 if (-headerViewHeight + offsetY / RATIO &gt;= 0) &#123; //将状态变为放开刷新 state = RELEASE_TO_REFRESH; changeHeaderByState(state); //如果当前y的位移值小于0，即为headerView隐藏了 &#125; else if (offsetY &lt;= 0) &#123; //将状态变为done state = DONE; changeHeaderByState(state); &#125; &#125; //如果当前状态为done并且已经记录y坐标 if (state == DONE &amp;&amp; isRecord) &#123; //如果位移值大于0 if (offsetY &gt;= 0) &#123; //将状态改为下拉刷新状态 state = PULL_TO_REFRESH; &#125; &#125; //如果为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //则改变headerView的padding来实现下拉的效果 headerView.setPadding(0, (int) (-headerViewHeight + offsetY / RATIO), 0, 0); //给第一个状态的View设置当前进度值 firstView.setCurrentProgress(currentProgress); //重画 firstView.postInvalidate(); &#125; //如果为放开刷新状态 if (state == RELEASE_TO_REFRESH) &#123; //改变headerView的padding值 headerView.setPadding(0, (int) (-headerViewHeight + offsetY / RATIO), 0, 0); //给第一个状态的View设置当前进度值 firstView.setCurrentProgress(currentProgress); //重画 firstView.postInvalidate(); &#125; &#125; break; default: //如果当前状态为下拉刷新状态 if (state == PULL_TO_REFRESH) &#123; //平滑的隐藏headerView this.smoothScrollBy((int) (-headerViewHeight + offsetY / RATIO) + headerViewHeight, 500); changeHeaderByState(state); &#125; //如果当前状态为放开刷新 if (state == RELEASE_TO_REFRESH) &#123; //平滑的滑到正好显示headerView// this.smoothScrollBy((int) (-headerViewHeight + offsetY / RATIO), 500); mScroller.startScroll(0, (int) (-headerViewHeight + offsetY / RATIO), 0, (int) (headerViewHeight - offsetY / RATIO), 500); //将当前状态设置为正在刷新 state = REFRESHING; //回调接口的onRefresh方法 changeHeaderByState(state); if (refreshListener != null) &#123; refreshListener.onRefresh(); &#125; &#125; //一套操作执行完，重置状态 isRecord = false; break; &#125; &#125; return super.onTouchEvent(ev); &#125; /** * 根据state改变HeaderView * * @param state */ private void changeHeaderByState(int state) &#123; switch (state) &#123; case DONE: if (refreshEnd) &#123; // 如果是刷新结束，则慢慢滚动消失 mScroller.startScroll(0, 0, 0, -headerViewHeight, 500); refreshEnd = false; &#125; else &#123; headerView.setPadding(0, -headerViewHeight, 0, 0); &#125; firstView.setVisibility(VISIBLE); secondView.setVisibility(GONE); secondAnim.stop(); thirdView.setVisibility(GONE); thirdAnim.stop(); break; case PULL_TO_REFRESH: refreshText.setText(&quot;下拉刷新&quot;); firstView.setVisibility(View.VISIBLE); secondView.setVisibility(View.GONE); secondAnim.stop(); thirdView.setVisibility(View.GONE); thirdAnim.stop(); break; case RELEASE_TO_REFRESH: refreshText.setText(&quot;放开刷新&quot;); firstView.setVisibility(View.GONE); secondView.setVisibility(View.VISIBLE); secondAnim.start(); thirdView.setVisibility(View.GONE); thirdAnim.stop(); break; case REFRESHING: refreshText.setText(&quot;正在刷新&quot;); firstView.setVisibility(View.GONE); thirdView.setVisibility(View.VISIBLE); secondView.setVisibility(View.GONE); secondAnim.stop(); thirdAnim.start(); break; default: break; &#125; &#125; /** * 在init时View尚未绘制，为了获取HeaderView的高度，需要此方法提前绘制 * * @param child */ private void measureView(View child) &#123; ViewGroup.LayoutParams p = child.getLayoutParams(); if (p == null) &#123; p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125; /** * 刷新结束后的回调，重置状态 */ public void setOnRefreshComplete() &#123; state = DONE; refreshEnd = true; changeHeaderByState(state); &#125; /** * 刷新回调接口 */ public interface OnRefreshListener &#123; void onRefresh(); &#125;&#125; 讨论在原博客中有这样的讨论：setOnRefreshComplete没必要暴露，隐藏在ListView里面更好。 个人觉得也确实是这样，我们使用下拉刷新只会关心onRefresh，对于setOnRefreshComplete是不关心的。但是setOnRefreshComplete是必须要在onRefresh执行完之后才会执行，对于ListView它是不知道onRefresh在何时结束的，所以如果非要隐藏setOnRefreshComplete，我暂时没想到好的实现方案。 后面我找了一下下拉刷新相关的库，都有类似setOnRefreshComplete的方法。XListView：SwipeRefreshLayout:希望有想法的大神不吝赐教~ 感受 对于自己记忆中模棱两可的知识一定要自己动手做一遍，以加深印象。 可以通过缩放canvas，来实现自定义view的缩放。 通过设置paddingTop值来控制headerView的显示。 在查看XListView相关源码的时候，发现它是这样在View还没显示的时候获取高度的：12345678mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener( new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; mHeaderViewHeight = mHeaderViewContent.getHeight(); getViewTreeObserver().removeGlobalOnLayoutListener(this); &#125;&#125;); onTouchEvent里的事件处理是非常繁杂的，当时自己写滑动删除的ListView时也重写过onTouchEvent，一定要细心。 我的代码代码已上传至我的Github。 参考文章Android自定义控件之仿美团下拉刷新","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"博客添加域名映射","date":"2016-04-07T06:05:45.000Z","path":"2016/04/07/domain/","text":"利用Github搭建博客有一阵子了，每次访问都必须带上github.io，其实我的内心是拒绝的，于是今天打算买个自己的域名，然后映射到博客。 购买域名首先第一步自然是买域名了。许多人都说是用GoDaddy，但是我去搜了一下，随便一个就是15刀，吓死宝宝了~刚开始嘛，弄个便宜的尝尝鲜才是我的目的，于是我上阿里云买了lastwarmth.site这个域名，首年才只收费4块钱哟~ 域名解析登录阿里云，进入到管理控制台，点击域名。可以看到自己购买的域名，点击后面的解析。跳过新手设置引导，直接点击进入高级设置。然后点击添加解析。可以看到记录的几种类型，因为映射到的github.io博客也是Github的域名，所以我选择的CNAME，主机记录配置www，解析线路默认，记录值填写自己的博客地址，我填的是lijia92.github.io。填写完之后，再添加一条@主机记录配置。 Github关联在自己Github的github.io的仓库根目录下创建CNAME文件，编辑，填入你的域名。 最后wait。 稍后便能通过域名访问博客啦。 小问题在更新博客deploy的时候，添加的CNAME文件会被刷掉，导致映射不过去。所以需要将CNAME添加到hexo/source下面，然后重新部署。","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Android接入JPush（极光推送）","date":"2016-04-05T06:14:58.000Z","path":"2016/04/05/jpush/","text":"项目中需要有推送功能，技术负责人最后决定使用极光推送，活被分配给我了，于是我便接了一波，在此小记一下~ 在极光推送的官方文档中，已经有了较详细的说明了，这里只做一下简单的摘录。 三分钟快速Demo在极光推送的官方文档中，有三分钟快速Demo，我也是从demo入手。 创建开发者账号接过sdk的同学应该都知道，再使用第三方的服务的时候，总会需要先注册一个开发者账号。要创建极光推送开发者帐号，请访问极光推送官方网站。 创建应用使用注册账号登录，进入极光控制台后，点击创建应用。创建帐号进入极光推送后，首先显示的是创建应用的界面。填上你的应用程序的名称，以及 Android包名这二顶就可以了。 下载应用Example点击下载Android Example。 启动项目下载后得到一个Zip，可直接解压导入到Android Studio中，然后编译运行项目，安装到手机运行即可。gradle配置可能需要依据你当前开发极其做些修改。 推送消息填写要推送的内容，选择推送对象，点击发送即可推送消息了。这时手机便能接受到推送的消息了。 接入JPush到实际项目导入sdk在官网上下载sdk，然后导入到项目中： 解压缩 jpush-sdk_v2.x.y.zip 集成压缩包 复制libs/jpush-sdk-release2.x.y.jar到工程 libs&#x2F; 目录下 复制libs/armeabi/libjpush2xy.so到工程 libs&#x2F;armeabi 目录下 复制libs/armeabi-v7a/libjpush.so到工程 libs&#x2F;armeabi-v7a 目录下 复制res/drawable-hdpi中的资源文件到工程的 res&#x2F;drawable-hdpi&#x2F; 目录下 复制res/layout中的布局文件到工程的 res&#x2F;layout&#x2F; 目录下 其中5和6，其实是可以忽略的，我导入的时候看了下，这是极光推送默认的布局，在集成的时候，项目肯定会有自己的布局，需要自己去自定义，本身的默认布局是用不到的。 配置AndroidManifest.xml参考官网的示例xml中进行配置AndroidManifest.xml，这里贴一下官网的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;您应用的包名&quot; android:versionCode=&quot;205&quot; android:versionName=&quot;2.0.5&quot; &gt; &lt;uses-sdk android:minSdkVersion=&quot;11&quot; android:targetSdkVersion=&quot;17&quot; /&gt; &lt;!-- Required 自定义用来收发消息的相关权限 --&gt; &lt;permission android:name=&quot;$&#123;applicationId&#125;.permission.JPUSH_MESSAGE&quot; android:protectionLevel=&quot;signature&quot; /&gt; &lt;!-- Required 一些系统要求的权限，如访问网络等--&gt; &lt;uses-permission android:name=&quot;$&#123;applicationId&#125;.permission.JPUSH_MESSAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_USER_PRESENT&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;!-- Optional for location --&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_LOCATION_EXTRA_COMMANDS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt; &lt;application android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;!-- Required SDK核心功能--&gt; &lt;activity android:name=&quot;cn.jpush.android.ui.PushActivity&quot; android:configChanges=&quot;orientation|keyboardHidden&quot; android:theme=&quot;@android:style/Theme.NoTitleBar&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;cn.jpush.android.ui.PushActivity&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;$&#123;applicationId&#125;&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- Required SDK核心功能--&gt; &lt;service android:name=&quot;cn.jpush.android.service.DownloadService&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot; &gt; &lt;/service&gt; &lt;!-- Required SDK 核心功能--&gt; &lt;!-- option since 2.0.5 可配置PushService的android:process参数 将JPush服务配置为一个独立进程 --&gt; &lt;!-- 如：android:process=&quot;:remote&quot; --&gt; &lt;service android:name=&quot;cn.jpush.android.service.PushService&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;cn.jpush.android.intent.REGISTER&quot; /&gt; &lt;action android:name=&quot;cn.jpush.android.intent.REPORT&quot; /&gt; &lt;action android:name=&quot;cn.jpush.android.intent.PushService&quot; /&gt; &lt;action android:name=&quot;cn.jpush.android.intent.PUSH_TIME&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;!-- Required SDK 核心功能 since 1.8.0 --&gt; &lt;service android:name=&quot;cn.jpush.android.service.DaemonService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter &gt; &lt;action android:name=&quot;cn.jpush.android.intent.DaemonService&quot; /&gt; &lt;category android:name=&quot;$&#123;applicationId&#125;&quot;/&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;!-- Required SDK核心功能--&gt; &lt;receiver android:name=&quot;cn.jpush.android.service.PushReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;cn.jpush.android.intent.NOTIFICATION_RECEIVED_PROXY&quot; /&gt; &lt;!--Required 显示通知栏 --&gt; &lt;category android:name=&quot;$&#123;applicationId&#125;&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.USER_PRESENT&quot; /&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt; &lt;/intent-filter&gt; &lt;!-- Optional --&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Required SDK核心功能--&gt; &lt;receiver android:name=&quot;cn.jpush.android.service.AlarmReceiver&quot; /&gt; &lt;!-- User defined. 用户自定义的广播接收器--&gt; &lt;receiver android:name=&quot;您自己定义的Receiver&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;cn.jpush.android.intent.REGISTRATION&quot; /&gt; &lt;!--Required 用户注册SDK的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.MESSAGE_RECEIVED&quot; /&gt; &lt;!--Required 用户接收SDK消息的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.NOTIFICATION_RECEIVED&quot; /&gt; &lt;!--Required 用户接收SDK通知栏信息的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.NOTIFICATION_OPENED&quot; /&gt; &lt;!--Required 用户打开自定义通知栏的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.ACTION_RICHPUSH_CALLBACK&quot; /&gt; &lt;!--Optional 用户接受Rich Push Javascript 回调函数的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.CONNECTION&quot; /&gt;&lt;!-- 接收网络变化 连接/断开 since 1.6.3 --&gt; &lt;category android:name=&quot;$&#123;applicationId&#125;&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Required . Enable it you can get statistics data with channel --&gt; &lt;meta-data android:name=&quot;JPUSH_CHANNEL&quot; android:value=&quot;developer-default&quot;/&gt; &lt;meta-data android:name=&quot;JPUSH_APPKEY&quot; android:value=&quot;您应用applicationId对应的appKey&quot; /&gt; &lt;!-- &lt;/&gt;值来自开发者平台取得的AppKey--&gt; &lt;/application&gt;&lt;/manifest&gt; 其中注意： 标注Required为必须的 包名 AppKey 初始化在Application中初始化JPush。 123456789public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); JPushInterface.setDebugMode(true); JPushInterface.init(this); &#125;&#125; 至此，JPush便已全部集成完毕。至于自定义通知布局，以及Notification的点击响应，后面再说了。 问题 我是小米的测试机，在接收推送消息的时候，必须要启动应用的时候才会收到推送的消息。后面才知道，是有些手机需要允许应用自启动。修改之后便可在没启动应用的时候也能收到推送消息了。点这里传送常见问题。 所感作为一款比较大众的产品，肯定是不会有很多坑的（不然也没那么多人会用它了），在其官方文档的说明上，一般都会有相应的说明。在看文档的时候，一定要仔细，仔细，仔细，重要的事情说三遍~","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android使用VideoView进行视频播放","date":"2016-04-01T07:07:19.000Z","path":"2016/04/01/video-view/","text":"最近在做一个主播类的App，里面涉及到视频播放，之前没有接触过，在探索一阵后能够播放基本视频了。特此写下小记，方便日后查看。 首先，确定使用VideoView进行视频播放。 步骤： 在界面布局文件中定义VideoView组件，或在程序中创建VideoView组件。 调用VideoView的如下两个方法来加载指定的视频: setVidePath(String path)：加载path文件代表的视频 setVideoURI(Uri uri)：加载uri所对应的视频 调用VideoView的start()、stop()、psuse()等方法来控制视频的播放。 若要显示进度条，可结合MediaController一起使用。 下面代码进行说明。 布局文件： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;VideoView android:id=&quot;@+id/video_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/RelativeLayout&gt; Activity： 1234567891011121314151617181920public class VideoPlayActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_video_play); VideoView videoView = (VideoView) this.findViewById(R.id.video_view); videoView.setMediaController(new MediaController(this)); // 添加MediaController videoView.setVideoPath(&quot;你的视频路径&quot;); // 设置路径 videoView.requestFocus(); // 获取焦点 videoView.start(); // 播放 videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; finish(); // 播放结束回调 &#125; &#125;); &#125;&#125; 因为视频播放一般是全屏，直接使用系统的FullScreen会提示需要使用AppCompat主题，所以我给Activity设置了一个style。 123456&lt;style name=&quot;NoTitleFullscreen&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;&lt;/style&gt; 12345&lt;activity android:name=&quot;.ui.VideoPlayActivity&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/NoTitleFullscreen&quot;&gt;&lt;/activity&gt; 实际效果： 因为是虚拟机，效果看起来可能不太满意，但是至少视频是能播放了。后续可能还有屏幕视频适配的问题，现在就不多说了，后面解决了再来更新。 问题：VideoView加载资源需要一定的耗时, 会造成短暂的黑屏现象。如何避免播放前的黑屏现象呢？可以给videoview设置加载的监听，在加载前给一个遮罩，等资源加载完成后隐藏遮罩。 123456789101112131415161718&lt;FrameLayout android:id=&quot;@+id/frameLayout1&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:layout_gravity=&quot;center&quot; android:layout_marginTop=&quot;50dip&quot; &gt; &lt;VideoView android:id=&quot;@+id/geoloc_anim&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;172dip&quot; android:layout_gravity=&quot;top|center&quot; android:visibility=&quot;visible&quot;/&gt; &lt;FrameLayout android:id=&quot;@+id/placeholder&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:background=&quot;@drawable/fondvert_anim&quot;&gt; &lt;/FrameLayout&gt;&lt;/FrameLayout&gt; 设置监听： 123456789videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mediaPlayer) &#123; //Called when the video is ready to play View placeholder = findViewById(R.id.placeholder); placeholder.setVisibility(View.GONE); &#125; &#125;); 今天是愚人节，节日快乐哦~","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"博客搬家","date":"2016-03-25T01:39:01.000Z","path":"2016/03/25/blog-move/","text":"在2015年10月24日，正好是程序猿节，我开始写博客。 在半年前找工作的时候，看到许多许多公司的招聘上，都会有个加分项：拥有维护半年以上的个人博客。 其实也是一直想写博客来着，因为我学习安卓都是从许多大牛的博客中学习的，我也想朝着他们的方向努力。分享自己的知识，帮助他人。 刚开始写博客的时候，还不太熟练，借用的CSDN平台，比较方便快捷的写起了博客。 最近使用Hexo+Github搭建完自己的博客之后，便打算把所有的博客迁移过来，并做了些许调整。 有几篇转载的，写得非常好的文章因为没有md格式的文件，暂时迁移不过来，后面再说了。 文章列表： Android Studio使用Gradle进行多渠道打包 Android实现渐变title栏 Android实现简易轻量下载器：单线程任务队列 Android实现照片墙背景 使用Android新特性：Material Design React Native For Android初探-问题小结 React Native For Android初探 Android Hybrid开发实战之图片的交互 Android Notification使用小记 Android Hybrid开发入门：原生Android与JS的交互 Android仿QQ空间浏览图片 Android Studio中使用.9（Nine Patch）图 Android仿QQ实现ListView滑动删除 Android事件分发机制学习小记 Android Studio使用Genymotion小记 Java反射实现接口 百度定位SDK无法定位 Android DDMS无法输出logcat 现在，我作为一个入门不久的安卓开发工程师，大牛自然是称不上的。但是在学习安卓的路上，各种各样的钉子是肯定会碰到的，我会把这些钉子分享出来，方便他人能够少走一些弯路，也记录我自己在学习之路上的点点滴滴，以及生活中的所想所感。","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"android接入微信支付SDK","date":"2016-03-18T07:04:30.000Z","path":"2016/03/18/wechat-sdk/","text":"本文主要讲述一下android接入微信支付SDK的步骤以及需要注意的一些Tips。 前期准备接入微信支付SDK前期需要许多前期准备。 微信开放平台 注册微信开放平台账号。 登录账号，进入管理中心，创建你的App应用，创建应用的包名与签名要与你实际的应用一致。 进入应用详情，获取AppID，以及申请开通微信支付能力。 等待审核通过。 微信商户平台 注册微信商户平台账号。 登录账号，在基本信息中获得微信支付商户号。 安装操作证书，然后进入API安全设置秘钥，最好使用UUID自动生成的，记住这个秘钥。OK，前期准备做完，下面进行代码接入。 工程接入SDK新建应用工程以AS为例，新建工程，注意包名与使用的签名要与微信开放平台申请应用时填写的一致。 引入libs将libammsdk.jar放到libs文件夹下。 配置debug、release的签名文件123456789101112131415signingConfigs &#123; debug &#123; storeFile file(&quot;你的keystore路径&quot;) storePassword &quot;xxx&quot; keyAlias &quot;xxx&quot; keyPassword &quot;xxx&quot; &#125; release &#123; storeFile file(&quot;你的keystore路径&quot;) storePassword &quot;xxx&quot; keyAlias &quot;xxx&quot; keyPassword &quot;xxx&quot; &#125; &#125; 这里debug、realse我采用的是一样的签名。不论是debug，还是release都能对应上。 AndroidManifest.xml中配置12345678910111213&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;你的AppID&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 也别忘记加入网络权限。 获取prepay_id在支付之前，都需要调用微信的接口https://api.mch.weixin.qq.com/pay/unifiedorder来获得prepay_id。 支付获取到prepay_id之后，调用IWXAPI的sendReq方法即可完成支付。 添加支付成功回调Activity添加wxapi的包名，在这个包名下必须要有WXPayEntryActivity这个Activity，支付成功后会显示此界面。 另外，声明此 Activity 需要添加如下属性： 1234&lt;activity android:name=&quot;.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot; /&gt; 调用接口相关参数以及返回值参考开发者手册。 Tips下面说一下接入过程中需要注意的点。 官网下的demo，第一次支付时，能成功。之后就会一直支付失败。原因是：支付的时候商户唯一订单ID是唯一的，测试的时候请不断的更换订单ID参数支付。若要继续使用demo支付，可以微信清除数据、或者退出登录重新登录。 微信支付返回-1，一般是签名错误。这个签名有2种意思：1、Apk签名文件，debug与release最好使用同样的keystore；2、参数MD5签名生成的sign。要仔细检查是否正确。 签名、包名必须跟微信开放平台申请的一致. 获取prepay_id最好是在服务器完成，由服务器去跟微信服务器交互，客户端不需要参与，以免泄露重要信息。 与微信接口交互时，参数都需要签名。签名方法如下图：这里重点说一下。 参数名ASCII码从小到大排序（字典序） 参数名区分大小写，包括sign。 需要添加商户key值，这个key即是在前期准备中，我所说的微信商户的那个秘钥。 若接入过程中注意到这些Tips，一步一步来，那么应该是能支付成功了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Hexo-Tools","date":"2016-03-17T10:14:16.000Z","path":"2016/03/17/hexo-tools/","text":"本文主要讲述一下使用Hexo搭建博客的过程中，使用的一些比较实用的工具。 七牛介绍在博客中若要插入图片，我们可以直接将图片放在本地。但是这样的话，在deploy的时候，图片也会上传至Github。但是Github上的空间只有300Mb，很有可能导致以后不够用，所以最好找一个图床。之前听说过七牛，便打算试一试。它： 注册之后实名制便有10G的免费空间，一段时间内是肯定够用的； 比较稳定； 有很多实用的工具，你可以使用； 更多的就待以后慢慢发现了~ 注册 去到七牛官网注册账户。 上传图片 创建空间。 长传图片。选择空间后，点击内容管理。点击上传文件。在长传文件时，建议加入路径前缀，方便后面进行查找。 使用图片 在七牛中预览图片，点击复制外链。 在Markdown中引用1![这里输入图片描述](图片外链地址) Atom介绍在代码编辑器、文本编辑器领域，有着不少的「神器」级的产品，如历史悠久的 VIM、Emacs 以及如今当红的 SublimeText。另外还有 EditPlus、NotePad++、UltraEdit 等一大堆流行的利器，可谓百家争鸣。 然而，作为目前全球范围内影响力最大的代码仓库&#x2F;开源社区，GitHub 的程序员们并不满足于此。他们使用目前最先进流行的技术重新打造了一款称为“属于21世纪”的代码编辑器——Atom， 它开源免费跨平台，并且整合 GIT 并提供类似 SublimeText 的包管理功能，支持插件扩展，可配置性非常高…… ATOM - 由 GitHub 打造更为先进的编辑器 安装去到 Atom 官网，进行下载安装。 使用点击File–&gt;Open Folder…打开自己的工程。然后便可以随心所欲的编辑了~ Markdown编辑与预览 打开任意.md文件(Markdown源文件); windows下使用快捷键 ctrl + shift + p，打开命令输入框； 输入Markdown Preview Toggle(可以偷懒只输入mdpt，支持模糊匹配)。也可以通过菜单栏Packages-&gt;Markdown Preview-&gt;Toggle Treview。按enter键即可看到预览，左边编辑，右边实时预览。也可以直接使用快捷键Ctrl + Shift + M。 如此便能非常方便的编辑、预览我们的博客了。","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo-Tips","date":"2016-03-17T04:23:14.000Z","path":"2016/03/17/hexo-tips/","text":"本文主要讲述一下使用Hexo搭建博客的一些Tips。 hexo基本指令 hexo clean 清除 hexo new page “menu name” 新建菜单 hexo g &#x3D;&#x3D; hexo generate 生成 hexo d &#x3D;&#x3D; hexo deploy 部署 hexo s &#x3D;&#x3D; hexo server 启动本地 hexo n &#x3D;&#x3D; hexo new 新建 首页文章显示在md文件中添加&lt;!--more--&gt;，那么首页就只会显示这个标签之上的内容了，并显示一个阅读全文的按钮。 部署到Github保证README.md不被渲染 在Hexo目录下的source根目录下创建README.md文件,并编辑保存。 编辑Hexo目录的_config.yml文件中的“skip_render”参数。1skip_render: README.md 部署到Github，然后看仓库是否有README.md。 博客基本配置打开hexo目录下的_config.yml文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 听雪楼 #站点名，站点左上角subtitle: 那是一座悲欢离合聚集的楼。 #副标题，站点左上角description: #对站点的描述author: 最后的温存 #作者language: zh-Hans #语言timezone: #时区# URL## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: http://lijia92.github.io/ #站点Urlroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next #主题插件# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署相关信息 type: git repository: https://github.com/LiJia92/LiJia92.github.io.git branch: master 分类与标签1.若已存在分类或标签，则直接修改。打开hexo/source/tags/index.md。修改为如下。 123title: tagsdate: 2016-03-16 15:33:44type: &quot;tags&quot; 时间可随意修改，必须设置type字段为”tags”。分类也如此： 123title: categoriesdate: 2016-03-16 15:33:56type: &quot;categories&quot; 2.若不存在，则直接新建，修改为1中所示即可。 12$ hexo new page &quot;tags&quot;$ hexo new page &quot;categories&quot; index.md中不需要再额外写什么东西，它会根据你日志的分类、标签自动匹配。 123456title: Windows使用Hexo + Github Pages搭建自己的博客date: 2016-03-17 11:30:45tags: - blog - hexocategories: hexo 主题hexo有许多主题可以选择，可以参考知乎回答选择自己喜欢的主题。我这里选择的是next主题。 下载主题使用Git Bash进入到hexo目录。输入指令下载主题： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 使用主题回到上面的_config.yml配置文件中，找到theme字段，修改成next主题： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next Next主题相关语言hexo/_config.yml的配置中，language字段若要使用中文，需使用zh-Hans。 菜单hexo/themes/hexo-theme-next/_config.yml的配置中。menu是设置菜单，menu_icons是设置菜单对应的图标。这里对应的key都必须是一样的，大小写也有区分。 1234567891011121314151617181920212223242526272829# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: home: / categories: /categories archives: /archives tags: /tags # about: /about commonweal: /404.html# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置个人信息hexo/themes/hexo-theme-next/_config.yml的配置中。将图像avatar.png放在hexo&#x2F;themes&#x2F;hexo-theme-next&#x2F;source&#x2F;images目录下。avatar–&gt;个人头像，author–&gt;昵称，description–&gt;描述 12345avatar: /images/avatar.pngauthor: lastwarmthdescription: 如果要飞得高，就该把地平线忘掉 社交信息hexo/themes/hexo-theme-next/_config.yml的配置中。设置社交信息与icon，与菜单一样，key值需要完全对应，区分大小写。 123456789101112# Social linkssocial: GitHub: https://github.com/LiJia92 Weibo: http://weibo.com/2950244271# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo Schemeshexo/themes/hexo-theme-next/_config.yml的配置中。Next主题有三种Scheme，可随意切换。 123#scheme: Muse#scheme: Mistscheme: Pisces 网站图标与设置个人图像类似。 12# Place your favicon.ico to /source directory.favicon: /images/avatar.png 集成多说hexo/themes/hexo-theme-next/_config.yml的配置中。设置duoshuo_shortname字段。 12# Duoshuo ShortNameduoshuo_shortname: lastwarmth 这个ShortName怎么来？进入多说红色方框填写的即是ShortName 代码高亮hexo/_config.yml的配置中。修改auto_detect字段为true 12345highlight: enable: true line_number: true auto_detect: true tab_replace: hexo/themes/hexo-theme-next/_config.yml的配置中。修改highlight_theme: normal字段。NexT使用Tomorrow Theme作为代码高亮，共有5款主题供你选择，可选的值有 normal，night， night blue， night bright， night eighties。 12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 问题 本地预览没问题，deploy后主页显示大面积空白 点此 更多更多请查看 Next 官网","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Windows使用Hexo + Github Pages搭建自己的博客","date":"2016-03-17T03:30:45.000Z","path":"2016/03/17/hexo-blog/","text":"本文主要讲述一下Windows环境使用Hexo + Github Pages搭建自己博客的一些主要步骤。 介绍Hexohexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在Github上。 A fast, simple &amp; powerful blog framework 超快的速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署：只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 丰富的插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Github PagesGitHub Pages本用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 Websites for you and your projects. Github Pages 有300M免费空间，资料自己管理，保存可靠； Github作为最大的同性交流社区，已经得到了人们的肯定； Github上有很多大牛，学着用 Github ，享受 GitHub 的便利，眼界会开阔很多。 前期准备安装Git去 Git 官网下载相应版本，进行安装即可。 安装Node.js去 NodeJs 官网下载相应版本，进行安装即可。 注册Github账号去 Github 官网进行注册即可。注册完之后记得添加 SSH Key。 搭建博客安装Hexo在本地新建一个blog文件夹，右键，选择Git Bash。输入指令安装Hexo： 1npm install -g hexo 等到完成之后，输入指令初始化Hexo： 1hexo init Hexo 完成之后，便能在blog文件夹下看到hexo文件夹了。 进入到hexo目录，输入指令npm install，安装依赖文件 12$ cd hexo$ npm install 安装完成之后，输入指令部署： 12$ hexo generate$ hexo server 此时打开浏览器，输入http://localhost:4000/便可看到最原始的博客了。 此时，Hexo已搭建完毕。 GitHub创建仓库登录Github，点击New respository。 输入仓库名：你的Github名称.github.io。然后点击Create repository。图中因为我已经创建，故给出提示，不用管。 托管到Github打开hexo配置文件_config.yml。 编辑deploy属性：repository属性改成你的git地址即可。 然后Git Bash进入到hexo文件夹，输入指令即可完成部署： 123$ hexo clean$ hexo generate$ hexo deploy 最后，打开你的github.io页面看下效果吧~","tags":[{"name":"博客","slug":"博客","permalink":"http://lijia92.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Android Studio 使用 Gradle 进行多渠道打包","date":"2016-03-09T06:39:58.000Z","path":"2016/03/09/gradle-pack/","text":"使用Android Studio也有一段时间了，最近项目开发完成，内部测试也已经通过。下一步就是渠道打包，然后上线了。 在出渠道包的时候，若是出一个包，便手动修改一次渠道号，很显然是很费时费力的。庆幸的是，Android Studio采用的Gradle可以很方便的实现我们的多渠道出包。 下面结合代码进行说明。 项目中使用的是友盟，在AndroidManifest.xml中有这样的代码： 1&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; /&gt; 其中${UMENG_CHANNEL_VALUE}中的值就是在gradle中自定义配置的值。 然后在项目的build.gradle中利用productFlavors进行多渠道的配置，在android节点下添加如下代码： 1234567891011121314151617181920productFlavors &#123; official &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;official&quot;] &#125; baidu &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;baidu&quot;] &#125; _360 &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;_360&quot;] &#125; samsung &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;samsung&quot;] &#125; huawei &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;huawei&quot;] &#125; lenovo &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;lenovo&quot;] &#125; &#125; 项目实际情况，便是上线百度、360、三星、华为、联想这5个市场。 至此，所有的配置已经完成。下面开始编译出包了。 在Android Studio中打开Terminal：输入指令gradlew assembleRelease便可以生成所有的渠道包了。但是此次命令中使用的gradle版本无法控制，很有可能会去下其他的gradle版本，gradle的下载需要翻墙，若是没翻则会一直下载，耽误时间。这里我们直接ctrl+c，再输入y，终止操作。使用下面的方法。 先找到gralde的根目录，在系统变量里添加两个环境变量： 变量名为GRADLE_HOME，变量值就为gradle的根目录。在我的环境里，使用的gradle 2.2.1的版本，目录是C:\\Users*****.gradle\\wrapper\\dists\\gradle-2.2.1-all\\c64ydeuardnfqctvr1gm30w53\\gradle-2.2.1。 然后在系统变量path里面添加gradle的bin目录%GRADLE_HOME%\\bin。 这里配置完成了，接着在Terminal中敲下gradle assembleRelease就可以一次性生成所有的渠道包了。build成功后，便可生成所有渠道的渠道包了。若是想单独生成某一个渠道包，先打开Android Studio右侧的Gradle栏：点到相应项目的build task中。要生成什么渠道包，双击相应的栏目即可。 改进：将productFlavors改成如下，更加简洁些： 123456789101112productFlavors &#123; &quot;official&quot; &#123;&#125; &quot;baidu&quot; &#123;&#125; &quot;_360&quot; &#123;&#125; &quot;samsung&quot; &#123;&#125; &quot;huawei&quot; &#123;&#125; &quot;lenovo&quot; &#123;&#125; &#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125;","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android实现渐变title栏","date":"2016-03-02T02:03:48.000Z","path":"2016/03/02/change-title/","text":"最近用美团外卖点餐看到这样一个效果： 顶部的title栏伴随着滑动有这样的一个效果，看起来很不错。 正好项目中可能需要用到，于是打算自己实现一波。 后面在百度、谷歌之后，发现ToolBar+CoordinatorLayout可以很轻易的实现这种效果。 但是在项目中，并没有采用Android新特性的一些东西，所以就得基于目前状况想办法了。 先上一下最终的效果图： 项目中并没有使用ToolBar这种控件，而是全部自己写的xml文件当做title，整个页面又是由ListView构成。顶部的遮罩背景是添加的一个HeaderView。 贴一下这个页面的布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffffff&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ListView android:id=&quot;@+id/share_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:divider=&quot;@null&quot; android:scrollbars=&quot;none&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/profile_header&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/activity_head_normal_height&quot; android:background=&quot;#00ffffff&quot;&gt; &lt;ImageView android:id=&quot;@+id/profile_play_entry&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_vertical|right&quot; android:scaleType=&quot;center&quot; android:src=&quot;@drawable/play_entry&quot; /&gt; &lt;TextView android:id=&quot;@+id/profile_page&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;我的&quot; android:textColor=&quot;#ffffff&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/FrameLayout&gt; &lt;View android:id=&quot;@+id/divider&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1px&quot; android:background=&quot;@color/dark_gray&quot; /&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; 使用了一个布局固定在顶部，利用FrameLayout进行遮盖。那么要怎么样实现图中的效果呢？ 起初，我是想着自定义View，然后重写onTouchEvent事件，但是后面考虑到滑动距离，上滑、下滑等等很多可能性之后，可能需要各种各样的逻辑判断，会显得非常复杂，所以便放弃了这种思路。 后面考虑到，其实我只需要获得到ListView顶端滑出屏幕的纵向距离，然后计算alpha值，赋给title的父布局应该就可以实现了。 若是使用ScrollView，则会有个方法getScrollY可以直接获得到滑出的Y值，但是ListView我试了一下，获得的Y值总是0，所以得另想办法了。 在网上找到这样的一个方法： 123456789public int getScrollY() &#123; View c = mListView.getChildAt(0); if (c == null) &#123; return 0; &#125; int firstVisiblePosition = mListView.getFirstVisiblePosition(); int top = c.getTop(); return -top + firstVisiblePosition * c.getHeight() ;&#125; 就是通过item高度，以及第一个child的top值来计算出滑出的距离。 结合这个思路，写出如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private AbsListView.OnScrollListener mScrollListener = new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE &amp;&amp; !nothingToLoad) &#123; // 如果到达最后一行 if (shareList.getLastVisiblePosition() == shareList.getAdapter().getCount() - 1) &#123; loadMore(); // 加载更多 &#125; &#125; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; float scrollY = getScrollY(); float alpha = getAlpha(scrollY); profilePage.setAlpha(alpha); if (alpha &gt; 0.5) &#123; // alpha &gt; 0.5设置黑色图标 if (isWhite) &#123; entryPlay.setImageResource(R.drawable.play_entry1); profilePage.setTextColor(Color.BLACK); ObjectAnimator animator = ObjectAnimator.ofFloat(entryPlay, &quot;alpha&quot;, 0.5f, 1); animator.setDuration(1000); animator.start(); &#125; isWhite = false; &#125; else &#123; // 否则设置白色 if (!isWhite) &#123; entryPlay.setImageResource(R.drawable.play_entry); profilePage.setTextColor(Color.WHITE); ObjectAnimator animator = ObjectAnimator.ofFloat(entryPlay, &quot;alpha&quot;, 0.5f, 1); animator.setDuration(1000); animator.start(); &#125; isWhite = true; &#125; if (Math.abs(alpha - 1) &lt; 0.03) &#123; divider.setVisibility(View.VISIBLE); &#125; else &#123; divider.setVisibility(View.GONE); &#125; header.setBackgroundColor(Color.argb((int) (alpha * 255), 255, 255, 255)); &#125; &#125;; /** * 计算ListView顶部滑动Y值 * * @return */ public float getScrollY() &#123; float scrollY; View c = shareList.getChildAt(0); if (c == null) &#123; return 0; &#125; int firstVisiblePosition = shareList.getFirstVisiblePosition(); int top = c.getTop(); if (firstVisiblePosition &gt; 0) &#123; scrollY = mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height); // 当HeaderView完全滑出时，alpha值为1，直接设置其高度值 &#125; else &#123; scrollY = -top; &#125; if (scrollY &gt; mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height)) &#123; scrollY = mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height); &#125; return scrollY; &#125; /** * 根据滑动Y值计算alpha值 * * @param scrollY * @return */ public float getAlpha(float scrollY) &#123; if (mHeaderView.getHeight() != 0) &#123; return scrollY / (mHeaderView.getHeight() - getResources().getDimension(R.dimen.activity_head_normal_height)); &#125; return 0; &#125; activity_head_normal_height就是title栏的高度，所以能够滑动的最高距离是ListView的HeaderView的高度减去title的高度，当滑出高度大于这个高度，alpha直接就等于1了。 通过上述代码，即可实现之前的效果了。 疑问： 当HeaderView完全滑出的时候，c.getHeight() !&#x3D; mHeaderView.getHeight()，按理说c应该是跟mHeaderView是一致的； 在滑动过程中，白色变黑色如何能够让它更自然的过渡呢（图标、文字）？目前是alpha &#x3D; 0.5这个阈值，直接由白变黑，由黑变白，显得不太自然。 欢迎网友们一起探讨~","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android实现简易轻量下载器：单线程任务队列","date":"2016-02-23T03:40:10.000Z","path":"2016/02/23/single-thread-queue/","text":"最近的项目是一个与音乐相关的App，其中有一个功能：收藏喜欢的歌曲，在wifi的环境下自动下载。 考虑到音乐歌曲都是3、4Mb的小文件，断点下载的功能便不需要了。因此只需要实现一个特别轻量、简单的下载管理类，进行管理即可。 最初的思路便是任务队列，单线程顺序执行，一个文件接着一个文件进行下载。 之前看过AsyncTask的部分源码，其设计与我的想法类似，于是便借鉴着AsyncTask的源码，实现了一个特别简单、轻量的下载管理类。 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class MyDownloadManager &#123; private static final String TAG = &quot;MyDownloadManager&quot;; private File downloadDir; // 文件保存路径 private static MyDownloadManager instance; // 单例 // 单线程任务队列 public static Executor executor; private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;MyDownloadManager #&quot; + mCount.getAndIncrement()); &#125; &#125;; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;&gt;(128); public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(1, 1, 1, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); private MyDownloadManager() &#123; // 初始化下载路径 downloadDir = new File(AndroidCacheUtils.getCacheDirFile(MiaApplication.getInstance()), &quot;download&quot;); if (!downloadDir.exists()) &#123; downloadDir.mkdirs(); &#125; executor = new SerialExecutor(); &#125; /** * 顺序执行下载任务 */ private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; /** * 获取单例对象 * * @return */ public static MyDownloadManager getInstance() &#123; if (instance == null) &#123; instance = new MyDownloadManager(); &#125; return instance; &#125; /** * 添加下载任务 * * @param path */ public void addDownloadTask(final String path) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; download(path); &#125; &#125;); &#125; /** * 下载文件 * * @param path */ private void download(String path) &#123; String fileName = AndroidMD5.MD5(path); File savePath = new File(downloadDir, fileName); // 下载文件路径 File finallyPath = new File(downloadDir, fileName + &quot;.mp3&quot;); // 下载完成后加入.mp3后缀 if (finallyPath.exists()) &#123; // 文件存在则已下载 Log.i(TAG, &quot;file is existed&quot;); return; &#125; if (AndroidNetWorkUtils.isWifiDataEnable(MiaApplication.getInstance())) &#123; // 如果是Wifi则开始下载 if (savePath.exists() &amp;&amp; savePath.delete()) &#123; // 如果之前存在文件，证明没有下载完成，删掉重新创建 savePath = new File(downloadDir, fileName); &#125; Log.i(TAG, &quot;download start&quot;); try &#123; byte[] bs = new byte[1024]; int len; URL url = new URL(path); InputStream is = url.openStream(); OutputStream os = new FileOutputStream(savePath); while ((len = is.read(bs)) != -1) &#123; os.write(bs, 0, len); &#125; os.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (savePath.renameTo(finallyPath)) &#123; // 下载完成后重命名为.mp3文件 Log.i(TAG, &quot;download end&quot;); EventBus.getDefault().post(new DownloadDoneEvent(path)); &#125; &#125; else &#123; // 不是wifi则不下载 Log.i(TAG, &quot;not wifi net, stop download&quot;); &#125; &#125; /** * 添加删除任务 * * @param path */ public void addDeleteTask(final String path) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; delete(path); &#125; &#125;); &#125; /** * 删除本地文件 * * @param path */ private void delete(String path) &#123; String fileName = AndroidMD5.MD5(path); File savePath = new File(downloadDir, fileName + &quot;.mp3&quot;); Log.i(TAG, savePath.getPath()); if (savePath.exists()) &#123; if (savePath.delete()) &#123; Log.i(TAG, &quot;file is deleted&quot;); &#125; &#125; &#125; /** * 返回下载路径 * * @return */ public File getDownloadDir() &#123; return downloadDir; &#125;&#125; 我们看到public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(1, 1, 1,TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);，这句代码便是创建一个线程池。其方法源码及参数说明： 12345678910111213141516171819202122232425262728293031323334/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default rejected execution handler. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; 这里我前三个参数传的都是1，既是最多只有1个线程。sPoolWorkQueue参数则是一个容量为128的任务队列，既最多能存放128个任务。 下面我们看到SerialExecutor的代码，它有一个Runnable队列mTasks ，不断的接受Runnable对象，并通过poll操作，每次取出顶部的Runnable进行执行。结合创建的单一线程池，便实现了我需要的简易、轻量的下载器。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android实现照片墙背景","date":"2016-02-17T09:34:49.000Z","path":"2016/02/17/photo-wall/","text":"项目开发中，有一个这样的需求：在个人主页里会有12张图片的背景墙。这12张图片由服务器返回，会不定时刷新。 第一种方案起初，自己的实现思路是：xml直接定义12个ImageView，然后在接收到图片路径后，再进行异步加载。 显然，这种方法是肯定可以的，但是却显得不“优雅”。而且后续可能会对这整个背景墙有个缩放的动画之类的，那么再实现起来便会比较复杂了。 第二种方案之后，我想到了GridView，显然也是可以的，在得到图片路径后传入到Adapter中即可。比起方案一稍微“优雅”些，但是也是很难将这个背景墙当成一个整体，进行将来可能会添加的动画特效需求。 第三种方案最后，我想到，既然要当成一整个整体，那么自定义View或许是个不错的办法。 思路思路是这样的： 首先ImageView展示初始图片； 下载图片； 所有图片下载完成后刷新View，显示下载的图片墙。 下面上代码。 代码自定义ImageView： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class JointImageView extends ImageView &#123; private Paint mPaint;// 画笔 private List&lt;Bitmap&gt; bitmaps;// 位图 private List&lt;Rect&gt; rectList; // 正方形画bitmap private int width; // 边长 private static int pictureInRow = 4; // 每一行显示4张图片 public JointImageView(Context context) &#123; super(context); &#125; public JointImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); &#125; /** * 设置Bitmap数据 * * @param bitmaps */ public void setBitmaps(List&lt;Bitmap&gt; bitmaps) &#123; this.bitmaps = bitmaps; width = getMeasuredWidth() / pictureInRow; createRect(); postInvalidate(); // 在设置Bitmaps之后重绘 &#125; private void createRect() &#123; // 计算12个矩形的坐标 rectList = new ArrayList&lt;&gt;(AppConfigs.PROFILE_PICTURE_NUM); for (int i = 0; i &lt; AppConfigs.PROFILE_PICTURE_NUM; i++) &#123; Rect rect = new Rect((i % pictureInRow) * width, (i / pictureInRow) * width, (i % pictureInRow + 1) * width, (i / pictureInRow + 1) * width); rectList.add(rect); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; if (bitmaps == null) &#123; super.onDraw(canvas); &#125; else &#123; for (int i = 0; i &lt; bitmaps.size(); i++) &#123; if (bitmaps.get(i) != null) &#123; canvas.drawBitmap(bitmaps.get(i), null, rectList.get(i), mPaint); // 画图 &#125; &#125; &#125; &#125;&#125; 布局文件中使用： 123456&lt;com.android.widget.JointImageView android:id=&quot;@+id/my_profile_background&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/background&quot; /&gt; 项目中使用的Universal-Image-Loader三方库进行图片的加载。 下载图片的异步任务代码： 1234567891011121314151617181920212223242526272829303132private class BitmapLoaderTask extends AsyncTask&lt;String[], Integer, List&lt;Bitmap&gt;&gt; &#123; private List&lt;Bitmap&gt; bitmaps; public BitmapLoaderTask() &#123; bitmaps = new ArrayList&lt;&gt;(AppConfigs.PROFILE_PICTURE_NUM); &#125; @Override protected List&lt;Bitmap&gt; doInBackground(String[]... params) &#123; ImageSize imageSize = new ImageSize(80, 80); // 图片压缩到80*80的大小 for (int i = 0; i &lt; params[0].length &amp;&amp; i &lt; AppConfigs.PROFILE_PICTURE_NUM; i++) &#123; // 使用UIL同步下载图片的方法下载图片，存到bitmap数组 Bitmap bitmap = ImageLoader.getInstance().loadImageSync(params[0][i], imageSize); bitmaps.add(bitmap); &#125; return bitmaps; &#125; @Override protected void onPostExecute(List&lt;Bitmap&gt; bitmaps) &#123; // 全部下载完毕，通知View进行重绘 if (bitmaps != null &amp;&amp; bitmaps.size() == AppConfigs.PROFILE_PICTURE_NUM) &#123; profileBackground.setBitmaps(bitmaps); &#125; &#125; @Override protected void onCancelled() &#123; super.onCancelled(); &#125;&#125; 通过方案三，在实现当下需求的同时，也可以作为一个单独的View，在将来拓展可能的缩放等特效动画。 但是也有一个缺点：必须所有的图片下载完毕才进行刷新。 当然，也可以将刷新策略调整成下载一张刷新一次，这个就得看具体的需求了。 题外话对于图片中的阴影效果，我们可以采用alpha背景来实现。也可以通过色彩矩阵在绘制的时候进行调整。 通过alpha背景实现很简单，在FrameLayout上遮罩一个View，alpha设置成相应的值即可。 12345&lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:alpha=&quot;0.7&quot; android:background=&quot;#000000&quot; /&gt; 通过色彩矩阵就得不停的调整了。 12345678// 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); // 画笔设置色彩矩阵，这样再绘制的时候就会有效果了","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"使用Android新特性：Material Design","date":"2016-02-17T08:34:11.000Z","path":"2016/02/17/material-design/","text":"前言大年初十，相信许多人都已经过完年，在上班的路上或者已经上班了。在这里跟大家说一声：新年好~ 新年新气象，今天打算写一篇关于Android新特性：Material Design的文章。Material Design作为android 5.0的重头戏，说是新特性，但是其实已经算不上“新”了，毕竟android 6.0都出来了呢。 情人节刚过，我便以“秀恩爱”为主题，做一个新特性的使用例子。废话少说，下面开撸。 添加依赖使用新特性需要添加依赖： 123compile &#x27;com.android.support:design:23.0.1&#x27;compile &#x27;com.android.support:cardview-v7:23.1.0&#x27;compile &#x27;com.android.support:recyclerview-v7:23.1.0&#x27; 新组件介绍AppBarlayoutAppBarLayout是继承LinearLayout实现的一个ViewGroup容器组件，它是为了Material Design设计的App Bar,支持手势滑动操作。默认的AppBarLayout是垂直方向的，它的作用是把AppBarLayout包裹的内容都作为AppBar。 常用效果：将Toolbar 和Tablayout的组合部分共同构成 AppBar的效果。 CoordinatorLayoutCoordinatorLayout是一个增强型的FrameLayout。它的作用有两个： 作为一个布局的根布局 最后一个为子视图之间相互协调手势效果的一个协调布局 我们可以用过上滑将顶部的ToolBar移出屏幕，下滑时再显示。 NavigationView用于侧滑菜单中的menu布局。 FloatingActionButton悬浮按钮，给人一种Z轴的空间感。 SnackBar当Snackbar在显示的时候，往往出现在屏幕的底部。为了给Snackbar留出空间，浮动操作按钮需要向上移动。 CardViewCardView继承自FrameLayout类，可以在一个卡片布局中一致性的显示内容，卡片可以包含圆角和阴影。CardView是一个Layout，可以布局其他View。 RecyclerViewRecyclerView用于展示数据集，与ListView、GridView类似，但是它更灵活。 SwipeRefreshLayoutGoogle官方推出的下拉刷新控件，使用非常简便。 布局文件首先是activity_main布局文件： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;include layout=&quot;@layout/content_main&quot; /&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/navigation&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;left&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 看到content_main.xml： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot; app:title=&quot;&quot; /&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tab_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabGravity=&quot;fill&quot; app:tabIndicatorColor=&quot;#ffffff&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;@dimen/fab_margin&quot; android:src=&quot;@android:drawable/ic_dialog_email&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; ViewPager对应的fragment布局： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/swipe_refresh&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; RecyclerView对应的Adapter布局： 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; app:cardCornerRadius=&quot;4dp&quot; app:cardElevation=&quot;5dp&quot; app:cardMaxElevation=&quot;10dp&quot; app:cardPreventCornerOverlap=&quot;true&quot; app:cardUseCompatPadding=&quot;true&quot;&gt; &lt;TextView android:id=&quot;@+id/card_text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;1111&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;30sp&quot; /&gt;&lt;/android.support.v7.widget.CardView&gt; 抽屉对应的HeaderView布局： 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;220dp&quot; android:background=&quot;@drawable/ic_user_background&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/id_header_face&quot; android:layout_width=&quot;120dp&quot; android:layout_height=&quot;120dp&quot; android:scaleType=&quot;fitXY&quot; android:src=&quot;@drawable/user&quot; /&gt; &lt;TextView android:id=&quot;@+id/id_header_authorname&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/header_author_name&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/id_header_url&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/header_author_url&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;18sp&quot; /&gt;&lt;/LinearLayout&gt; 相关说明 使用NavigationView时，通过layout_gravity=&quot;left&quot;属性控制抽屉从左边打开。抽屉内容填充对应于xml属性app:headerLayout与app:menu。 12345678// 跳转到Menu的ToggleActionBarDrawerToggle mActionBarDrawerToggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.drawer_open, R.string.drawer_open);mActionBarDrawerToggle.syncState();drawerLayout.setDrawerListener(mActionBarDrawerToggle);// 抽屉菜单填充内容navigationView.inflateHeaderView(R.layout.header_navigation);navigationView.inflateMenu(R.menu.menu_navigation); TabLayout与ViewPager关联。 123tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);tabLayout.setupWithViewPager(viewPager);tabLayout.setTabsFromPagerAdapter(myViewPagerAdapter); SwipeRefreshLayout刷新设置颜色及刷新事件。 123swipeRefreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.swipe_refresh);swipeRefreshLayout.setColorSchemeResources(R.color.colorPrimary);swipeRefreshLayout.setOnRefreshListener(this); RecyclerView设置布局及Adapter。 12345RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);adapter = new MyRecyclerViewAdapter(getActivity());RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false);recyclerView.setAdapter(adapter);recyclerView.setLayoutManager(layoutManager); CoordinatorLayout可滑动的条件。 CoordinatorLayout必须作为整个布局的父布局容器。 给需要滑动的组件设置 app:layout_scrollFlags&#x3D;”scroll|enterAlways” 属性。 (ToolBar) 给你的可滑动的组件，也就是RecyclerView、ViewPager或者 NestedScrollView 设置属性：app:layout_behavior=@string/appbar_scrolling_view_behavior 设置的layout_scrollFlags有如下几种选项： scroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。 enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 滚动退出屏幕，最后折叠在顶端。 在我的布局中给Toolbar设置了app:layout_scrollFlags属性，因此，Toolbar是可以滚动出屏幕，且向下滚动有可以出现。 最后最终效果：源码地址：https://github.com/LiJia92/showlove Tips：本文只对这些新的特性做了最基本的说明及非常简单的使用，至于更加复杂的使用及效果，则需要在使用过程中慢慢发现、慢慢学习了。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"React Native For Android初探-问题小结","date":"2016-01-19T03:38:48.000Z","path":"2016/01/19/react-native-tips/","text":"在上一篇文章中，我介绍了React Native For Android的基本使用。这篇文章重点介绍一下使用过程中碰到的问题以及解决办法。 真机运行白屏在执行react-native run-android指令编译安装apk到真机之后，运行程序，发现程序白屏，感觉像ANR一样。解决方法：手机设置中打开应用管理，选择我们安装的应用。然后点击权限管理，将显示悬浮框设置为允许。白屏问题便能解决了。 真机运行提示Unable to download JS bundle在我们解决完白屏问题之后，重新运行程序，发现程序能运行了，但是报错了：点击Reload JS后，提示Unable to download JS bundle：解决方法：摇晃设备或按Menu键，可以打开调试菜单，点击DevSettings，选Debug server host for device，输入你的正在运行packager的那台电脑的局域网IP加:8081（同时要保证手机和电脑在同一网段，且没有防火墙阻拦），再按back键返回，再次打开Menu键，在调试菜单中选择Reload JS，就可以看到运行的结果了。 Chrome调试JS 安装拓展程序React Developer Tools。 在模拟器或真机菜单中选择Debug JS，打开调试开关。 Chrome打开：http://localhost:8081/debugger-ui，按F12打开开发者工具便能进行调试。","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"React Native For Android初探","date":"2016-01-15T09:20:02.000Z","path":"2016/01/15/react-native/","text":"介绍Facebook 在 React.js Conf 2015 大会上推出了基于 JavaScript 的开源框架 React Native。React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。 React Native enables you to build world-class application experiences on native platforms using a consistent developer experience based on JavaScript and React. The focus of React Native is on developer efficiency across all the platforms you care about — learn once, write anywhere. Facebook uses React Native in multiple production apps and will continue investing in React Native. React Native 使你能够使用基于 JavaScript 和 React 一致的开发体验在本地平台上构建世界一流的应用程序体验。React Native 把重点放在所有开发人员关心的平台的开发效率上——开发者只需学习一种语言就能轻易为任何平台高效地编写代码。Facebook 在多个应用程序产品中使用了 React Native，并将继续为 React Native 投资。 对于不太了解React Native是什么以及Facebook为什么要创建React Native，可以先看看这篇博客。 Facebook 于 2015 年 9 月 15 日发布了 React Native for Android， 把 Web 和原生平台的 JavaScript 开发技术扩展到了 Google 的流行移动平台–Android。 最近项目技术负责人说可能以后我们也会使用这套框架进行App开发，所以便预先学习一下，顺便做下笔记，分享给大家。 实践安装Node.jsreact native依赖Node.js，第一步便是下载Node.js。去官网下载，对应电脑系统版本。我是Win 10，下载的64位。下载完成后，直接安装。 可以随意创建一个一个test.js，来测试Node.js是否安装成功。 123456789var http = require(&quot;http&quot;);http.createServer(function(req, res) &#123; res.writeHead( 200 , &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;); res.write(&quot;&lt;h1&gt;Node.js&lt;/h1&gt;&quot;); res.write(&quot;&lt;p&gt;Hello World&lt;/p&gt;&quot;); res.end(&quot;&quot;);&#125;).listen(8080);console.log(&quot;HTTP server is listening at port 8080.&quot;); 然后进入到响应的目录，执行cmd，键入命令：node test.js，然后浏览器打开”localhost:8080”，显示如下则是安装成功。 安装native环境使用npm指令安装react-native-cli。打开命令行，执行指令： 1npm install -g react-native-cli react-native-cli是用来开发React Native的命令行工具。你需要使用npm来安装它。上面这行代码将会帮助你在terminal中安装react-native命令。这行cmd命令只需要执行一次，后面便可持续使用。 下面便可以开始创建我们的React Native项目了。 创建项目创建好自己的文件夹之后，cmd命令进入文件夹，执行命令： 1react-native init HelloWorld HelloWorld便是项目名，可自己随意取。执行完毕之后便会生成HelloWorld文件夹。目录结构是这样的：可以看到生成的项目既包含IOS，也包含Android。因为我是Android开发，所以就暂时不管IOS了。 运行项目在命令行执行完毕之后，我们会看到To run your app on Android的提示。进入到HelloWorld文件夹，执行命令： 1react-native run-android 图上所示便是在进行编译，准备安装了。编译成功后，安装运行，界面如下：提示不能下载JS bundle。这里我们注意一下编译时的黄色提示：Starting the packager in a new window is not supported on Windows yet.Please start it manually using &#39;react-native start&#39;.就是说不支持在Windows上自动开启packager，需要我们自己先启动。 照着提示来，执行命令： 1react-native start 可以看到React packager ready. OK，再来运行我们的程序。此时界面变显示正常了：同时React packager会打印一些信息：很多东西都还不懂，暂时就先不管了，后面再慢慢了解，至少现在看起来没出什么错。 js代码初探下面便来研究一下显示到界面上的内容到底是怎么来的。 看到HelloWolrd文件夹下有index.android.js文件，编辑器打开，看到的代码是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Sample React Native App * https://github.com/facebook/react-native */&#x27;use strict&#x27;;import React, &#123; AppRegistry, Component, StyleSheet, Text, View&#125; from &#x27;react-native&#x27;;class HelloWorld extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Shake or press menu button for dev menu &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27;, backgroundColor: &#x27;#F5FCFF&#x27;, &#125;, welcome: &#123; fontSize: 20, textAlign: &#x27;center&#x27;, margin: 10, &#125;, instructions: &#123; textAlign: &#x27;center&#x27;, color: &#x27;#333333&#x27;, marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent(&#x27;HelloWorld&#x27;, () =&gt; HelloWorld); 此时，对着代码与界面，我们便可以大胆的猜测界面上显示的文字就是HelloWorld class中对应的3个Text标签了。下面尝试一下： HelloWorld class代码改成如下： 1234567891011class HelloWorld extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Hello World! &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 我们把之前3个Text标签去掉，写一个显示Hello World的Text标签。那么改好之后如何看到效果呢？？？请注意，这便是React Native框架非常厉害的地方，你不需要重新编译安装apk，更新包等操作，直接虚拟机点出Menu，点击Roload JS即可实现更新：可以看到，界面确实是变成了我们预想的样子。 下面我从官网复制了一份index.android.js代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * Sample React Native App * https://github.com/facebook/react-native */&#x27;use strict&#x27;;var React = require(&#x27;react-native&#x27;);var &#123; AppRegistry, Image, ListView, StyleSheet, Text, View,&#125; = React;var API_KEY = &#x27;7waqfqbprs7pajbz28mqf6vz&#x27;;var API_URL = &#x27;http://api.rottentomatoes.com/api/public/v1.0/lists/movies/in_theaters.json&#x27;;var PAGE_SIZE = 25;var PARAMS = &#x27;?apikey=&#x27; + API_KEY + &#x27;&amp;page_limit=&#x27; + PAGE_SIZE;var REQUEST_URL = API_URL + PARAMS;var AwesomeProject = React.createClass(&#123; getInitialState: function() &#123; return &#123; dataSource: new ListView.DataSource(&#123; rowHasChanged: (row1, row2) =&gt; row1 !== row2, &#125;), loaded: false, &#125;; &#125;, componentDidMount: function() &#123; this.fetchData(); &#125;, fetchData: function() &#123; fetch(REQUEST_URL) .then((response) =&gt; response.json()) .then((responseData) =&gt; &#123; this.setState(&#123; dataSource: this.state.dataSource.cloneWithRows(responseData.movies), loaded: true, &#125;); &#125;) .done(); &#125;, render: function() &#123; if (!this.state.loaded) &#123; return this.renderLoadingView(); &#125; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderMovie&#125; style=&#123;styles.listView&#125; /&gt; ); &#125;, renderLoadingView: function() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt; Loading movies... &lt;/Text&gt; &lt;/View&gt; ); &#125;, renderMovie: function(movie) &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Image source=&#123;&#123;uri: movie.posters.thumbnail&#125;&#125; style=&#123;styles.thumbnail&#125; /&gt; &lt;View style=&#123;styles.rightContainer&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;,&#125;);var styles = StyleSheet.create(&#123; container: &#123; flex: 1, flexDirection: &#x27;row&#x27;, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27;, backgroundColor: &#x27;#F5FCFF&#x27;, &#125;, rightContainer: &#123; flex: 1, &#125;, title: &#123; fontSize: 20, marginBottom: 8, textAlign: &#x27;center&#x27;, &#125;, year: &#123; textAlign: &#x27;center&#x27;, &#125;, thumbnail: &#123; width: 53, height: 81, &#125;, listView: &#123; paddingTop: 20, backgroundColor: &#x27;#F5FCFF&#x27;, &#125;,&#125;);AppRegistry.registerComponent(&#x27;AwesomeProject&#x27;, () =&gt; AwesomeProject); 然后Reload JS，界面如下：呀，出错了。我们看到是在registerComponent的时候出错了。想起来我们的项目名称是HelloWorld，将最后一句代码改掉。 1AppRegistry.registerComponent(&#x27;HelloWorld&#x27;, () =&gt; AwesomeProject); Reload JS。加载完毕后的显示界面：但是将代码改成： 1AppRegistry.registerComponent(&#x27;HelloWorld&#x27;, () =&gt; HelloWorld); 执行又出错了：看来东西不能乱改呀，至于是什么原因，就放在以后慢慢去发现去解决了。另外这种JS代码的写法也是需要在实践中慢慢积累，学习，才能逐步掌握。 今天就到这里了，代码都是自动生成的，便不上传了。Have a nice weekend~","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android Hybrid开发实战之图片的交互","date":"2016-01-14T06:32:59.000Z","path":"2016/01/14/hybrid-practice/","text":"前言最近一直在学习Hybrid开发，如何在H5页面调用Android原生接口，并返回值，以及回调。学习了一段时间，总算是有点收获，效果也做出来了。于是写下这篇博客，记录一下。 本文中我以2个接口示例，来进行讲解。第1个示例很简单，就是调用接口，返回登录Token；第2个示例是H5调用接口，弹出Android原生界面进行图片选择，选择完之后返回选择图片的Base64格式的字符串。然后H5页面接收返回的字符串，回调进行图片显示。 Base64首先，讲解一下Base64。图片也是一个文件，可以通过Base64返回这个文件的Base64字符串，这个字符串可以直接放到H5的img标签进行显示。 下面做个示例，方便大家了解。新建一个Html文件，编写代码如下： 1234567&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAAwCAMAAAChd4FcAAAAA3NCSVQICAjb4U/gAAACRlBMVEUAAADi6OSMjIxSUlIrXja5trg8rFEDRhErokJ8w4pJrVxmZmYERRIinTn++P07nk/X0Naww7Stra0pdTj37/dlunUXWiS53L+ZmZmOy5pahGJKdVIQEBAsXzdni24VmC7MzMw1kEYzMzPZ4Nul1K6Wr5tWs2jp8eseaC0ufz5mZmaEoorI1cszpUkXTSJErFix2bi1tbVKSkp7e3skWC9wvn5zlHq6yL3S3dSXzqJBcEspKSnY6dxCQkLI486mvKulpaVAbUkTSx8ICAgjcDIhISHh7eM6Ojonnz1QsGP///+Dxo9Re1paWlqNqZOZzJmasJ6s1rMZGRk4pkx5wYYcYyodmzViuHPFxcVEtFl5mH/V3def0qlhh2rZ7d7F2MiEhIQ4Z0Lv8+/F4csvo0QbUidAp1OEoIoqfDozZjOx27kOSho6mkw2j0iftaMyi0S2xroSUiBrvHuFx5J0v4Lm7+eNqJOc0KVBq1TU59gpoEBskXRzc3Pg2N6tubDe5d99nYRNr1+ZmZkbWyg9pFHN18779/patWuZzJkzZT6Sq5e0xbfAz8OtvbUhazC12ryJpY6+3sXD0MbE4MmJyJUgVCtSsmXQ5tWjuKd5wobd8OEfYy0ZUCS9vb3v7+8LRxgtgD0xZzw1j0cnWjJiimp2mX2An4aUtZye1qkYmjDm5ube3t7W1tbk9+fM5NA4lEombjRWfl9Ke1K2270xhUGbs6BrjnI7akSY1aSrvq+5yr1Kc0q8zL/19fVrvXMxYjt5mX+1vbVNR7MSAAAACXBIWXMAAAsSAAALEgHS3X78AAAAFnRFWHRDcmVhdGlvbiBUaW1lADAzLzI0LzEzWoVZMQAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNXG14zYAAAt9SURBVFiFzZn/U9NoHsfDl3KFXgOWAQtUL0Kh7EiF0sUFSqG0UsoDdYQgxBM9zUbOubIo2C7feoeM8HRWdjiqq7jnJuyt685d2ivrCHg4ZvRPuydJW5ICCj/s6WeYJn1Kklfen29PnmDCJ27YAeMQwv8rx4G2DyAEyNAWR5uPT7kHEICs16vbL1pbW/vmzr+xfHTGDEAgHLuSe2biXu25c+dqSycmTpxcFj4uogoQwPFXgdKbG4vT9aJNL27cLHV3dkDwsegENSB4UBGo3ZhW21dPAxV1H5FwFxDC1TOlG0i3TDtV+kO12s0ofZJpLn4kE16K1nTuox1pHMeTBzy4i3Ju/As5AY8Q2WlAXPh5vXh0L55oxetzyqoDLl+4DHie4CC9FIccH4+JJA8uzEOhqAh9hzzPxWIwViTAeYJHv4HmC6Fvy1+/xuuqqurGq3DLkyfcUQFx4UXg1qV98ZBtrl/ZJcSX+t51NrMG1sCxlIaIGSlXHIJjfavlNMsaiJgGUAQaImw2NqYhDDyE3/ad7Vu+fvrV7dM7z/vOtoa2V8tPHjZqUoDwSuCnA/mmL90KbKe9AubGwdd3qTjQsC6KdRUhIArHb3f++fa8AXCGOCsCLgEDh3M2G+GiADi5A0LL5eDC6urO2WXQd7luZ67isD5OAoLT6wfrJ2t4PnXPYHsL3P8FASK9+FhMBEKAVcvVr/6mAZytSFJwCSLAmIHi4/MQnOwAdePboPr86s4fl0H5t+Vbq334kQDBa/fN9/KhODzzIEmIP+h811fFulgNbWBZKi4ruNx6/0WzRmMjOBflWqIIQBk0bNxA2JCL37Q+f9FxBdxfPd1x9hh48UXF+Z9bD8knA0L61cX34yG7lz4naN6qAhoiTkO6qEiQkgJh112oAnRRDEI+znM8SoJ4PJ0kS1shrhnOz1dlXeaFJaF5/PISfRRA8HVgbP/8VdhGoDrlZBxAyMbEb4rkTpcZCFMlKF1m0G9y3RE3QOryR1EQWt7+mslXv7cgrlynD4hs/ICAOmhcZpa3H2pTIiDY2iPg2KlTGxlF8VKh+4l8Mohn2FobLii/p06+ZtlFxdX/AClKPlmMSvKqTa1gRUYEbpa6f/jBXfrZ6KhisPDH3/0sHQfXyloUVhYNkWQDaJhsStpkr6w03q+/k2JtKFMdASHn8UiEoBsj0BYSOpVlKwFB86NNZQovPj1z5djS0u25G/cK0yKeWnE/Kl+SLxz8g17PMD69Xj9rZfRDBUIZw7QUMLOzswxJarU+0ivJBKb0+UBWrJ1h9LumJdsAsGOVUtA6MI3Y+5yY2mJAATg+UahK19w3ssx1128syg4XJzVfVyWFhwmkQkFe71TLSNAamWqJ4ng/OVlQcDyRKGMi7e0Pr+IJc39/f0OQGW5AW/NxPMrUNKTspbmAvFqUnW3qMoqOrUQKShun/do1u2jhHLvdBZUKzpUqXVn8aClJD+ZzV+rrF29dDDzbfiPsxoWoSY8VqQAakEZAjD/vWl6JpTcYIQuCwWAbXYB09Pms9ST69DHMTLt2cK1lKmntEfI/3ZJMYUQ0gPnt9mzYjRlAVpakS46JUMcg3lerSIcxd7plCOCJe7N44kzFVlZmWbAskAkE1u8bRFFmaQiBNnKyxUeS09Mk6Wuh6/Mm8wfzI+Tj/MHBwXrrlwnt4OQQigCrVqsdGhwm/2HThXWYqSvt0bgTM8QwTzbiM2BSVCqTpLNYAfjjs6x0FkL6n+tv39XBPVUL0hIgEAFx/PhQjdeLAGeD0Zcvo8HZKbp+2osuNSLHYIRpb9c2WRKJtYjVPJNIeGvIGQnET4TDYRPmD4clBecHMMwZAw4sR3k5TIBZb28qAFeUbRx/0GHZW1MhLSrYDmnc7BtEX4R8fWRtdLLFKp/BKgKKhadFny/eqwwIQ6FQCXOcDtF0DzmD4/yAKQ52Y7AbcwE+B8MGcjBPPBMwVwl4UdXG95lZQstkT03N9DT6qFnIK6ipebyGf1/TjgCZyPfIIsx+gIO9Pqs1DwUAST6MiAo6sW5KbCwOjAVStXEhzGwTcrdRpYgIeEIJeE41EdqnJ+FtpNWKxBI/UcxZrUwUNTLRxdpJ88iIeVJycUhyca8ozrAIGGxoCgYX8iZLSu601ZBXgV+MPL8aELVAHRp1ZQAK9CtlDG5+XrX7D/Qv1fN7RbyamDk+Onp8Zq0NMbUlZiC80/SlddA8axXLo9VnRklSZjabm5jhfrTpYVCSTIqok0xb/gKN95BXRRCHCQsDoFQQhj1YpoRiFlesKAALJ97tZvH937s/L+/gMxghBAkruhAulRmUBlfJAjOTL5jLRhbyyu40CJZpxieXGb1UZhIJbZMX5U/EOpI/G2yryfsTNqDDdJRJDaipxLBGtkutoVgHt0uVdfrmmdtJHlD3qLjwx3vu3JPHODUj+G62BM1LkmUGf6ltGvGVge8WvMP1d6ZHcLxhMD8/v3eYfNyLtoMt8CETjAwhVCuqNPrHEbKNitlQsvJSJ0kC2oxiZYQg1oV5OKgC3FJ3kpUb49LqB9j5/OIomtWIfeTt2Te0olJ767UtIlkSMN/X0uuLtmsLvJH6MpKJyv1NikF5N6oNRlPduOyllCQuBCiaA6PkLGaNpkYpoXmnTl2owdKNW6qJy6/uivvLy9V97pXF5PhG8cTE9bt1KRcLJUy9F6YAYaiA7F+oj/b4/g5qSG+vbzh5G8ksRntRbQmdNu8CKjMSIEFRRBdmJCgC78bscRsRp5ARyHhlqxOE1hX1zOqn2glkF28px06dmwgkeww9yTBm8dK4WR9E5WRKX4JcHhn67stgPekNTfse4knA79OApNKsEqDOtTs3MGZMFrrSTpbmg+fdKh8jWxwbW8wYurQRuC8B4u0+ckRGaPg30ggfWWjvIRP//Rc+OMTUWMBfSrzyrGfqD0kFBUvwcY3C8mkoNhKqMmXdhMHRpTS/0sUCPv+s+AOPTKIVn0gJH02kLtyfZIkmQNFf8VA0ahFsfCqfQmZvSgf11Bo1SYE3EtKDgGR7FvrUE1YB3A0UfvCZZCywuvtMsruCKB0v9Sw56LMqWXQ1+QfF3FjahfIOeixxNR72sUR+qgudWPmggE+/SccFoIxGNKMEcSOSQQC0wajBQaUubrQJkGN5geU1Rkr+wZicebLzrJEVJ2Yao4sDsW6TgTvco3vyubgjsPkBJ38WOJa+ZV1l2D+QDYwOe9ikA4QjJ1xZyTUONOaYnMI8ZhM8jpxGTxhQA357jkmcMAucqQsN6YDF2Wj3OyjKYQrzRwFEk9bAxvsIL321/jy9smDEUG9BH36PgWcNkm95O++sBIDFCB4BYnYAwibIGiFHIFAREG3ANQ/QdcV4vtEE7I7Drm8lAaFQMTH2nrWZDfeL9CMw0DmQ+7JQB8ju7qrMpj2od4oxiMorIQN6DGhiMgB5ndOpM9nFpTrOg1qt0QQrHf7GRr8OhB1HXTwCodaJgzX8yl1BpxMRlTCUgNkYb88WhYw7nQD1J9bpTwOKjf+aCXQ7IOA9dsDxCNAoTqaAbgDdi/EaUvKICoqEFYHNfZYvpfhb7+MUdwzDXf4chw24Bhp1Th1eVenUVepgt1+l4LUBYOzy+3O6/CC7i5MAjSaBa3SgQw3A5emOHW75aHeFFQhzgdrCfUQcexp4rn5rAmIGlkZ+5VhDXHQvhTYwHkOhtsRxRZxQhB7Y+bj8b3wRjBGCEOelIQiKDCy6FCRsh1zCVKxRQ7BzIlBcmKHiWHHgm+VMf8BkYd2tg8l1DiD/QXkXSkvF0upGakisnXI5PBxfxiq/5Zdngdpbu32vcLM2kLvKHfZkv4Wp35NAkFVdccNdWlt8E1lt6cSjigv8J/SeRBARYfPWXF/n29zczr658cvwE3vTJJrUQHmeP9Iy3m9mB7zthJ/M287/AdxppEv2qVN4AAAAAElFTkSuQmCC&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 可以看到img标签的src属性跟一串字符。”data:image&#x2F;jpg;base64“表示数据的类型，之后的一大长串就是Base64串。直接浏览器打开，显示如下：可以看到图片正常显示了。 有了这个基础之后，后面的思路就很清楚了：Android层选择好图片后，返回图片的Base64格式的String对象到H5，H5回调拿来显示即可。 实践本次例子采用三方库safe-java-js-webview-bridge进行Android、JS互调，PhotoPicker进行图片选择。 AS新建项目，添加gradle依赖。PhotoPicker不支持gradle依赖，直接将代码下载下来后导入library Module。添加asserts目录，将H5页面，js、css文件添加进去。这里我直接将项目中的联调页面扔进去了，以求简便。 根据safe-java-js-webview-bridge三方库的使用说明，新建MyBridge类。这个类就是定义Android、JS互调接口的类。 1234567891011121314151617181920212223242526272829303132public class MyBridge &#123; private static WebViewActivity activity; public static void init(WebViewActivity activity) &#123; MyBridge.activity = activity; &#125; public static void send(WebView webView, JSONObject jsonObject, JsCallback jsCallback) &#123; try &#123; String method = jsonObject.getString(&quot;cmd&quot;); switch (method) &#123; case &quot;getToken&quot;: String token = activity.getToken(); if (jsCallback != null) &#123; jsCallback.apply(token); &#125; break; case &quot;getPictures&quot;: activity.getPictures(jsCallback); break; default: break; &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; catch (JsCallback.JsCallbackException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这个类需要根据H5页面那边调用接口的格式来进行编写，示例中的接口调用是这样子的。 12345678910111213141516171819202122232425262728293031323334353637function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge); &#125; else &#123; document.addEventListener(&#x27;WebViewJavascriptBridgeReady&#x27;, function() &#123; callback(WebViewJavascriptBridge) &#125;, false); &#125;&#125;;$(document).ready(function() &#123; connectWebViewJavascriptBridge(function(bridge) &#123; $(&quot;#getTokenBtn&quot;).click(function() &#123; bridge.send(&#123; &quot;cmd&quot;: &quot;getToken&quot;, &quot;data&quot;:&#123;&#125; &#125;, function responseCallback(responseData) &#123; $(&quot;#logger&quot;)[0].innerHTML += responseData + &quot;&lt;br&gt;&quot;; &#125;); &#125;); $(&quot;#addPicBtn&quot;).click(function() &#123; bridge.send(&#123; &quot;cmd&quot;: &quot;getPictures&quot;, &quot;data&quot;: &#123; &quot;count&quot;: 9 &#125; &#125;, function responseCallback(responseData) &#123; var imgs = JSON.parse(responseData).data.imgs; for (var i = 0; i &lt; imgs.length; i++) &#123; $(&#x27;#picList&#x27;).append(&#x27;&lt;li&gt;&lt;img src=&quot;data:image/jpeg;base64,&#x27; + imgs[i] + &#x27;&quot; alt=&quot;image&quot; width=&quot;50&quot; height=&quot;50&quot;&gt;&lt;/li&gt;&#x27;); &#125; &#125;); &#125;); &#125;);&#125;); 所以我的MyBridge类只定义了一个send方法，在其内部接收Json数据，根据cmd参数判断到底要执行哪个方法。我把方法写在引用WebView的Activity中了，所以添加了一个init方法，进行初始化，保持WebViewActivity对象，以便调用。 下面编写WebViewActivity类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class WebViewActivity extends Activity &#123; private WebView webView; public static JsCallback onceCallback; // 单次回调 private static final int PICK_PHOTO_REQUEST = 1; // 选择图片请求码 private static final int MAX_PHOTO_NUM = 9; // 最大选择数量 private static boolean showCamera = true; // 是否打开相机 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyBridge.init(this); webView = new WebView(this); // 切换到内容视图 setContentView(webView); // 获取WebView配置 WebSettings ws = webView.getSettings(); // 启用JavaScript ws.setJavaScriptEnabled(true); webView.setWebChromeClient(new InjectedChromeClient(&quot;WebViewJavascriptBridge&quot;, MyBridge.class)); // 载入assets目录下的一个页面 webView.loadUrl(&quot;file:///android_asset/native-api.html&quot;); &#125; public String getToken() &#123; return &quot;hello world&quot;; &#125; public void getPictures(JsCallback jsCallback) &#123; onceCallback = jsCallback; Intent intent = new Intent(this, PhotoPickerActivity.class); intent.putExtra(PhotoPickerActivity.EXTRA_SHOW_CAMERA, showCamera); intent.putExtra(PhotoPickerActivity.EXTRA_SELECT_MODE, PhotoPickerActivity.MODE_MULTI); intent.putExtra(PhotoPickerActivity.EXTRA_MAX_MUN, MAX_PHOTO_NUM); startActivityForResult(intent, PICK_PHOTO_REQUEST); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == PICK_PHOTO_REQUEST) &#123; if (resultCode == RESULT_OK) &#123; // 拼接返回Json ArrayList&lt;String&gt; result = data.getStringArrayListExtra(PhotoPickerActivity.KEY_RESULT); JSONObject dataJson = new JSONObject(); JSONObject images = new JSONObject(); JSONArray jsonArray = new JSONArray(); for (int i = 0; i &lt; result.size(); i++) &#123; File file = new File(result.get(i)); try &#123; FileInputStream fis = new FileInputStream(file); byte[] dataInByte = steamToByte(fis); String msg = Base64.encodeToString(dataInByte, Base64.DEFAULT); // 通过Base64方式返回的String会包含许多\\n，需去除掉 msg = msg.replaceAll(&quot;\\n&quot;, &quot;&quot;); jsonArray.put(msg); fis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; images.put(&quot;imgs&quot;, jsonArray); dataJson.put(&quot;data&quot;, images); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; // 回调 try &#123; if (onceCallback != null) &#123; onceCallback.apply(dataJson.toString()); &#125; &#125; catch (JsCallback.JsCallbackException e) &#123; e.printStackTrace(); &#125; &#125; &#125; super.onActivityResult(requestCode, resultCode, data); &#125; public static byte[] steamToByte(InputStream input) throws IOException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); int len; byte[] b = new byte[1024]; while ((len = input.read(b, 0, b.length)) != -1) &#123; baos.write(b, 0, len); &#125; byte[] buffer = baos.toByteArray(); return buffer; &#125;&#125; 可以看到MyBridge中的send方法最终会调用到WebViewActivity中的getToken方法与getPictures方法。getToken方法很简单，仅仅是返回一个”Hello world“。getPictures方法则是打开PhotoPicker三方库中的Activity。在选完图片之后，利用onActivityResult接收返回的图片路径。然后利用Base64进行处理，得到我们需要的String对象，返回给JsCallback进行回调。 在JS中处理回调参数的代码是var imgs = JSON.parse(responseData).data.imgs;，所以我们返回的String对象也需要时JSON格式，并且包含data、imgs属性。类似这样：{“data”:{“imgs”:[“string1”, “string2”]}}。所以我在onActivityResult中进行了拼接处理。 最后运行程序，得到的效果大致是这样的。可以看到，在我们的H5页面确实显示了图片。 题外话话题1在引入PhotoPicker的时候，若在选择图片碰到很长的图片，例如微博长图，400*8000px这样的图，会导致在时容易出现OOM。在原来库中进行压缩的inSampleSize是这样计算的： 123456789101112private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // 源图片的宽度 int width = options.outWidth; int height = options.outHeight; int inSampleSize = 1; int min = Math.min(width, height); int maxReq = Math.max(reqWidth, reqHeight); if(min &gt; maxReq) &#123; inSampleSize = Math.round((float) min / (float) maxReq); &#125; return inSampleSize;&#125; 使用这种方式，计算得到的inSampleSize值，在压缩这种长图后得到的Bitmap仍然会很大，导致OOM。改成如下则不会OOM了，但是图片会变得模糊一些（不可避免的，总要舍弃一些东西，微信也是这样）。 12345678910111213private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // 源图片的宽度 int width = options.outWidth; int height = options.outHeight; int inSampleSize = 1; if (width &gt; reqWidth || height &gt; reqHeight) &#123; int widthRadio = Math.round(width * 1.0f / reqWidth); int heightRadio = Math.round(height * 1.0f / reqHeight); inSampleSize = Math.max(widthRadio, heightRadio); &#125; return inSampleSize;&#125; 这个问题我已经跟作者反应，并且已经改正了。 话题2拼接好String字符串，准备返回给JsCallback进行回调时会出错。Log信息： 1Log：I/chromium: [INFO:CONSOLE(1)] &quot;Uncaught SyntaxError: Unexpected identifier&quot;, source: (1) 后面我看到JsCallback里的apply函数： 123456789101112131415161718192021222324public void apply (Object... args) throws JsCallbackException &#123; if (mWebViewRef.get() == null) &#123; throw new JsCallbackException(&quot;the WebView related to the JsCallback has been recycled&quot;); &#125; if (!mCouldGoOn) &#123; throw new JsCallbackException(&quot;the JsCallback isn&#x27;t permanent,cannot be called more than once&quot;); &#125; StringBuilder sb = new StringBuilder(); for (Object arg : args)&#123; sb.append(&quot;,&quot;); boolean isStrArg = arg instanceof String; if (isStrArg) &#123; sb.append(&quot;\\&quot;&quot;); &#125; sb.append(String.valueOf(arg)); if (isStrArg) &#123; sb.append(&quot;\\&quot;&quot;); &#125; &#125; String execJs = String.format(CALLBACK_JS_FORMAT, mInjectedName, mIndex, mIsPermanent, sb.toString()); Log.d(&quot;JsCallBack&quot;, execJs); mWebViewRef.get().loadUrl(execJs); mCouldGoOn = mIsPermanent &gt; 0;&#125; 他会在参数的前后加上双引号。因为返回的String对象是类似Json格式，里面也会包含双引号，这就会导致传递出错。这个问题我也已经提了issue给作者，但目前还没有什么回应。 碰到问题需要解决，在作者回应之前只能自己改咯。将代码下载下来，丢到工程中，不采用gradle依赖的方式了。也就三个类：InjectedChromeClient、JsCallback、JsCallJava。手动将apply中的代码改成如下： 123456789101112131415161718192021222324public void apply (Object... args) throws JsCallbackException &#123; if (mWebViewRef.get() == null) &#123; throw new JsCallbackException(&quot;the WebView related to the JsCallback has been recycled&quot;); &#125; if (!mCouldGoOn) &#123; throw new JsCallbackException(&quot;the JsCallback isn&#x27;t permanent,cannot be called more than once&quot;); &#125; StringBuilder sb = new StringBuilder(); for (Object arg : args)&#123; sb.append(&quot;,&quot;); boolean isStrArg = arg instanceof String; if (isStrArg) &#123; sb.append(&quot;&#x27;&quot;); &#125; sb.append(String.valueOf(arg)); if (isStrArg) &#123; sb.append(&quot;&#x27;&quot;); &#125; &#125; String execJs = String.format(CALLBACK_JS_FORMAT, mInjectedName, mIndex, mIsPermanent, sb.toString()); Log.d(&quot;JsCallBack&quot;, execJs); mWebViewRef.get().loadUrl(execJs); mCouldGoOn = mIsPermanent &gt; 0;&#125; 双引号改成单引号就行了。 但是只有又会引发新的问题：返回的String不能包含单引号。这确实比较蛋疼了，只能根据需求来吧，能解决当前问题的就行。延伸到既包含双引号又包含单引号的String对象又该如何传递呢？这里抛个疑问，大家可以共同探讨。 补充一点：通过Base64返回的String串来显示图片只适合小图片，太大的图片需要压缩后再返回，不然也会OOM。 最后源码下载","tags":[{"name":"Android 进阶","slug":"Android-进阶","permalink":"http://lijia92.github.io/tags/Android-%E8%BF%9B%E9%98%B6/"}]},{"title":"Android Notification使用小记","date":"2016-01-11T12:46:50.000Z","path":"2016/01/11/notification/","text":"介绍最近的项目中，需要用到Notification。上一下效果图： 首先，学习一下关于Notification的基本知识。 状态通知栏主要涉及到2个类： Notification 和 NotificationManager 。Notification为通知信息类，它里面对应了通知栏的各个属性。NotificationManager ： 是状态栏通知的管理类，负责发通知、清除通知等操作。注意：NotificationManager 是一个系统Service，必须通过 getSystemService(NOTIFICATION_SERVICE)方法来获取： 1mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 自定义Notification大致分为以下几步： 自定义布局； 使用NotificationCompat.Builder创建Notification。使用RemoteViews填充自定义布局，然后通过setContent()添加到Builder中； 使用广播，添加按钮点击事件； NotificationManager.notify()将Notification显示到手机状态栏。 下面结合代码进行说明。 代码第一步，对应于Notification的布局文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/music_cover&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/mia&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/music_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;end&quot; android:singleLine=&quot;true&quot; android:text=&quot;无与伦比的美丽&quot; /&gt; &lt;TextView android:id=&quot;@+id/singer_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;end&quot; android:singleLine=&quot;true&quot; android:text=&quot;苏打绿&quot; /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/pause&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/button_pause&quot; /&gt; &lt;ImageView android:id=&quot;@+id/play&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/button_play&quot; android:visibility=&quot;gone&quot; /&gt; &lt;ImageView android:id=&quot;@+id/next&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/btn_next&quot; /&gt; &lt;ImageView android:id=&quot;@+id/delete&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/search_delete&quot; /&gt;&lt;/LinearLayout&gt; 布局文件很简单，不做过多叙述。 再来看到Notification的创建。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class PlayerService extends Service &#123; // 广播Action private final static String NOTIFICATION_PLAY_ACTION = &quot;com.notifications.intent.action.PlayClick&quot;; private final static String NOTIFICATION_PAUSE_ACTION = &quot;com.notifications.intent.action.PauseClick&quot;; private final static String NOTIFICATION_NEXT_ACTION = &quot;com.notifications.intent.action.NextClick&quot;; private final static String NOTIFICATION_DELETE_ACTION = &quot;com.notifications.intent.action.DeleteClick&quot;; // 自定义Notification private NotificationManager mNotificationManager = null; private PendingIntent contentIntent; private NotificationCompat.Builder builder; private Notification notification; private RemoteViews contentView; // 自定义Notification，接收布局 private PlayerService service = this; private BroadcastReceiver onClickReceiver; // 注册广播接收点击事件 @Override public void onCreate() &#123; mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, MusicPlayActivity.class), 0); contentView = new RemoteViews(getPackageName(), R.layout.custom_notification); builder = new NotificationCompat.Builder(this); notification = builder .setContentIntent(contentIntent) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.drawable.mia) .setContent(contentView) .build(); notification.flags = Notification.FLAG_NO_CLEAR; // 注意Flag，会影响是否能cancel // 播放 Intent playIntent = new Intent(NOTIFICATION_PLAY_ACTION); PendingIntent play = PendingIntent.getBroadcast(this, 0, playIntent, 0); contentView.setOnClickPendingIntent(R.id.play, play); // 暂停 Intent pauseIntent = new Intent(NOTIFICATION_PAUSE_ACTION); PendingIntent pause = PendingIntent.getBroadcast(this, 0, pauseIntent, 0); contentView.setOnClickPendingIntent(R.id.pause, pause); // 下一首 Intent nextIntent = new Intent(NOTIFICATION_NEXT_ACTION); PendingIntent next = PendingIntent.getBroadcast(this, 0, nextIntent, 0); contentView.setOnClickPendingIntent(R.id.next, next); // 关闭 Intent deleteIntent = new Intent(NOTIFICATION_DELETE_ACTION); final PendingIntent delete = PendingIntent.getBroadcast(this, 0, deleteIntent, 0); contentView.setOnClickPendingIntent(R.id.delete, delete); // Notification中按钮点击事件需注册广播 onClickReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); switch (action) &#123; case NOTIFICATION_PLAY_ACTION: contentView.setViewVisibility(R.id.play, View.GONE); contentView.setViewVisibility(R.id.pause, View.VISIBLE); if (!service.isPlaying()) &#123; service.resume(); // 继续播放 &#125; mNotificationManager.notify(PLAYING_NOTIFY_ID, notification); break; case NOTIFICATION_PAUSE_ACTION: contentView.setViewVisibility(R.id.pause, View.GONE); contentView.setViewVisibility(R.id.play, View.VISIBLE); if (service.isPlaying()) &#123; service.pause(); // 暂停 &#125; mNotificationManager.notify(PLAYING_NOTIFY_ID, notification); break; case NOTIFICATION_NEXT_ACTION: service.next(); // 下一首 break; case NOTIFICATION_DELETE_ACTION: service.stop(); break; default: break; &#125; &#125; &#125;; IntentFilter filter = new IntentFilter(); filter.addAction(NOTIFICATION_PLAY_ACTION); filter.addAction(NOTIFICATION_PAUSE_ACTION); filter.addAction(NOTIFICATION_NEXT_ACTION); filter.addAction(NOTIFICATION_DELETE_ACTION); registerReceiver(onClickReceiver, filter); &#125; 播放音乐使用的自然是Service了。于是我定义了PlayerService继承自Service，声明相应的变量，然后在onCreate()中进行初始化。 我们可以看到，代码中使用RemoteViews填充了布局，并将其设置到Notification创建的Builder中。 RemoteViews不同于View，它不能通过findViewById()来获取View控件。它里面的控件的点击事件必须通过setOnClickPendingIntent()来进行设置。它有2个参数，1个是控件ID，另外1个是进行处理的PendingIntent。PendingIntent的创建必须通过广播的方式来实现。重复下上面的代码： 123Intent playIntent = new Intent(NOTIFICATION_PLAY_ACTION);PendingIntent play = PendingIntent.getBroadcast(this, 0, playIntent, 0);contentView.setOnClickPendingIntent(R.id.play, play); 然后在广播的onReceive()方法中，判断是哪个控件被点击。然后执行相应的逻辑。 记得广播一定要先注册才能使用。 最后，便是将Notification显示到手机了。 12345678910final Track track = getCurrentEntry().getTrack();ImageLoader.getInstance().loadImage(track.getUrl(), new SimpleImageLoadingListener() &#123; @Override public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123; contentView.setImageViewBitmap(R.id.music_cover, loadedImage); contentView.setTextViewText(R.id.music_name, track.getName()); contentView.setTextViewText(R.id.singer_name, track.getSinger()); mNotificationManager.notify(PLAYING_NOTIFY_ID, notification); &#125; &#125;); Track是我进行音乐播放的一个Model类。包含一些播放音乐的基本信息。这里我是通过的Universal-Image-Loader进行图片加载。在其加载成功后的回调中，通过setTextViewText()等类似方法给控件设值。也是有2个参数，第1个是控件Id，第二个便是要设置的值。最后通过mNotificationManager.notify(PLAYING_NOTIFY_ID, notification)将Notification显示到手机。 经过上述几个步骤，自定义Notification便能显示到手机了，并且具备点击事件。 Tips 自定义布局仅支持FrameLayout、LinearLayout、RelativeLayout三种布局控件和AnalogClock、Chronometer、Button、ImageButton、ImageView、ProgressBar、TextView、ViewFlipper、ListView、GridView、StackView和AdapterViewFlipper这些显示控件，不支持这些类的子类或Android提供的其他控件，否则会引起ClassNotFoundException异常。之前播放的按钮打算用ToggleButton，使用之后发现显示不了，后面才找到原因。 Notification属于系统级别的组件，使用了RemoteViews的setViewVisibility()、setTextViewText()等方法后，必须通知系统重绘才能更新UI，最简单的方式就是重新notify一下。只要传入的Id一样，就会覆盖掉之前的通知。在播放、暂停按钮切换的时候，就碰到这个问题，一直不能显示，加上notify语句后就能正常执行了。 关于Notification的取消。使用mNotificationManager.cancel(PLAYING_NOTIFY_ID)即可。但是一定要注意Notification的flag。这里补充下Notification的标识符。提醒标志符成员：Notification.FLAG_SHOW_LIGHTS &#x2F;&#x2F;三色灯提醒，在使用三色灯提醒时候必须加该标志符Notification.FLAG_ONGOING_EVENT &#x2F;&#x2F;发起正在运行事件（活动中）Notification.FLAG_INSISTENT &#x2F;&#x2F;让声音、振动无限循环，直到用户响应 （取消或者打开）Notification.FLAG_ONLY_ALERT_ONCE &#x2F;&#x2F;发起Notification后，铃声和震动均只执行一次Notification.FLAG_AUTO_CANCEL &#x2F;&#x2F;用户单击通知后自动消失Notification.FLAG_NO_CLEAR &#x2F;&#x2F;只有全部清除时，Notification才会清除 ，不清楚该通知(QQ的通知无法清除，就是用的这个)Notification.FLAG_FOREGROUND_SERVICE &#x2F;&#x2F;表示正在运行的服务我当时使用的FLAG_FOREGROUND_SERVICE，导致cancel一直关闭不了Notification，更换flag后就能关闭了。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android Hybrid开发入门：原生Android与JS的交互","date":"2015-12-25T07:03:16.000Z","path":"2015/12/25/hybrid-introduction/","text":"介绍我们知道，现在App大致分为3类：Hybrid App、Web App、Native App。Hybrid App兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”，市面上现在也有许多Hybrid App。 最近做的项目，也会使用到Hybrid开发，之前没做过的。所以今天初步学习了一下，记录一下学习心得。 代码首先，新建一个新的AS module，然后新建assets目录，至于src&#x2F;main文件夹下。如下图：我们再assets目录下，新建一个hello.html，编辑内容如下： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;script&gt; function hello() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Hybrid!&quot;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a href=&quot;#&quot; id=&quot;demo&quot; onclick=&quot;window.demo.clickOnAndroid()&quot;&gt;Click Me&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一个很简单的html页面。 然后新建一个WebViewActivity。 1234567891011121314151617181920212223242526272829303132333435public class WebViewActivity extends Activity &#123; private WebView webView; private Context mContext; private Handler mHandler = new Handler(); @SuppressLint(&quot;JavascriptInterface&quot;) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mContext = this; // 创建WebView对象 webView = new WebView(this); // 切换到内容视图 setContentView(webView); // 获取WebView配置 WebSettings ws = webView.getSettings(); // 启用JavaScript ws.setJavaScriptEnabled(true); // 载入assets目录下的一个页面 webView.loadUrl(&quot;file:///android_asset/hello.html&quot;); // 添加交互接口 webView.addJavascriptInterface(new Object() &#123; @JavascriptInterface public void clickOnAndroid() &#123; Toast.makeText(mContext, &quot;Hello Hybrid.&quot;, Toast.LENGTH_SHORT).show(); mHandler.post(new Runnable() &#123; public void run() &#123; webView.loadUrl(&quot;javascript:hello()&quot;); &#125; &#125;); &#125; &#125;, &quot;demo&quot;); &#125;&#125; 通过WebView的loadUrl，填入我们hello.html的路径，便能在App中加载这个页面了。（别忘记在AndroidManifest.xml中声明Activity）loadUrl填入JS方法，则可调JS方法。注意使用的handler发送消息来更新。如是直接webView.loadUrl(“javascript:hello()”);可能会导致如下错误： java.lang.Throwable: A WebView method was called on thread ‘JavaBridge’. All WebView methods must be called on the same thread. (Expected Looper Looper (main, tid 1) {425f48a8} called on Looper (JavaBridge, tid 92104) {426508d0}, FYI main Looper is Looper (main, tid 1) {425f48a8}) 即是需要在同一个进程中进行更新，所以需要使用handler发送消息更新。 回到AS帮我们自动建好的MainActivity。修改FloatingActionButton点击事件： 12345678FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(MainActivity.this, WebViewActivity.class); startActivity(intent); &#125; &#125;); 启动应用，看下效果：可以看到，点击“click me”的时候，弹出了Toast，并且button的text改变了，这即是android与js的交互。当然，这个交互十分简单，后面还有很多的坑要踩~ Tips注意到代码中的clickOnAndroid方法上方的注解@JavascriptInterface，这个注解很关键。若没有这个注解，会在4.2以上版本的android上出现：Uncaught TypeError: Object [object Object] has no method xxx的错误。 对于4.2之前的版本，采用这种方式可能会被恶意JS攻击，诸如平台型App需要访问三方Html的则不建议采用这种方式实现交互。 更多前面示例js调用android是通过addJavascriptInterface来进行交互的，下面再介绍2种方式。 重写WebViewClient.shouldOverrideUrlLoading：1234567webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; Toast.makeText(mContext, url, Toast.LENGTH_SHORT).show(); return super.shouldOverrideUrlLoading(view, url); &#125; &#125;); 当页面内的URL发生变化时，如点击链接、执行JavaScript（如location.href&#x3D;”xxxxxxx”）等均会触发WebViewClient.shouldOverrideUrlLoading，通过将Web调用Native的数据封装在URL，再由Native解析数据并执行响应Native方法。 例如：将前面示例中的hello.html改成如下： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;script&gt; function hello() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Hybrid!&quot;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a href=&quot;hybrid.html&quot; id=&quot;demo&quot; onclick=&quot;window.demo.clickOnAndroid()&quot;&gt;Click Me&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在点击“Click Me”之后，页面会跳转到hybrid.html，此时便会进入native执行shouldOverrideUrlLoading方法，再来解析Url，并执行相应的native方法。 重写WebChromeClient.onJsPrompt，或onJsConfirm，或onJsAlert：1234567webView.setWebChromeClient(new WebChromeClient() &#123; public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; Toast.makeText(mContext, url, Toast.LENGTH_SHORT).show(); result.confirm(&quot;&quot;); return true; &#125; &#125;); 当执行“window.prompt（“{}”）”这样的JavaScript代码时，将会触发WebChromeClient.onJsPrompt。onJsConfirm、onJsAlert也是如此。 例如：将前面示例中的hello.html改成如下： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;script&gt; function hello() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Hybrid!&quot;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a href=&quot;#&quot; id=&quot;demo&quot; onclick=&quot;window.prompt(&#x27;Hello&#x27;)&quot;&gt;Click Me&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当点击“Click Me”时，会进入native执行onJsPrompt方法，再来解析url，message，并执行相应的native方法。 最后Github上找到一个开源库：safe-java-js-webview-bridge，便是采用的这种方式进行交互，并做了更好的封装，是个不错的选择。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android仿QQ空间浏览图片","date":"2015-12-08T09:09:39.000Z","path":"2015/12/08/picture-view/","text":"前言最近的项目中需要用到类似QQ空间那样的图片浏览功能，于是Google了一波，发现使用ViewPager与PhotoView即可实现。有了思路便开撸了。 代码首先，我们定义一个用于展示原图的Activity。 12345678910111213141516171819202122232425public class ImageBrowseActivity extends Activity &#123; // ViewPager对象 private ViewPager mViewPager; // 原图url路径List private List&lt;String&gt; imagePath; // 当前显示的位置 private int position; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_images_view); // 获取参数 this.position = getIntent().getIntExtra(&quot;position&quot;, 0); this.imagePath = getIntent().getStringArrayListExtra(&quot;imagePath&quot;); mViewPager = (ViewPager) findViewById(R.id.images_view); // 设置左右两列缓存的数目 mViewPager.setOffscreenPageLimit(2); // 添加Adapter PagerAdapter adapter = new ImageBrowseAdapter(this, imagePath); mViewPager.setAdapter(adapter); mViewPager.setCurrentItem(position); &#125;&#125; 布局如下： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#000000&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/images_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; /&gt;&lt;/FrameLayout&gt; Activity比较简单，不做过多赘述。下面看看ImageBrowseAdapter怎么实现的。ImageBrowseAdapter代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class ImageBrowseAdapter extends PagerAdapter &#123; PhotoViewAttacher mAttacher; private Context context; private List&lt;String&gt; imagePath; public ImageBrowseAdapter(Context context, List&lt;String&gt; urls) &#123; this.context = context; this.imagePath = urls; &#125; @Override public int getCount() &#123; return imagePath.size(); &#125; @Override public boolean isViewFromObject(View view, Object o) &#123; return view == o; &#125; @Override public void destroyItem(ViewGroup view, int position, Object object) &#123; view.removeView((View) object); &#125; @Override public Object instantiateItem(ViewGroup view, int position) &#123; ImageView imageView = new ImageView(context); new DownloadImageTask(context, imageView).execute(imagePath.get(position)); view.addView(imageView); return imageView; &#125; private class DownloadImageTask extends BaseAsyncTask&lt;String, Void, Bitmap&gt; &#123; ImageView bmImage; public DownloadImageTask(Context context, ImageView bmImage) &#123; super(context); this.bmImage = bmImage; &#125; @Override protected void onPreExecute() &#123; &#125; protected Bitmap doInBackground(String... urls) &#123; String path = urls[0]; Bitmap result = null; try &#123; BitmapFactory.Options options = new BitmapFactory.Options(); //先设置为true，获取bitmap宽度、高度 options.inJustDecodeBounds = true; InputStream in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options); in.close(); resetOptions(options); //后设置为false，加载进内存显示 options.inJustDecodeBounds = false; // InputStream在读取完之后就到结尾了，需要再次打开才能重新读取，否则下面的result将返回null in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; protected void onPostExecute(Bitmap result) &#123; if (result != null) &#123; bmImage.setImageBitmap(result); // PhotoViewAttacher绑定ImageView mAttacher = new PhotoViewAttacher(bmImage); &#125; &#125; &#125; /** * 设置inSampleSize参数 * * @param options * @return */ public void resetOptions(BitmapFactory.Options options) &#123; DisplayMetrics dm = context.getResources().getDisplayMetrics(); int width = dm.widthPixels / 2; int height = dm.heightPixels / 2; options.inSampleSize = (options.outWidth / width &gt; options.outHeight / height) ? options.outWidth / width : options.outHeight / height; &#125;&#125; 在Adapter中，我为了求简便，直接在instantiateItem()中新建ImageView实例，然后传入到DownloadImageTask异步任务中进行下载，下载完成后更新，然后将PhotoViewAttacher与ImageView实例绑定。示例中没有使用PhoteView这个类，主要是用到了PhotoViewAttacher这个类。 我们会有一个显示缩略图的列表，给列表的Item设置如下点击事件： 1234567@Overridepublic void ImageClicked(ArrayList&lt;String&gt; imagePath, int position) &#123; Intent intent = new Intent(getActivity(), ImageBrowseActivity.class); intent.putExtra(&quot;position&quot;, position); intent.putStringArrayListExtra(&quot;imagePath&quot;, imagePath); startActivity(intent);&#125; imagePath是原图的路径数组，position代表当前显示第几张。点击事件设置好之后，便能实现网络图片浏览功能了。下面上效果图： 小结 使用ViewPager来实现大图左右滑动。 使用PhotoView开源库实现图片的缩放，移动等特性，点击传送PhotoView开源库。 问题 在使用PhotoView与ViewPager结合进行滑动显示的时候，会打出ImageView no longer exists. You should not use this PhotoViewAttacher any more.的Log，算不上错误，是个Warning，网上查找的解决办法是修改cleapUp方法。 自己手贱，传了一些手机拍摄的“高清大图”，没滑2张就OOM了。也算是个契机让自己了解下Bitmap的内存优化。故在示例中会有resetOptions()方法以及这样的代码片段：12345678910111213141516...BitmapFactory.Options options = new BitmapFactory.Options(); //先设置为true，获取bitmap宽度、高度 options.inJustDecodeBounds = true; InputStream in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options); in.close(); resetOptions(options); //后设置为false，加载进内存显示 options.inJustDecodeBounds = false; // InputStream在读取完之后就到结尾了，需要再次打开才能重新读取，否则下面的result将返回null in = new java.net.URL(path).openStream(); result = BitmapFactory.decodeStream(in, null, options);... Bitmap是OOM的一大凶器，所以碰到大图我们需要压缩。压缩可以通过设置BitmapFactory.Options，来生成压缩后的图片，主要是inSampleSize参数的设置。resetOptions()方法便是进行设置inSampleSize参数的，方法内部的具体逻辑则需要根据项目业务的需求来制定了。 另外，在第二次BitmapFactory.decodeStream()时，若不进行其他处理，会返回null，后面查询原因，是InputStream流在访问后，内部指针会指到尾部，相当于是传入的in是空的。所以需要添加一句in = new java.net.URL(path).openStream();，重新打开in，然后再使用decodeStream方法，返回bitmap。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android Studio中使用.9（Nine Patch）图","date":"2015-11-23T02:09:38.000Z","path":"2015/11/23/nine-patch/","text":"本文主要结合Android Studio讲述一下.9图片的原理与使用。 原理在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以任意调整大小的一种图片格式“.9.png”。这种图片是用于Android开发的一种特殊的图片格式，它的好处在于可以用简单的方式把一张图片中哪些区域可以拉伸，哪些区域不可以拉伸设定好，同时可以把显示内容区域的位置标示清楚。 .9图片相比普通图片，在四条边会多出1px的空隙，我们在这1px的空隙中画上黑线，即可控制图片怎么拉伸，内容区域的位置。讲解一下四条边的作用： Top，图中1所示，是控制图片可横向拉伸的区域。 Left，图中2所示，是控制图片可纵向拉伸的区域。 Right&amp;Botton，图中的3与4，结合起来控制内容显示的区域。 使用我们在Android Studio中新建一个项目，选择一张普通图片，置于drawable目录下。 下面我们将它改为.9图片。在Android Studio中使用.9图很简单：直接将图片名称以”.9.png”结束。使用.9图必须注意一点：文件的后缀名必须是.9.png，不能是.png或者是.9.png.png，这样的命名都会导致编译失败。 将名称改好之后，重新打开图片，可以看到图片下面会有2个Tab，切换到9-Patch即可配置.9图片了。 下面做如下配置： 在右边的效果图中，纵向只拉伸了Left所画黑线对应的区域，横向只拉伸了Top所画黑线对应的区域。至于Right与Bottom，我们可以通过勾选下方的Show content让其显示内容区域。 可以看到，这里上下左右四条黑边的作用确实如原理中所说。图中效果很难看，改成这样：看起来效果还不错，这样我们可以尽情的配置图片该如何拉伸，针对不同分辨率，以达到一个更好的效果。 解惑起初对Right与Bottom这2条边限定的内容区域不太了解，便做了个小测试。将2条边改成如下：然后布局文件里引入一个TextView，将background设置为此.9图片。 123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:background=&quot;@drawable/ninepatch&quot; android:text=&quot;Hello World!&quot; /&gt; 运行后的效果：可以看到“Hello World！”显示在了图片的右下方。Right与Bottom这2条边限定的内容区域所起的作用便一目了然了。","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android仿QQ实现ListView滑动删除","date":"2015-11-13T18:09:38.000Z","path":"2015/11/14/swipe-listview/","text":"前言手机QQ应该是很普及的App了，看到QQ消息栏对话框列表的每个子项左滑的时候会弹出删除、置顶图标。like this：于是突发奇想：想要自己实现一个这样的效果。很显然的，这样的效果实现要依赖Android的事件分发机制，于是我先从Android事件分发入手。对于事件分发还不太熟悉的朋友可以参考Android事件分发机制学习。下面开工！ List Item首先，针对ListView的每个Item自定义一个MyItemLayout。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MyItemLayout extends LinearLayout &#123; // content View private LinearLayout contentView; // menu View private LinearLayout menuView; // content View的布局参数对象 private LayoutParams contentLayout; // 菜单是否打开 private boolean isMenuOpen; // contentView最小的leftMargin private int minLeftMargin; // contentView最大的leftMargin private int maxLeftMargin = 0; // 滑动类 private Scroller mScroller = null; public MyItemLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); contentLayout = new LayoutParams(getScreenWidth(), LayoutParams.WRAP_CONTENT); mScroller = new Scroller(context); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; setLeftMargin(mScroller.getCurrX()); postInvalidate(); &#125; &#125; /** * Scroller平滑打开Menu */ public void smoothOpenMenu() &#123; isMenuOpen = true; mScroller.startScroll(contentLayout.leftMargin, 0, minLeftMargin - contentLayout.leftMargin, 0, 350); postInvalidate(); &#125; /** * Scroller平滑关闭Menu */ public void smoothCloseMenu() &#123; isMenuOpen = false; mScroller.startScroll(contentLayout.leftMargin, 0, maxLeftMargin - contentLayout.leftMargin, 0, 350); postInvalidate(); &#125; /** * 在布局inflate完成后调用 */ @Override protected void onFinishInflate() &#123; super.onFinishInflate(); // 第一个孩子是contentView contentView = (LinearLayout) getChildAt(0); // 第二个孩子是MenuView menuView = (LinearLayout) getChildAt(1); // 最小的leftMargin为负的menuView宽度 ViewGroup.LayoutParams lp = menuView.getLayoutParams(); minLeftMargin = -lp.width; &#125; /** * 获取屏幕宽度 * @return */ private int getScreenWidth() &#123; DisplayMetrics dm = getResources().getDisplayMetrics(); return dm.widthPixels; &#125; /** * 给contentView设置leftMargin * @param leftMargin */ public void setLeftMargin(int leftMargin) &#123; // 控制leftMargin不越界 if (leftMargin &gt; maxLeftMargin) &#123; leftMargin = maxLeftMargin; &#125; if (leftMargin &lt; minLeftMargin) &#123; leftMargin = minLeftMargin; &#125; contentLayout.leftMargin = leftMargin; // 通过设置leftMargin，达到menu显示的效果 contentView.setLayoutParams(contentLayout); &#125; /** * 获取menuView宽度 * @return */ public int getMenuWidth() &#123; return -minLeftMargin; &#125; /** * Menu是否打开 * @return */ public boolean isMenuOpen() &#123; return isMenuOpen; &#125;&#125; 每个Item有2个直接子节点，第一个是contentView，第二个是menuView。通过设置contentView的leftMargin，达到显示Menu的效果。初始时，leftMargin为0，Menu完全隐藏。当滑动时，leftMargin逐渐缩小（因为是负数），当leftMargin等于minLeftMargin时，Menu完全显示。本来有种想法（参考郭霖大神的博客）是采用线程Sleep的方式来达到滑动效果的。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private class ScrollTask extends AsyncTask&lt;Integer, Integer, Integer&gt; &#123; @Override protected Integer doInBackground(Integer... speed) &#123; int leftMargin = contentLayout.leftMargin; while (true) &#123; leftMargin = leftMargin - speed[0]; if (leftMargin &gt; maxLeftMargin) &#123; leftMargin = maxLeftMargin; break; &#125; if (leftMargin &lt; minLeftMargin) &#123; leftMargin = minLeftMargin; break; &#125; publishProgress(leftMargin); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; isMenuOpen = speed[0] &gt; 0; return leftMargin; &#125; @Override protected void onProgressUpdate(Integer... leftMargin) &#123; contentLayout.leftMargin = leftMargin[0]; contentView.setLayoutParams(contentLayout); &#125; @Override protected void onPostExecute(Integer leftMargin) &#123; contentLayout.leftMargin = leftMargin; contentView.setLayoutParams(contentLayout); &#125; &#125;public void toOpenMenu() &#123; new ScrollTask().execute(30); &#125; public void toCloseMenu() &#123; new ScrollTask().execute(-30); &#125; 但是后面产生的实际效果不太好，滑动的时候总是有点卡顿的感觉，于是便弃用了，后面还是采用的Scroller类。 下面贴上每个Item的布局： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.lastwarmth.mylistview.MyItemLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:paddingBottom=&quot;4dp&quot; android:paddingLeft=&quot;8dp&quot; android:paddingTop=&quot;4dp&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=&quot;@+id/profile_image&quot; android:layout_width=&quot;56dp&quot; android:layout_height=&quot;56dp&quot; app:civ_border_color=&quot;#FF000000&quot; app:civ_border_width=&quot;1dp&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginTop=&quot;4dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/group_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;群名称&quot; /&gt; &lt;TextView android:id=&quot;@+id/qq_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:text=&quot;聊天内容&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=&quot;@+id/menu&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/to_top&quot; style=&quot;@style/menu_text_style&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/darker_gray&quot; android:gravity=&quot;center&quot; android:text=&quot;置顶&quot; /&gt; &lt;TextView android:id=&quot;@+id/had_read&quot; style=&quot;@style/menu_text_style&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/holo_orange_light&quot; android:gravity=&quot;center&quot; android:text=&quot;标为已读&quot; /&gt; &lt;TextView android:id=&quot;@+id/delete&quot; style=&quot;@style/menu_text_style&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/holo_red_light&quot; android:gravity=&quot;center&quot; android:text=&quot;删除&quot; /&gt; &lt;/LinearLayout&gt;&lt;/com.lastwarmth.mylistview.MyItemLayout&gt; content id即是第一个子节点，menu id为第二个子节点。 Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MyAdapter extends BaseAdapter &#123; private List&lt;MyModel&gt; data; private Context mContext; public MyAdapter(List&lt;MyModel&gt; data, Context mContext) &#123; this.data = data; this.mContext = mContext; &#125; @Override public int getCount() &#123; if (data != null) &#123; return data.size(); &#125; return 0; &#125; @Override public Object getItem(int position) &#123; if (data != null) &#123; return data.get(position); &#125; return null; &#125; @Override public long getItemId(int position) &#123; return 0; &#125; @Override public View getView(final int position, View contentView, ViewGroup parent) &#123; ViewHolder holder; if (contentView == null) &#123; holder = new ViewHolder(); contentView = LayoutInflater.from(mContext).inflate(R.layout.list_item, parent, false); holder.imageView = (CircleImageView) contentView.findViewById(R.id.profile_image); holder.groupName = (TextView) contentView.findViewById(R.id.group_name); holder.content = (TextView) contentView.findViewById(R.id.qq_content); holder.toTop = (TextView) contentView.findViewById(R.id.to_top); holder.hadRead = (TextView) contentView.findViewById(R.id.had_read); holder.delete = (TextView) contentView.findViewById(R.id.delete); contentView.setTag(holder); &#125; else &#123; holder = (ViewHolder) contentView.getTag(); &#125; MyModel myModel = (MyModel) getItem(position); holder.groupName.setText(myModel.getGroupName()); holder.content.setText(myModel.getContent()); Picasso.with(mContext) .load(myModel.getImageUrl()) .placeholder(R.mipmap.lb_zjtx) .into(holder.imageView); final MyItemLayout finalContentView = (MyItemLayout) contentView; holder.toTop.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(mContext, &quot;已置顶&quot;, Toast.LENGTH_SHORT).show(); finalContentView.smoothCloseMenu(); &#125; &#125;); holder.hadRead.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(mContext, &quot;已阅读&quot;, Toast.LENGTH_SHORT).show(); finalContentView.smoothCloseMenu(); &#125; &#125;); holder.delete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; data.remove(position); finalContentView.smoothCloseMenu(); notifyDataSetChanged(); Toast.makeText(mContext, &quot;已删除&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); return contentView; &#125; private static class ViewHolder &#123; CircleImageView imageView; TextView groupName; TextView content; TextView toTop; TextView hadRead; TextView delete; &#125;&#125; Adapter类比较简单，这里不做过多的赘述。 Model类MyModel类主要是为了模仿QQ会话写的一个类。 12345678910111213141516171819202122232425public class MyModel &#123; String imageUrl; // 头像Url String groupName; // 群名称 String content; // 聊天内容 public MyModel(String imageUrl, String groupName, String content) &#123; this.imageUrl = imageUrl; this.groupName = groupName; this.content = content; &#125; public String getImageUrl() &#123; return imageUrl; &#125; public String getGroupName() &#123; return groupName; &#125; public String getContent() &#123; return content; &#125;&#125; 自定义ListView下面便是最关键的一个：自定义ListView，覆写onTouchEvent方法，实现滑动删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class MyListView extends ListView &#123; // 滑动速度追踪类 private VelocityTracker mVelocityTracker; // ACTION_DOWN的坐标 private float xDown; private float yDown; // 判断横滑、竖滑的最小值 private int MAX_Y = 5; private int MAX_X = 3; // 当前点击的position private int mTouchPosition; // 当前点击的item View private MyItemLayout mTouchView; // 当前触摸状态 private int mTouchState = TOUCH_STATE_NONE; private static final int TOUCH_STATE_NONE = 0; //ACTION_DOWN时设置的状态 private static final int TOUCH_STATE_X = 1; //横滑 private static final int TOUCH_STATE_Y = 2; //竖滑 public MyListView(Context context, AttributeSet attrs) &#123; super(context, attrs); MAX_X = dp2px(MAX_X); MAX_Y = dp2px(MAX_Y); &#125; /** * 创建VelocityTracker对象，并将触摸事件加入到VelocityTracker当中 * * @param event */ private void createVelocityTracker(MotionEvent event) &#123; if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(event); &#125; /** * 获取手指在滑动的速度 * * @return 滑动速度，以每秒钟移动了多少像素值为单位 */ private int getScrollVelocity() &#123; mVelocityTracker.computeCurrentVelocity(1000); int velocity = (int) mVelocityTracker.getXVelocity(); return Math.abs(velocity); &#125; /** * 回收VelocityTracker对象 */ private void recycleVelocityTracker() &#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return super.onInterceptTouchEvent(ev); &#125; /** * 触摸事件的控制 * * @param ev * @return */ @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (ev.getAction() != MotionEvent.ACTION_DOWN &amp;&amp; mTouchView == null) &#123; return super.onTouchEvent(ev); &#125; // 加入触摸跟踪类 createVelocityTracker(ev); float moveX; float moveY; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN: int prevPosition = mTouchPosition; xDown = ev.getX(); yDown = ev.getY(); mTouchState = TOUCH_STATE_NONE; mTouchPosition = pointToPosition((int) xDown, (int) yDown); // 当前点击的Item正好是已经显示Menu的Item if (prevPosition == mTouchPosition &amp;&amp; mTouchView != null &amp;&amp; mTouchView.isMenuOpen()) &#123; mTouchState = TOUCH_STATE_X; return true; // 返回true表示接受了ACTION_DOWN，那么后面的事件依然会分发给MyListView &#125; View view = getChildAt(mTouchPosition - getFirstVisiblePosition()); // 点击的Item不是正在显示Menu的Item，则直接关闭Menu if (mTouchView != null &amp;&amp; mTouchView.isMenuOpen()) &#123; mTouchView.smoothCloseMenu(); mTouchView = null; return false; // 返回false，那么后面的事件全部会接收不到 &#125; if (view instanceof MyItemLayout) &#123; mTouchView = (MyItemLayout) view; &#125; break; case MotionEvent.ACTION_MOVE: moveX = ev.getX() - xDown; moveY = ev.getY() - yDown; if (mTouchState == TOUCH_STATE_X) &#123; // 如果是横滑，则设置leftMargin if (!mTouchView.isMenuOpen()) &#123; mTouchView.setLeftMargin((int) moveX); &#125; else &#123; mTouchView.setLeftMargin((int) (moveX - mTouchView.getMenuWidth())); &#125; return true; &#125; else if (mTouchState == TOUCH_STATE_NONE) &#123; // 设置横滑还是竖滑 if (Math.abs(moveY) &gt; MAX_Y) &#123; mTouchState = TOUCH_STATE_Y; &#125; else if (Math.abs(moveX) &gt; MAX_X) &#123; mTouchState = TOUCH_STATE_X; &#125; &#125; break; case MotionEvent.ACTION_UP: moveX = ev.getX() - xDown; if (mTouchState == TOUCH_STATE_X) &#123; // 若滑动的距离是Menu宽度的一半，或者左滑速度大于200, if (-moveX &gt; mTouchView.getMenuWidth() / 2 || (moveX &lt; 0 &amp;&amp; getScrollVelocity() &gt; 200)) &#123; // 若Menu是关闭的 if (!mTouchView.isMenuOpen()) &#123; // 滑动打开Menu mTouchView.smoothOpenMenu(); &#125; &#125; else &#123; // 滑动关闭Menu mTouchView.smoothCloseMenu(); mTouchView = null; mTouchPosition = -1; &#125; recycleVelocityTracker(); return true; &#125; break; &#125; return super.onTouchEvent(ev); &#125; private int dp2px(int dp) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, getContext().getResources().getDisplayMetrics()); &#125;&#125; 在这个项目中，触摸事件分以下几种情况： 当前没有Menu正在显示 ACTION_DOWN记录相关信息，准备接收ACTION_MOVE、ACTION_UP事件。 ACTION_MOVE中，判断是横滑还是竖滑。若是横滑，则调用setLeftMargin()，这个时候若一直滑动，Menu会慢慢地显示出来。后面会返回true，主要是为了拦截最后的super.onTouchEvent(ev)不执行。若是竖滑，则直接调用super.onTouchEvent(ev)，这个时候若一直滑动，则是ListView的上下滑动了。 ACTION_UP中，我们只需要判断是否要显示，若显示则调用smoothOpenMenu()，并返回true（这里返回true或者false都没有实际的意义）。若是不需要，则直接super.onTouchEvent(ev)。 当前有Menu正在显示 ACTION_DOWN，若当前点击的Item不是Menu正在显示的Item，那么直接smoothCloseMenu()，并且返回false。返回false后MOVE、UP等事件会统统不接收。 若是正在点击的Item，那么首先设置为横滑，并且返回true，等待后续的触摸事件。 ACTION_MOVE因为在DOWN的时候设置了mTouchState &#x3D; TOUCH_STATE_X;那么会执行到if内部，因为Menu正在显示，所以不会调用setLeftMargin()，并且直接返回true，即后面的super.onTouchEvent(ev)也不会调用。 ACTION_UP中判断Menu是否要关闭，若关闭则调用smoothCloseMenu()，并且返回true。若是不需要，则直接返回super.onTouchEvent(ev)。 这里是复杂的地方，需要对各种情况进行判断，然后执行相应的逻辑。我写了好多次，改过好多次QAQ… Tips 在ACTION_DOWN的分支中，返回false会直接截断后面MOVE、UP等事件的接收。 在ACTION_MOVE与ACTION_UP的返回值，为true为false，并没有特别实际的效果，仅仅是为了返回，以此来截断super.onTouchEvent(ev)的执行。 最后下面上效果图：看起来效果也还不错，是吧？ 源码下载","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android事件分发机制学习小记","date":"2015-11-13T17:15:22.000Z","path":"2015/11/14/touch-event/","text":"Android事件分发机制有三类：Activity、View、ViewGroup，其调用顺序是Activity-&gt;ViewGroup-&gt;View，考虑到实际开发中Activity的事件分发很少用到，这里便不作赘述。想要了解的可自行百度、谷歌。下面，我从View的事件分发开始。 View的事件分发我们知道，任何触摸事件都是从dispatchTouchEvent函数开始。在View的dispatchTouchEvent函数中，会看到这样的代码块： 123456789101112131415...if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125;... 说明View若要进行事件分发，那么会优先分发给onTouch()，若onTouch()返回true，则直接返回true，不会进入到onTouchEvent()中。否则，进入到onTouchEvent()。 onTouch()与onTouchEvent()都是View中用户处理触摸事件的方法。onTouch是OnTouchListener接口中的函数，OnTouchListener接口是暴露给用户，让用户自己处理触摸事件。onTouchEvent()是View自带的接口，Android系统提供了默认的实现，当然，也可以重载该方法。 在onTouchEvent()函数中，会看到这样的代码块： 12345678910...if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; ... return true; ...&#125;return false;... 即若View可点击，则返回true；若不可点击，则返回false。 在if内部，若是ACTION_UP事件，条件符合的情况下会执行performClick()方法，该方法会执行mOnClickListener.onClick()，即View的onClick事件，是在onTouchEvent()方法的ACTION_UP分支中进行调用的。 下面我做了一个测试： 分别定义一个Button与TextView，设置OnTouchListener。 123456789101112131415button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction()); return false; &#125; &#125;);textView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction()); return false; &#125; &#125;); 点击Button，log如下：点击ImageView，log如下：可以看到Button的所有事件都执行了，而TextView只执行了ACTION_DOWN事件。针对ACTION_DOWN事件，Button的dispatchTouchEvent()返回的是true（onTouch返回false后会继续执行onTouchEvent，由于可点击，所以返回true），而TextView返回false。 修改textView的onTouch如下： 123456789101112131415@Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: return true; case MotionEvent.ACTION_MOVE: return false; case MotionEvent.ACTION_UP: return false; default: break; &#125; Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction()); return false; &#125; 会发现ACTION_DOWN、ACTION_MOVE（手指点击不精确，会造成移动）、ACTION_UP都会执行。后面我对这三个事件的返回值进行组合，后面发现只有在ACTION_DOWN事件触发，dispatchTouchEvent返回true时，后面的ACTION_MOVE、ACTION_UP才会执行。暂时还不知道原因，姑且理解为：ACTION_DOWN是触摸事件的起点，连消费开头的能力都不具备，那么后面的事件就免谈了？这里暂时留一个疑问。 下面我们来看看ViewGroup。 ViewGroup的事件分发ViewGroup继承于View，它中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理： ViewGroup重载了dispatchTouchEvent()方法。 ViewGroup新增了onInterceptTouchEvent()方法。 onInterceptTouchEvent()是用来判断ViewGroup是否拦截事件。默认返回false，即不拦截。在dispatchTouchEvent()中，会通过onInterceptTouchEvent()判断ViewGroup是否拦截事件，若返回true，则没有后续。若返回false，则ViewGroup会尝试分发事件给自己的子View。在分发时，会有这么一个判断： 1234567if (!canceled &amp;&amp; !intercepted) &#123; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; ... &#125; 即只有在ACTION_DOWN的时候，ViewGroup才会尝试着将事件分发给子View，这便是疑问的答案。在ACTION_DOWN之后，传递ACTION_MOVE或ACTION_UP时，ViewGroup不会再执行上面的if，而是直接遍历子View链表，查找之前接受ACTION_DOWN的子View，并将触摸事件分配给这些子View。 小结 View事件分发，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 onTouchEvent()的返回值与View是否可点击有关。 ViewGroup中的dispatchTouchEvent()会将触摸事件进行递归遍历传递。ViewGroup会遍历它的所有孩子，对每个孩子都递归的调用dispatchTouchEvent()来分发触摸事件。 若ViewGroup的某个孩子没有接受(消费或者拦截)ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子。 ViewGroup的onInterceptTouchEvent()默认返回false。 下面贴一张总结图：注：文中源码的if判断都是以一般情况为前提，提取我们比较关注的点进行判断来得出的结论。 参考文章http://blog.csdn.net/guolin_blog/article/details/9097463http://blog.csdn.net/guolin_blog/article/details/9153747http://wangkuiwu.github.io/2015/01/03/TouchEvent-View/http://wangkuiwu.github.io/2015/01/04/TouchEvent-ViewGroup/","tags":[{"name":"Android 基础","slug":"Android-基础","permalink":"http://lijia92.github.io/tags/Android-%E5%9F%BA%E7%A1%80/"}]},{"title":"Android Studio使用Genymotion小记","date":"2015-11-05T02:46:29.000Z","path":"2015/11/05/genymotion/","text":"在学习Android Studio的过程中，看到网上很多人都推荐使用Genymotion插件，在某些无法使用真机的情况下，这个模拟器插件能大大加快模拟器的运行速度。而且由于没有Android 5.0以上的真机，使用Genymotion可以运行Android 5.0以上的模拟器，看看Meterial Design的设计，所谓一举两得，于是便开始了一波Genymotion的学习。 安装Genymotion安装Genymotion。进入到官网，下载Genymotion，没有安装Virtual Box的，选择带有Virtual Box的安装文件进行下载。下载成功后，安装，基本都是下一步，下一步。 Android Studio使用Genymotion插件 Android Studio安装Genymotion插件。安装过程很简单，网上一搜一大把，就不赘述了。 将Genymotion路径配置到Android Studio中。 启动Genymotion插件，选择要配置的机型，系统，点击Next，等待下载，安装，部署结束之后，启动模拟器即可进行使用了。 问题 在选择好机型后，点击Next时，一直在Downloading files界面，最后弹出”Connection timeout occurred”，提示创建虚拟机失败。出现这种情况，主要是下载的ova文件无法正常下载下来。打开日志文件（路径：C:\\Users\\Administrator\\AppData\\Local\\Genymobile\\genymotion.log），可以看到类似的log：拷贝出.ova的那个地址，下载好这个ova文件后，替换到C:\\Users\\Administrator\\AppData\\Local\\Genymobile\\Genymotion\\ova文件夹中即可。在我的情形中，是由于公司网速太慢导致QAQ…后面在寝室一下就好了~ 创建好虚拟机后，启动失败。网上查了许多解决方法，诸如修改Ip的一些等等，但是并不适用于我的情况。后面找到了解决方法：减少虚拟机内存！打开Virtual Box，找到相应的虚拟机，打开设置-&gt;系统，将内存大小从2048改成1024后，虚拟机启动成功！ 但是当我创建安卓5.0以上的虚拟机时，虚拟机虽然启动成功了，却一直停留在下面这个画面：本以为进度到了74之后就会结束，进入系统的，结果是我太天真…进度到了74之后，黑屏，显示一个“Android”字样，然后又重复开始从1到74，就这样不停重复不停重复，根本无法使用虚拟机。于是又在网上搜罗相关的解决办法，最后算是找到了：安装HAXM。 首先进入BIOS开启intel虚拟加速。不同的品牌电脑设置界面不同，这个自行百度。 需要在SDK Manager里面下载Intel x86 Emulator Accelator。 下载完成之后，找到相关安装文件进行安装。 进入cmd，输入命令【sc query intelhaxm】查看intelhaxm状态。没有开启的话，输入【sc start intelhaxm】即可进行开启。通过以上步骤，我的安卓5.1虚拟机，总算是成功跑起来了！！！ 后面回到家里，也通过上述一些操作，但是却仍然启动失败！！！后面打开VirtualBox，从VirtualBox启动虚拟机，报如下的错误：后面网上找到该错误的原因，是因为系统破解，system32文件夹下的uxtheme.dll文件出问题。在网上下载电脑相应64位或32位的未破解的uxtheme.dll文件，替换到system32里去，然后重新启动虚拟机，成功！也可以下载下面的破解还原工具，还原破解。破解还原工具 使用Genymotion安装APK出现错误INSTALL_FAILED_CPU_ABI_INCOMPATIBLE，解决办法如下：下载这个Zip，不要解压，直接拖到虚拟机窗口中。对，你没有看错，就是直接拖进去。然后重启虚拟机就可以了。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Java反射实现接口","date":"2015-10-28T04:00:03.000Z","path":"2015/10/28/reflect-interface/","text":"之前做过一个插件，综合了移动MM，移动和游戏，沃商店等一些计费SDK。将这些计费SDK提供的接口全部整合，最后由插件提供一套接口。通过后台配置，来让游戏使用某种计费SDK。游戏开发商接入计费的时候，只需要调用插件提供的一套接口即可。因为不可能保证游戏会包含所有的计费SDK的代码，所以插件内部只能利用反射来实现。通过反射来获取类，获取方法进行调用是比较简单的。 但是有个问题困扰了我很久：计费SDK都有提供回调接口，使游戏开发商在计费成功或失败进行回调，那么如何通过反射来实现这些回调接口，进行调用呢？通过一段时间的摸索，知道了一种解决方法：使用Proxy类与InvocationHandler接口。 下面通过一个例子进行讲解。 首先以计费SDK为例子写一个library工程，提供一个方法和一个回调接口：12345678910111213package com.lastwarmth.library;public class MyLibrary &#123; public interface Callback &#123; void doCallback(); &#125; public void mainMethod(Callback callback) &#123; System.out.println(&quot;doing main...&quot;); callback.doCallback(); &#125;&#125; 新建MyTest工程，编写类实现InvocationHandler：123456789101112131415package com.lastwarmth.demo;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyHandler implements InvocationHandler&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;doing callback...&quot;); return null; &#125;&#125; MyTest工程测试代码：12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lastwarmth.demo;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class MyTest &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; mClass = Class.forName(&quot;com.lastwarmth.library.MyLibrary&quot;); Class&lt;?&gt; mCallback = Class.forName(&quot;com.lastwarmth.library.MyLibrary$Callback&quot;); MyHandler mHandler = new MyHandler(); Object mObj = Proxy.newProxyInstance(MyTest.class.getClassLoader(), new Class[] &#123; mCallback &#125;, mHandler); Method mMethod = mClass.getDeclaredMethod(&quot;mainMethod&quot;, new Class[] &#123; mCallback &#125;); mMethod.invoke(mClass.newInstance(), new Object[] &#123; mObj &#125;); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SecurityException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 将MyLibrary打成jar包，引入到MyTest的build path中，或者直接将java代码考到MyTest工程下（若不这样做，运行会抛出异常，但不会致使程序崩溃）。然后运行，控制台输出结果：12doing main...doing callback... 说明MyTest类通过反射获取到了MyLibrary类中的Callback接口，并实现调用。代码比较简单，就不作过多讲述了。 总结：java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。 static InvocationHandler getInvocationHandler(Object proxy)：该方法用于获取指定代理对象所关联的调用处理器 static Class getProxyClass(ClassLoader loader, Class[] interfaces) ：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 static boolean isProxyClass(Class cl)：该方法用于判断指定类对象是否是一个动态代理类 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例文中采用第4个方法，获取到了实现接口Callback的实例。 java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。 Object invoke(Object proxy, Method method, Object[] args)：该方法负责集中处理动态代理类上的所有方法调用。第一个参数是代理类实例，第二个参数是被调用的方法对象。第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行。 在本文中，并没有代理类。直接在invoke方法中写入我们继承Callback接口需要实现的方法内容即可。通过Proxy类与InvocationHandler接口，即可完成反射实现接口的功能了。","tags":[{"name":"Java","slug":"Java","permalink":"http://lijia92.github.io/tags/Java/"}]},{"title":"百度定位SDK无法定位","date":"2015-10-24T09:14:50.000Z","path":"2015/10/24/baidu-loc/","text":"最近的项目中，有使用到百度定位SDK，在自己的debug环境安装apk，手机可以进行定位。但是发布release版本后安装，手机却无法定位。后面找到问题是百度配置的秘钥不对。 百度地图SDK在申请秘钥时，需要SHA1值。此值在Eclipse中在Eclipse中，可直接看到：若是使用Android Studio，直接在setting中好像看不到该值。此时需要通过命令行来获取，具体操作可参考百度开发指南。 通过上述方式获取到的SHA1值为debug版本的，若是在Android Studio中，采用自己的keystore生成的apk对应的SHA1值会与debug版本的值不一致，这就导致了在百度开放平台上申请到的key值不对（key值需要SHA1值与app包名）。 此时需要获得release版本对应的SHA1值。步骤如下： 将自己的keystore拷贝一份到C:\\Users\\Administrator.android目录下； 命令行进入到.android文件夹，执行命令：1keytool -list -keystore keystorefile keystorefile为刚刚拷贝的keystore文件。会提示输入秘钥库口令，输入之后回车即可获取SHA1值。使用该SHA1值去开放平台申请秘钥，然后替换AndroidManifest.xml中的key值。之后采用自己那个keystore进行release打包出来的apk即可正常使用百度SDK了。","tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://lijia92.github.io/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Android DDMS无法输出logcat","date":"2015-10-24T08:00:11.000Z","path":"2015/10/24/ddms-logcat/","text":"问题在Android开发中，我们经常需要真机测试，查看log。有好几次碰到如下的情况： 1Unable to open log device‘/dev/log/main’: No such file or directory 导致连上真机却看不到log。 网上有很多解决方法，比如各种重启，重启手机，电脑，eclipse，adb，重新安装eclipse，拨号等。又或者stackoverflow上说的与手机内核有关。但是对我的手机都不奏效，我的手机是华为3C，刷的MIUI的rom。 原因后面折腾了老半天，终于找到了原因： .&#x2F;system&#x2F;etc&#x2F;init.d目录下的脚本删掉了日志设备 知道问题出在哪了，那么解决起来就很方便了。 解决方法找到删掉日志设备的脚本123adb shellsucd /system/etc/init.d &amp;&amp; grep -r &quot;rm /dev/log/main&quot; 找到该文件：03MTKTweakElse文件。 修改脚本利用pull指令将该文件拷贝到电脑上。 1abd pull /system/ect/init.d/03MTKTweakElse L:\\ 利用文本编辑工具（editplus、notepad++等）打开03MTKTweakElse文件，找到rm /dev/log/main，然后注释掉该行。 将文件替换到之前的路径中1adb push L:\\03MTKTweakElse /system/etc/init.d 重启手机 经过以上几个步骤，应该就可以输出logcat了。 Tips 手机需要root。 adb pull、push指令可能会失败，建议可以使用R.E资源管理器。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://lijia92.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]}]